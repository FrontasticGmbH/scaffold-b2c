"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/core-js/internals/global.js
var require_global = __commonJS({
  "node_modules/core-js/internals/global.js"(exports, module2) {
    "use strict";
    var check = function(it) {
      return it && it.Math == Math && it;
    };
    module2.exports = // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == "object" && self) || check(typeof global == "object" && global) || // eslint-disable-next-line no-new-func -- fallback
    function() {
      return this;
    }() || Function("return this")();
  }
});

// node_modules/core-js/internals/fails.js
var require_fails = __commonJS({
  "node_modules/core-js/internals/fails.js"(exports, module2) {
    "use strict";
    module2.exports = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
  }
});

// node_modules/core-js/internals/descriptors.js
var require_descriptors = __commonJS({
  "node_modules/core-js/internals/descriptors.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    module2.exports = !fails(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] != 7;
    });
  }
});

// node_modules/core-js/internals/function-call.js
var require_function_call = __commonJS({
  "node_modules/core-js/internals/function-call.js"(exports, module2) {
    "use strict";
    var call = Function.prototype.call;
    module2.exports = call.bind ? call.bind(call) : function() {
      return call.apply(call, arguments);
    };
  }
});

// node_modules/core-js/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS({
  "node_modules/core-js/internals/object-property-is-enumerable.js"(exports) {
    "use strict";
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor3 = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor3 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    exports.f = NASHORN_BUG ? function propertyIsEnumerable3(V) {
      var descriptor = getOwnPropertyDescriptor3(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
  }
});

// node_modules/core-js/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS({
  "node_modules/core-js/internals/create-property-descriptor.js"(exports, module2) {
    "use strict";
    module2.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js/internals/function-uncurry-this.js
var require_function_uncurry_this = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this.js"(exports, module2) {
    "use strict";
    var FunctionPrototype = Function.prototype;
    var bind = FunctionPrototype.bind;
    var call = FunctionPrototype.call;
    var callBind = bind && bind.bind(call);
    module2.exports = bind ? function(fn) {
      return fn && callBind(call, fn);
    } : function(fn) {
      return fn && function() {
        return call.apply(fn, arguments);
      };
    };
  }
});

// node_modules/core-js/internals/classof-raw.js
var require_classof_raw = __commonJS({
  "node_modules/core-js/internals/classof-raw.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toString = uncurryThis({}.toString);
    var stringSlice = uncurryThis("".slice);
    module2.exports = function(it) {
      return stringSlice(toString(it), 8, -1);
    };
  }
});

// node_modules/core-js/internals/indexed-object.js
var require_indexed_object = __commonJS({
  "node_modules/core-js/internals/indexed-object.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var classof = require_classof_raw();
    var Object2 = global2.Object;
    var split = uncurryThis("".split);
    module2.exports = fails(function() {
      return !Object2("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof(it) == "String" ? split(it, "") : Object2(it);
    } : Object2;
  }
});

// node_modules/core-js/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS({
  "node_modules/core-js/internals/require-object-coercible.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var TypeError2 = global2.TypeError;
    module2.exports = function(it) {
      if (it == void 0)
        throw TypeError2("Can't call method on " + it);
      return it;
    };
  }
});

// node_modules/core-js/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS({
  "node_modules/core-js/internals/to-indexed-object.js"(exports, module2) {
    "use strict";
    var IndexedObject = require_indexed_object();
    var requireObjectCoercible = require_require_object_coercible();
    module2.exports = function(it) {
      return IndexedObject(requireObjectCoercible(it));
    };
  }
});

// node_modules/core-js/internals/is-callable.js
var require_is_callable = __commonJS({
  "node_modules/core-js/internals/is-callable.js"(exports, module2) {
    "use strict";
    module2.exports = function(argument) {
      return typeof argument == "function";
    };
  }
});

// node_modules/core-js/internals/is-object.js
var require_is_object = __commonJS({
  "node_modules/core-js/internals/is-object.js"(exports, module2) {
    "use strict";
    var isCallable = require_is_callable();
    module2.exports = function(it) {
      return typeof it == "object" ? it !== null : isCallable(it);
    };
  }
});

// node_modules/core-js/internals/get-built-in.js
var require_get_built_in = __commonJS({
  "node_modules/core-js/internals/get-built-in.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var isCallable = require_is_callable();
    var aFunction = function(argument) {
      return isCallable(argument) ? argument : void 0;
    };
    module2.exports = function(namespace2, method) {
      return arguments.length < 2 ? aFunction(global2[namespace2]) : global2[namespace2] && global2[namespace2][method];
    };
  }
});

// node_modules/core-js/internals/object-is-prototype-of.js
var require_object_is_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-is-prototype-of.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module2.exports = uncurryThis({}.isPrototypeOf);
  }
});

// node_modules/core-js/internals/engine-user-agent.js
var require_engine_user_agent = __commonJS({
  "node_modules/core-js/internals/engine-user-agent.js"(exports, module2) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    module2.exports = getBuiltIn("navigator", "userAgent") || "";
  }
});

// node_modules/core-js/internals/engine-v8-version.js
var require_engine_v8_version = __commonJS({
  "node_modules/core-js/internals/engine-v8-version.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var userAgent = require_engine_user_agent();
    var process2 = global2.process;
    var Deno = global2.Deno;
    var versions = process2 && process2.versions || Deno && Deno.version;
    var v8 = versions && versions.v8;
    var match;
    var version;
    if (v8) {
      match = v8.split(".");
      version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    }
    if (!version && userAgent) {
      match = userAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match)
          version = +match[1];
      }
    }
    module2.exports = version;
  }
});

// node_modules/core-js/internals/native-symbol.js
var require_native_symbol = __commonJS({
  "node_modules/core-js/internals/native-symbol.js"(exports, module2) {
    "use strict";
    var V8_VERSION = require_engine_v8_version();
    var fails = require_fails();
    module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
      var symbol = Symbol();
      return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
  }
});

// node_modules/core-js/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS({
  "node_modules/core-js/internals/use-symbol-as-uid.js"(exports, module2) {
    "use strict";
    var NATIVE_SYMBOL = require_native_symbol();
    module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  }
});

// node_modules/core-js/internals/is-symbol.js
var require_is_symbol = __commonJS({
  "node_modules/core-js/internals/is-symbol.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var isPrototypeOf = require_object_is_prototype_of();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var Object2 = global2.Object;
    module2.exports = USE_SYMBOL_AS_UID ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn("Symbol");
      return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, Object2(it));
    };
  }
});

// node_modules/core-js/internals/try-to-string.js
var require_try_to_string = __commonJS({
  "node_modules/core-js/internals/try-to-string.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var String2 = global2.String;
    module2.exports = function(argument) {
      try {
        return String2(argument);
      } catch (error) {
        return "Object";
      }
    };
  }
});

// node_modules/core-js/internals/a-callable.js
var require_a_callable = __commonJS({
  "node_modules/core-js/internals/a-callable.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var isCallable = require_is_callable();
    var tryToString = require_try_to_string();
    var TypeError2 = global2.TypeError;
    module2.exports = function(argument) {
      if (isCallable(argument))
        return argument;
      throw TypeError2(tryToString(argument) + " is not a function");
    };
  }
});

// node_modules/core-js/internals/get-method.js
var require_get_method = __commonJS({
  "node_modules/core-js/internals/get-method.js"(exports, module2) {
    "use strict";
    var aCallable = require_a_callable();
    module2.exports = function(V, P) {
      var func = V[P];
      return func == null ? void 0 : aCallable(func);
    };
  }
});

// node_modules/core-js/internals/ordinary-to-primitive.js
var require_ordinary_to_primitive = __commonJS({
  "node_modules/core-js/internals/ordinary-to-primitive.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var call = require_function_call();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var TypeError2 = global2.TypeError;
    module2.exports = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
        return val;
      if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))
        return val;
      if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
        return val;
      throw TypeError2("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js/internals/is-pure.js
var require_is_pure = __commonJS({
  "node_modules/core-js/internals/is-pure.js"(exports, module2) {
    "use strict";
    module2.exports = false;
  }
});

// node_modules/core-js/internals/set-global.js
var require_set_global = __commonJS({
  "node_modules/core-js/internals/set-global.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var defineProperty3 = Object.defineProperty;
    module2.exports = function(key, value) {
      try {
        defineProperty3(global2, key, { value, configurable: true, writable: true });
      } catch (error) {
        global2[key] = value;
      }
      return value;
    };
  }
});

// node_modules/core-js/internals/shared-store.js
var require_shared_store = __commonJS({
  "node_modules/core-js/internals/shared-store.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var setGlobal = require_set_global();
    var SHARED = "__core-js_shared__";
    var store2 = global2[SHARED] || setGlobal(SHARED, {});
    module2.exports = store2;
  }
});

// node_modules/core-js/internals/shared.js
var require_shared = __commonJS({
  "node_modules/core-js/internals/shared.js"(exports, module2) {
    "use strict";
    var IS_PURE = require_is_pure();
    var store2 = require_shared_store();
    (module2.exports = function(key, value) {
      return store2[key] || (store2[key] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: "3.20.0",
      mode: IS_PURE ? "pure" : "global",
      copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"
    });
  }
});

// node_modules/core-js/internals/to-object.js
var require_to_object = __commonJS({
  "node_modules/core-js/internals/to-object.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var requireObjectCoercible = require_require_object_coercible();
    var Object2 = global2.Object;
    module2.exports = function(argument) {
      return Object2(requireObjectCoercible(argument));
    };
  }
});

// node_modules/core-js/internals/has-own-property.js
var require_has_own_property = __commonJS({
  "node_modules/core-js/internals/has-own-property.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var hasOwnProperty3 = uncurryThis({}.hasOwnProperty);
    module2.exports = Object.hasOwn || function hasOwn(it, key) {
      return hasOwnProperty3(toObject(it), key);
    };
  }
});

// node_modules/core-js/internals/uid.js
var require_uid = __commonJS({
  "node_modules/core-js/internals/uid.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var id = 0;
    var postfix = Math.random();
    var toString = uncurryThis(1 .toString);
    module2.exports = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
    };
  }
});

// node_modules/core-js/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS({
  "node_modules/core-js/internals/well-known-symbol.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var shared = require_shared();
    var hasOwn = require_has_own_property();
    var uid = require_uid();
    var NATIVE_SYMBOL = require_native_symbol();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var WellKnownSymbolsStore = shared("wks");
    var Symbol2 = global2.Symbol;
    var symbolFor = Symbol2 && Symbol2["for"];
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
    module2.exports = function(name) {
      if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
        var description = "Symbol." + name;
        if (NATIVE_SYMBOL && hasOwn(Symbol2, name)) {
          WellKnownSymbolsStore[name] = Symbol2[name];
        } else if (USE_SYMBOL_AS_UID && symbolFor) {
          WellKnownSymbolsStore[name] = symbolFor(description);
        } else {
          WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
        }
      }
      return WellKnownSymbolsStore[name];
    };
  }
});

// node_modules/core-js/internals/to-primitive.js
var require_to_primitive = __commonJS({
  "node_modules/core-js/internals/to-primitive.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var call = require_function_call();
    var isObject = require_is_object();
    var isSymbol = require_is_symbol();
    var getMethod = require_get_method();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var wellKnownSymbol = require_well_known_symbol();
    var TypeError2 = global2.TypeError;
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    module2.exports = function(input, pref) {
      if (!isObject(input) || isSymbol(input))
        return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0)
          pref = "default";
        result = call(exoticToPrim, input, pref);
        if (!isObject(result) || isSymbol(result))
          return result;
        throw TypeError2("Can't convert object to primitive value");
      }
      if (pref === void 0)
        pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
  }
});

// node_modules/core-js/internals/to-property-key.js
var require_to_property_key = __commonJS({
  "node_modules/core-js/internals/to-property-key.js"(exports, module2) {
    "use strict";
    var toPrimitive2 = require_to_primitive();
    var isSymbol = require_is_symbol();
    module2.exports = function(argument) {
      var key = toPrimitive2(argument, "string");
      return isSymbol(key) ? key : key + "";
    };
  }
});

// node_modules/core-js/internals/document-create-element.js
var require_document_create_element = __commonJS({
  "node_modules/core-js/internals/document-create-element.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var isObject = require_is_object();
    var document2 = global2.document;
    var EXISTS = isObject(document2) && isObject(document2.createElement);
    module2.exports = function(it) {
      return EXISTS ? document2.createElement(it) : {};
    };
  }
});

// node_modules/core-js/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "node_modules/core-js/internals/ie8-dom-define.js"(exports, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var createElement = require_document_create_element();
    module2.exports = !DESCRIPTORS && !fails(function() {
      return Object.defineProperty(createElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a != 7;
    });
  }
});

// node_modules/core-js/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var call = require_function_call();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var createPropertyDescriptor = require_create_property_descriptor();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey2 = require_to_property_key();
    var hasOwn = require_has_own_property();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor3(O, P) {
      O = toIndexedObject(O);
      P = toPropertyKey2(P);
      if (IE8_DOM_DEFINE)
        try {
          return $getOwnPropertyDescriptor(O, P);
        } catch (error) {
        }
      if (hasOwn(O, P))
        return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
    };
  }
});

// node_modules/core-js/internals/an-object.js
var require_an_object = __commonJS({
  "node_modules/core-js/internals/an-object.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var isObject = require_is_object();
    var String2 = global2.String;
    var TypeError2 = global2.TypeError;
    module2.exports = function(argument) {
      if (isObject(argument))
        return argument;
      throw TypeError2(String2(argument) + " is not an object");
    };
  }
});

// node_modules/core-js/internals/object-define-property.js
var require_object_define_property = __commonJS({
  "node_modules/core-js/internals/object-define-property.js"(exports) {
    "use strict";
    var global2 = require_global();
    var DESCRIPTORS = require_descriptors();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var anObject = require_an_object();
    var toPropertyKey2 = require_to_property_key();
    var TypeError2 = global2.TypeError;
    var $defineProperty = Object.defineProperty;
    exports.f = DESCRIPTORS ? $defineProperty : function defineProperty3(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey2(P);
      anObject(Attributes);
      if (IE8_DOM_DEFINE)
        try {
          return $defineProperty(O, P, Attributes);
        } catch (error) {
        }
      if ("get" in Attributes || "set" in Attributes)
        throw TypeError2("Accessors not supported");
      if ("value" in Attributes)
        O[P] = Attributes.value;
      return O;
    };
  }
});

// node_modules/core-js/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS({
  "node_modules/core-js/internals/create-non-enumerable-property.js"(exports, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module2.exports = DESCRIPTORS ? function(object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// node_modules/core-js/internals/inspect-source.js
var require_inspect_source = __commonJS({
  "node_modules/core-js/internals/inspect-source.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var isCallable = require_is_callable();
    var store2 = require_shared_store();
    var functionToString = uncurryThis(Function.toString);
    if (!isCallable(store2.inspectSource)) {
      store2.inspectSource = function(it) {
        return functionToString(it);
      };
    }
    module2.exports = store2.inspectSource;
  }
});

// node_modules/core-js/internals/native-weak-map.js
var require_native_weak_map = __commonJS({
  "node_modules/core-js/internals/native-weak-map.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var isCallable = require_is_callable();
    var inspectSource = require_inspect_source();
    var WeakMap2 = global2.WeakMap;
    module2.exports = isCallable(WeakMap2) && /native code/.test(inspectSource(WeakMap2));
  }
});

// node_modules/core-js/internals/shared-key.js
var require_shared_key = __commonJS({
  "node_modules/core-js/internals/shared-key.js"(exports, module2) {
    "use strict";
    var shared = require_shared();
    var uid = require_uid();
    var keys = shared("keys");
    module2.exports = function(key) {
      return keys[key] || (keys[key] = uid(key));
    };
  }
});

// node_modules/core-js/internals/hidden-keys.js
var require_hidden_keys = __commonJS({
  "node_modules/core-js/internals/hidden-keys.js"(exports, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/core-js/internals/internal-state.js
var require_internal_state = __commonJS({
  "node_modules/core-js/internals/internal-state.js"(exports, module2) {
    "use strict";
    var NATIVE_WEAK_MAP = require_native_weak_map();
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var isObject = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn = require_has_own_property();
    var shared = require_shared_store();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError2 = global2.TypeError;
    var WeakMap2 = global2.WeakMap;
    var set;
    var get;
    var has;
    var enforce = function(it) {
      return has(it) ? get(it) : set(it, {});
    };
    var getterFor = function(TYPE2) {
      return function(it) {
        var state;
        if (!isObject(it) || (state = get(it)).type !== TYPE2) {
          throw TypeError2("Incompatible receiver, " + TYPE2 + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP || shared.state) {
      store2 = shared.state || (shared.state = new WeakMap2());
      wmget = uncurryThis(store2.get);
      wmhas = uncurryThis(store2.has);
      wmset = uncurryThis(store2.set);
      set = function(it, metadata) {
        if (wmhas(store2, it))
          throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        wmset(store2, it, metadata);
        return metadata;
      };
      get = function(it) {
        return wmget(store2, it) || {};
      };
      has = function(it) {
        return wmhas(store2, it);
      };
    } else {
      STATE = sharedKey("state");
      hiddenKeys[STATE] = true;
      set = function(it, metadata) {
        if (hasOwn(it, STATE))
          throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      };
      get = function(it) {
        return hasOwn(it, STATE) ? it[STATE] : {};
      };
      has = function(it) {
        return hasOwn(it, STATE);
      };
    }
    var store2;
    var wmget;
    var wmhas;
    var wmset;
    var STATE;
    module2.exports = {
      set,
      get,
      has,
      enforce,
      getterFor
    };
  }
});

// node_modules/core-js/internals/function-name.js
var require_function_name = __commonJS({
  "node_modules/core-js/internals/function-name.js"(exports, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var hasOwn = require_has_own_property();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn(FunctionPrototype, "name");
    var PROPER = EXISTS && function something() {
    }.name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
    module2.exports = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
  }
});

// node_modules/core-js/internals/redefine.js
var require_redefine = __commonJS({
  "node_modules/core-js/internals/redefine.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var setGlobal = require_set_global();
    var inspectSource = require_inspect_source();
    var InternalStateModule = require_internal_state();
    var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
    var getInternalState = InternalStateModule.get;
    var enforceInternalState = InternalStateModule.enforce;
    var TEMPLATE = String(String).split("String");
    (module2.exports = function(O, key, value, options) {
      var unsafe = options ? !!options.unsafe : false;
      var simple = options ? !!options.enumerable : false;
      var noTargetGet = options ? !!options.noTargetGet : false;
      var name = options && options.name !== void 0 ? options.name : key;
      var state;
      if (isCallable(value)) {
        if (String(name).slice(0, 7) === "Symbol(") {
          name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
        }
        if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
          createNonEnumerableProperty(value, "name", name);
        }
        state = enforceInternalState(value);
        if (!state.source) {
          state.source = TEMPLATE.join(typeof name == "string" ? name : "");
        }
      }
      if (O === global2) {
        if (simple)
          O[key] = value;
        else
          setGlobal(key, value);
        return;
      } else if (!unsafe) {
        delete O[key];
      } else if (!noTargetGet && O[key]) {
        simple = true;
      }
      if (simple)
        O[key] = value;
      else
        createNonEnumerableProperty(O, key, value);
    })(Function.prototype, "toString", function toString() {
      return isCallable(this) && getInternalState(this).source || inspectSource(this);
    });
  }
});

// node_modules/core-js/internals/to-integer-or-infinity.js
var require_to_integer_or_infinity = __commonJS({
  "node_modules/core-js/internals/to-integer-or-infinity.js"(exports, module2) {
    "use strict";
    var ceil = Math.ceil;
    var floor = Math.floor;
    module2.exports = function(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
    };
  }
});

// node_modules/core-js/internals/to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "node_modules/core-js/internals/to-absolute-index.js"(exports, module2) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var max = Math.max;
    var min = Math.min;
    module2.exports = function(index2, length) {
      var integer = toIntegerOrInfinity(index2);
      return integer < 0 ? max(integer + length, 0) : min(integer, length);
    };
  }
});

// node_modules/core-js/internals/to-length.js
var require_to_length = __commonJS({
  "node_modules/core-js/internals/to-length.js"(exports, module2) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var min = Math.min;
    module2.exports = function(argument) {
      return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
    };
  }
});

// node_modules/core-js/internals/length-of-array-like.js
var require_length_of_array_like = __commonJS({
  "node_modules/core-js/internals/length-of-array-like.js"(exports, module2) {
    "use strict";
    var toLength = require_to_length();
    module2.exports = function(obj) {
      return toLength(obj.length);
    };
  }
});

// node_modules/core-js/internals/array-includes.js
var require_array_includes = __commonJS({
  "node_modules/core-js/internals/array-includes.js"(exports, module2) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var createMethod = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = lengthOfArrayLike(O);
        var index2 = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el != el)
          while (length > index2) {
            value = O[index2++];
            if (value != value)
              return true;
          }
        else
          for (; length > index2; index2++) {
            if ((IS_INCLUDES || index2 in O) && O[index2] === el)
              return IS_INCLUDES || index2 || 0;
          }
        return !IS_INCLUDES && -1;
      };
    };
    module2.exports = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod(false)
    };
  }
});

// node_modules/core-js/internals/object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "node_modules/core-js/internals/object-keys-internal.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var hasOwn = require_has_own_property();
    var toIndexedObject = require_to_indexed_object();
    var indexOf = require_array_includes().indexOf;
    var hiddenKeys = require_hidden_keys();
    var push = uncurryThis([].push);
    module2.exports = function(object, names) {
      var O = toIndexedObject(object);
      var i = 0;
      var result = [];
      var key;
      for (key in O)
        !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
      while (names.length > i)
        if (hasOwn(O, key = names[i++])) {
          ~indexOf(result, key) || push(result, key);
        }
      return result;
    };
  }
});

// node_modules/core-js/internals/enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "node_modules/core-js/internals/enum-bug-keys.js"(exports, module2) {
    "use strict";
    module2.exports = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
  }
});

// node_modules/core-js/internals/object-get-own-property-names.js
var require_object_get_own_property_names = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-names.js"(exports) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = enumBugKeys.concat("length", "prototype");
    exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames3(O) {
      return internalObjectKeys(O, hiddenKeys);
    };
  }
});

// node_modules/core-js/internals/object-get-own-property-symbols.js
var require_object_get_own_property_symbols = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-symbols.js"(exports) {
    "use strict";
    exports.f = Object.getOwnPropertySymbols;
  }
});

// node_modules/core-js/internals/own-keys.js
var require_own_keys = __commonJS({
  "node_modules/core-js/internals/own-keys.js"(exports, module2) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var anObject = require_an_object();
    var concat = uncurryThis([].concat);
    module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys3(it) {
      var keys = getOwnPropertyNamesModule.f(anObject(it));
      var getOwnPropertySymbols3 = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols3 ? concat(keys, getOwnPropertySymbols3(it)) : keys;
    };
  }
});

// node_modules/core-js/internals/copy-constructor-properties.js
var require_copy_constructor_properties = __commonJS({
  "node_modules/core-js/internals/copy-constructor-properties.js"(exports, module2) {
    "use strict";
    var hasOwn = require_has_own_property();
    var ownKeys3 = require_own_keys();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    module2.exports = function(target, source, exceptions) {
      var keys = ownKeys3(source);
      var defineProperty3 = definePropertyModule.f;
      var getOwnPropertyDescriptor3 = getOwnPropertyDescriptorModule.f;
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
          defineProperty3(target, key, getOwnPropertyDescriptor3(source, key));
        }
      }
    };
  }
});

// node_modules/core-js/internals/is-forced.js
var require_is_forced = __commonJS({
  "node_modules/core-js/internals/is-forced.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var replacement = /#|\.prototype\./;
    var isForced = function(feature, detection) {
      var value = data[normalize(feature)];
      return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
    };
    var normalize = isForced.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    module2.exports = isForced;
  }
});

// node_modules/core-js/internals/export.js
var require_export = __commonJS({
  "node_modules/core-js/internals/export.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var getOwnPropertyDescriptor3 = require_object_get_own_property_descriptor().f;
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var redefine = require_redefine();
    var setGlobal = require_set_global();
    var copyConstructorProperties = require_copy_constructor_properties();
    var isForced = require_is_forced();
    module2.exports = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = global2;
      } else if (STATIC) {
        target = global2[TARGET] || setGlobal(TARGET, {});
      } else {
        target = (global2[TARGET] || {}).prototype;
      }
      if (target)
        for (key in source) {
          sourceProperty = source[key];
          if (options.noTargetGet) {
            descriptor = getOwnPropertyDescriptor3(target, key);
            targetProperty = descriptor && descriptor.value;
          } else
            targetProperty = target[key];
          FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
          if (!FORCED && targetProperty !== void 0) {
            if (typeof sourceProperty == typeof targetProperty)
              continue;
            copyConstructorProperties(sourceProperty, targetProperty);
          }
          if (options.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty(sourceProperty, "sham", true);
          }
          redefine(target, key, sourceProperty, options);
        }
    };
  }
});

// node_modules/core-js/internals/function-apply.js
var require_function_apply = __commonJS({
  "node_modules/core-js/internals/function-apply.js"(exports, module2) {
    "use strict";
    var FunctionPrototype = Function.prototype;
    var apply = FunctionPrototype.apply;
    var bind = FunctionPrototype.bind;
    var call = FunctionPrototype.call;
    module2.exports = typeof Reflect == "object" && Reflect.apply || (bind ? call.bind(apply) : function() {
      return call.apply(apply, arguments);
    });
  }
});

// node_modules/core-js/internals/is-array.js
var require_is_array = __commonJS({
  "node_modules/core-js/internals/is-array.js"(exports, module2) {
    "use strict";
    var classof = require_classof_raw();
    module2.exports = Array.isArray || function isArray3(argument) {
      return classof(argument) == "Array";
    };
  }
});

// node_modules/core-js/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS({
  "node_modules/core-js/internals/to-string-tag-support.js"(exports, module2) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    module2.exports = String(test) === "[object z]";
  }
});

// node_modules/core-js/internals/classof.js
var require_classof = __commonJS({
  "node_modules/core-js/internals/classof.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var isCallable = require_is_callable();
    var classofRaw = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var Object2 = global2.Object;
    var CORRECT_ARGUMENTS = classofRaw(function() {
      return arguments;
    }()) == "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (error) {
      }
    };
    module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object2(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable(O.callee) ? "Arguments" : result;
    };
  }
});

// node_modules/core-js/internals/to-string.js
var require_to_string = __commonJS({
  "node_modules/core-js/internals/to-string.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var classof = require_classof();
    var String2 = global2.String;
    module2.exports = function(argument) {
      if (classof(argument) === "Symbol")
        throw TypeError("Cannot convert a Symbol value to a string");
      return String2(argument);
    };
  }
});

// node_modules/core-js/internals/object-keys.js
var require_object_keys = __commonJS({
  "node_modules/core-js/internals/object-keys.js"(exports, module2) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module2.exports = Object.keys || function keys(O) {
      return internalObjectKeys(O, enumBugKeys);
    };
  }
});

// node_modules/core-js/internals/object-define-properties.js
var require_object_define_properties = __commonJS({
  "node_modules/core-js/internals/object-define-properties.js"(exports, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var anObject = require_an_object();
    var toIndexedObject = require_to_indexed_object();
    var objectKeys = require_object_keys();
    module2.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject(O);
      var props = toIndexedObject(Properties);
      var keys = objectKeys(Properties);
      var length = keys.length;
      var index2 = 0;
      var key;
      while (length > index2)
        definePropertyModule.f(O, key = keys[index2++], props[key]);
      return O;
    };
  }
});

// node_modules/core-js/internals/html.js
var require_html = __commonJS({
  "node_modules/core-js/internals/html.js"(exports, module2) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    module2.exports = getBuiltIn("document", "documentElement");
  }
});

// node_modules/core-js/internals/object-create.js
var require_object_create = __commonJS({
  "node_modules/core-js/internals/object-create.js"(exports, module2) {
    "use strict";
    var anObject = require_an_object();
    var defineProperties = require_object_define_properties();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = require_hidden_keys();
    var html = require_html();
    var documentCreateElement = require_document_create_element();
    var sharedKey = require_shared_key();
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey("IE_PROTO");
    var EmptyConstructor = function() {
    };
    var scriptTag = function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var NullProtoObject = function() {
      try {
        activeXDocument = new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length = enumBugKeys.length;
      while (length--)
        delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
      return NullProtoObject();
    };
    hiddenKeys[IE_PROTO] = true;
    module2.exports = Object.create || function create3(O, Properties) {
      var result;
      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O;
      } else
        result = NullProtoObject();
      return Properties === void 0 ? result : defineProperties(result, Properties);
    };
  }
});

// node_modules/core-js/internals/create-property.js
var require_create_property = __commonJS({
  "node_modules/core-js/internals/create-property.js"(exports, module2) {
    "use strict";
    var toPropertyKey2 = require_to_property_key();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module2.exports = function(object, key, value) {
      var propertyKey = toPropertyKey2(key);
      if (propertyKey in object)
        definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
      else
        object[propertyKey] = value;
    };
  }
});

// node_modules/core-js/internals/array-slice-simple.js
var require_array_slice_simple = __commonJS({
  "node_modules/core-js/internals/array-slice-simple.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var createProperty = require_create_property();
    var Array2 = global2.Array;
    var max = Math.max;
    module2.exports = function(O, start, end) {
      var length = lengthOfArrayLike(O);
      var k = toAbsoluteIndex(start, length);
      var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
      var result = Array2(max(fin - k, 0));
      for (var n = 0; k < fin; k++, n++)
        createProperty(result, n, O[k]);
      result.length = n;
      return result;
    };
  }
});

// node_modules/core-js/internals/object-get-own-property-names-external.js
var require_object_get_own_property_names_external = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-names-external.js"(exports, module2) {
    "use strict";
    var classof = require_classof_raw();
    var toIndexedObject = require_to_indexed_object();
    var $getOwnPropertyNames = require_object_get_own_property_names().f;
    var arraySlice = require_array_slice_simple();
    var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    var getWindowNames = function(it) {
      try {
        return $getOwnPropertyNames(it);
      } catch (error) {
        return arraySlice(windowNames);
      }
    };
    module2.exports.f = function getOwnPropertyNames3(it) {
      return windowNames && classof(it) == "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
    };
  }
});

// node_modules/core-js/internals/array-slice.js
var require_array_slice = __commonJS({
  "node_modules/core-js/internals/array-slice.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module2.exports = uncurryThis([].slice);
  }
});

// node_modules/core-js/internals/well-known-symbol-wrapped.js
var require_well_known_symbol_wrapped = __commonJS({
  "node_modules/core-js/internals/well-known-symbol-wrapped.js"(exports) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    exports.f = wellKnownSymbol;
  }
});

// node_modules/core-js/internals/path.js
var require_path = __commonJS({
  "node_modules/core-js/internals/path.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    module2.exports = global2;
  }
});

// node_modules/core-js/internals/define-well-known-symbol.js
var require_define_well_known_symbol = __commonJS({
  "node_modules/core-js/internals/define-well-known-symbol.js"(exports, module2) {
    "use strict";
    var path = require_path();
    var hasOwn = require_has_own_property();
    var wrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
    var defineProperty3 = require_object_define_property().f;
    module2.exports = function(NAME) {
      var Symbol2 = path.Symbol || (path.Symbol = {});
      if (!hasOwn(Symbol2, NAME))
        defineProperty3(Symbol2, NAME, {
          value: wrappedWellKnownSymbolModule.f(NAME)
        });
    };
  }
});

// node_modules/core-js/internals/set-to-string-tag.js
var require_set_to_string_tag = __commonJS({
  "node_modules/core-js/internals/set-to-string-tag.js"(exports, module2) {
    "use strict";
    var defineProperty3 = require_object_define_property().f;
    var hasOwn = require_has_own_property();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    module2.exports = function(target, TAG, STATIC) {
      if (target && !STATIC)
        target = target.prototype;
      if (target && !hasOwn(target, TO_STRING_TAG)) {
        defineProperty3(target, TO_STRING_TAG, { configurable: true, value: TAG });
      }
    };
  }
});

// node_modules/core-js/internals/function-bind-context.js
var require_function_bind_context = __commonJS({
  "node_modules/core-js/internals/function-bind-context.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    var bind = uncurryThis(uncurryThis.bind);
    module2.exports = function(fn, that) {
      aCallable(fn);
      return that === void 0 ? fn : bind ? bind(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js/internals/is-constructor.js
var require_is_constructor = __commonJS({
  "node_modules/core-js/internals/is-constructor.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var classof = require_classof();
    var getBuiltIn = require_get_built_in();
    var inspectSource = require_inspect_source();
    var noop2 = function() {
    };
    var empty = [];
    var construct = getBuiltIn("Reflect", "construct");
    var constructorRegExp = /^\s*(?:class|function)\b/;
    var exec = uncurryThis(constructorRegExp.exec);
    var INCORRECT_TO_STRING = !constructorRegExp.exec(noop2);
    var isConstructorModern = function isConstructor(argument) {
      if (!isCallable(argument))
        return false;
      try {
        construct(noop2, empty, argument);
        return true;
      } catch (error) {
        return false;
      }
    };
    var isConstructorLegacy = function isConstructor(argument) {
      if (!isCallable(argument))
        return false;
      switch (classof(argument)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
      } catch (error) {
        return true;
      }
    };
    isConstructorLegacy.sham = true;
    module2.exports = !construct || fails(function() {
      var called;
      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
        called = true;
      }) || called;
    }) ? isConstructorLegacy : isConstructorModern;
  }
});

// node_modules/core-js/internals/array-species-constructor.js
var require_array_species_constructor = __commonJS({
  "node_modules/core-js/internals/array-species-constructor.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var isArray3 = require_is_array();
    var isConstructor = require_is_constructor();
    var isObject = require_is_object();
    var wellKnownSymbol = require_well_known_symbol();
    var SPECIES = wellKnownSymbol("species");
    var Array2 = global2.Array;
    module2.exports = function(originalArray) {
      var C;
      if (isArray3(originalArray)) {
        C = originalArray.constructor;
        if (isConstructor(C) && (C === Array2 || isArray3(C.prototype)))
          C = void 0;
        else if (isObject(C)) {
          C = C[SPECIES];
          if (C === null)
            C = void 0;
        }
      }
      return C === void 0 ? Array2 : C;
    };
  }
});

// node_modules/core-js/internals/array-species-create.js
var require_array_species_create = __commonJS({
  "node_modules/core-js/internals/array-species-create.js"(exports, module2) {
    "use strict";
    var arraySpeciesConstructor = require_array_species_constructor();
    module2.exports = function(originalArray, length) {
      return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
    };
  }
});

// node_modules/core-js/internals/array-iteration.js
var require_array_iteration = __commonJS({
  "node_modules/core-js/internals/array-iteration.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind_context();
    var uncurryThis = require_function_uncurry_this();
    var IndexedObject = require_indexed_object();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var arraySpeciesCreate = require_array_species_create();
    var push = uncurryThis([].push);
    var createMethod = function(TYPE2) {
      var IS_MAP = TYPE2 == 1;
      var IS_FILTER = TYPE2 == 2;
      var IS_SOME = TYPE2 == 3;
      var IS_EVERY = TYPE2 == 4;
      var IS_FIND_INDEX = TYPE2 == 6;
      var IS_FILTER_REJECT = TYPE2 == 7;
      var NO_HOLES = TYPE2 == 5 || IS_FIND_INDEX;
      return function($this, callbackfn, that, specificCreate) {
        var O = toObject($this);
        var self2 = IndexedObject(O);
        var boundFunction = bind(callbackfn, that);
        var length = lengthOfArrayLike(self2);
        var index2 = 0;
        var create3 = specificCreate || arraySpeciesCreate;
        var target = IS_MAP ? create3($this, length) : IS_FILTER || IS_FILTER_REJECT ? create3($this, 0) : void 0;
        var value, result;
        for (; length > index2; index2++)
          if (NO_HOLES || index2 in self2) {
            value = self2[index2];
            result = boundFunction(value, index2, O);
            if (TYPE2) {
              if (IS_MAP)
                target[index2] = result;
              else if (result)
                switch (TYPE2) {
                  case 3:
                    return true;
                  case 5:
                    return value;
                  case 6:
                    return index2;
                  case 2:
                    push(target, value);
                }
              else
                switch (TYPE2) {
                  case 4:
                    return false;
                  case 7:
                    push(target, value);
                }
            }
          }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
      };
    };
    module2.exports = {
      // `Array.prototype.forEach` method
      // https://tc39.es/ecma262/#sec-array.prototype.foreach
      forEach: createMethod(0),
      // `Array.prototype.map` method
      // https://tc39.es/ecma262/#sec-array.prototype.map
      map: createMethod(1),
      // `Array.prototype.filter` method
      // https://tc39.es/ecma262/#sec-array.prototype.filter
      filter: createMethod(2),
      // `Array.prototype.some` method
      // https://tc39.es/ecma262/#sec-array.prototype.some
      some: createMethod(3),
      // `Array.prototype.every` method
      // https://tc39.es/ecma262/#sec-array.prototype.every
      every: createMethod(4),
      // `Array.prototype.find` method
      // https://tc39.es/ecma262/#sec-array.prototype.find
      find: createMethod(5),
      // `Array.prototype.findIndex` method
      // https://tc39.es/ecma262/#sec-array.prototype.findIndex
      findIndex: createMethod(6),
      // `Array.prototype.filterReject` method
      // https://github.com/tc39/proposal-array-filtering
      filterReject: createMethod(7)
    };
  }
});

// node_modules/core-js/modules/es.symbol.js
var require_es_symbol = __commonJS({
  "node_modules/core-js/modules/es.symbol.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var getBuiltIn = require_get_built_in();
    var apply = require_function_apply();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var IS_PURE = require_is_pure();
    var DESCRIPTORS = require_descriptors();
    var NATIVE_SYMBOL = require_native_symbol();
    var fails = require_fails();
    var hasOwn = require_has_own_property();
    var isArray3 = require_is_array();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var isPrototypeOf = require_object_is_prototype_of();
    var isSymbol = require_is_symbol();
    var anObject = require_an_object();
    var toObject = require_to_object();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey2 = require_to_property_key();
    var $toString = require_to_string();
    var createPropertyDescriptor = require_create_property_descriptor();
    var nativeObjectCreate = require_object_create();
    var objectKeys = require_object_keys();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertyNamesExternal = require_object_get_own_property_names_external();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var arraySlice = require_array_slice();
    var redefine = require_redefine();
    var shared = require_shared();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var uid = require_uid();
    var wellKnownSymbol = require_well_known_symbol();
    var wrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
    var defineWellKnownSymbol = require_define_well_known_symbol();
    var setToStringTag = require_set_to_string_tag();
    var InternalStateModule = require_internal_state();
    var $forEach = require_array_iteration().forEach;
    var HIDDEN = sharedKey("hidden");
    var SYMBOL = "Symbol";
    var PROTOTYPE = "prototype";
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(SYMBOL);
    var ObjectPrototype = Object[PROTOTYPE];
    var $Symbol = global2.Symbol;
    var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
    var TypeError2 = global2.TypeError;
    var QObject = global2.QObject;
    var $stringify = getBuiltIn("JSON", "stringify");
    var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var nativeDefineProperty = definePropertyModule.f;
    var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
    var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
    var push = uncurryThis([].push);
    var AllSymbols = shared("symbols");
    var ObjectPrototypeSymbols = shared("op-symbols");
    var StringToSymbolRegistry = shared("string-to-symbol-registry");
    var SymbolToStringRegistry = shared("symbol-to-string-registry");
    var WellKnownSymbolsStore = shared("wks");
    var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
    var setSymbolDescriptor = DESCRIPTORS && fails(function() {
      return nativeObjectCreate(nativeDefineProperty({}, "a", {
        get: function() {
          return nativeDefineProperty(this, "a", { value: 7 }).a;
        }
      })).a != 7;
    }) ? function(O, P, Attributes) {
      var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
      if (ObjectPrototypeDescriptor)
        delete ObjectPrototype[P];
      nativeDefineProperty(O, P, Attributes);
      if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
        nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
      }
    } : nativeDefineProperty;
    var wrap = function(tag, description) {
      var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
      setInternalState(symbol, {
        type: SYMBOL,
        tag,
        description
      });
      if (!DESCRIPTORS)
        symbol.description = description;
      return symbol;
    };
    var $defineProperty = function defineProperty3(O, P, Attributes) {
      if (O === ObjectPrototype)
        $defineProperty(ObjectPrototypeSymbols, P, Attributes);
      anObject(O);
      var key = toPropertyKey2(P);
      anObject(Attributes);
      if (hasOwn(AllSymbols, key)) {
        if (!Attributes.enumerable) {
          if (!hasOwn(O, HIDDEN))
            nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
          O[HIDDEN][key] = true;
        } else {
          if (hasOwn(O, HIDDEN) && O[HIDDEN][key])
            O[HIDDEN][key] = false;
          Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
        }
        return setSymbolDescriptor(O, key, Attributes);
      }
      return nativeDefineProperty(O, key, Attributes);
    };
    var $defineProperties = function defineProperties(O, Properties) {
      anObject(O);
      var properties = toIndexedObject(Properties);
      var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
      $forEach(keys, function(key) {
        if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key))
          $defineProperty(O, key, properties[key]);
      });
      return O;
    };
    var $create = function create3(O, Properties) {
      return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
    };
    var $propertyIsEnumerable = function propertyIsEnumerable3(V) {
      var P = toPropertyKey2(V);
      var enumerable = call(nativePropertyIsEnumerable, this, P);
      if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P))
        return false;
      return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
    };
    var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor3(O, P) {
      var it = toIndexedObject(O);
      var key = toPropertyKey2(P);
      if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key))
        return;
      var descriptor = nativeGetOwnPropertyDescriptor(it, key);
      if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
        descriptor.enumerable = true;
      }
      return descriptor;
    };
    var $getOwnPropertyNames = function getOwnPropertyNames3(O) {
      var names = nativeGetOwnPropertyNames(toIndexedObject(O));
      var result = [];
      $forEach(names, function(key) {
        if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key))
          push(result, key);
      });
      return result;
    };
    var $getOwnPropertySymbols = function getOwnPropertySymbols3(O) {
      var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
      var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
      var result = [];
      $forEach(names, function(key) {
        if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
          push(result, AllSymbols[key]);
        }
      });
      return result;
    };
    if (!NATIVE_SYMBOL) {
      $Symbol = function Symbol2() {
        if (isPrototypeOf(SymbolPrototype, this))
          throw TypeError2("Symbol is not a constructor");
        var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
        var tag = uid(description);
        var setter = function(value) {
          if (this === ObjectPrototype)
            call(setter, ObjectPrototypeSymbols, value);
          if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag))
            this[HIDDEN][tag] = false;
          setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
        };
        if (DESCRIPTORS && USE_SETTER)
          setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
        return wrap(tag, description);
      };
      SymbolPrototype = $Symbol[PROTOTYPE];
      redefine(SymbolPrototype, "toString", function toString() {
        return getInternalState(this).tag;
      });
      redefine($Symbol, "withoutSetter", function(description) {
        return wrap(uid(description), description);
      });
      propertyIsEnumerableModule.f = $propertyIsEnumerable;
      definePropertyModule.f = $defineProperty;
      getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
      getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
      getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
      wrappedWellKnownSymbolModule.f = function(name) {
        return wrap(wellKnownSymbol(name), name);
      };
      if (DESCRIPTORS) {
        nativeDefineProperty(SymbolPrototype, "description", {
          configurable: true,
          get: function description() {
            return getInternalState(this).description;
          }
        });
        if (!IS_PURE) {
          redefine(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
        }
      }
    }
    $({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
      Symbol: $Symbol
    });
    $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
      defineWellKnownSymbol(name);
    });
    $({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
      // `Symbol.for` method
      // https://tc39.es/ecma262/#sec-symbol.for
      "for": function(key) {
        var string = $toString(key);
        if (hasOwn(StringToSymbolRegistry, string))
          return StringToSymbolRegistry[string];
        var symbol = $Symbol(string);
        StringToSymbolRegistry[string] = symbol;
        SymbolToStringRegistry[symbol] = string;
        return symbol;
      },
      // `Symbol.keyFor` method
      // https://tc39.es/ecma262/#sec-symbol.keyfor
      keyFor: function keyFor(sym) {
        if (!isSymbol(sym))
          throw TypeError2(sym + " is not a symbol");
        if (hasOwn(SymbolToStringRegistry, sym))
          return SymbolToStringRegistry[sym];
      },
      useSetter: function() {
        USE_SETTER = true;
      },
      useSimple: function() {
        USE_SETTER = false;
      }
    });
    $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
      // `Object.create` method
      // https://tc39.es/ecma262/#sec-object.create
      create: $create,
      // `Object.defineProperty` method
      // https://tc39.es/ecma262/#sec-object.defineproperty
      defineProperty: $defineProperty,
      // `Object.defineProperties` method
      // https://tc39.es/ecma262/#sec-object.defineproperties
      defineProperties: $defineProperties,
      // `Object.getOwnPropertyDescriptor` method
      // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
      getOwnPropertyDescriptor: $getOwnPropertyDescriptor
    });
    $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
      // `Object.getOwnPropertyNames` method
      // https://tc39.es/ecma262/#sec-object.getownpropertynames
      getOwnPropertyNames: $getOwnPropertyNames,
      // `Object.getOwnPropertySymbols` method
      // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
      getOwnPropertySymbols: $getOwnPropertySymbols
    });
    $({ target: "Object", stat: true, forced: fails(function() {
      getOwnPropertySymbolsModule.f(1);
    }) }, {
      getOwnPropertySymbols: function getOwnPropertySymbols3(it) {
        return getOwnPropertySymbolsModule.f(toObject(it));
      }
    });
    if ($stringify) {
      FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {
        var symbol = $Symbol();
        return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
      });
      $({ target: "JSON", stat: true, forced: FORCED_JSON_STRINGIFY }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        stringify: function stringify2(it, replacer, space) {
          var args = arraySlice(arguments);
          var $replacer = replacer;
          if (!isObject(replacer) && it === void 0 || isSymbol(it))
            return;
          if (!isArray3(replacer))
            replacer = function(key, value) {
              if (isCallable($replacer))
                value = call($replacer, this, key, value);
              if (!isSymbol(value))
                return value;
            };
          args[1] = replacer;
          return apply($stringify, null, args);
        }
      });
    }
    var FORCED_JSON_STRINGIFY;
    if (!SymbolPrototype[TO_PRIMITIVE]) {
      valueOf = SymbolPrototype.valueOf;
      redefine(SymbolPrototype, TO_PRIMITIVE, function(hint) {
        return call(valueOf, this);
      });
    }
    var valueOf;
    setToStringTag($Symbol, SYMBOL);
    hiddenKeys[HIDDEN] = true;
  }
});

// node_modules/core-js/modules/es.symbol.description.js
var require_es_symbol_description = __commonJS({
  "node_modules/core-js/modules/es.symbol.description.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var hasOwn = require_has_own_property();
    var isCallable = require_is_callable();
    var isPrototypeOf = require_object_is_prototype_of();
    var toString = require_to_string();
    var defineProperty3 = require_object_define_property().f;
    var copyConstructorProperties = require_copy_constructor_properties();
    var NativeSymbol = global2.Symbol;
    var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
    if (DESCRIPTORS && isCallable(NativeSymbol) && (!("description" in SymbolPrototype) || // Safari 12 bug
    NativeSymbol().description !== void 0)) {
      EmptyStringDescriptionStore = {};
      SymbolWrapper = function Symbol2() {
        var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : toString(arguments[0]);
        var result = isPrototypeOf(SymbolPrototype, this) ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
        if (description === "")
          EmptyStringDescriptionStore[result] = true;
        return result;
      };
      copyConstructorProperties(SymbolWrapper, NativeSymbol);
      SymbolWrapper.prototype = SymbolPrototype;
      SymbolPrototype.constructor = SymbolWrapper;
      NATIVE_SYMBOL = String(NativeSymbol("test")) == "Symbol(test)";
      symbolToString = uncurryThis(SymbolPrototype.toString);
      symbolValueOf = uncurryThis(SymbolPrototype.valueOf);
      regexp = /^Symbol\((.*)\)[^)]+$/;
      replace = uncurryThis("".replace);
      stringSlice = uncurryThis("".slice);
      defineProperty3(SymbolPrototype, "description", {
        configurable: true,
        get: function description() {
          var symbol = symbolValueOf(this);
          var string = symbolToString(symbol);
          if (hasOwn(EmptyStringDescriptionStore, symbol))
            return "";
          var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, "$1");
          return desc === "" ? void 0 : desc;
        }
      });
      $({ global: true, forced: true }, {
        Symbol: SymbolWrapper
      });
    }
    var EmptyStringDescriptionStore;
    var SymbolWrapper;
    var NATIVE_SYMBOL;
    var symbolToString;
    var symbolValueOf;
    var regexp;
    var replace;
    var stringSlice;
  }
});

// node_modules/core-js/modules/es.symbol.async-iterator.js
var require_es_symbol_async_iterator = __commonJS({
  "node_modules/core-js/modules/es.symbol.async-iterator.js"() {
    "use strict";
    var defineWellKnownSymbol = require_define_well_known_symbol();
    defineWellKnownSymbol("asyncIterator");
  }
});

// node_modules/core-js/modules/es.symbol.has-instance.js
var require_es_symbol_has_instance = __commonJS({
  "node_modules/core-js/modules/es.symbol.has-instance.js"() {
    "use strict";
    var defineWellKnownSymbol = require_define_well_known_symbol();
    defineWellKnownSymbol("hasInstance");
  }
});

// node_modules/core-js/modules/es.symbol.is-concat-spreadable.js
var require_es_symbol_is_concat_spreadable = __commonJS({
  "node_modules/core-js/modules/es.symbol.is-concat-spreadable.js"() {
    "use strict";
    var defineWellKnownSymbol = require_define_well_known_symbol();
    defineWellKnownSymbol("isConcatSpreadable");
  }
});

// node_modules/core-js/modules/es.symbol.iterator.js
var require_es_symbol_iterator = __commonJS({
  "node_modules/core-js/modules/es.symbol.iterator.js"() {
    "use strict";
    var defineWellKnownSymbol = require_define_well_known_symbol();
    defineWellKnownSymbol("iterator");
  }
});

// node_modules/core-js/modules/es.symbol.match.js
var require_es_symbol_match = __commonJS({
  "node_modules/core-js/modules/es.symbol.match.js"() {
    "use strict";
    var defineWellKnownSymbol = require_define_well_known_symbol();
    defineWellKnownSymbol("match");
  }
});

// node_modules/core-js/modules/es.symbol.match-all.js
var require_es_symbol_match_all = __commonJS({
  "node_modules/core-js/modules/es.symbol.match-all.js"() {
    "use strict";
    var defineWellKnownSymbol = require_define_well_known_symbol();
    defineWellKnownSymbol("matchAll");
  }
});

// node_modules/core-js/modules/es.symbol.replace.js
var require_es_symbol_replace = __commonJS({
  "node_modules/core-js/modules/es.symbol.replace.js"() {
    "use strict";
    var defineWellKnownSymbol = require_define_well_known_symbol();
    defineWellKnownSymbol("replace");
  }
});

// node_modules/core-js/modules/es.symbol.search.js
var require_es_symbol_search = __commonJS({
  "node_modules/core-js/modules/es.symbol.search.js"() {
    "use strict";
    var defineWellKnownSymbol = require_define_well_known_symbol();
    defineWellKnownSymbol("search");
  }
});

// node_modules/core-js/modules/es.symbol.species.js
var require_es_symbol_species = __commonJS({
  "node_modules/core-js/modules/es.symbol.species.js"() {
    "use strict";
    var defineWellKnownSymbol = require_define_well_known_symbol();
    defineWellKnownSymbol("species");
  }
});

// node_modules/core-js/modules/es.symbol.split.js
var require_es_symbol_split = __commonJS({
  "node_modules/core-js/modules/es.symbol.split.js"() {
    "use strict";
    var defineWellKnownSymbol = require_define_well_known_symbol();
    defineWellKnownSymbol("split");
  }
});

// node_modules/core-js/modules/es.symbol.to-primitive.js
var require_es_symbol_to_primitive = __commonJS({
  "node_modules/core-js/modules/es.symbol.to-primitive.js"() {
    "use strict";
    var defineWellKnownSymbol = require_define_well_known_symbol();
    defineWellKnownSymbol("toPrimitive");
  }
});

// node_modules/core-js/modules/es.symbol.to-string-tag.js
var require_es_symbol_to_string_tag = __commonJS({
  "node_modules/core-js/modules/es.symbol.to-string-tag.js"() {
    "use strict";
    var defineWellKnownSymbol = require_define_well_known_symbol();
    defineWellKnownSymbol("toStringTag");
  }
});

// node_modules/core-js/modules/es.symbol.unscopables.js
var require_es_symbol_unscopables = __commonJS({
  "node_modules/core-js/modules/es.symbol.unscopables.js"() {
    "use strict";
    var defineWellKnownSymbol = require_define_well_known_symbol();
    defineWellKnownSymbol("unscopables");
  }
});

// node_modules/core-js/internals/a-possible-prototype.js
var require_a_possible_prototype = __commonJS({
  "node_modules/core-js/internals/a-possible-prototype.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var isCallable = require_is_callable();
    var String2 = global2.String;
    var TypeError2 = global2.TypeError;
    module2.exports = function(argument) {
      if (typeof argument == "object" || isCallable(argument))
        return argument;
      throw TypeError2("Can't set " + String2(argument) + " as a prototype");
    };
  }
});

// node_modules/core-js/internals/object-set-prototype-of.js
var require_object_set_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-set-prototype-of.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var anObject = require_an_object();
    var aPossiblePrototype = require_a_possible_prototype();
    module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;
      try {
        setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set);
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf(O, proto) {
        anObject(O);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER)
          setter(O, proto);
        else
          O.__proto__ = proto;
        return O;
      };
    }() : void 0);
  }
});

// node_modules/core-js/internals/inherit-if-required.js
var require_inherit_if_required = __commonJS({
  "node_modules/core-js/internals/inherit-if-required.js"(exports, module2) {
    "use strict";
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var setPrototypeOf = require_object_set_prototype_of();
    module2.exports = function($this, dummy, Wrapper) {
      var NewTarget, NewTargetPrototype;
      if (
        // it can work only with native `setPrototypeOf`
        setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
        isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
      )
        setPrototypeOf($this, NewTargetPrototype);
      return $this;
    };
  }
});

// node_modules/core-js/internals/normalize-string-argument.js
var require_normalize_string_argument = __commonJS({
  "node_modules/core-js/internals/normalize-string-argument.js"(exports, module2) {
    "use strict";
    var toString = require_to_string();
    module2.exports = function(argument, $default) {
      return argument === void 0 ? arguments.length < 2 ? "" : $default : toString(argument);
    };
  }
});

// node_modules/core-js/internals/install-error-cause.js
var require_install_error_cause = __commonJS({
  "node_modules/core-js/internals/install-error-cause.js"(exports, module2) {
    "use strict";
    var isObject = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    module2.exports = function(O, options) {
      if (isObject(options) && "cause" in options) {
        createNonEnumerableProperty(O, "cause", options.cause);
      }
    };
  }
});

// node_modules/core-js/internals/clear-error-stack.js
var require_clear_error_stack = __commonJS({
  "node_modules/core-js/internals/clear-error-stack.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var replace = uncurryThis("".replace);
    var TEST = function(arg) {
      return String(Error(arg).stack);
    }("zxcasd");
    var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
    var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
    module2.exports = function(stack, dropEntries) {
      if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string") {
        while (dropEntries--)
          stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
      }
      return stack;
    };
  }
});

// node_modules/core-js/internals/error-stack-installable.js
var require_error_stack_installable = __commonJS({
  "node_modules/core-js/internals/error-stack-installable.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    var createPropertyDescriptor = require_create_property_descriptor();
    module2.exports = !fails(function() {
      var error = Error("a");
      if (!("stack" in error))
        return true;
      Object.defineProperty(error, "stack", createPropertyDescriptor(1, 7));
      return error.stack !== 7;
    });
  }
});

// node_modules/core-js/internals/wrap-error-constructor-with-cause.js
var require_wrap_error_constructor_with_cause = __commonJS({
  "node_modules/core-js/internals/wrap-error-constructor-with-cause.js"(exports, module2) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var hasOwn = require_has_own_property();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var copyConstructorProperties = require_copy_constructor_properties();
    var inheritIfRequired = require_inherit_if_required();
    var normalizeStringArgument = require_normalize_string_argument();
    var installErrorCause = require_install_error_cause();
    var clearErrorStack = require_clear_error_stack();
    var ERROR_STACK_INSTALLABLE = require_error_stack_installable();
    var IS_PURE = require_is_pure();
    module2.exports = function(FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
      var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
      var path = FULL_NAME.split(".");
      var ERROR_NAME = path[path.length - 1];
      var OriginalError = getBuiltIn.apply(null, path);
      if (!OriginalError)
        return;
      var OriginalErrorPrototype = OriginalError.prototype;
      if (!IS_PURE && hasOwn(OriginalErrorPrototype, "cause"))
        delete OriginalErrorPrototype.cause;
      if (!FORCED)
        return OriginalError;
      var BaseError = getBuiltIn("Error");
      var WrappedError = wrapper(function(a, b) {
        var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, void 0);
        var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
        if (message !== void 0)
          createNonEnumerableProperty(result, "message", message);
        if (ERROR_STACK_INSTALLABLE)
          createNonEnumerableProperty(result, "stack", clearErrorStack(result.stack, 2));
        if (this && isPrototypeOf(OriginalErrorPrototype, this))
          inheritIfRequired(result, this, WrappedError);
        if (arguments.length > OPTIONS_POSITION)
          installErrorCause(result, arguments[OPTIONS_POSITION]);
        return result;
      });
      WrappedError.prototype = OriginalErrorPrototype;
      if (ERROR_NAME !== "Error") {
        if (setPrototypeOf)
          setPrototypeOf(WrappedError, BaseError);
        else
          copyConstructorProperties(WrappedError, BaseError, { name: true });
      }
      copyConstructorProperties(WrappedError, OriginalError);
      if (!IS_PURE)
        try {
          if (OriginalErrorPrototype.name !== ERROR_NAME) {
            createNonEnumerableProperty(OriginalErrorPrototype, "name", ERROR_NAME);
          }
          OriginalErrorPrototype.constructor = WrappedError;
        } catch (error) {
        }
      return WrappedError;
    };
  }
});

// node_modules/core-js/modules/es.error.cause.js
var require_es_error_cause = __commonJS({
  "node_modules/core-js/modules/es.error.cause.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var apply = require_function_apply();
    var wrapErrorConstructorWithCause = require_wrap_error_constructor_with_cause();
    var WEB_ASSEMBLY = "WebAssembly";
    var WebAssembly = global2[WEB_ASSEMBLY];
    var FORCED = Error("e", { cause: 7 }).cause !== 7;
    var exportGlobalErrorCauseWrapper = function(ERROR_NAME, wrapper) {
      var O = {};
      O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED);
      $({ global: true, forced: FORCED }, O);
    };
    var exportWebAssemblyErrorCauseWrapper = function(ERROR_NAME, wrapper) {
      if (WebAssembly && WebAssembly[ERROR_NAME]) {
        var O = {};
        O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + "." + ERROR_NAME, wrapper, FORCED);
        $({ target: WEB_ASSEMBLY, stat: true, forced: FORCED }, O);
      }
    };
    exportGlobalErrorCauseWrapper("Error", function(init) {
      return function Error2(message) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("EvalError", function(init) {
      return function EvalError2(message) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("RangeError", function(init) {
      return function RangeError2(message) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("ReferenceError", function(init) {
      return function ReferenceError2(message) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("SyntaxError", function(init) {
      return function SyntaxError2(message) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("TypeError", function(init) {
      return function TypeError2(message) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("URIError", function(init) {
      return function URIError2(message) {
        return apply(init, this, arguments);
      };
    });
    exportWebAssemblyErrorCauseWrapper("CompileError", function(init) {
      return function CompileError(message) {
        return apply(init, this, arguments);
      };
    });
    exportWebAssemblyErrorCauseWrapper("LinkError", function(init) {
      return function LinkError(message) {
        return apply(init, this, arguments);
      };
    });
    exportWebAssemblyErrorCauseWrapper("RuntimeError", function(init) {
      return function RuntimeError(message) {
        return apply(init, this, arguments);
      };
    });
  }
});

// node_modules/core-js/internals/error-to-string.js
var require_error_to_string = __commonJS({
  "node_modules/core-js/internals/error-to-string.js"(exports, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var anObject = require_an_object();
    var create3 = require_object_create();
    var normalizeStringArgument = require_normalize_string_argument();
    var nativeErrorToString = Error.prototype.toString;
    var INCORRECT_TO_STRING = fails(function() {
      if (DESCRIPTORS) {
        var object = create3(Object.defineProperty({}, "name", { get: function() {
          return this === object;
        } }));
        if (nativeErrorToString.call(object) !== "true")
          return true;
      }
      return nativeErrorToString.call({ message: 1, name: 2 }) !== "2: 1" || nativeErrorToString.call({}) !== "Error";
    });
    module2.exports = INCORRECT_TO_STRING ? function toString() {
      var O = anObject(this);
      var name = normalizeStringArgument(O.name, "Error");
      var message = normalizeStringArgument(O.message);
      return !name ? message : !message ? name : name + ": " + message;
    } : nativeErrorToString;
  }
});

// node_modules/core-js/modules/es.error.to-string.js
var require_es_error_to_string = __commonJS({
  "node_modules/core-js/modules/es.error.to-string.js"() {
    "use strict";
    var redefine = require_redefine();
    var errorToString = require_error_to_string();
    var ErrorPrototype = Error.prototype;
    if (ErrorPrototype.toString !== errorToString) {
      redefine(ErrorPrototype, "toString", errorToString);
    }
  }
});

// node_modules/core-js/internals/correct-prototype-getter.js
var require_correct_prototype_getter = __commonJS({
  "node_modules/core-js/internals/correct-prototype-getter.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    module2.exports = !fails(function() {
      function F() {
      }
      F.prototype.constructor = null;
      return Object.getPrototypeOf(new F()) !== F.prototype;
    });
  }
});

// node_modules/core-js/internals/object-get-prototype-of.js
var require_object_get_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-get-prototype-of.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var hasOwn = require_has_own_property();
    var isCallable = require_is_callable();
    var toObject = require_to_object();
    var sharedKey = require_shared_key();
    var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
    var IE_PROTO = sharedKey("IE_PROTO");
    var Object2 = global2.Object;
    var ObjectPrototype = Object2.prototype;
    module2.exports = CORRECT_PROTOTYPE_GETTER ? Object2.getPrototypeOf : function(O) {
      var object = toObject(O);
      if (hasOwn(object, IE_PROTO))
        return object[IE_PROTO];
      var constructor = object.constructor;
      if (isCallable(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }
      return object instanceof Object2 ? ObjectPrototype : null;
    };
  }
});

// node_modules/core-js/internals/iterators.js
var require_iterators = __commonJS({
  "node_modules/core-js/internals/iterators.js"(exports, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/core-js/internals/is-array-iterator-method.js
var require_is_array_iterator_method = __commonJS({
  "node_modules/core-js/internals/is-array-iterator-method.js"(exports, module2) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayPrototype = Array.prototype;
    module2.exports = function(it) {
      return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
    };
  }
});

// node_modules/core-js/internals/get-iterator-method.js
var require_get_iterator_method = __commonJS({
  "node_modules/core-js/internals/get-iterator-method.js"(exports, module2) {
    "use strict";
    var classof = require_classof();
    var getMethod = require_get_method();
    var Iterators = require_iterators();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    module2.exports = function(it) {
      if (it != void 0)
        return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
    };
  }
});

// node_modules/core-js/internals/get-iterator.js
var require_get_iterator = __commonJS({
  "node_modules/core-js/internals/get-iterator.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var getIteratorMethod = require_get_iterator_method();
    var TypeError2 = global2.TypeError;
    module2.exports = function(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
      if (aCallable(iteratorMethod))
        return anObject(call(iteratorMethod, argument));
      throw TypeError2(tryToString(argument) + " is not iterable");
    };
  }
});

// node_modules/core-js/internals/iterator-close.js
var require_iterator_close = __commonJS({
  "node_modules/core-js/internals/iterator-close.js"(exports, module2) {
    "use strict";
    var call = require_function_call();
    var anObject = require_an_object();
    var getMethod = require_get_method();
    module2.exports = function(iterator, kind, value) {
      var innerResult, innerError;
      anObject(iterator);
      try {
        innerResult = getMethod(iterator, "return");
        if (!innerResult) {
          if (kind === "throw")
            throw value;
          return value;
        }
        innerResult = call(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === "throw")
        throw value;
      if (innerError)
        throw innerResult;
      anObject(innerResult);
      return value;
    };
  }
});

// node_modules/core-js/internals/iterate.js
var require_iterate = __commonJS({
  "node_modules/core-js/internals/iterate.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var bind = require_function_bind_context();
    var call = require_function_call();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var lengthOfArrayLike = require_length_of_array_like();
    var isPrototypeOf = require_object_is_prototype_of();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var iteratorClose = require_iterator_close();
    var TypeError2 = global2.TypeError;
    var Result = function(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    var ResultPrototype = Result.prototype;
    module2.exports = function(iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn = bind(unboundFunction, that);
      var iterator, iterFn, index2, length, result, next, step;
      var stop = function(condition) {
        if (iterator)
          iteratorClose(iterator, "normal", condition);
        return new Result(true, condition);
      };
      var callFn = function(value) {
        if (AS_ENTRIES) {
          anObject(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
      };
      if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn)
          throw TypeError2(tryToString(iterable) + " is not iterable");
        if (isArrayIteratorMethod(iterFn)) {
          for (index2 = 0, length = lengthOfArrayLike(iterable); length > index2; index2++) {
            result = callFn(iterable[index2]);
            if (result && isPrototypeOf(ResultPrototype, result))
              return result;
          }
          return new Result(false);
        }
        iterator = getIterator(iterable, iterFn);
      }
      next = iterator.next;
      while (!(step = call(next, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose(iterator, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
          return result;
      }
      return new Result(false);
    };
  }
});

// node_modules/core-js/modules/es.aggregate-error.js
var require_es_aggregate_error = __commonJS({
  "node_modules/core-js/modules/es.aggregate-error.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var isPrototypeOf = require_object_is_prototype_of();
    var getPrototypeOf3 = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var copyConstructorProperties = require_copy_constructor_properties();
    var create3 = require_object_create();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    var clearErrorStack = require_clear_error_stack();
    var installErrorCause = require_install_error_cause();
    var iterate = require_iterate();
    var normalizeStringArgument = require_normalize_string_argument();
    var wellKnownSymbol = require_well_known_symbol();
    var ERROR_STACK_INSTALLABLE = require_error_stack_installable();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var Error2 = global2.Error;
    var push = [].push;
    var $AggregateError = function AggregateError2(errors, message) {
      var options = arguments.length > 2 ? arguments[2] : void 0;
      var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
      var that;
      if (setPrototypeOf) {
        that = setPrototypeOf(new Error2(), isInstance ? getPrototypeOf3(this) : AggregateErrorPrototype);
      } else {
        that = isInstance ? this : create3(AggregateErrorPrototype);
        createNonEnumerableProperty(that, TO_STRING_TAG, "Error");
      }
      if (message !== void 0)
        createNonEnumerableProperty(that, "message", normalizeStringArgument(message));
      if (ERROR_STACK_INSTALLABLE)
        createNonEnumerableProperty(that, "stack", clearErrorStack(that.stack, 1));
      installErrorCause(that, options);
      var errorsArray = [];
      iterate(errors, push, { that: errorsArray });
      createNonEnumerableProperty(that, "errors", errorsArray);
      return that;
    };
    if (setPrototypeOf)
      setPrototypeOf($AggregateError, Error2);
    else
      copyConstructorProperties($AggregateError, Error2, { name: true });
    var AggregateErrorPrototype = $AggregateError.prototype = create3(Error2.prototype, {
      constructor: createPropertyDescriptor(1, $AggregateError),
      message: createPropertyDescriptor(1, ""),
      name: createPropertyDescriptor(1, "AggregateError")
    });
    $({ global: true }, {
      AggregateError: $AggregateError
    });
  }
});

// node_modules/core-js/modules/es.aggregate-error.cause.js
var require_es_aggregate_error_cause = __commonJS({
  "node_modules/core-js/modules/es.aggregate-error.cause.js"() {
    "use strict";
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var apply = require_function_apply();
    var fails = require_fails();
    var wrapErrorConstructorWithCause = require_wrap_error_constructor_with_cause();
    var AGGREGATE_ERROR = "AggregateError";
    var $AggregateError = getBuiltIn(AGGREGATE_ERROR);
    var FORCED = !fails(function() {
      return $AggregateError([1]).errors[0] !== 1;
    }) && fails(function() {
      return $AggregateError([1], AGGREGATE_ERROR, { cause: 7 }).cause !== 7;
    });
    $({ global: true, forced: FORCED }, {
      AggregateError: wrapErrorConstructorWithCause(AGGREGATE_ERROR, function(init) {
        return function AggregateError2(errors, message) {
          return apply(init, this, arguments);
        };
      }, FORCED, true)
    });
  }
});

// node_modules/core-js/internals/add-to-unscopables.js
var require_add_to_unscopables = __commonJS({
  "node_modules/core-js/internals/add-to-unscopables.js"(exports, module2) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var create3 = require_object_create();
    var definePropertyModule = require_object_define_property();
    var UNSCOPABLES = wellKnownSymbol("unscopables");
    var ArrayPrototype = Array.prototype;
    if (ArrayPrototype[UNSCOPABLES] == void 0) {
      definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
        configurable: true,
        value: create3(null)
      });
    }
    module2.exports = function(key) {
      ArrayPrototype[UNSCOPABLES][key] = true;
    };
  }
});

// node_modules/core-js/modules/es.array.at.js
var require_es_array_at = __commonJS({
  "node_modules/core-js/modules/es.array.at.js"() {
    "use strict";
    var $ = require_export();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var addToUnscopables = require_add_to_unscopables();
    $({ target: "Array", proto: true }, {
      at: function at(index2) {
        var O = toObject(this);
        var len = lengthOfArrayLike(O);
        var relativeIndex = toIntegerOrInfinity(index2);
        var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
        return k < 0 || k >= len ? void 0 : O[k];
      }
    });
    addToUnscopables("at");
  }
});

// node_modules/core-js/internals/array-method-has-species-support.js
var require_array_method_has_species_support = __commonJS({
  "node_modules/core-js/internals/array-method-has-species-support.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var V8_VERSION = require_engine_v8_version();
    var SPECIES = wellKnownSymbol("species");
    module2.exports = function(METHOD_NAME) {
      return V8_VERSION >= 51 || !fails(function() {
        var array = [];
        var constructor = array.constructor = {};
        constructor[SPECIES] = function() {
          return { foo: 1 };
        };
        return array[METHOD_NAME](Boolean).foo !== 1;
      });
    };
  }
});

// node_modules/core-js/modules/es.array.concat.js
var require_es_array_concat = __commonJS({
  "node_modules/core-js/modules/es.array.concat.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var fails = require_fails();
    var isArray3 = require_is_array();
    var isObject = require_is_object();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var createProperty = require_create_property();
    var arraySpeciesCreate = require_array_species_create();
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var wellKnownSymbol = require_well_known_symbol();
    var V8_VERSION = require_engine_v8_version();
    var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
    var TypeError2 = global2.TypeError;
    var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
      var array = [];
      array[IS_CONCAT_SPREADABLE] = false;
      return array.concat()[0] !== array;
    });
    var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
    var isConcatSpreadable = function(O) {
      if (!isObject(O))
        return false;
      var spreadable = O[IS_CONCAT_SPREADABLE];
      return spreadable !== void 0 ? !!spreadable : isArray3(O);
    };
    var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
    $({ target: "Array", proto: true, forced: FORCED }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      concat: function concat(arg) {
        var O = toObject(this);
        var A = arraySpeciesCreate(O, 0);
        var n = 0;
        var i, k, length, len, E;
        for (i = -1, length = arguments.length; i < length; i++) {
          E = i === -1 ? O : arguments[i];
          if (isConcatSpreadable(E)) {
            len = lengthOfArrayLike(E);
            if (n + len > MAX_SAFE_INTEGER)
              throw TypeError2(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
            for (k = 0; k < len; k++, n++)
              if (k in E)
                createProperty(A, n, E[k]);
          } else {
            if (n >= MAX_SAFE_INTEGER)
              throw TypeError2(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
            createProperty(A, n++, E);
          }
        }
        A.length = n;
        return A;
      }
    });
  }
});

// node_modules/core-js/internals/array-copy-within.js
var require_array_copy_within = __commonJS({
  "node_modules/core-js/internals/array-copy-within.js"(exports, module2) {
    "use strict";
    var toObject = require_to_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var min = Math.min;
    module2.exports = [].copyWithin || function copyWithin(target, start) {
      var O = toObject(this);
      var len = lengthOfArrayLike(O);
      var to = toAbsoluteIndex(target, len);
      var from = toAbsoluteIndex(start, len);
      var end = arguments.length > 2 ? arguments[2] : void 0;
      var count = min((end === void 0 ? len : toAbsoluteIndex(end, len)) - from, len - to);
      var inc = 1;
      if (from < to && to < from + count) {
        inc = -1;
        from += count - 1;
        to += count - 1;
      }
      while (count-- > 0) {
        if (from in O)
          O[to] = O[from];
        else
          delete O[to];
        to += inc;
        from += inc;
      }
      return O;
    };
  }
});

// node_modules/core-js/modules/es.array.copy-within.js
var require_es_array_copy_within = __commonJS({
  "node_modules/core-js/modules/es.array.copy-within.js"() {
    "use strict";
    var $ = require_export();
    var copyWithin = require_array_copy_within();
    var addToUnscopables = require_add_to_unscopables();
    $({ target: "Array", proto: true }, {
      copyWithin
    });
    addToUnscopables("copyWithin");
  }
});

// node_modules/core-js/internals/array-method-is-strict.js
var require_array_method_is_strict = __commonJS({
  "node_modules/core-js/internals/array-method-is-strict.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    module2.exports = function(METHOD_NAME, argument) {
      var method = [][METHOD_NAME];
      return !!method && fails(function() {
        method.call(null, argument || function() {
          throw 1;
        }, 1);
      });
    };
  }
});

// node_modules/core-js/modules/es.array.every.js
var require_es_array_every = __commonJS({
  "node_modules/core-js/modules/es.array.every.js"() {
    "use strict";
    var $ = require_export();
    var $every = require_array_iteration().every;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var STRICT_METHOD = arrayMethodIsStrict("every");
    $({ target: "Array", proto: true, forced: !STRICT_METHOD }, {
      every: function every(callbackfn) {
        return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js/internals/array-fill.js
var require_array_fill = __commonJS({
  "node_modules/core-js/internals/array-fill.js"(exports, module2) {
    "use strict";
    var toObject = require_to_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    module2.exports = function fill(value) {
      var O = toObject(this);
      var length = lengthOfArrayLike(O);
      var argumentsLength = arguments.length;
      var index2 = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : void 0, length);
      var end = argumentsLength > 2 ? arguments[2] : void 0;
      var endPos = end === void 0 ? length : toAbsoluteIndex(end, length);
      while (endPos > index2)
        O[index2++] = value;
      return O;
    };
  }
});

// node_modules/core-js/modules/es.array.fill.js
var require_es_array_fill = __commonJS({
  "node_modules/core-js/modules/es.array.fill.js"() {
    "use strict";
    var $ = require_export();
    var fill = require_array_fill();
    var addToUnscopables = require_add_to_unscopables();
    $({ target: "Array", proto: true }, {
      fill
    });
    addToUnscopables("fill");
  }
});

// node_modules/core-js/modules/es.array.filter.js
var require_es_array_filter = __commonJS({
  "node_modules/core-js/modules/es.array.filter.js"() {
    "use strict";
    var $ = require_export();
    var $filter = require_array_iteration().filter;
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
    $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
      filter: function filter3(callbackfn) {
        return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js/modules/es.array.find.js
var require_es_array_find = __commonJS({
  "node_modules/core-js/modules/es.array.find.js"() {
    "use strict";
    var $ = require_export();
    var $find = require_array_iteration().find;
    var addToUnscopables = require_add_to_unscopables();
    var FIND = "find";
    var SKIPS_HOLES = true;
    if (FIND in [])
      Array(1)[FIND](function() {
        SKIPS_HOLES = false;
      });
    $({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
      find: function find4(callbackfn) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    addToUnscopables(FIND);
  }
});

// node_modules/core-js/modules/es.array.find-index.js
var require_es_array_find_index = __commonJS({
  "node_modules/core-js/modules/es.array.find-index.js"() {
    "use strict";
    var $ = require_export();
    var $findIndex = require_array_iteration().findIndex;
    var addToUnscopables = require_add_to_unscopables();
    var FIND_INDEX = "findIndex";
    var SKIPS_HOLES = true;
    if (FIND_INDEX in [])
      Array(1)[FIND_INDEX](function() {
        SKIPS_HOLES = false;
      });
    $({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
      findIndex: function findIndex(callbackfn) {
        return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    addToUnscopables(FIND_INDEX);
  }
});

// node_modules/core-js/internals/flatten-into-array.js
var require_flatten_into_array = __commonJS({
  "node_modules/core-js/internals/flatten-into-array.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var isArray3 = require_is_array();
    var lengthOfArrayLike = require_length_of_array_like();
    var bind = require_function_bind_context();
    var TypeError2 = global2.TypeError;
    var flattenIntoArray = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
      var targetIndex = start;
      var sourceIndex = 0;
      var mapFn = mapper ? bind(mapper, thisArg) : false;
      var element, elementLen;
      while (sourceIndex < sourceLen) {
        if (sourceIndex in source) {
          element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
          if (depth > 0 && isArray3(element)) {
            elementLen = lengthOfArrayLike(element);
            targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
          } else {
            if (targetIndex >= 9007199254740991)
              throw TypeError2("Exceed the acceptable array length");
            target[targetIndex] = element;
          }
          targetIndex++;
        }
        sourceIndex++;
      }
      return targetIndex;
    };
    module2.exports = flattenIntoArray;
  }
});

// node_modules/core-js/modules/es.array.flat.js
var require_es_array_flat = __commonJS({
  "node_modules/core-js/modules/es.array.flat.js"() {
    "use strict";
    var $ = require_export();
    var flattenIntoArray = require_flatten_into_array();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var arraySpeciesCreate = require_array_species_create();
    $({ target: "Array", proto: true }, {
      flat: function flat() {
        var depthArg = arguments.length ? arguments[0] : void 0;
        var O = toObject(this);
        var sourceLen = lengthOfArrayLike(O);
        var A = arraySpeciesCreate(O, 0);
        A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === void 0 ? 1 : toIntegerOrInfinity(depthArg));
        return A;
      }
    });
  }
});

// node_modules/core-js/modules/es.array.flat-map.js
var require_es_array_flat_map = __commonJS({
  "node_modules/core-js/modules/es.array.flat-map.js"() {
    "use strict";
    var $ = require_export();
    var flattenIntoArray = require_flatten_into_array();
    var aCallable = require_a_callable();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var arraySpeciesCreate = require_array_species_create();
    $({ target: "Array", proto: true }, {
      flatMap: function flatMap(callbackfn) {
        var O = toObject(this);
        var sourceLen = lengthOfArrayLike(O);
        var A;
        aCallable(callbackfn);
        A = arraySpeciesCreate(O, 0);
        A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        return A;
      }
    });
  }
});

// node_modules/core-js/internals/array-for-each.js
var require_array_for_each = __commonJS({
  "node_modules/core-js/internals/array-for-each.js"(exports, module2) {
    "use strict";
    var $forEach = require_array_iteration().forEach;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var STRICT_METHOD = arrayMethodIsStrict("forEach");
    module2.exports = !STRICT_METHOD ? function forEach(callbackfn) {
      return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    } : [].forEach;
  }
});

// node_modules/core-js/modules/es.array.for-each.js
var require_es_array_for_each = __commonJS({
  "node_modules/core-js/modules/es.array.for-each.js"() {
    "use strict";
    var $ = require_export();
    var forEach = require_array_for_each();
    $({ target: "Array", proto: true, forced: [].forEach != forEach }, {
      forEach
    });
  }
});

// node_modules/core-js/internals/call-with-safe-iteration-closing.js
var require_call_with_safe_iteration_closing = __commonJS({
  "node_modules/core-js/internals/call-with-safe-iteration-closing.js"(exports, module2) {
    "use strict";
    var anObject = require_an_object();
    var iteratorClose = require_iterator_close();
    module2.exports = function(iterator, fn, value, ENTRIES) {
      try {
        return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
      } catch (error) {
        iteratorClose(iterator, "throw", error);
      }
    };
  }
});

// node_modules/core-js/internals/array-from.js
var require_array_from = __commonJS({
  "node_modules/core-js/internals/array-from.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var bind = require_function_bind_context();
    var call = require_function_call();
    var toObject = require_to_object();
    var callWithSafeIterationClosing = require_call_with_safe_iteration_closing();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var isConstructor = require_is_constructor();
    var lengthOfArrayLike = require_length_of_array_like();
    var createProperty = require_create_property();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var Array2 = global2.Array;
    module2.exports = function from(arrayLike) {
      var O = toObject(arrayLike);
      var IS_CONSTRUCTOR = isConstructor(this);
      var argumentsLength = arguments.length;
      var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
      var mapping = mapfn !== void 0;
      if (mapping)
        mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
      var iteratorMethod = getIteratorMethod(O);
      var index2 = 0;
      var length, result, step, iterator, next, value;
      if (iteratorMethod && !(this == Array2 && isArrayIteratorMethod(iteratorMethod))) {
        iterator = getIterator(O, iteratorMethod);
        next = iterator.next;
        result = IS_CONSTRUCTOR ? new this() : [];
        for (; !(step = call(next, iterator)).done; index2++) {
          value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index2], true) : step.value;
          createProperty(result, index2, value);
        }
      } else {
        length = lengthOfArrayLike(O);
        result = IS_CONSTRUCTOR ? new this(length) : Array2(length);
        for (; length > index2; index2++) {
          value = mapping ? mapfn(O[index2], index2) : O[index2];
          createProperty(result, index2, value);
        }
      }
      result.length = index2;
      return result;
    };
  }
});

// node_modules/core-js/internals/check-correctness-of-iteration.js
var require_check_correctness_of_iteration = __commonJS({
  "node_modules/core-js/internals/check-correctness-of-iteration.js"(exports, module2) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var SAFE_CLOSING = false;
    try {
      called = 0;
      iteratorWithReturn = {
        next: function() {
          return { done: !!called++ };
        },
        "return": function() {
          SAFE_CLOSING = true;
        }
      };
      iteratorWithReturn[ITERATOR] = function() {
        return this;
      };
      Array.from(iteratorWithReturn, function() {
        throw 2;
      });
    } catch (error) {
    }
    var called;
    var iteratorWithReturn;
    module2.exports = function(exec, SKIP_CLOSING) {
      if (!SKIP_CLOSING && !SAFE_CLOSING)
        return false;
      var ITERATION_SUPPORT = false;
      try {
        var object = {};
        object[ITERATOR] = function() {
          return {
            next: function() {
              return { done: ITERATION_SUPPORT = true };
            }
          };
        };
        exec(object);
      } catch (error) {
      }
      return ITERATION_SUPPORT;
    };
  }
});

// node_modules/core-js/modules/es.array.from.js
var require_es_array_from = __commonJS({
  "node_modules/core-js/modules/es.array.from.js"() {
    "use strict";
    var $ = require_export();
    var from = require_array_from();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
      Array.from(iterable);
    });
    $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
      from
    });
  }
});

// node_modules/core-js/modules/es.array.includes.js
var require_es_array_includes = __commonJS({
  "node_modules/core-js/modules/es.array.includes.js"() {
    "use strict";
    var $ = require_export();
    var $includes = require_array_includes().includes;
    var addToUnscopables = require_add_to_unscopables();
    $({ target: "Array", proto: true }, {
      includes: function includes(el) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    addToUnscopables("includes");
  }
});

// node_modules/core-js/modules/es.array.index-of.js
var require_es_array_index_of = __commonJS({
  "node_modules/core-js/modules/es.array.index-of.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var $IndexOf = require_array_includes().indexOf;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var un$IndexOf = uncurryThis([].indexOf);
    var NEGATIVE_ZERO = !!un$IndexOf && 1 / un$IndexOf([1], 1, -0) < 0;
    var STRICT_METHOD = arrayMethodIsStrict("indexOf");
    $({ target: "Array", proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD }, {
      indexOf: function indexOf(searchElement) {
        var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
        return NEGATIVE_ZERO ? un$IndexOf(this, searchElement, fromIndex) || 0 : $IndexOf(this, searchElement, fromIndex);
      }
    });
  }
});

// node_modules/core-js/modules/es.array.is-array.js
var require_es_array_is_array = __commonJS({
  "node_modules/core-js/modules/es.array.is-array.js"() {
    "use strict";
    var $ = require_export();
    var isArray3 = require_is_array();
    $({ target: "Array", stat: true }, {
      isArray: isArray3
    });
  }
});

// node_modules/core-js/internals/iterators-core.js
var require_iterators_core = __commonJS({
  "node_modules/core-js/internals/iterators-core.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var create3 = require_object_create();
    var getPrototypeOf3 = require_object_get_prototype_of();
    var redefine = require_redefine();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var ITERATOR = wellKnownSymbol("iterator");
    var BUGGY_SAFARI_ITERATORS = false;
    var IteratorPrototype;
    var PrototypeOfArrayIteratorPrototype;
    var arrayIterator;
    if ([].keys) {
      arrayIterator = [].keys();
      if (!("next" in arrayIterator))
        BUGGY_SAFARI_ITERATORS = true;
      else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf3(getPrototypeOf3(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
          IteratorPrototype = PrototypeOfArrayIteratorPrototype;
      }
    }
    var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == void 0 || fails(function() {
      var test = {};
      return IteratorPrototype[ITERATOR].call(test) !== test;
    });
    if (NEW_ITERATOR_PROTOTYPE)
      IteratorPrototype = {};
    else if (IS_PURE)
      IteratorPrototype = create3(IteratorPrototype);
    if (!isCallable(IteratorPrototype[ITERATOR])) {
      redefine(IteratorPrototype, ITERATOR, function() {
        return this;
      });
    }
    module2.exports = {
      IteratorPrototype,
      BUGGY_SAFARI_ITERATORS
    };
  }
});

// node_modules/core-js/internals/create-iterator-constructor.js
var require_create_iterator_constructor = __commonJS({
  "node_modules/core-js/internals/create-iterator-constructor.js"(exports, module2) {
    "use strict";
    var IteratorPrototype = require_iterators_core().IteratorPrototype;
    var create3 = require_object_create();
    var createPropertyDescriptor = require_create_property_descriptor();
    var setToStringTag = require_set_to_string_tag();
    var Iterators = require_iterators();
    var returnThis = function() {
      return this;
    };
    module2.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
      var TO_STRING_TAG = NAME + " Iterator";
      IteratorConstructor.prototype = create3(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
      setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
      Iterators[TO_STRING_TAG] = returnThis;
      return IteratorConstructor;
    };
  }
});

// node_modules/core-js/internals/define-iterator.js
var require_define_iterator = __commonJS({
  "node_modules/core-js/internals/define-iterator.js"(exports, module2) {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var IS_PURE = require_is_pure();
    var FunctionName = require_function_name();
    var isCallable = require_is_callable();
    var createIteratorConstructor = require_create_iterator_constructor();
    var getPrototypeOf3 = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var redefine = require_redefine();
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var IteratorsCore = require_iterators_core();
    var PROPER_FUNCTION_NAME = FunctionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
    var IteratorPrototype = IteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR = wellKnownSymbol("iterator");
    var KEYS = "keys";
    var VALUES = "values";
    var ENTRIES = "entries";
    var returnThis = function() {
      return this;
    };
    module2.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
      createIteratorConstructor(IteratorConstructor, NAME, next);
      var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator)
          return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
          return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS:
            return function keys() {
              return new IteratorConstructor(this, KIND);
            };
          case VALUES:
            return function values() {
              return new IteratorConstructor(this, KIND);
            };
          case ENTRIES:
            return function entries() {
              return new IteratorConstructor(this, KIND);
            };
        }
        return function() {
          return new IteratorConstructor(this);
        };
      };
      var TO_STRING_TAG = NAME + " Iterator";
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY;
      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf3(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (!IS_PURE && getPrototypeOf3(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (setPrototypeOf) {
              setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
            } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
              redefine(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
          }
          setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
          if (IS_PURE)
            Iterators[TO_STRING_TAG] = returnThis;
        }
      }
      if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty(IterablePrototype, "name", VALUES);
        } else {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = function values() {
            return call(nativeIterator, this);
          };
        }
      }
      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED)
          for (KEY in methods) {
            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
              redefine(IterablePrototype, KEY, methods[KEY]);
            }
          }
        else
          $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
      }
      if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
        redefine(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
      }
      Iterators[NAME] = defaultIterator;
      return methods;
    };
  }
});

// node_modules/core-js/modules/es.array.iterator.js
var require_es_array_iterator = __commonJS({
  "node_modules/core-js/modules/es.array.iterator.js"(exports, module2) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var addToUnscopables = require_add_to_unscopables();
    var Iterators = require_iterators();
    var InternalStateModule = require_internal_state();
    var defineProperty3 = require_object_define_property().f;
    var defineIterator = require_define_iterator();
    var IS_PURE = require_is_pure();
    var DESCRIPTORS = require_descriptors();
    var ARRAY_ITERATOR = "Array Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
    module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
      setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        // target
        index: 0,
        // next index
        kind
        // kind
      });
    }, function() {
      var state = getInternalState(this);
      var target = state.target;
      var kind = state.kind;
      var index2 = state.index++;
      if (!target || index2 >= target.length) {
        state.target = void 0;
        return { value: void 0, done: true };
      }
      if (kind == "keys")
        return { value: index2, done: false };
      if (kind == "values")
        return { value: target[index2], done: false };
      return { value: [index2, target[index2]], done: false };
    }, "values");
    var values = Iterators.Arguments = Iterators.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
    if (!IS_PURE && DESCRIPTORS && values.name !== "values")
      try {
        defineProperty3(values, "name", { value: "values" });
      } catch (error) {
      }
  }
});

// node_modules/core-js/modules/es.array.join.js
var require_es_array_join = __commonJS({
  "node_modules/core-js/modules/es.array.join.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var IndexedObject = require_indexed_object();
    var toIndexedObject = require_to_indexed_object();
    var arrayMethodIsStrict = require_array_method_is_strict();
    var un$Join = uncurryThis([].join);
    var ES3_STRINGS = IndexedObject != Object;
    var STRICT_METHOD = arrayMethodIsStrict("join", ",");
    $({ target: "Array", proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
      join: function join(separator) {
        return un$Join(toIndexedObject(this), separator === void 0 ? "," : separator);
      }
    });
  }
});

// node_modules/core-js/internals/array-last-index-of.js
var require_array_last_index_of = __commonJS({
  "node_modules/core-js/internals/array-last-index-of.js"(exports, module2) {
    "use strict";
    var apply = require_function_apply();
    var toIndexedObject = require_to_indexed_object();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var lengthOfArrayLike = require_length_of_array_like();
    var arrayMethodIsStrict = require_array_method_is_strict();
    var min = Math.min;
    var $lastIndexOf = [].lastIndexOf;
    var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
    var STRICT_METHOD = arrayMethodIsStrict("lastIndexOf");
    var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;
    module2.exports = FORCED ? function lastIndexOf(searchElement) {
      if (NEGATIVE_ZERO)
        return apply($lastIndexOf, this, arguments) || 0;
      var O = toIndexedObject(this);
      var length = lengthOfArrayLike(O);
      var index2 = length - 1;
      if (arguments.length > 1)
        index2 = min(index2, toIntegerOrInfinity(arguments[1]));
      if (index2 < 0)
        index2 = length + index2;
      for (; index2 >= 0; index2--)
        if (index2 in O && O[index2] === searchElement)
          return index2 || 0;
      return -1;
    } : $lastIndexOf;
  }
});

// node_modules/core-js/modules/es.array.last-index-of.js
var require_es_array_last_index_of = __commonJS({
  "node_modules/core-js/modules/es.array.last-index-of.js"() {
    "use strict";
    var $ = require_export();
    var lastIndexOf = require_array_last_index_of();
    $({ target: "Array", proto: true, forced: lastIndexOf !== [].lastIndexOf }, {
      lastIndexOf
    });
  }
});

// node_modules/core-js/modules/es.array.map.js
var require_es_array_map = __commonJS({
  "node_modules/core-js/modules/es.array.map.js"() {
    "use strict";
    var $ = require_export();
    var $map = require_array_iteration().map;
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
    $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
      map: function map(callbackfn) {
        return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js/modules/es.array.of.js
var require_es_array_of = __commonJS({
  "node_modules/core-js/modules/es.array.of.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var fails = require_fails();
    var isConstructor = require_is_constructor();
    var createProperty = require_create_property();
    var Array2 = global2.Array;
    var ISNT_GENERIC = fails(function() {
      function F() {
      }
      return !(Array2.of.call(F) instanceof F);
    });
    $({ target: "Array", stat: true, forced: ISNT_GENERIC }, {
      of: function of() {
        var index2 = 0;
        var argumentsLength = arguments.length;
        var result = new (isConstructor(this) ? this : Array2)(argumentsLength);
        while (argumentsLength > index2)
          createProperty(result, index2, arguments[index2++]);
        result.length = argumentsLength;
        return result;
      }
    });
  }
});

// node_modules/core-js/internals/array-reduce.js
var require_array_reduce = __commonJS({
  "node_modules/core-js/internals/array-reduce.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var aCallable = require_a_callable();
    var toObject = require_to_object();
    var IndexedObject = require_indexed_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var TypeError2 = global2.TypeError;
    var createMethod = function(IS_RIGHT) {
      return function(that, callbackfn, argumentsLength, memo) {
        aCallable(callbackfn);
        var O = toObject(that);
        var self2 = IndexedObject(O);
        var length = lengthOfArrayLike(O);
        var index2 = IS_RIGHT ? length - 1 : 0;
        var i = IS_RIGHT ? -1 : 1;
        if (argumentsLength < 2)
          while (true) {
            if (index2 in self2) {
              memo = self2[index2];
              index2 += i;
              break;
            }
            index2 += i;
            if (IS_RIGHT ? index2 < 0 : length <= index2) {
              throw TypeError2("Reduce of empty array with no initial value");
            }
          }
        for (; IS_RIGHT ? index2 >= 0 : length > index2; index2 += i)
          if (index2 in self2) {
            memo = callbackfn(memo, self2[index2], index2, O);
          }
        return memo;
      };
    };
    module2.exports = {
      // `Array.prototype.reduce` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduce
      left: createMethod(false),
      // `Array.prototype.reduceRight` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduceright
      right: createMethod(true)
    };
  }
});

// node_modules/core-js/internals/engine-is-node.js
var require_engine_is_node = __commonJS({
  "node_modules/core-js/internals/engine-is-node.js"(exports, module2) {
    "use strict";
    var classof = require_classof_raw();
    var global2 = require_global();
    module2.exports = classof(global2.process) == "process";
  }
});

// node_modules/core-js/modules/es.array.reduce.js
var require_es_array_reduce = __commonJS({
  "node_modules/core-js/modules/es.array.reduce.js"() {
    "use strict";
    var $ = require_export();
    var $reduce = require_array_reduce().left;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var CHROME_VERSION = require_engine_v8_version();
    var IS_NODE = require_engine_is_node();
    var STRICT_METHOD = arrayMethodIsStrict("reduce");
    var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
    $({ target: "Array", proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {
      reduce: function reduce(callbackfn) {
        var length = arguments.length;
        return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js/modules/es.array.reduce-right.js
var require_es_array_reduce_right = __commonJS({
  "node_modules/core-js/modules/es.array.reduce-right.js"() {
    "use strict";
    var $ = require_export();
    var $reduceRight = require_array_reduce().right;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var CHROME_VERSION = require_engine_v8_version();
    var IS_NODE = require_engine_is_node();
    var STRICT_METHOD = arrayMethodIsStrict("reduceRight");
    var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
    $({ target: "Array", proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {
      reduceRight: function reduceRight(callbackfn) {
        return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js/modules/es.array.reverse.js
var require_es_array_reverse = __commonJS({
  "node_modules/core-js/modules/es.array.reverse.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var isArray3 = require_is_array();
    var un$Reverse = uncurryThis([].reverse);
    var test = [1, 2];
    $({ target: "Array", proto: true, forced: String(test) === String(test.reverse()) }, {
      reverse: function reverse() {
        if (isArray3(this))
          this.length = this.length;
        return un$Reverse(this);
      }
    });
  }
});

// node_modules/core-js/modules/es.array.slice.js
var require_es_array_slice = __commonJS({
  "node_modules/core-js/modules/es.array.slice.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var isArray3 = require_is_array();
    var isConstructor = require_is_constructor();
    var isObject = require_is_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var toIndexedObject = require_to_indexed_object();
    var createProperty = require_create_property();
    var wellKnownSymbol = require_well_known_symbol();
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var un$Slice = require_array_slice();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
    var SPECIES = wellKnownSymbol("species");
    var Array2 = global2.Array;
    var max = Math.max;
    $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
      slice: function slice(start, end) {
        var O = toIndexedObject(this);
        var length = lengthOfArrayLike(O);
        var k = toAbsoluteIndex(start, length);
        var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
        var Constructor, result, n;
        if (isArray3(O)) {
          Constructor = O.constructor;
          if (isConstructor(Constructor) && (Constructor === Array2 || isArray3(Constructor.prototype))) {
            Constructor = void 0;
          } else if (isObject(Constructor)) {
            Constructor = Constructor[SPECIES];
            if (Constructor === null)
              Constructor = void 0;
          }
          if (Constructor === Array2 || Constructor === void 0) {
            return un$Slice(O, k, fin);
          }
        }
        result = new (Constructor === void 0 ? Array2 : Constructor)(max(fin - k, 0));
        for (n = 0; k < fin; k++, n++)
          if (k in O)
            createProperty(result, n, O[k]);
        result.length = n;
        return result;
      }
    });
  }
});

// node_modules/core-js/modules/es.array.some.js
var require_es_array_some = __commonJS({
  "node_modules/core-js/modules/es.array.some.js"() {
    "use strict";
    var $ = require_export();
    var $some = require_array_iteration().some;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var STRICT_METHOD = arrayMethodIsStrict("some");
    $({ target: "Array", proto: true, forced: !STRICT_METHOD }, {
      some: function some(callbackfn) {
        return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js/internals/array-sort.js
var require_array_sort = __commonJS({
  "node_modules/core-js/internals/array-sort.js"(exports, module2) {
    "use strict";
    var arraySlice = require_array_slice_simple();
    var floor = Math.floor;
    var mergeSort = function(array, comparefn) {
      var length = array.length;
      var middle = floor(length / 2);
      return length < 8 ? insertionSort(array, comparefn) : merge(
        array,
        mergeSort(arraySlice(array, 0, middle), comparefn),
        mergeSort(arraySlice(array, middle), comparefn),
        comparefn
      );
    };
    var insertionSort = function(array, comparefn) {
      var length = array.length;
      var i = 1;
      var element, j;
      while (i < length) {
        j = i;
        element = array[i];
        while (j && comparefn(array[j - 1], element) > 0) {
          array[j] = array[--j];
        }
        if (j !== i++)
          array[j] = element;
      }
      return array;
    };
    var merge = function(array, left, right, comparefn) {
      var llength = left.length;
      var rlength = right.length;
      var lindex = 0;
      var rindex = 0;
      while (lindex < llength || rindex < rlength) {
        array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
      }
      return array;
    };
    module2.exports = mergeSort;
  }
});

// node_modules/core-js/internals/engine-ff-version.js
var require_engine_ff_version = __commonJS({
  "node_modules/core-js/internals/engine-ff-version.js"(exports, module2) {
    "use strict";
    var userAgent = require_engine_user_agent();
    var firefox = userAgent.match(/firefox\/(\d+)/i);
    module2.exports = !!firefox && +firefox[1];
  }
});

// node_modules/core-js/internals/engine-is-ie-or-edge.js
var require_engine_is_ie_or_edge = __commonJS({
  "node_modules/core-js/internals/engine-is-ie-or-edge.js"(exports, module2) {
    "use strict";
    var UA = require_engine_user_agent();
    module2.exports = /MSIE|Trident/.test(UA);
  }
});

// node_modules/core-js/internals/engine-webkit-version.js
var require_engine_webkit_version = __commonJS({
  "node_modules/core-js/internals/engine-webkit-version.js"(exports, module2) {
    "use strict";
    var userAgent = require_engine_user_agent();
    var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
    module2.exports = !!webkit && +webkit[1];
  }
});

// node_modules/core-js/modules/es.array.sort.js
var require_es_array_sort = __commonJS({
  "node_modules/core-js/modules/es.array.sort.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var toString = require_to_string();
    var fails = require_fails();
    var internalSort = require_array_sort();
    var arrayMethodIsStrict = require_array_method_is_strict();
    var FF = require_engine_ff_version();
    var IE_OR_EDGE = require_engine_is_ie_or_edge();
    var V8 = require_engine_v8_version();
    var WEBKIT = require_engine_webkit_version();
    var test = [];
    var un$Sort = uncurryThis(test.sort);
    var push = uncurryThis(test.push);
    var FAILS_ON_UNDEFINED = fails(function() {
      test.sort(void 0);
    });
    var FAILS_ON_NULL = fails(function() {
      test.sort(null);
    });
    var STRICT_METHOD = arrayMethodIsStrict("sort");
    var STABLE_SORT = !fails(function() {
      if (V8)
        return V8 < 70;
      if (FF && FF > 3)
        return;
      if (IE_OR_EDGE)
        return true;
      if (WEBKIT)
        return WEBKIT < 603;
      var result = "";
      var code, chr, value, index2;
      for (code = 65; code < 76; code++) {
        chr = String.fromCharCode(code);
        switch (code) {
          case 66:
          case 69:
          case 70:
          case 72:
            value = 3;
            break;
          case 68:
          case 71:
            value = 4;
            break;
          default:
            value = 2;
        }
        for (index2 = 0; index2 < 47; index2++) {
          test.push({ k: chr + index2, v: value });
        }
      }
      test.sort(function(a, b) {
        return b.v - a.v;
      });
      for (index2 = 0; index2 < test.length; index2++) {
        chr = test[index2].k.charAt(0);
        if (result.charAt(result.length - 1) !== chr)
          result += chr;
      }
      return result !== "DGBEFHACIJK";
    });
    var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
    var getSortCompare = function(comparefn) {
      return function(x, y) {
        if (y === void 0)
          return -1;
        if (x === void 0)
          return 1;
        if (comparefn !== void 0)
          return +comparefn(x, y) || 0;
        return toString(x) > toString(y) ? 1 : -1;
      };
    };
    $({ target: "Array", proto: true, forced: FORCED }, {
      sort: function sort(comparefn) {
        if (comparefn !== void 0)
          aCallable(comparefn);
        var array = toObject(this);
        if (STABLE_SORT)
          return comparefn === void 0 ? un$Sort(array) : un$Sort(array, comparefn);
        var items = [];
        var arrayLength = lengthOfArrayLike(array);
        var itemsLength, index2;
        for (index2 = 0; index2 < arrayLength; index2++) {
          if (index2 in array)
            push(items, array[index2]);
        }
        internalSort(items, getSortCompare(comparefn));
        itemsLength = items.length;
        index2 = 0;
        while (index2 < itemsLength)
          array[index2] = items[index2++];
        while (index2 < arrayLength)
          delete array[index2++];
        return array;
      }
    });
  }
});

// node_modules/core-js/internals/set-species.js
var require_set_species = __commonJS({
  "node_modules/core-js/internals/set-species.js"(exports, module2) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var definePropertyModule = require_object_define_property();
    var wellKnownSymbol = require_well_known_symbol();
    var DESCRIPTORS = require_descriptors();
    var SPECIES = wellKnownSymbol("species");
    module2.exports = function(CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
      var defineProperty3 = definePropertyModule.f;
      if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
        defineProperty3(Constructor, SPECIES, {
          configurable: true,
          get: function() {
            return this;
          }
        });
      }
    };
  }
});

// node_modules/core-js/modules/es.array.species.js
var require_es_array_species = __commonJS({
  "node_modules/core-js/modules/es.array.species.js"() {
    "use strict";
    var setSpecies = require_set_species();
    setSpecies("Array");
  }
});

// node_modules/core-js/modules/es.array.splice.js
var require_es_array_splice = __commonJS({
  "node_modules/core-js/modules/es.array.splice.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var toAbsoluteIndex = require_to_absolute_index();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var lengthOfArrayLike = require_length_of_array_like();
    var toObject = require_to_object();
    var arraySpeciesCreate = require_array_species_create();
    var createProperty = require_create_property();
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
    var TypeError2 = global2.TypeError;
    var max = Math.max;
    var min = Math.min;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
    $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
      splice: function splice(start, deleteCount) {
        var O = toObject(this);
        var len = lengthOfArrayLike(O);
        var actualStart = toAbsoluteIndex(start, len);
        var argumentsLength = arguments.length;
        var insertCount, actualDeleteCount, A, k, from, to;
        if (argumentsLength === 0) {
          insertCount = actualDeleteCount = 0;
        } else if (argumentsLength === 1) {
          insertCount = 0;
          actualDeleteCount = len - actualStart;
        } else {
          insertCount = argumentsLength - 2;
          actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
        }
        if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
          throw TypeError2(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
        }
        A = arraySpeciesCreate(O, actualDeleteCount);
        for (k = 0; k < actualDeleteCount; k++) {
          from = actualStart + k;
          if (from in O)
            createProperty(A, k, O[from]);
        }
        A.length = actualDeleteCount;
        if (insertCount < actualDeleteCount) {
          for (k = actualStart; k < len - actualDeleteCount; k++) {
            from = k + actualDeleteCount;
            to = k + insertCount;
            if (from in O)
              O[to] = O[from];
            else
              delete O[to];
          }
          for (k = len; k > len - actualDeleteCount + insertCount; k--)
            delete O[k - 1];
        } else if (insertCount > actualDeleteCount) {
          for (k = len - actualDeleteCount; k > actualStart; k--) {
            from = k + actualDeleteCount - 1;
            to = k + insertCount - 1;
            if (from in O)
              O[to] = O[from];
            else
              delete O[to];
          }
        }
        for (k = 0; k < insertCount; k++) {
          O[k + actualStart] = arguments[k + 2];
        }
        O.length = len - actualDeleteCount + insertCount;
        return A;
      }
    });
  }
});

// node_modules/core-js/modules/es.array.unscopables.flat.js
var require_es_array_unscopables_flat = __commonJS({
  "node_modules/core-js/modules/es.array.unscopables.flat.js"() {
    "use strict";
    var addToUnscopables = require_add_to_unscopables();
    addToUnscopables("flat");
  }
});

// node_modules/core-js/modules/es.array.unscopables.flat-map.js
var require_es_array_unscopables_flat_map = __commonJS({
  "node_modules/core-js/modules/es.array.unscopables.flat-map.js"() {
    "use strict";
    var addToUnscopables = require_add_to_unscopables();
    addToUnscopables("flatMap");
  }
});

// node_modules/core-js/internals/array-buffer-native.js
var require_array_buffer_native = __commonJS({
  "node_modules/core-js/internals/array-buffer-native.js"(exports, module2) {
    "use strict";
    module2.exports = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
  }
});

// node_modules/core-js/internals/redefine-all.js
var require_redefine_all = __commonJS({
  "node_modules/core-js/internals/redefine-all.js"(exports, module2) {
    "use strict";
    var redefine = require_redefine();
    module2.exports = function(target, src, options) {
      for (var key in src)
        redefine(target, key, src[key], options);
      return target;
    };
  }
});

// node_modules/core-js/internals/an-instance.js
var require_an_instance = __commonJS({
  "node_modules/core-js/internals/an-instance.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var isPrototypeOf = require_object_is_prototype_of();
    var TypeError2 = global2.TypeError;
    module2.exports = function(it, Prototype) {
      if (isPrototypeOf(Prototype, it))
        return it;
      throw TypeError2("Incorrect invocation");
    };
  }
});

// node_modules/core-js/internals/to-index.js
var require_to_index = __commonJS({
  "node_modules/core-js/internals/to-index.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toLength = require_to_length();
    var RangeError2 = global2.RangeError;
    module2.exports = function(it) {
      if (it === void 0)
        return 0;
      var number = toIntegerOrInfinity(it);
      var length = toLength(number);
      if (number !== length)
        throw RangeError2("Wrong length or index");
      return length;
    };
  }
});

// node_modules/core-js/internals/ieee754.js
var require_ieee754 = __commonJS({
  "node_modules/core-js/internals/ieee754.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var Array2 = global2.Array;
    var abs = Math.abs;
    var pow = Math.pow;
    var floor = Math.floor;
    var log = Math.log;
    var LN2 = Math.LN2;
    var pack = function(number, mantissaLength, bytes) {
      var buffer = Array2(bytes);
      var exponentLength = bytes * 8 - mantissaLength - 1;
      var eMax = (1 << exponentLength) - 1;
      var eBias = eMax >> 1;
      var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
      var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
      var index2 = 0;
      var exponent, mantissa, c;
      number = abs(number);
      if (number != number || number === Infinity) {
        mantissa = number != number ? 1 : 0;
        exponent = eMax;
      } else {
        exponent = floor(log(number) / LN2);
        c = pow(2, -exponent);
        if (number * c < 1) {
          exponent--;
          c *= 2;
        }
        if (exponent + eBias >= 1) {
          number += rt / c;
        } else {
          number += rt * pow(2, 1 - eBias);
        }
        if (number * c >= 2) {
          exponent++;
          c /= 2;
        }
        if (exponent + eBias >= eMax) {
          mantissa = 0;
          exponent = eMax;
        } else if (exponent + eBias >= 1) {
          mantissa = (number * c - 1) * pow(2, mantissaLength);
          exponent = exponent + eBias;
        } else {
          mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
          exponent = 0;
        }
      }
      while (mantissaLength >= 8) {
        buffer[index2++] = mantissa & 255;
        mantissa /= 256;
        mantissaLength -= 8;
      }
      exponent = exponent << mantissaLength | mantissa;
      exponentLength += mantissaLength;
      while (exponentLength > 0) {
        buffer[index2++] = exponent & 255;
        exponent /= 256;
        exponentLength -= 8;
      }
      buffer[--index2] |= sign * 128;
      return buffer;
    };
    var unpack = function(buffer, mantissaLength) {
      var bytes = buffer.length;
      var exponentLength = bytes * 8 - mantissaLength - 1;
      var eMax = (1 << exponentLength) - 1;
      var eBias = eMax >> 1;
      var nBits = exponentLength - 7;
      var index2 = bytes - 1;
      var sign = buffer[index2--];
      var exponent = sign & 127;
      var mantissa;
      sign >>= 7;
      while (nBits > 0) {
        exponent = exponent * 256 + buffer[index2--];
        nBits -= 8;
      }
      mantissa = exponent & (1 << -nBits) - 1;
      exponent >>= -nBits;
      nBits += mantissaLength;
      while (nBits > 0) {
        mantissa = mantissa * 256 + buffer[index2--];
        nBits -= 8;
      }
      if (exponent === 0) {
        exponent = 1 - eBias;
      } else if (exponent === eMax) {
        return mantissa ? NaN : sign ? -Infinity : Infinity;
      } else {
        mantissa = mantissa + pow(2, mantissaLength);
        exponent = exponent - eBias;
      }
      return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
    };
    module2.exports = {
      pack,
      unpack
    };
  }
});

// node_modules/core-js/internals/array-buffer.js
var require_array_buffer = __commonJS({
  "node_modules/core-js/internals/array-buffer.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var DESCRIPTORS = require_descriptors();
    var NATIVE_ARRAY_BUFFER = require_array_buffer_native();
    var FunctionName = require_function_name();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var redefineAll = require_redefine_all();
    var fails = require_fails();
    var anInstance = require_an_instance();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toLength = require_to_length();
    var toIndex = require_to_index();
    var IEEE754 = require_ieee754();
    var getPrototypeOf3 = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var getOwnPropertyNames3 = require_object_get_own_property_names().f;
    var defineProperty3 = require_object_define_property().f;
    var arrayFill = require_array_fill();
    var arraySlice = require_array_slice_simple();
    var setToStringTag = require_set_to_string_tag();
    var InternalStateModule = require_internal_state();
    var PROPER_FUNCTION_NAME = FunctionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
    var getInternalState = InternalStateModule.get;
    var setInternalState = InternalStateModule.set;
    var ARRAY_BUFFER = "ArrayBuffer";
    var DATA_VIEW = "DataView";
    var PROTOTYPE = "prototype";
    var WRONG_LENGTH = "Wrong length";
    var WRONG_INDEX = "Wrong index";
    var NativeArrayBuffer = global2[ARRAY_BUFFER];
    var $ArrayBuffer = NativeArrayBuffer;
    var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
    var $DataView = global2[DATA_VIEW];
    var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
    var ObjectPrototype = Object.prototype;
    var Array2 = global2.Array;
    var RangeError2 = global2.RangeError;
    var fill = uncurryThis(arrayFill);
    var reverse = uncurryThis([].reverse);
    var packIEEE754 = IEEE754.pack;
    var unpackIEEE754 = IEEE754.unpack;
    var packInt8 = function(number) {
      return [number & 255];
    };
    var packInt16 = function(number) {
      return [number & 255, number >> 8 & 255];
    };
    var packInt32 = function(number) {
      return [number & 255, number >> 8 & 255, number >> 16 & 255, number >> 24 & 255];
    };
    var unpackInt32 = function(buffer) {
      return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
    };
    var packFloat32 = function(number) {
      return packIEEE754(number, 23, 4);
    };
    var packFloat64 = function(number) {
      return packIEEE754(number, 52, 8);
    };
    var addGetter = function(Constructor, key2) {
      defineProperty3(Constructor[PROTOTYPE], key2, { get: function() {
        return getInternalState(this)[key2];
      } });
    };
    var get = function(view, count, index2, isLittleEndian) {
      var intIndex = toIndex(index2);
      var store2 = getInternalState(view);
      if (intIndex + count > store2.byteLength)
        throw RangeError2(WRONG_INDEX);
      var bytes = getInternalState(store2.buffer).bytes;
      var start = intIndex + store2.byteOffset;
      var pack = arraySlice(bytes, start, start + count);
      return isLittleEndian ? pack : reverse(pack);
    };
    var set = function(view, count, index2, conversion, value, isLittleEndian) {
      var intIndex = toIndex(index2);
      var store2 = getInternalState(view);
      if (intIndex + count > store2.byteLength)
        throw RangeError2(WRONG_INDEX);
      var bytes = getInternalState(store2.buffer).bytes;
      var start = intIndex + store2.byteOffset;
      var pack = conversion(+value);
      for (var i = 0; i < count; i++)
        bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
    };
    if (!NATIVE_ARRAY_BUFFER) {
      $ArrayBuffer = function ArrayBuffer2(length) {
        anInstance(this, ArrayBufferPrototype);
        var byteLength = toIndex(length);
        setInternalState(this, {
          bytes: fill(Array2(byteLength), 0),
          byteLength
        });
        if (!DESCRIPTORS)
          this.byteLength = byteLength;
      };
      ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE];
      $DataView = function DataView2(buffer, byteOffset, byteLength) {
        anInstance(this, DataViewPrototype);
        anInstance(buffer, ArrayBufferPrototype);
        var bufferLength = getInternalState(buffer).byteLength;
        var offset = toIntegerOrInfinity(byteOffset);
        if (offset < 0 || offset > bufferLength)
          throw RangeError2("Wrong offset");
        byteLength = byteLength === void 0 ? bufferLength - offset : toLength(byteLength);
        if (offset + byteLength > bufferLength)
          throw RangeError2(WRONG_LENGTH);
        setInternalState(this, {
          buffer,
          byteLength,
          byteOffset: offset
        });
        if (!DESCRIPTORS) {
          this.buffer = buffer;
          this.byteLength = byteLength;
          this.byteOffset = offset;
        }
      };
      DataViewPrototype = $DataView[PROTOTYPE];
      if (DESCRIPTORS) {
        addGetter($ArrayBuffer, "byteLength");
        addGetter($DataView, "buffer");
        addGetter($DataView, "byteLength");
        addGetter($DataView, "byteOffset");
      }
      redefineAll(DataViewPrototype, {
        getInt8: function getInt8(byteOffset) {
          return get(this, 1, byteOffset)[0] << 24 >> 24;
        },
        getUint8: function getUint8(byteOffset) {
          return get(this, 1, byteOffset)[0];
        },
        getInt16: function getInt16(byteOffset) {
          var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : void 0);
          return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
        },
        getUint16: function getUint16(byteOffset) {
          var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : void 0);
          return bytes[1] << 8 | bytes[0];
        },
        getInt32: function getInt32(byteOffset) {
          return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0));
        },
        getUint32: function getUint32(byteOffset) {
          return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0)) >>> 0;
        },
        getFloat32: function getFloat32(byteOffset) {
          return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0), 23);
        },
        getFloat64: function getFloat64(byteOffset) {
          return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : void 0), 52);
        },
        setInt8: function setInt8(byteOffset, value) {
          set(this, 1, byteOffset, packInt8, value);
        },
        setUint8: function setUint8(byteOffset, value) {
          set(this, 1, byteOffset, packInt8, value);
        },
        setInt16: function setInt16(byteOffset, value) {
          set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : void 0);
        },
        setUint16: function setUint16(byteOffset, value) {
          set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : void 0);
        },
        setInt32: function setInt32(byteOffset, value) {
          set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : void 0);
        },
        setUint32: function setUint32(byteOffset, value) {
          set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : void 0);
        },
        setFloat32: function setFloat32(byteOffset, value) {
          set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : void 0);
        },
        setFloat64: function setFloat64(byteOffset, value) {
          set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : void 0);
        }
      });
    } else {
      INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
      if (!fails(function() {
        NativeArrayBuffer(1);
      }) || !fails(function() {
        new NativeArrayBuffer(-1);
      }) || fails(function() {
        new NativeArrayBuffer();
        new NativeArrayBuffer(1.5);
        new NativeArrayBuffer(NaN);
        return INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
      })) {
        $ArrayBuffer = function ArrayBuffer2(length) {
          anInstance(this, ArrayBufferPrototype);
          return new NativeArrayBuffer(toIndex(length));
        };
        $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype;
        for (keys = getOwnPropertyNames3(NativeArrayBuffer), j = 0; keys.length > j; ) {
          if (!((key = keys[j++]) in $ArrayBuffer)) {
            createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
          }
        }
        ArrayBufferPrototype.constructor = $ArrayBuffer;
      } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
        createNonEnumerableProperty(NativeArrayBuffer, "name", ARRAY_BUFFER);
      }
      if (setPrototypeOf && getPrototypeOf3(DataViewPrototype) !== ObjectPrototype) {
        setPrototypeOf(DataViewPrototype, ObjectPrototype);
      }
      testView = new $DataView(new $ArrayBuffer(2));
      $setInt8 = uncurryThis(DataViewPrototype.setInt8);
      testView.setInt8(0, 2147483648);
      testView.setInt8(1, 2147483649);
      if (testView.getInt8(0) || !testView.getInt8(1))
        redefineAll(DataViewPrototype, {
          setInt8: function setInt8(byteOffset, value) {
            $setInt8(this, byteOffset, value << 24 >> 24);
          },
          setUint8: function setUint8(byteOffset, value) {
            $setInt8(this, byteOffset, value << 24 >> 24);
          }
        }, { unsafe: true });
    }
    var INCORRECT_ARRAY_BUFFER_NAME;
    var keys;
    var j;
    var key;
    var testView;
    var $setInt8;
    setToStringTag($ArrayBuffer, ARRAY_BUFFER);
    setToStringTag($DataView, DATA_VIEW);
    module2.exports = {
      ArrayBuffer: $ArrayBuffer,
      DataView: $DataView
    };
  }
});

// node_modules/core-js/modules/es.array-buffer.constructor.js
var require_es_array_buffer_constructor = __commonJS({
  "node_modules/core-js/modules/es.array-buffer.constructor.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var arrayBufferModule = require_array_buffer();
    var setSpecies = require_set_species();
    var ARRAY_BUFFER = "ArrayBuffer";
    var ArrayBuffer2 = arrayBufferModule[ARRAY_BUFFER];
    var NativeArrayBuffer = global2[ARRAY_BUFFER];
    $({ global: true, forced: NativeArrayBuffer !== ArrayBuffer2 }, {
      ArrayBuffer: ArrayBuffer2
    });
    setSpecies(ARRAY_BUFFER);
  }
});

// node_modules/core-js/internals/array-buffer-view-core.js
var require_array_buffer_view_core = __commonJS({
  "node_modules/core-js/internals/array-buffer-view-core.js"(exports, module2) {
    "use strict";
    var NATIVE_ARRAY_BUFFER = require_array_buffer_native();
    var DESCRIPTORS = require_descriptors();
    var global2 = require_global();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var hasOwn = require_has_own_property();
    var classof = require_classof();
    var tryToString = require_try_to_string();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var redefine = require_redefine();
    var defineProperty3 = require_object_define_property().f;
    var isPrototypeOf = require_object_is_prototype_of();
    var getPrototypeOf3 = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var wellKnownSymbol = require_well_known_symbol();
    var uid = require_uid();
    var Int8Array2 = global2.Int8Array;
    var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
    var Uint8ClampedArray2 = global2.Uint8ClampedArray;
    var Uint8ClampedArrayPrototype = Uint8ClampedArray2 && Uint8ClampedArray2.prototype;
    var TypedArray = Int8Array2 && getPrototypeOf3(Int8Array2);
    var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf3(Int8ArrayPrototype);
    var ObjectPrototype = Object.prototype;
    var TypeError2 = global2.TypeError;
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var TYPED_ARRAY_TAG = uid("TYPED_ARRAY_TAG");
    var TYPED_ARRAY_CONSTRUCTOR = uid("TYPED_ARRAY_CONSTRUCTOR");
    var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global2.opera) !== "Opera";
    var TYPED_ARRAY_TAG_REQIRED = false;
    var NAME;
    var Constructor;
    var Prototype;
    var TypedArrayConstructorsList = {
      Int8Array: 1,
      Uint8Array: 1,
      Uint8ClampedArray: 1,
      Int16Array: 2,
      Uint16Array: 2,
      Int32Array: 4,
      Uint32Array: 4,
      Float32Array: 4,
      Float64Array: 8
    };
    var BigIntArrayConstructorsList = {
      BigInt64Array: 8,
      BigUint64Array: 8
    };
    var isView = function isView2(it) {
      if (!isObject(it))
        return false;
      var klass = classof(it);
      return klass === "DataView" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
    };
    var isTypedArray = function(it) {
      if (!isObject(it))
        return false;
      var klass = classof(it);
      return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
    };
    var aTypedArray = function(it) {
      if (isTypedArray(it))
        return it;
      throw TypeError2("Target is not a typed array");
    };
    var aTypedArrayConstructor = function(C) {
      if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C)))
        return C;
      throw TypeError2(tryToString(C) + " is not a typed array constructor");
    };
    var exportTypedArrayMethod = function(KEY, property, forced, options) {
      if (!DESCRIPTORS)
        return;
      if (forced)
        for (var ARRAY in TypedArrayConstructorsList) {
          var TypedArrayConstructor = global2[ARRAY];
          if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY))
            try {
              delete TypedArrayConstructor.prototype[KEY];
            } catch (error) {
            }
        }
      if (!TypedArrayPrototype[KEY] || forced) {
        redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
      }
    };
    var exportTypedArrayStaticMethod = function(KEY, property, forced) {
      var ARRAY, TypedArrayConstructor;
      if (!DESCRIPTORS)
        return;
      if (setPrototypeOf) {
        if (forced)
          for (ARRAY in TypedArrayConstructorsList) {
            TypedArrayConstructor = global2[ARRAY];
            if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY))
              try {
                delete TypedArrayConstructor[KEY];
              } catch (error) {
              }
          }
        if (!TypedArray[KEY] || forced) {
          try {
            return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
          } catch (error) {
          }
        } else
          return;
      }
      for (ARRAY in TypedArrayConstructorsList) {
        TypedArrayConstructor = global2[ARRAY];
        if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
          redefine(TypedArrayConstructor, KEY, property);
        }
      }
    };
    for (NAME in TypedArrayConstructorsList) {
      Constructor = global2[NAME];
      Prototype = Constructor && Constructor.prototype;
      if (Prototype)
        createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
      else
        NATIVE_ARRAY_BUFFER_VIEWS = false;
    }
    for (NAME in BigIntArrayConstructorsList) {
      Constructor = global2[NAME];
      Prototype = Constructor && Constructor.prototype;
      if (Prototype)
        createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
    }
    if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
      TypedArray = function TypedArray2() {
        throw TypeError2("Incorrect invocation");
      };
      if (NATIVE_ARRAY_BUFFER_VIEWS)
        for (NAME in TypedArrayConstructorsList) {
          if (global2[NAME])
            setPrototypeOf(global2[NAME], TypedArray);
        }
    }
    if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
      TypedArrayPrototype = TypedArray.prototype;
      if (NATIVE_ARRAY_BUFFER_VIEWS)
        for (NAME in TypedArrayConstructorsList) {
          if (global2[NAME])
            setPrototypeOf(global2[NAME].prototype, TypedArrayPrototype);
        }
    }
    if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf3(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
      setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
    }
    if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
      TYPED_ARRAY_TAG_REQIRED = true;
      defineProperty3(TypedArrayPrototype, TO_STRING_TAG, { get: function() {
        return isObject(this) ? this[TYPED_ARRAY_TAG] : void 0;
      } });
      for (NAME in TypedArrayConstructorsList)
        if (global2[NAME]) {
          createNonEnumerableProperty(global2[NAME], TYPED_ARRAY_TAG, NAME);
        }
    }
    module2.exports = {
      NATIVE_ARRAY_BUFFER_VIEWS,
      TYPED_ARRAY_CONSTRUCTOR,
      TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
      aTypedArray,
      aTypedArrayConstructor,
      exportTypedArrayMethod,
      exportTypedArrayStaticMethod,
      isView,
      isTypedArray,
      TypedArray,
      TypedArrayPrototype
    };
  }
});

// node_modules/core-js/modules/es.array-buffer.is-view.js
var require_es_array_buffer_is_view = __commonJS({
  "node_modules/core-js/modules/es.array-buffer.is-view.js"() {
    "use strict";
    var $ = require_export();
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
    $({ target: "ArrayBuffer", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
      isView: ArrayBufferViewCore.isView
    });
  }
});

// node_modules/core-js/internals/a-constructor.js
var require_a_constructor = __commonJS({
  "node_modules/core-js/internals/a-constructor.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var isConstructor = require_is_constructor();
    var tryToString = require_try_to_string();
    var TypeError2 = global2.TypeError;
    module2.exports = function(argument) {
      if (isConstructor(argument))
        return argument;
      throw TypeError2(tryToString(argument) + " is not a constructor");
    };
  }
});

// node_modules/core-js/internals/species-constructor.js
var require_species_constructor = __commonJS({
  "node_modules/core-js/internals/species-constructor.js"(exports, module2) {
    "use strict";
    var anObject = require_an_object();
    var aConstructor = require_a_constructor();
    var wellKnownSymbol = require_well_known_symbol();
    var SPECIES = wellKnownSymbol("species");
    module2.exports = function(O, defaultConstructor) {
      var C = anObject(O).constructor;
      var S;
      return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? defaultConstructor : aConstructor(S);
    };
  }
});

// node_modules/core-js/modules/es.array-buffer.slice.js
var require_es_array_buffer_slice = __commonJS({
  "node_modules/core-js/modules/es.array-buffer.slice.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var ArrayBufferModule = require_array_buffer();
    var anObject = require_an_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var toLength = require_to_length();
    var speciesConstructor = require_species_constructor();
    var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
    var DataView2 = ArrayBufferModule.DataView;
    var DataViewPrototype = DataView2.prototype;
    var un$ArrayBufferSlice = uncurryThis(ArrayBuffer2.prototype.slice);
    var getUint8 = uncurryThis(DataViewPrototype.getUint8);
    var setUint8 = uncurryThis(DataViewPrototype.setUint8);
    var INCORRECT_SLICE = fails(function() {
      return !new ArrayBuffer2(2).slice(1, void 0).byteLength;
    });
    $({ target: "ArrayBuffer", proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
      slice: function slice(start, end) {
        if (un$ArrayBufferSlice && end === void 0) {
          return un$ArrayBufferSlice(anObject(this), start);
        }
        var length = anObject(this).byteLength;
        var first = toAbsoluteIndex(start, length);
        var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
        var result = new (speciesConstructor(this, ArrayBuffer2))(toLength(fin - first));
        var viewSource = new DataView2(this);
        var viewTarget = new DataView2(result);
        var index2 = 0;
        while (first < fin) {
          setUint8(viewTarget, index2++, getUint8(viewSource, first++));
        }
        return result;
      }
    });
  }
});

// node_modules/core-js/modules/es.data-view.js
var require_es_data_view = __commonJS({
  "node_modules/core-js/modules/es.data-view.js"() {
    "use strict";
    var $ = require_export();
    var ArrayBufferModule = require_array_buffer();
    var NATIVE_ARRAY_BUFFER = require_array_buffer_native();
    $({ global: true, forced: !NATIVE_ARRAY_BUFFER }, {
      DataView: ArrayBufferModule.DataView
    });
  }
});

// node_modules/core-js/modules/es.date.get-year.js
var require_es_date_get_year = __commonJS({
  "node_modules/core-js/modules/es.date.get-year.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var FORCED = fails(function() {
      return (/* @__PURE__ */ new Date(16e11)).getYear() !== 120;
    });
    var getFullYear = uncurryThis(Date.prototype.getFullYear);
    $({ target: "Date", proto: true, forced: FORCED }, {
      getYear: function getYear() {
        return getFullYear(this) - 1900;
      }
    });
  }
});

// node_modules/core-js/modules/es.date.now.js
var require_es_date_now = __commonJS({
  "node_modules/core-js/modules/es.date.now.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var Date2 = global2.Date;
    var getTime = uncurryThis(Date2.prototype.getTime);
    $({ target: "Date", stat: true }, {
      now: function now2() {
        return getTime(new Date2());
      }
    });
  }
});

// node_modules/core-js/modules/es.date.set-year.js
var require_es_date_set_year = __commonJS({
  "node_modules/core-js/modules/es.date.set-year.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var DatePrototype = Date.prototype;
    var getTime = uncurryThis(DatePrototype.getTime);
    var setFullYear = uncurryThis(DatePrototype.setFullYear);
    $({ target: "Date", proto: true }, {
      setYear: function setYear(year) {
        getTime(this);
        var yi = toIntegerOrInfinity(year);
        var yyyy = 0 <= yi && yi <= 99 ? yi + 1900 : yi;
        return setFullYear(this, yyyy);
      }
    });
  }
});

// node_modules/core-js/modules/es.date.to-gmt-string.js
var require_es_date_to_gmt_string = __commonJS({
  "node_modules/core-js/modules/es.date.to-gmt-string.js"() {
    "use strict";
    var $ = require_export();
    $({ target: "Date", proto: true }, {
      toGMTString: Date.prototype.toUTCString
    });
  }
});

// node_modules/core-js/internals/string-repeat.js
var require_string_repeat = __commonJS({
  "node_modules/core-js/internals/string-repeat.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var RangeError2 = global2.RangeError;
    module2.exports = function repeat(count) {
      var str = toString(requireObjectCoercible(this));
      var result = "";
      var n = toIntegerOrInfinity(count);
      if (n < 0 || n == Infinity)
        throw RangeError2("Wrong number of repetitions");
      for (; n > 0; (n >>>= 1) && (str += str))
        if (n & 1)
          result += str;
      return result;
    };
  }
});

// node_modules/core-js/internals/string-pad.js
var require_string_pad = __commonJS({
  "node_modules/core-js/internals/string-pad.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toLength = require_to_length();
    var toString = require_to_string();
    var $repeat = require_string_repeat();
    var requireObjectCoercible = require_require_object_coercible();
    var repeat = uncurryThis($repeat);
    var stringSlice = uncurryThis("".slice);
    var ceil = Math.ceil;
    var createMethod = function(IS_END) {
      return function($this, maxLength, fillString) {
        var S = toString(requireObjectCoercible($this));
        var intMaxLength = toLength(maxLength);
        var stringLength = S.length;
        var fillStr = fillString === void 0 ? " " : toString(fillString);
        var fillLen, stringFiller;
        if (intMaxLength <= stringLength || fillStr == "")
          return S;
        fillLen = intMaxLength - stringLength;
        stringFiller = repeat(fillStr, ceil(fillLen / fillStr.length));
        if (stringFiller.length > fillLen)
          stringFiller = stringSlice(stringFiller, 0, fillLen);
        return IS_END ? S + stringFiller : stringFiller + S;
      };
    };
    module2.exports = {
      // `String.prototype.padStart` method
      // https://tc39.es/ecma262/#sec-string.prototype.padstart
      start: createMethod(false),
      // `String.prototype.padEnd` method
      // https://tc39.es/ecma262/#sec-string.prototype.padend
      end: createMethod(true)
    };
  }
});

// node_modules/core-js/internals/date-to-iso-string.js
var require_date_to_iso_string = __commonJS({
  "node_modules/core-js/internals/date-to-iso-string.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var padStart = require_string_pad().start;
    var RangeError2 = global2.RangeError;
    var abs = Math.abs;
    var DatePrototype = Date.prototype;
    var n$DateToISOString = DatePrototype.toISOString;
    var getTime = uncurryThis(DatePrototype.getTime);
    var getUTCDate = uncurryThis(DatePrototype.getUTCDate);
    var getUTCFullYear = uncurryThis(DatePrototype.getUTCFullYear);
    var getUTCHours = uncurryThis(DatePrototype.getUTCHours);
    var getUTCMilliseconds = uncurryThis(DatePrototype.getUTCMilliseconds);
    var getUTCMinutes = uncurryThis(DatePrototype.getUTCMinutes);
    var getUTCMonth = uncurryThis(DatePrototype.getUTCMonth);
    var getUTCSeconds = uncurryThis(DatePrototype.getUTCSeconds);
    module2.exports = fails(function() {
      return n$DateToISOString.call(new Date(-5e13 - 1)) != "0385-07-25T07:06:39.999Z";
    }) || !fails(function() {
      n$DateToISOString.call(/* @__PURE__ */ new Date(NaN));
    }) ? function toISOString() {
      if (!isFinite(getTime(this)))
        throw RangeError2("Invalid time value");
      var date = this;
      var year = getUTCFullYear(date);
      var milliseconds = getUTCMilliseconds(date);
      var sign = year < 0 ? "-" : year > 9999 ? "+" : "";
      return sign + padStart(abs(year), sign ? 6 : 4, 0) + "-" + padStart(getUTCMonth(date) + 1, 2, 0) + "-" + padStart(getUTCDate(date), 2, 0) + "T" + padStart(getUTCHours(date), 2, 0) + ":" + padStart(getUTCMinutes(date), 2, 0) + ":" + padStart(getUTCSeconds(date), 2, 0) + "." + padStart(milliseconds, 3, 0) + "Z";
    } : n$DateToISOString;
  }
});

// node_modules/core-js/modules/es.date.to-iso-string.js
var require_es_date_to_iso_string = __commonJS({
  "node_modules/core-js/modules/es.date.to-iso-string.js"() {
    "use strict";
    var $ = require_export();
    var toISOString = require_date_to_iso_string();
    $({ target: "Date", proto: true, forced: Date.prototype.toISOString !== toISOString }, {
      toISOString
    });
  }
});

// node_modules/core-js/modules/es.date.to-json.js
var require_es_date_to_json = __commonJS({
  "node_modules/core-js/modules/es.date.to-json.js"() {
    "use strict";
    var $ = require_export();
    var fails = require_fails();
    var toObject = require_to_object();
    var toPrimitive2 = require_to_primitive();
    var FORCED = fails(function() {
      return (/* @__PURE__ */ new Date(NaN)).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function() {
        return 1;
      } }) !== 1;
    });
    $({ target: "Date", proto: true, forced: FORCED }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      toJSON: function toJSON(key) {
        var O = toObject(this);
        var pv = toPrimitive2(O, "number");
        return typeof pv == "number" && !isFinite(pv) ? null : O.toISOString();
      }
    });
  }
});

// node_modules/core-js/internals/date-to-primitive.js
var require_date_to_primitive = __commonJS({
  "node_modules/core-js/internals/date-to-primitive.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var anObject = require_an_object();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var TypeError2 = global2.TypeError;
    module2.exports = function(hint) {
      anObject(this);
      if (hint === "string" || hint === "default")
        hint = "string";
      else if (hint !== "number")
        throw TypeError2("Incorrect hint");
      return ordinaryToPrimitive(this, hint);
    };
  }
});

// node_modules/core-js/modules/es.date.to-primitive.js
var require_es_date_to_primitive = __commonJS({
  "node_modules/core-js/modules/es.date.to-primitive.js"() {
    "use strict";
    var hasOwn = require_has_own_property();
    var redefine = require_redefine();
    var dateToPrimitive = require_date_to_primitive();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    var DatePrototype = Date.prototype;
    if (!hasOwn(DatePrototype, TO_PRIMITIVE)) {
      redefine(DatePrototype, TO_PRIMITIVE, dateToPrimitive);
    }
  }
});

// node_modules/core-js/modules/es.date.to-string.js
var require_es_date_to_string = __commonJS({
  "node_modules/core-js/modules/es.date.to-string.js"() {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var redefine = require_redefine();
    var DatePrototype = Date.prototype;
    var INVALID_DATE = "Invalid Date";
    var TO_STRING = "toString";
    var un$DateToString = uncurryThis(DatePrototype[TO_STRING]);
    var getTime = uncurryThis(DatePrototype.getTime);
    if (String(/* @__PURE__ */ new Date(NaN)) != INVALID_DATE) {
      redefine(DatePrototype, TO_STRING, function toString() {
        var value = getTime(this);
        return value === value ? un$DateToString(this) : INVALID_DATE;
      });
    }
  }
});

// node_modules/core-js/modules/es.escape.js
var require_es_escape = __commonJS({
  "node_modules/core-js/modules/es.escape.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var toString = require_to_string();
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var exec = uncurryThis(/./.exec);
    var numberToString = uncurryThis(1 .toString);
    var toUpperCase = uncurryThis("".toUpperCase);
    var raw = /[\w*+\-./@]/;
    var hex = function(code, length) {
      var result = numberToString(code, 16);
      while (result.length < length)
        result = "0" + result;
      return result;
    };
    $({ global: true }, {
      escape: function escape3(string) {
        var str = toString(string);
        var result = "";
        var length = str.length;
        var index2 = 0;
        var chr, code;
        while (index2 < length) {
          chr = charAt(str, index2++);
          if (exec(raw, chr)) {
            result += chr;
          } else {
            code = charCodeAt(chr, 0);
            if (code < 256) {
              result += "%" + hex(code, 2);
            } else {
              result += "%u" + toUpperCase(hex(code, 4));
            }
          }
        }
        return result;
      }
    });
  }
});

// node_modules/core-js/internals/function-bind.js
var require_function_bind = __commonJS({
  "node_modules/core-js/internals/function-bind.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    var isObject = require_is_object();
    var hasOwn = require_has_own_property();
    var arraySlice = require_array_slice();
    var Function2 = global2.Function;
    var concat = uncurryThis([].concat);
    var join = uncurryThis([].join);
    var factories = {};
    var construct = function(C, argsLength, args) {
      if (!hasOwn(factories, argsLength)) {
        for (var list = [], i = 0; i < argsLength; i++)
          list[i] = "a[" + i + "]";
        factories[argsLength] = Function2("C,a", "return new C(" + join(list, ",") + ")");
      }
      return factories[argsLength](C, args);
    };
    module2.exports = Function2.bind || function bind(that) {
      var F = aCallable(this);
      var Prototype = F.prototype;
      var partArgs = arraySlice(arguments, 1);
      var boundFunction = function bound() {
        var args = concat(partArgs, arraySlice(arguments));
        return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
      };
      if (isObject(Prototype))
        boundFunction.prototype = Prototype;
      return boundFunction;
    };
  }
});

// node_modules/core-js/modules/es.function.bind.js
var require_es_function_bind = __commonJS({
  "node_modules/core-js/modules/es.function.bind.js"() {
    "use strict";
    var $ = require_export();
    var bind = require_function_bind();
    $({ target: "Function", proto: true }, {
      bind
    });
  }
});

// node_modules/core-js/modules/es.function.has-instance.js
var require_es_function_has_instance = __commonJS({
  "node_modules/core-js/modules/es.function.has-instance.js"() {
    "use strict";
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var definePropertyModule = require_object_define_property();
    var getPrototypeOf3 = require_object_get_prototype_of();
    var wellKnownSymbol = require_well_known_symbol();
    var HAS_INSTANCE = wellKnownSymbol("hasInstance");
    var FunctionPrototype = Function.prototype;
    if (!(HAS_INSTANCE in FunctionPrototype)) {
      definePropertyModule.f(FunctionPrototype, HAS_INSTANCE, { value: function(O) {
        if (!isCallable(this) || !isObject(O))
          return false;
        var P = this.prototype;
        if (!isObject(P))
          return O instanceof this;
        while (O = getPrototypeOf3(O))
          if (P === O)
            return true;
        return false;
      } });
    }
  }
});

// node_modules/core-js/modules/es.function.name.js
var require_es_function_name = __commonJS({
  "node_modules/core-js/modules/es.function.name.js"() {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var FUNCTION_NAME_EXISTS = require_function_name().EXISTS;
    var uncurryThis = require_function_uncurry_this();
    var defineProperty3 = require_object_define_property().f;
    var FunctionPrototype = Function.prototype;
    var functionToString = uncurryThis(FunctionPrototype.toString);
    var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
    var regExpExec = uncurryThis(nameRE.exec);
    var NAME = "name";
    if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
      defineProperty3(FunctionPrototype, NAME, {
        configurable: true,
        get: function() {
          try {
            return regExpExec(nameRE, functionToString(this))[1];
          } catch (error) {
            return "";
          }
        }
      });
    }
  }
});

// node_modules/core-js/modules/es.global-this.js
var require_es_global_this = __commonJS({
  "node_modules/core-js/modules/es.global-this.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    $({ global: true }, {
      globalThis: global2
    });
  }
});

// node_modules/core-js/modules/es.json.stringify.js
var require_es_json_stringify = __commonJS({
  "node_modules/core-js/modules/es.json.stringify.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var getBuiltIn = require_get_built_in();
    var apply = require_function_apply();
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var Array2 = global2.Array;
    var $stringify = getBuiltIn("JSON", "stringify");
    var exec = uncurryThis(/./.exec);
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var replace = uncurryThis("".replace);
    var numberToString = uncurryThis(1 .toString);
    var tester = /[\uD800-\uDFFF]/g;
    var low = /^[\uD800-\uDBFF]$/;
    var hi = /^[\uDC00-\uDFFF]$/;
    var fix = function(match, offset, string) {
      var prev = charAt(string, offset - 1);
      var next = charAt(string, offset + 1);
      if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
        return "\\u" + numberToString(charCodeAt(match, 0), 16);
      }
      return match;
    };
    var FORCED = fails(function() {
      return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
    });
    if ($stringify) {
      $({ target: "JSON", stat: true, forced: FORCED }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        stringify: function stringify2(it, replacer, space) {
          for (var i = 0, l = arguments.length, args = Array2(l); i < l; i++)
            args[i] = arguments[i];
          var result = apply($stringify, null, args);
          return typeof result == "string" ? replace(result, tester, fix) : result;
        }
      });
    }
  }
});

// node_modules/core-js/modules/es.json.to-string-tag.js
var require_es_json_to_string_tag = __commonJS({
  "node_modules/core-js/modules/es.json.to-string-tag.js"() {
    "use strict";
    var global2 = require_global();
    var setToStringTag = require_set_to_string_tag();
    setToStringTag(global2.JSON, "JSON", true);
  }
});

// node_modules/core-js/internals/array-buffer-non-extensible.js
var require_array_buffer_non_extensible = __commonJS({
  "node_modules/core-js/internals/array-buffer-non-extensible.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    module2.exports = fails(function() {
      if (typeof ArrayBuffer == "function") {
        var buffer = new ArrayBuffer(8);
        if (Object.isExtensible(buffer))
          Object.defineProperty(buffer, "a", { value: 8 });
      }
    });
  }
});

// node_modules/core-js/internals/object-is-extensible.js
var require_object_is_extensible = __commonJS({
  "node_modules/core-js/internals/object-is-extensible.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    var isObject = require_is_object();
    var classof = require_classof_raw();
    var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
    var $isExtensible = Object.isExtensible;
    var FAILS_ON_PRIMITIVES = fails(function() {
      $isExtensible(1);
    });
    module2.exports = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
      if (!isObject(it))
        return false;
      if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == "ArrayBuffer")
        return false;
      return $isExtensible ? $isExtensible(it) : true;
    } : $isExtensible;
  }
});

// node_modules/core-js/internals/freezing.js
var require_freezing = __commonJS({
  "node_modules/core-js/internals/freezing.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    module2.exports = !fails(function() {
      return Object.isExtensible(Object.preventExtensions({}));
    });
  }
});

// node_modules/core-js/internals/internal-metadata.js
var require_internal_metadata = __commonJS({
  "node_modules/core-js/internals/internal-metadata.js"(exports, module2) {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var hiddenKeys = require_hidden_keys();
    var isObject = require_is_object();
    var hasOwn = require_has_own_property();
    var defineProperty3 = require_object_define_property().f;
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertyNamesExternalModule = require_object_get_own_property_names_external();
    var isExtensible = require_object_is_extensible();
    var uid = require_uid();
    var FREEZING = require_freezing();
    var REQUIRED = false;
    var METADATA = uid("meta");
    var id = 0;
    var setMetadata = function(it) {
      defineProperty3(it, METADATA, { value: {
        objectID: "O" + id++,
        // object ID
        weakData: {}
        // weak collections IDs
      } });
    };
    var fastKey = function(it, create3) {
      if (!isObject(it))
        return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
      if (!hasOwn(it, METADATA)) {
        if (!isExtensible(it))
          return "F";
        if (!create3)
          return "E";
        setMetadata(it);
      }
      return it[METADATA].objectID;
    };
    var getWeakData = function(it, create3) {
      if (!hasOwn(it, METADATA)) {
        if (!isExtensible(it))
          return true;
        if (!create3)
          return false;
        setMetadata(it);
      }
      return it[METADATA].weakData;
    };
    var onFreeze = function(it) {
      if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA))
        setMetadata(it);
      return it;
    };
    var enable = function() {
      meta.enable = function() {
      };
      REQUIRED = true;
      var getOwnPropertyNames3 = getOwnPropertyNamesModule.f;
      var splice = uncurryThis([].splice);
      var test = {};
      test[METADATA] = 1;
      if (getOwnPropertyNames3(test).length) {
        getOwnPropertyNamesModule.f = function(it) {
          var result = getOwnPropertyNames3(it);
          for (var i = 0, length = result.length; i < length; i++) {
            if (result[i] === METADATA) {
              splice(result, i, 1);
              break;
            }
          }
          return result;
        };
        $({ target: "Object", stat: true, forced: true }, {
          getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
        });
      }
    };
    var meta = module2.exports = {
      enable,
      fastKey,
      getWeakData,
      onFreeze
    };
    hiddenKeys[METADATA] = true;
  }
});

// node_modules/core-js/internals/collection.js
var require_collection = __commonJS({
  "node_modules/core-js/internals/collection.js"(exports, module2) {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var isForced = require_is_forced();
    var redefine = require_redefine();
    var InternalMetadataModule = require_internal_metadata();
    var iterate = require_iterate();
    var anInstance = require_an_instance();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var fails = require_fails();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var setToStringTag = require_set_to_string_tag();
    var inheritIfRequired = require_inherit_if_required();
    module2.exports = function(CONSTRUCTOR_NAME, wrapper, common) {
      var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
      var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
      var ADDER = IS_MAP ? "set" : "add";
      var NativeConstructor = global2[CONSTRUCTOR_NAME];
      var NativePrototype = NativeConstructor && NativeConstructor.prototype;
      var Constructor = NativeConstructor;
      var exported = {};
      var fixMethod = function(KEY) {
        var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
        redefine(
          NativePrototype,
          KEY,
          KEY == "add" ? function add(value) {
            uncurriedNativeMethod(this, value === 0 ? 0 : value);
            return this;
          } : KEY == "delete" ? function(key) {
            return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : KEY == "get" ? function get(key) {
            return IS_WEAK && !isObject(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : KEY == "has" ? function has(key) {
            return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : function set(key, value) {
            uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
            return this;
          }
        );
      };
      var REPLACE = isForced(
        CONSTRUCTOR_NAME,
        !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
          new NativeConstructor().entries().next();
        }))
      );
      if (REPLACE) {
        Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
        InternalMetadataModule.enable();
      } else if (isForced(CONSTRUCTOR_NAME, true)) {
        var instance = new Constructor();
        var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
        var THROWS_ON_PRIMITIVES = fails(function() {
          instance.has(1);
        });
        var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
          new NativeConstructor(iterable);
        });
        var BUGGY_ZERO = !IS_WEAK && fails(function() {
          var $instance = new NativeConstructor();
          var index2 = 5;
          while (index2--)
            $instance[ADDER](index2, index2);
          return !$instance.has(-0);
        });
        if (!ACCEPT_ITERABLES) {
          Constructor = wrapper(function(dummy, iterable) {
            anInstance(dummy, NativePrototype);
            var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
            if (iterable != void 0)
              iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
            return that;
          });
          Constructor.prototype = NativePrototype;
          NativePrototype.constructor = Constructor;
        }
        if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
          fixMethod("delete");
          fixMethod("has");
          IS_MAP && fixMethod("get");
        }
        if (BUGGY_ZERO || HASNT_CHAINING)
          fixMethod(ADDER);
        if (IS_WEAK && NativePrototype.clear)
          delete NativePrototype.clear;
      }
      exported[CONSTRUCTOR_NAME] = Constructor;
      $({ global: true, forced: Constructor != NativeConstructor }, exported);
      setToStringTag(Constructor, CONSTRUCTOR_NAME);
      if (!IS_WEAK)
        common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
      return Constructor;
    };
  }
});

// node_modules/core-js/internals/collection-strong.js
var require_collection_strong = __commonJS({
  "node_modules/core-js/internals/collection-strong.js"(exports, module2) {
    "use strict";
    var defineProperty3 = require_object_define_property().f;
    var create3 = require_object_create();
    var redefineAll = require_redefine_all();
    var bind = require_function_bind_context();
    var anInstance = require_an_instance();
    var iterate = require_iterate();
    var defineIterator = require_define_iterator();
    var setSpecies = require_set_species();
    var DESCRIPTORS = require_descriptors();
    var fastKey = require_internal_metadata().fastKey;
    var InternalStateModule = require_internal_state();
    var setInternalState = InternalStateModule.set;
    var internalStateGetterFor = InternalStateModule.getterFor;
    module2.exports = {
      getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var Constructor = wrapper(function(that, iterable) {
          anInstance(that, Prototype);
          setInternalState(that, {
            type: CONSTRUCTOR_NAME,
            index: create3(null),
            first: void 0,
            last: void 0,
            size: 0
          });
          if (!DESCRIPTORS)
            that.size = 0;
          if (iterable != void 0)
            iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
        });
        var Prototype = Constructor.prototype;
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var define2 = function(that, key, value) {
          var state = getInternalState(that);
          var entry = getEntry(that, key);
          var previous, index2;
          if (entry) {
            entry.value = value;
          } else {
            state.last = entry = {
              index: index2 = fastKey(key, true),
              key,
              value,
              previous: previous = state.last,
              next: void 0,
              removed: false
            };
            if (!state.first)
              state.first = entry;
            if (previous)
              previous.next = entry;
            if (DESCRIPTORS)
              state.size++;
            else
              that.size++;
            if (index2 !== "F")
              state.index[index2] = entry;
          }
          return that;
        };
        var getEntry = function(that, key) {
          var state = getInternalState(that);
          var index2 = fastKey(key);
          var entry;
          if (index2 !== "F")
            return state.index[index2];
          for (entry = state.first; entry; entry = entry.next) {
            if (entry.key == key)
              return entry;
          }
        };
        redefineAll(Prototype, {
          // `{ Map, Set }.prototype.clear()` methods
          // https://tc39.es/ecma262/#sec-map.prototype.clear
          // https://tc39.es/ecma262/#sec-set.prototype.clear
          clear: function clear() {
            var that = this;
            var state = getInternalState(that);
            var data = state.index;
            var entry = state.first;
            while (entry) {
              entry.removed = true;
              if (entry.previous)
                entry.previous = entry.previous.next = void 0;
              delete data[entry.index];
              entry = entry.next;
            }
            state.first = state.last = void 0;
            if (DESCRIPTORS)
              state.size = 0;
            else
              that.size = 0;
          },
          // `{ Map, Set }.prototype.delete(key)` methods
          // https://tc39.es/ecma262/#sec-map.prototype.delete
          // https://tc39.es/ecma262/#sec-set.prototype.delete
          "delete": function(key) {
            var that = this;
            var state = getInternalState(that);
            var entry = getEntry(that, key);
            if (entry) {
              var next = entry.next;
              var prev = entry.previous;
              delete state.index[entry.index];
              entry.removed = true;
              if (prev)
                prev.next = next;
              if (next)
                next.previous = prev;
              if (state.first == entry)
                state.first = next;
              if (state.last == entry)
                state.last = prev;
              if (DESCRIPTORS)
                state.size--;
              else
                that.size--;
            }
            return !!entry;
          },
          // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
          // https://tc39.es/ecma262/#sec-map.prototype.foreach
          // https://tc39.es/ecma262/#sec-set.prototype.foreach
          forEach: function forEach(callbackfn) {
            var state = getInternalState(this);
            var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
            var entry;
            while (entry = entry ? entry.next : state.first) {
              boundFunction(entry.value, entry.key, this);
              while (entry && entry.removed)
                entry = entry.previous;
            }
          },
          // `{ Map, Set}.prototype.has(key)` methods
          // https://tc39.es/ecma262/#sec-map.prototype.has
          // https://tc39.es/ecma262/#sec-set.prototype.has
          has: function has(key) {
            return !!getEntry(this, key);
          }
        });
        redefineAll(Prototype, IS_MAP ? {
          // `Map.prototype.get(key)` method
          // https://tc39.es/ecma262/#sec-map.prototype.get
          get: function get(key) {
            var entry = getEntry(this, key);
            return entry && entry.value;
          },
          // `Map.prototype.set(key, value)` method
          // https://tc39.es/ecma262/#sec-map.prototype.set
          set: function set(key, value) {
            return define2(this, key === 0 ? 0 : key, value);
          }
        } : {
          // `Set.prototype.add(value)` method
          // https://tc39.es/ecma262/#sec-set.prototype.add
          add: function add(value) {
            return define2(this, value = value === 0 ? 0 : value, value);
          }
        });
        if (DESCRIPTORS)
          defineProperty3(Prototype, "size", {
            get: function() {
              return getInternalState(this).size;
            }
          });
        return Constructor;
      },
      setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
        var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
        var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
        defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
          setInternalState(this, {
            type: ITERATOR_NAME,
            target: iterated,
            state: getInternalCollectionState(iterated),
            kind,
            last: void 0
          });
        }, function() {
          var state = getInternalIteratorState(this);
          var kind = state.kind;
          var entry = state.last;
          while (entry && entry.removed)
            entry = entry.previous;
          if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
            state.target = void 0;
            return { value: void 0, done: true };
          }
          if (kind == "keys")
            return { value: entry.key, done: false };
          if (kind == "values")
            return { value: entry.value, done: false };
          return { value: [entry.key, entry.value], done: false };
        }, IS_MAP ? "entries" : "values", !IS_MAP, true);
        setSpecies(CONSTRUCTOR_NAME);
      }
    };
  }
});

// node_modules/core-js/modules/es.map.js
var require_es_map = __commonJS({
  "node_modules/core-js/modules/es.map.js"() {
    "use strict";
    var collection = require_collection();
    var collectionStrong = require_collection_strong();
    collection("Map", function(init) {
      return function Map2() {
        return init(this, arguments.length ? arguments[0] : void 0);
      };
    }, collectionStrong);
  }
});

// node_modules/core-js/internals/math-log1p.js
var require_math_log1p = __commonJS({
  "node_modules/core-js/internals/math-log1p.js"(exports, module2) {
    "use strict";
    var log = Math.log;
    module2.exports = Math.log1p || function log1p(x) {
      return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
    };
  }
});

// node_modules/core-js/modules/es.math.acosh.js
var require_es_math_acosh = __commonJS({
  "node_modules/core-js/modules/es.math.acosh.js"() {
    "use strict";
    var $ = require_export();
    var log1p = require_math_log1p();
    var $acosh = Math.acosh;
    var log = Math.log;
    var sqrt = Math.sqrt;
    var LN2 = Math.LN2;
    var FORCED = !$acosh || Math.floor($acosh(Number.MAX_VALUE)) != 710 || $acosh(Infinity) != Infinity;
    $({ target: "Math", stat: true, forced: FORCED }, {
      acosh: function acosh(x) {
        return (x = +x) < 1 ? NaN : x > 9490626562425156e-8 ? log(x) + LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
      }
    });
  }
});

// node_modules/core-js/modules/es.math.asinh.js
var require_es_math_asinh = __commonJS({
  "node_modules/core-js/modules/es.math.asinh.js"() {
    "use strict";
    var $ = require_export();
    var $asinh = Math.asinh;
    var log = Math.log;
    var sqrt = Math.sqrt;
    function asinh(x) {
      return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
    }
    $({ target: "Math", stat: true, forced: !($asinh && 1 / $asinh(0) > 0) }, {
      asinh
    });
  }
});

// node_modules/core-js/modules/es.math.atanh.js
var require_es_math_atanh = __commonJS({
  "node_modules/core-js/modules/es.math.atanh.js"() {
    "use strict";
    var $ = require_export();
    var $atanh = Math.atanh;
    var log = Math.log;
    $({ target: "Math", stat: true, forced: !($atanh && 1 / $atanh(-0) < 0) }, {
      atanh: function atanh(x) {
        return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
      }
    });
  }
});

// node_modules/core-js/internals/math-sign.js
var require_math_sign = __commonJS({
  "node_modules/core-js/internals/math-sign.js"(exports, module2) {
    "use strict";
    module2.exports = Math.sign || function sign(x) {
      return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
    };
  }
});

// node_modules/core-js/modules/es.math.cbrt.js
var require_es_math_cbrt = __commonJS({
  "node_modules/core-js/modules/es.math.cbrt.js"() {
    "use strict";
    var $ = require_export();
    var sign = require_math_sign();
    var abs = Math.abs;
    var pow = Math.pow;
    $({ target: "Math", stat: true }, {
      cbrt: function cbrt(x) {
        return sign(x = +x) * pow(abs(x), 1 / 3);
      }
    });
  }
});

// node_modules/core-js/modules/es.math.clz32.js
var require_es_math_clz32 = __commonJS({
  "node_modules/core-js/modules/es.math.clz32.js"() {
    "use strict";
    var $ = require_export();
    var floor = Math.floor;
    var log = Math.log;
    var LOG2E = Math.LOG2E;
    $({ target: "Math", stat: true }, {
      clz32: function clz32(x) {
        return (x >>>= 0) ? 31 - floor(log(x + 0.5) * LOG2E) : 32;
      }
    });
  }
});

// node_modules/core-js/internals/math-expm1.js
var require_math_expm1 = __commonJS({
  "node_modules/core-js/internals/math-expm1.js"(exports, module2) {
    "use strict";
    var $expm1 = Math.expm1;
    var exp = Math.exp;
    module2.exports = !$expm1 || $expm1(10) > 22025.465794806718 || $expm1(10) < 22025.465794806718 || $expm1(-2e-17) != -2e-17 ? function expm1(x) {
      return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
    } : $expm1;
  }
});

// node_modules/core-js/modules/es.math.cosh.js
var require_es_math_cosh = __commonJS({
  "node_modules/core-js/modules/es.math.cosh.js"() {
    "use strict";
    var $ = require_export();
    var expm1 = require_math_expm1();
    var $cosh = Math.cosh;
    var abs = Math.abs;
    var E = Math.E;
    $({ target: "Math", stat: true, forced: !$cosh || $cosh(710) === Infinity }, {
      cosh: function cosh(x) {
        var t = expm1(abs(x) - 1) + 1;
        return (t + 1 / (t * E * E)) * (E / 2);
      }
    });
  }
});

// node_modules/core-js/modules/es.math.expm1.js
var require_es_math_expm1 = __commonJS({
  "node_modules/core-js/modules/es.math.expm1.js"() {
    "use strict";
    var $ = require_export();
    var expm1 = require_math_expm1();
    $({ target: "Math", stat: true, forced: expm1 != Math.expm1 }, { expm1 });
  }
});

// node_modules/core-js/internals/math-fround.js
var require_math_fround = __commonJS({
  "node_modules/core-js/internals/math-fround.js"(exports, module2) {
    "use strict";
    var sign = require_math_sign();
    var abs = Math.abs;
    var pow = Math.pow;
    var EPSILON = pow(2, -52);
    var EPSILON32 = pow(2, -23);
    var MAX32 = pow(2, 127) * (2 - EPSILON32);
    var MIN32 = pow(2, -126);
    var roundTiesToEven = function(n) {
      return n + 1 / EPSILON - 1 / EPSILON;
    };
    module2.exports = Math.fround || function fround(x) {
      var $abs = abs(x);
      var $sign = sign(x);
      var a, result;
      if ($abs < MIN32)
        return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
      a = (1 + EPSILON32 / EPSILON) * $abs;
      result = a - (a - $abs);
      if (result > MAX32 || result != result)
        return $sign * Infinity;
      return $sign * result;
    };
  }
});

// node_modules/core-js/modules/es.math.fround.js
var require_es_math_fround = __commonJS({
  "node_modules/core-js/modules/es.math.fround.js"() {
    "use strict";
    var $ = require_export();
    var fround = require_math_fround();
    $({ target: "Math", stat: true }, { fround });
  }
});

// node_modules/core-js/modules/es.math.hypot.js
var require_es_math_hypot = __commonJS({
  "node_modules/core-js/modules/es.math.hypot.js"() {
    "use strict";
    var $ = require_export();
    var $hypot = Math.hypot;
    var abs = Math.abs;
    var sqrt = Math.sqrt;
    var BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity;
    $({ target: "Math", stat: true, forced: BUGGY }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      hypot: function hypot(value1, value2) {
        var sum = 0;
        var i = 0;
        var aLen = arguments.length;
        var larg = 0;
        var arg, div;
        while (i < aLen) {
          arg = abs(arguments[i++]);
          if (larg < arg) {
            div = larg / arg;
            sum = sum * div * div + 1;
            larg = arg;
          } else if (arg > 0) {
            div = arg / larg;
            sum += div * div;
          } else
            sum += arg;
        }
        return larg === Infinity ? Infinity : larg * sqrt(sum);
      }
    });
  }
});

// node_modules/core-js/modules/es.math.imul.js
var require_es_math_imul = __commonJS({
  "node_modules/core-js/modules/es.math.imul.js"() {
    "use strict";
    var $ = require_export();
    var fails = require_fails();
    var $imul = Math.imul;
    var FORCED = fails(function() {
      return $imul(4294967295, 5) != -5 || $imul.length != 2;
    });
    $({ target: "Math", stat: true, forced: FORCED }, {
      imul: function imul(x, y) {
        var UINT16 = 65535;
        var xn = +x;
        var yn = +y;
        var xl = UINT16 & xn;
        var yl = UINT16 & yn;
        return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
      }
    });
  }
});

// node_modules/core-js/internals/math-log10.js
var require_math_log10 = __commonJS({
  "node_modules/core-js/internals/math-log10.js"(exports, module2) {
    "use strict";
    var log = Math.log;
    var LOG10E = Math.LOG10E;
    module2.exports = Math.log10 || function log10(x) {
      return log(x) * LOG10E;
    };
  }
});

// node_modules/core-js/modules/es.math.log10.js
var require_es_math_log10 = __commonJS({
  "node_modules/core-js/modules/es.math.log10.js"() {
    "use strict";
    var $ = require_export();
    var log10 = require_math_log10();
    $({ target: "Math", stat: true }, {
      log10
    });
  }
});

// node_modules/core-js/modules/es.math.log1p.js
var require_es_math_log1p = __commonJS({
  "node_modules/core-js/modules/es.math.log1p.js"() {
    "use strict";
    var $ = require_export();
    var log1p = require_math_log1p();
    $({ target: "Math", stat: true }, { log1p });
  }
});

// node_modules/core-js/modules/es.math.log2.js
var require_es_math_log2 = __commonJS({
  "node_modules/core-js/modules/es.math.log2.js"() {
    "use strict";
    var $ = require_export();
    var log = Math.log;
    var LN2 = Math.LN2;
    $({ target: "Math", stat: true }, {
      log2: function log2(x) {
        return log(x) / LN2;
      }
    });
  }
});

// node_modules/core-js/modules/es.math.sign.js
var require_es_math_sign = __commonJS({
  "node_modules/core-js/modules/es.math.sign.js"() {
    "use strict";
    var $ = require_export();
    var sign = require_math_sign();
    $({ target: "Math", stat: true }, {
      sign
    });
  }
});

// node_modules/core-js/modules/es.math.sinh.js
var require_es_math_sinh = __commonJS({
  "node_modules/core-js/modules/es.math.sinh.js"() {
    "use strict";
    var $ = require_export();
    var fails = require_fails();
    var expm1 = require_math_expm1();
    var abs = Math.abs;
    var exp = Math.exp;
    var E = Math.E;
    var FORCED = fails(function() {
      return Math.sinh(-2e-17) != -2e-17;
    });
    $({ target: "Math", stat: true, forced: FORCED }, {
      sinh: function sinh(x) {
        return abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
      }
    });
  }
});

// node_modules/core-js/modules/es.math.tanh.js
var require_es_math_tanh = __commonJS({
  "node_modules/core-js/modules/es.math.tanh.js"() {
    "use strict";
    var $ = require_export();
    var expm1 = require_math_expm1();
    var exp = Math.exp;
    $({ target: "Math", stat: true }, {
      tanh: function tanh(x) {
        var a = expm1(x = +x);
        var b = expm1(-x);
        return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
      }
    });
  }
});

// node_modules/core-js/modules/es.math.to-string-tag.js
var require_es_math_to_string_tag = __commonJS({
  "node_modules/core-js/modules/es.math.to-string-tag.js"() {
    "use strict";
    var setToStringTag = require_set_to_string_tag();
    setToStringTag(Math, "Math", true);
  }
});

// node_modules/core-js/modules/es.math.trunc.js
var require_es_math_trunc = __commonJS({
  "node_modules/core-js/modules/es.math.trunc.js"() {
    "use strict";
    var $ = require_export();
    var ceil = Math.ceil;
    var floor = Math.floor;
    $({ target: "Math", stat: true }, {
      trunc: function trunc(it) {
        return (it > 0 ? floor : ceil)(it);
      }
    });
  }
});

// node_modules/core-js/internals/this-number-value.js
var require_this_number_value = __commonJS({
  "node_modules/core-js/internals/this-number-value.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module2.exports = uncurryThis(1 .valueOf);
  }
});

// node_modules/core-js/internals/whitespaces.js
var require_whitespaces = __commonJS({
  "node_modules/core-js/internals/whitespaces.js"(exports, module2) {
    "use strict";
    module2.exports = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
  }
});

// node_modules/core-js/internals/string-trim.js
var require_string_trim = __commonJS({
  "node_modules/core-js/internals/string-trim.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var toString = require_to_string();
    var whitespaces = require_whitespaces();
    var replace = uncurryThis("".replace);
    var whitespace = "[" + whitespaces + "]";
    var ltrim = RegExp("^" + whitespace + whitespace + "*");
    var rtrim = RegExp(whitespace + whitespace + "*$");
    var createMethod = function(TYPE2) {
      return function($this) {
        var string = toString(requireObjectCoercible($this));
        if (TYPE2 & 1)
          string = replace(string, ltrim, "");
        if (TYPE2 & 2)
          string = replace(string, rtrim, "");
        return string;
      };
    };
    module2.exports = {
      // `String.prototype.{ trimLeft, trimStart }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimstart
      start: createMethod(1),
      // `String.prototype.{ trimRight, trimEnd }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimend
      end: createMethod(2),
      // `String.prototype.trim` method
      // https://tc39.es/ecma262/#sec-string.prototype.trim
      trim: createMethod(3)
    };
  }
});

// node_modules/core-js/modules/es.number.constructor.js
var require_es_number_constructor = __commonJS({
  "node_modules/core-js/modules/es.number.constructor.js"() {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var isForced = require_is_forced();
    var redefine = require_redefine();
    var hasOwn = require_has_own_property();
    var inheritIfRequired = require_inherit_if_required();
    var isPrototypeOf = require_object_is_prototype_of();
    var isSymbol = require_is_symbol();
    var toPrimitive2 = require_to_primitive();
    var fails = require_fails();
    var getOwnPropertyNames3 = require_object_get_own_property_names().f;
    var getOwnPropertyDescriptor3 = require_object_get_own_property_descriptor().f;
    var defineProperty3 = require_object_define_property().f;
    var thisNumberValue = require_this_number_value();
    var trim = require_string_trim().trim;
    var NUMBER = "Number";
    var NativeNumber = global2[NUMBER];
    var NumberPrototype = NativeNumber.prototype;
    var TypeError2 = global2.TypeError;
    var arraySlice = uncurryThis("".slice);
    var charCodeAt = uncurryThis("".charCodeAt);
    var toNumeric = function(value) {
      var primValue = toPrimitive2(value, "number");
      return typeof primValue == "bigint" ? primValue : toNumber(primValue);
    };
    var toNumber = function(argument) {
      var it = toPrimitive2(argument, "number");
      var first, third, radix, maxCode, digits, length, index2, code;
      if (isSymbol(it))
        throw TypeError2("Cannot convert a Symbol value to a number");
      if (typeof it == "string" && it.length > 2) {
        it = trim(it);
        first = charCodeAt(it, 0);
        if (first === 43 || first === 45) {
          third = charCodeAt(it, 2);
          if (third === 88 || third === 120)
            return NaN;
        } else if (first === 48) {
          switch (charCodeAt(it, 1)) {
            case 66:
            case 98:
              radix = 2;
              maxCode = 49;
              break;
            case 79:
            case 111:
              radix = 8;
              maxCode = 55;
              break;
            default:
              return +it;
          }
          digits = arraySlice(it, 2);
          length = digits.length;
          for (index2 = 0; index2 < length; index2++) {
            code = charCodeAt(digits, index2);
            if (code < 48 || code > maxCode)
              return NaN;
          }
          return parseInt(digits, radix);
        }
      }
      return +it;
    };
    if (isForced(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"))) {
      NumberWrapper = function Number2(value) {
        var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
        var dummy = this;
        return isPrototypeOf(NumberPrototype, dummy) && fails(function() {
          thisNumberValue(dummy);
        }) ? inheritIfRequired(Object(n), dummy, NumberWrapper) : n;
      };
      for (keys = DESCRIPTORS ? getOwnPropertyNames3(NativeNumber) : (
        // ES3:
        "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(",")
      ), j = 0; keys.length > j; j++) {
        if (hasOwn(NativeNumber, key = keys[j]) && !hasOwn(NumberWrapper, key)) {
          defineProperty3(NumberWrapper, key, getOwnPropertyDescriptor3(NativeNumber, key));
        }
      }
      NumberWrapper.prototype = NumberPrototype;
      NumberPrototype.constructor = NumberWrapper;
      redefine(global2, NUMBER, NumberWrapper);
    }
    var NumberWrapper;
    var keys;
    var j;
    var key;
  }
});

// node_modules/core-js/modules/es.number.epsilon.js
var require_es_number_epsilon = __commonJS({
  "node_modules/core-js/modules/es.number.epsilon.js"() {
    "use strict";
    var $ = require_export();
    $({ target: "Number", stat: true }, {
      EPSILON: Math.pow(2, -52)
    });
  }
});

// node_modules/core-js/internals/number-is-finite.js
var require_number_is_finite = __commonJS({
  "node_modules/core-js/internals/number-is-finite.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var globalIsFinite = global2.isFinite;
    module2.exports = Number.isFinite || function isFinite2(it) {
      return typeof it == "number" && globalIsFinite(it);
    };
  }
});

// node_modules/core-js/modules/es.number.is-finite.js
var require_es_number_is_finite = __commonJS({
  "node_modules/core-js/modules/es.number.is-finite.js"() {
    "use strict";
    var $ = require_export();
    var numberIsFinite = require_number_is_finite();
    $({ target: "Number", stat: true }, { isFinite: numberIsFinite });
  }
});

// node_modules/core-js/internals/is-integral-number.js
var require_is_integral_number = __commonJS({
  "node_modules/core-js/internals/is-integral-number.js"(exports, module2) {
    "use strict";
    var isObject = require_is_object();
    var floor = Math.floor;
    module2.exports = Number.isInteger || function isInteger(it) {
      return !isObject(it) && isFinite(it) && floor(it) === it;
    };
  }
});

// node_modules/core-js/modules/es.number.is-integer.js
var require_es_number_is_integer = __commonJS({
  "node_modules/core-js/modules/es.number.is-integer.js"() {
    "use strict";
    var $ = require_export();
    var isIntegralNumber = require_is_integral_number();
    $({ target: "Number", stat: true }, {
      isInteger: isIntegralNumber
    });
  }
});

// node_modules/core-js/modules/es.number.is-nan.js
var require_es_number_is_nan = __commonJS({
  "node_modules/core-js/modules/es.number.is-nan.js"() {
    "use strict";
    var $ = require_export();
    $({ target: "Number", stat: true }, {
      isNaN: function isNaN2(number) {
        return number != number;
      }
    });
  }
});

// node_modules/core-js/modules/es.number.is-safe-integer.js
var require_es_number_is_safe_integer = __commonJS({
  "node_modules/core-js/modules/es.number.is-safe-integer.js"() {
    "use strict";
    var $ = require_export();
    var isIntegralNumber = require_is_integral_number();
    var abs = Math.abs;
    $({ target: "Number", stat: true }, {
      isSafeInteger: function isSafeInteger(number) {
        return isIntegralNumber(number) && abs(number) <= 9007199254740991;
      }
    });
  }
});

// node_modules/core-js/modules/es.number.max-safe-integer.js
var require_es_number_max_safe_integer = __commonJS({
  "node_modules/core-js/modules/es.number.max-safe-integer.js"() {
    "use strict";
    var $ = require_export();
    $({ target: "Number", stat: true }, {
      MAX_SAFE_INTEGER: 9007199254740991
    });
  }
});

// node_modules/core-js/modules/es.number.min-safe-integer.js
var require_es_number_min_safe_integer = __commonJS({
  "node_modules/core-js/modules/es.number.min-safe-integer.js"() {
    "use strict";
    var $ = require_export();
    $({ target: "Number", stat: true }, {
      MIN_SAFE_INTEGER: -9007199254740991
    });
  }
});

// node_modules/core-js/internals/number-parse-float.js
var require_number_parse_float = __commonJS({
  "node_modules/core-js/internals/number-parse-float.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var fails = require_fails();
    var uncurryThis = require_function_uncurry_this();
    var toString = require_to_string();
    var trim = require_string_trim().trim;
    var whitespaces = require_whitespaces();
    var charAt = uncurryThis("".charAt);
    var n$ParseFloat = global2.parseFloat;
    var Symbol2 = global2.Symbol;
    var ITERATOR = Symbol2 && Symbol2.iterator;
    var FORCED = 1 / n$ParseFloat(whitespaces + "-0") !== -Infinity || ITERATOR && !fails(function() {
      n$ParseFloat(Object(ITERATOR));
    });
    module2.exports = FORCED ? function parseFloat2(string) {
      var trimmedString = trim(toString(string));
      var result = n$ParseFloat(trimmedString);
      return result === 0 && charAt(trimmedString, 0) == "-" ? -0 : result;
    } : n$ParseFloat;
  }
});

// node_modules/core-js/modules/es.number.parse-float.js
var require_es_number_parse_float = __commonJS({
  "node_modules/core-js/modules/es.number.parse-float.js"() {
    "use strict";
    var $ = require_export();
    var parseFloat2 = require_number_parse_float();
    $({ target: "Number", stat: true, forced: Number.parseFloat != parseFloat2 }, {
      parseFloat: parseFloat2
    });
  }
});

// node_modules/core-js/internals/number-parse-int.js
var require_number_parse_int = __commonJS({
  "node_modules/core-js/internals/number-parse-int.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var fails = require_fails();
    var uncurryThis = require_function_uncurry_this();
    var toString = require_to_string();
    var trim = require_string_trim().trim;
    var whitespaces = require_whitespaces();
    var $parseInt = global2.parseInt;
    var Symbol2 = global2.Symbol;
    var ITERATOR = Symbol2 && Symbol2.iterator;
    var hex = /^[+-]?0x/i;
    var exec = uncurryThis(hex.exec);
    var FORCED = $parseInt(whitespaces + "08") !== 8 || $parseInt(whitespaces + "0x16") !== 22 || ITERATOR && !fails(function() {
      $parseInt(Object(ITERATOR));
    });
    module2.exports = FORCED ? function parseInt2(string, radix) {
      var S = trim(toString(string));
      return $parseInt(S, radix >>> 0 || (exec(hex, S) ? 16 : 10));
    } : $parseInt;
  }
});

// node_modules/core-js/modules/es.number.parse-int.js
var require_es_number_parse_int = __commonJS({
  "node_modules/core-js/modules/es.number.parse-int.js"() {
    "use strict";
    var $ = require_export();
    var parseInt2 = require_number_parse_int();
    $({ target: "Number", stat: true, forced: Number.parseInt != parseInt2 }, {
      parseInt: parseInt2
    });
  }
});

// node_modules/core-js/modules/es.number.to-exponential.js
var require_es_number_to_exponential = __commonJS({
  "node_modules/core-js/modules/es.number.to-exponential.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var thisNumberValue = require_this_number_value();
    var $repeat = require_string_repeat();
    var log10 = require_math_log10();
    var fails = require_fails();
    var RangeError2 = global2.RangeError;
    var String2 = global2.String;
    var isFinite2 = global2.isFinite;
    var abs = Math.abs;
    var floor = Math.floor;
    var pow = Math.pow;
    var round = Math.round;
    var un$ToExponential = uncurryThis(1 .toExponential);
    var repeat = uncurryThis($repeat);
    var stringSlice = uncurryThis("".slice);
    var ROUNDS_PROPERLY = un$ToExponential(-69e-12, 4) === "-6.9000e-11" && un$ToExponential(1.255, 2) === "1.25e+0" && un$ToExponential(12345, 3) === "1.235e+4" && un$ToExponential(25, 0) === "3e+1";
    var THROWS_ON_INFINITY_FRACTION = fails(function() {
      un$ToExponential(1, Infinity);
    }) && fails(function() {
      un$ToExponential(1, -Infinity);
    });
    var PROPER_NON_FINITE_THIS_CHECK = !fails(function() {
      un$ToExponential(Infinity, Infinity);
    }) && !fails(function() {
      un$ToExponential(NaN, Infinity);
    });
    var FORCED = !ROUNDS_PROPERLY || !THROWS_ON_INFINITY_FRACTION || !PROPER_NON_FINITE_THIS_CHECK;
    $({ target: "Number", proto: true, forced: FORCED }, {
      toExponential: function toExponential(fractionDigits) {
        var x = thisNumberValue(this);
        if (fractionDigits === void 0)
          return un$ToExponential(x);
        var f = toIntegerOrInfinity(fractionDigits);
        if (!isFinite2(x))
          return String2(x);
        if (f < 0 || f > 20)
          throw RangeError2("Incorrect fraction digits");
        if (ROUNDS_PROPERLY)
          return un$ToExponential(x, f);
        var s = "";
        var m = "";
        var e = 0;
        var c = "";
        var d = "";
        if (x < 0) {
          s = "-";
          x = -x;
        }
        if (x === 0) {
          e = 0;
          m = repeat("0", f + 1);
        } else {
          var l = log10(x);
          e = floor(l);
          var n = 0;
          var w = pow(10, e - f);
          n = round(x / w);
          if (2 * x >= (2 * n + 1) * w) {
            n += 1;
          }
          if (n >= pow(10, f + 1)) {
            n /= 10;
            e += 1;
          }
          m = String2(n);
        }
        if (f !== 0) {
          m = stringSlice(m, 0, 1) + "." + stringSlice(m, 1);
        }
        if (e === 0) {
          c = "+";
          d = "0";
        } else {
          c = e > 0 ? "+" : "-";
          d = String2(abs(e));
        }
        m += "e" + c + d;
        return s + m;
      }
    });
  }
});

// node_modules/core-js/modules/es.number.to-fixed.js
var require_es_number_to_fixed = __commonJS({
  "node_modules/core-js/modules/es.number.to-fixed.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var thisNumberValue = require_this_number_value();
    var $repeat = require_string_repeat();
    var fails = require_fails();
    var RangeError2 = global2.RangeError;
    var String2 = global2.String;
    var floor = Math.floor;
    var repeat = uncurryThis($repeat);
    var stringSlice = uncurryThis("".slice);
    var un$ToFixed = uncurryThis(1 .toFixed);
    var pow = function(x, n, acc) {
      return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
    };
    var log = function(x) {
      var n = 0;
      var x2 = x;
      while (x2 >= 4096) {
        n += 12;
        x2 /= 4096;
      }
      while (x2 >= 2) {
        n += 1;
        x2 /= 2;
      }
      return n;
    };
    var multiply = function(data, n, c) {
      var index2 = -1;
      var c2 = c;
      while (++index2 < 6) {
        c2 += n * data[index2];
        data[index2] = c2 % 1e7;
        c2 = floor(c2 / 1e7);
      }
    };
    var divide = function(data, n) {
      var index2 = 6;
      var c = 0;
      while (--index2 >= 0) {
        c += data[index2];
        data[index2] = floor(c / n);
        c = c % n * 1e7;
      }
    };
    var dataToString = function(data) {
      var index2 = 6;
      var s = "";
      while (--index2 >= 0) {
        if (s !== "" || index2 === 0 || data[index2] !== 0) {
          var t = String2(data[index2]);
          s = s === "" ? t : s + repeat("0", 7 - t.length) + t;
        }
      }
      return s;
    };
    var FORCED = fails(function() {
      return un$ToFixed(8e-5, 3) !== "0.000" || un$ToFixed(0.9, 0) !== "1" || un$ToFixed(1.255, 2) !== "1.25" || un$ToFixed(1000000000000000100, 0) !== "1000000000000000128";
    }) || !fails(function() {
      un$ToFixed({});
    });
    $({ target: "Number", proto: true, forced: FORCED }, {
      toFixed: function toFixed(fractionDigits) {
        var number = thisNumberValue(this);
        var fractDigits = toIntegerOrInfinity(fractionDigits);
        var data = [0, 0, 0, 0, 0, 0];
        var sign = "";
        var result = "0";
        var e, z, j, k;
        if (fractDigits < 0 || fractDigits > 20)
          throw RangeError2("Incorrect fraction digits");
        if (number != number)
          return "NaN";
        if (number <= -1e21 || number >= 1e21)
          return String2(number);
        if (number < 0) {
          sign = "-";
          number = -number;
        }
        if (number > 1e-21) {
          e = log(number * pow(2, 69, 1)) - 69;
          z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
          z *= 4503599627370496;
          e = 52 - e;
          if (e > 0) {
            multiply(data, 0, z);
            j = fractDigits;
            while (j >= 7) {
              multiply(data, 1e7, 0);
              j -= 7;
            }
            multiply(data, pow(10, j, 1), 0);
            j = e - 1;
            while (j >= 23) {
              divide(data, 1 << 23);
              j -= 23;
            }
            divide(data, 1 << j);
            multiply(data, 1, 1);
            divide(data, 2);
            result = dataToString(data);
          } else {
            multiply(data, 0, z);
            multiply(data, 1 << -e, 0);
            result = dataToString(data) + repeat("0", fractDigits);
          }
        }
        if (fractDigits > 0) {
          k = result.length;
          result = sign + (k <= fractDigits ? "0." + repeat("0", fractDigits - k) + result : stringSlice(result, 0, k - fractDigits) + "." + stringSlice(result, k - fractDigits));
        } else {
          result = sign + result;
        }
        return result;
      }
    });
  }
});

// node_modules/core-js/modules/es.number.to-precision.js
var require_es_number_to_precision = __commonJS({
  "node_modules/core-js/modules/es.number.to-precision.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var thisNumberValue = require_this_number_value();
    var un$ToPrecision = uncurryThis(1 .toPrecision);
    var FORCED = fails(function() {
      return un$ToPrecision(1, void 0) !== "1";
    }) || !fails(function() {
      un$ToPrecision({});
    });
    $({ target: "Number", proto: true, forced: FORCED }, {
      toPrecision: function toPrecision(precision) {
        return precision === void 0 ? un$ToPrecision(thisNumberValue(this)) : un$ToPrecision(thisNumberValue(this), precision);
      }
    });
  }
});

// node_modules/core-js/internals/object-assign.js
var require_object_assign = __commonJS({
  "node_modules/core-js/internals/object-assign.js"(exports, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var uncurryThis = require_function_uncurry_this();
    var call = require_function_call();
    var fails = require_fails();
    var objectKeys = require_object_keys();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var toObject = require_to_object();
    var IndexedObject = require_indexed_object();
    var $assign = Object.assign;
    var defineProperty3 = Object.defineProperty;
    var concat = uncurryThis([].concat);
    module2.exports = !$assign || fails(function() {
      if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty3({}, "a", {
        enumerable: true,
        get: function() {
          defineProperty3(this, "b", {
            value: 3,
            enumerable: false
          });
        }
      }), { b: 2 })).b !== 1)
        return true;
      var A = {};
      var B = {};
      var symbol = Symbol();
      var alphabet = "abcdefghijklmnopqrst";
      A[symbol] = 7;
      alphabet.split("").forEach(function(chr) {
        B[chr] = chr;
      });
      return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join("") != alphabet;
    }) ? function assign2(target, source) {
      var T = toObject(target);
      var argumentsLength = arguments.length;
      var index2 = 1;
      var getOwnPropertySymbols3 = getOwnPropertySymbolsModule.f;
      var propertyIsEnumerable3 = propertyIsEnumerableModule.f;
      while (argumentsLength > index2) {
        var S = IndexedObject(arguments[index2++]);
        var keys = getOwnPropertySymbols3 ? concat(objectKeys(S), getOwnPropertySymbols3(S)) : objectKeys(S);
        var length = keys.length;
        var j = 0;
        var key;
        while (length > j) {
          key = keys[j++];
          if (!DESCRIPTORS || call(propertyIsEnumerable3, S, key))
            T[key] = S[key];
        }
      }
      return T;
    } : $assign;
  }
});

// node_modules/core-js/modules/es.object.assign.js
var require_es_object_assign = __commonJS({
  "node_modules/core-js/modules/es.object.assign.js"() {
    "use strict";
    var $ = require_export();
    var assign2 = require_object_assign();
    $({ target: "Object", stat: true, forced: Object.assign !== assign2 }, {
      assign: assign2
    });
  }
});

// node_modules/core-js/modules/es.object.create.js
var require_es_object_create = __commonJS({
  "node_modules/core-js/modules/es.object.create.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var create3 = require_object_create();
    $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
      create: create3
    });
  }
});

// node_modules/core-js/internals/object-prototype-accessors-forced.js
var require_object_prototype_accessors_forced = __commonJS({
  "node_modules/core-js/internals/object-prototype-accessors-forced.js"(exports, module2) {
    "use strict";
    var IS_PURE = require_is_pure();
    var global2 = require_global();
    var fails = require_fails();
    var WEBKIT = require_engine_webkit_version();
    module2.exports = IS_PURE || !fails(function() {
      if (WEBKIT && WEBKIT < 535)
        return;
      var key = Math.random();
      __defineSetter__.call(null, key, function() {
      });
      delete global2[key];
    });
  }
});

// node_modules/core-js/modules/es.object.define-getter.js
var require_es_object_define_getter = __commonJS({
  "node_modules/core-js/modules/es.object.define-getter.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var FORCED = require_object_prototype_accessors_forced();
    var aCallable = require_a_callable();
    var toObject = require_to_object();
    var definePropertyModule = require_object_define_property();
    if (DESCRIPTORS) {
      $({ target: "Object", proto: true, forced: FORCED }, {
        __defineGetter__: function __defineGetter__(P, getter) {
          definePropertyModule.f(toObject(this), P, { get: aCallable(getter), enumerable: true, configurable: true });
        }
      });
    }
  }
});

// node_modules/core-js/modules/es.object.define-properties.js
var require_es_object_define_properties = __commonJS({
  "node_modules/core-js/modules/es.object.define-properties.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var defineProperties = require_object_define_properties();
    $({ target: "Object", stat: true, forced: !DESCRIPTORS, sham: !DESCRIPTORS }, {
      defineProperties
    });
  }
});

// node_modules/core-js/modules/es.object.define-property.js
var require_es_object_define_property = __commonJS({
  "node_modules/core-js/modules/es.object.define-property.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var objectDefinePropertyModile = require_object_define_property();
    $({ target: "Object", stat: true, forced: !DESCRIPTORS, sham: !DESCRIPTORS }, {
      defineProperty: objectDefinePropertyModile.f
    });
  }
});

// node_modules/core-js/modules/es.object.define-setter.js
var require_es_object_define_setter = __commonJS({
  "node_modules/core-js/modules/es.object.define-setter.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var FORCED = require_object_prototype_accessors_forced();
    var aCallable = require_a_callable();
    var toObject = require_to_object();
    var definePropertyModule = require_object_define_property();
    if (DESCRIPTORS) {
      $({ target: "Object", proto: true, forced: FORCED }, {
        __defineSetter__: function __defineSetter__2(P, setter) {
          definePropertyModule.f(toObject(this), P, { set: aCallable(setter), enumerable: true, configurable: true });
        }
      });
    }
  }
});

// node_modules/core-js/internals/object-to-array.js
var require_object_to_array = __commonJS({
  "node_modules/core-js/internals/object-to-array.js"(exports, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var uncurryThis = require_function_uncurry_this();
    var objectKeys = require_object_keys();
    var toIndexedObject = require_to_indexed_object();
    var $propertyIsEnumerable = require_object_property_is_enumerable().f;
    var propertyIsEnumerable3 = uncurryThis($propertyIsEnumerable);
    var push = uncurryThis([].push);
    var createMethod = function(TO_ENTRIES) {
      return function(it) {
        var O = toIndexedObject(it);
        var keys = objectKeys(O);
        var length = keys.length;
        var i = 0;
        var result = [];
        var key;
        while (length > i) {
          key = keys[i++];
          if (!DESCRIPTORS || propertyIsEnumerable3(O, key)) {
            push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
          }
        }
        return result;
      };
    };
    module2.exports = {
      // `Object.entries` method
      // https://tc39.es/ecma262/#sec-object.entries
      entries: createMethod(true),
      // `Object.values` method
      // https://tc39.es/ecma262/#sec-object.values
      values: createMethod(false)
    };
  }
});

// node_modules/core-js/modules/es.object.entries.js
var require_es_object_entries = __commonJS({
  "node_modules/core-js/modules/es.object.entries.js"() {
    "use strict";
    var $ = require_export();
    var $entries = require_object_to_array().entries;
    $({ target: "Object", stat: true }, {
      entries: function entries(O) {
        return $entries(O);
      }
    });
  }
});

// node_modules/core-js/modules/es.object.freeze.js
var require_es_object_freeze = __commonJS({
  "node_modules/core-js/modules/es.object.freeze.js"() {
    "use strict";
    var $ = require_export();
    var FREEZING = require_freezing();
    var fails = require_fails();
    var isObject = require_is_object();
    var onFreeze = require_internal_metadata().onFreeze;
    var $freeze = Object.freeze;
    var FAILS_ON_PRIMITIVES = fails(function() {
      $freeze(1);
    });
    $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
      freeze: function freeze(it) {
        return $freeze && isObject(it) ? $freeze(onFreeze(it)) : it;
      }
    });
  }
});

// node_modules/core-js/modules/es.object.from-entries.js
var require_es_object_from_entries = __commonJS({
  "node_modules/core-js/modules/es.object.from-entries.js"() {
    "use strict";
    var $ = require_export();
    var iterate = require_iterate();
    var createProperty = require_create_property();
    $({ target: "Object", stat: true }, {
      fromEntries: function fromEntries(iterable) {
        var obj = {};
        iterate(iterable, function(k, v) {
          createProperty(obj, k, v);
        }, { AS_ENTRIES: true });
        return obj;
      }
    });
  }
});

// node_modules/core-js/modules/es.object.get-own-property-descriptor.js
var require_es_object_get_own_property_descriptor = __commonJS({
  "node_modules/core-js/modules/es.object.get-own-property-descriptor.js"() {
    "use strict";
    var $ = require_export();
    var fails = require_fails();
    var toIndexedObject = require_to_indexed_object();
    var nativeGetOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var DESCRIPTORS = require_descriptors();
    var FAILS_ON_PRIMITIVES = fails(function() {
      nativeGetOwnPropertyDescriptor(1);
    });
    var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;
    $({ target: "Object", stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor3(it, key) {
        return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
      }
    });
  }
});

// node_modules/core-js/modules/es.object.get-own-property-descriptors.js
var require_es_object_get_own_property_descriptors = __commonJS({
  "node_modules/core-js/modules/es.object.get-own-property-descriptors.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var ownKeys3 = require_own_keys();
    var toIndexedObject = require_to_indexed_object();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var createProperty = require_create_property();
    $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
      getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
        var O = toIndexedObject(object);
        var getOwnPropertyDescriptor3 = getOwnPropertyDescriptorModule.f;
        var keys = ownKeys3(O);
        var result = {};
        var index2 = 0;
        var key, descriptor;
        while (keys.length > index2) {
          descriptor = getOwnPropertyDescriptor3(O, key = keys[index2++]);
          if (descriptor !== void 0)
            createProperty(result, key, descriptor);
        }
        return result;
      }
    });
  }
});

// node_modules/core-js/modules/es.object.get-own-property-names.js
var require_es_object_get_own_property_names = __commonJS({
  "node_modules/core-js/modules/es.object.get-own-property-names.js"() {
    "use strict";
    var $ = require_export();
    var fails = require_fails();
    var getOwnPropertyNames3 = require_object_get_own_property_names_external().f;
    var FAILS_ON_PRIMITIVES = fails(function() {
      return !Object.getOwnPropertyNames(1);
    });
    $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
      getOwnPropertyNames: getOwnPropertyNames3
    });
  }
});

// node_modules/core-js/modules/es.object.get-prototype-of.js
var require_es_object_get_prototype_of = __commonJS({
  "node_modules/core-js/modules/es.object.get-prototype-of.js"() {
    "use strict";
    var $ = require_export();
    var fails = require_fails();
    var toObject = require_to_object();
    var nativeGetPrototypeOf = require_object_get_prototype_of();
    var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
    var FAILS_ON_PRIMITIVES = fails(function() {
      nativeGetPrototypeOf(1);
    });
    $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
      getPrototypeOf: function getPrototypeOf3(it) {
        return nativeGetPrototypeOf(toObject(it));
      }
    });
  }
});

// node_modules/core-js/modules/es.object.has-own.js
var require_es_object_has_own = __commonJS({
  "node_modules/core-js/modules/es.object.has-own.js"() {
    "use strict";
    var $ = require_export();
    var hasOwn = require_has_own_property();
    $({ target: "Object", stat: true }, {
      hasOwn
    });
  }
});

// node_modules/core-js/internals/same-value.js
var require_same_value = __commonJS({
  "node_modules/core-js/internals/same-value.js"(exports, module2) {
    "use strict";
    module2.exports = Object.is || function is(x, y) {
      return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
    };
  }
});

// node_modules/core-js/modules/es.object.is.js
var require_es_object_is = __commonJS({
  "node_modules/core-js/modules/es.object.is.js"() {
    "use strict";
    var $ = require_export();
    var is = require_same_value();
    $({ target: "Object", stat: true }, {
      is
    });
  }
});

// node_modules/core-js/modules/es.object.is-extensible.js
var require_es_object_is_extensible = __commonJS({
  "node_modules/core-js/modules/es.object.is-extensible.js"() {
    "use strict";
    var $ = require_export();
    var $isExtensible = require_object_is_extensible();
    $({ target: "Object", stat: true, forced: Object.isExtensible !== $isExtensible }, {
      isExtensible: $isExtensible
    });
  }
});

// node_modules/core-js/modules/es.object.is-frozen.js
var require_es_object_is_frozen = __commonJS({
  "node_modules/core-js/modules/es.object.is-frozen.js"() {
    "use strict";
    var $ = require_export();
    var fails = require_fails();
    var isObject = require_is_object();
    var classof = require_classof_raw();
    var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
    var $isFrozen = Object.isFrozen;
    var FAILS_ON_PRIMITIVES = fails(function() {
      $isFrozen(1);
    });
    $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE }, {
      isFrozen: function isFrozen(it) {
        if (!isObject(it))
          return true;
        if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == "ArrayBuffer")
          return true;
        return $isFrozen ? $isFrozen(it) : false;
      }
    });
  }
});

// node_modules/core-js/modules/es.object.is-sealed.js
var require_es_object_is_sealed = __commonJS({
  "node_modules/core-js/modules/es.object.is-sealed.js"() {
    "use strict";
    var $ = require_export();
    var fails = require_fails();
    var isObject = require_is_object();
    var classof = require_classof_raw();
    var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
    var $isSealed = Object.isSealed;
    var FAILS_ON_PRIMITIVES = fails(function() {
      $isSealed(1);
    });
    $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE }, {
      isSealed: function isSealed(it) {
        if (!isObject(it))
          return true;
        if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == "ArrayBuffer")
          return true;
        return $isSealed ? $isSealed(it) : false;
      }
    });
  }
});

// node_modules/core-js/modules/es.object.keys.js
var require_es_object_keys = __commonJS({
  "node_modules/core-js/modules/es.object.keys.js"() {
    "use strict";
    var $ = require_export();
    var toObject = require_to_object();
    var nativeKeys = require_object_keys();
    var fails = require_fails();
    var FAILS_ON_PRIMITIVES = fails(function() {
      nativeKeys(1);
    });
    $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
      keys: function keys(it) {
        return nativeKeys(toObject(it));
      }
    });
  }
});

// node_modules/core-js/modules/es.object.lookup-getter.js
var require_es_object_lookup_getter = __commonJS({
  "node_modules/core-js/modules/es.object.lookup-getter.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var FORCED = require_object_prototype_accessors_forced();
    var toObject = require_to_object();
    var toPropertyKey2 = require_to_property_key();
    var getPrototypeOf3 = require_object_get_prototype_of();
    var getOwnPropertyDescriptor3 = require_object_get_own_property_descriptor().f;
    if (DESCRIPTORS) {
      $({ target: "Object", proto: true, forced: FORCED }, {
        __lookupGetter__: function __lookupGetter__(P) {
          var O = toObject(this);
          var key = toPropertyKey2(P);
          var desc;
          do {
            if (desc = getOwnPropertyDescriptor3(O, key))
              return desc.get;
          } while (O = getPrototypeOf3(O));
        }
      });
    }
  }
});

// node_modules/core-js/modules/es.object.lookup-setter.js
var require_es_object_lookup_setter = __commonJS({
  "node_modules/core-js/modules/es.object.lookup-setter.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var FORCED = require_object_prototype_accessors_forced();
    var toObject = require_to_object();
    var toPropertyKey2 = require_to_property_key();
    var getPrototypeOf3 = require_object_get_prototype_of();
    var getOwnPropertyDescriptor3 = require_object_get_own_property_descriptor().f;
    if (DESCRIPTORS) {
      $({ target: "Object", proto: true, forced: FORCED }, {
        __lookupSetter__: function __lookupSetter__(P) {
          var O = toObject(this);
          var key = toPropertyKey2(P);
          var desc;
          do {
            if (desc = getOwnPropertyDescriptor3(O, key))
              return desc.set;
          } while (O = getPrototypeOf3(O));
        }
      });
    }
  }
});

// node_modules/core-js/modules/es.object.prevent-extensions.js
var require_es_object_prevent_extensions = __commonJS({
  "node_modules/core-js/modules/es.object.prevent-extensions.js"() {
    "use strict";
    var $ = require_export();
    var isObject = require_is_object();
    var onFreeze = require_internal_metadata().onFreeze;
    var FREEZING = require_freezing();
    var fails = require_fails();
    var $preventExtensions = Object.preventExtensions;
    var FAILS_ON_PRIMITIVES = fails(function() {
      $preventExtensions(1);
    });
    $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
      preventExtensions: function preventExtensions(it) {
        return $preventExtensions && isObject(it) ? $preventExtensions(onFreeze(it)) : it;
      }
    });
  }
});

// node_modules/core-js/modules/es.object.seal.js
var require_es_object_seal = __commonJS({
  "node_modules/core-js/modules/es.object.seal.js"() {
    "use strict";
    var $ = require_export();
    var isObject = require_is_object();
    var onFreeze = require_internal_metadata().onFreeze;
    var FREEZING = require_freezing();
    var fails = require_fails();
    var $seal = Object.seal;
    var FAILS_ON_PRIMITIVES = fails(function() {
      $seal(1);
    });
    $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
      seal: function seal(it) {
        return $seal && isObject(it) ? $seal(onFreeze(it)) : it;
      }
    });
  }
});

// node_modules/core-js/modules/es.object.set-prototype-of.js
var require_es_object_set_prototype_of = __commonJS({
  "node_modules/core-js/modules/es.object.set-prototype-of.js"() {
    "use strict";
    var $ = require_export();
    var setPrototypeOf = require_object_set_prototype_of();
    $({ target: "Object", stat: true }, {
      setPrototypeOf
    });
  }
});

// node_modules/core-js/internals/object-to-string.js
var require_object_to_string = __commonJS({
  "node_modules/core-js/internals/object-to-string.js"(exports, module2) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var classof = require_classof();
    module2.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
      return "[object " + classof(this) + "]";
    };
  }
});

// node_modules/core-js/modules/es.object.to-string.js
var require_es_object_to_string = __commonJS({
  "node_modules/core-js/modules/es.object.to-string.js"() {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var redefine = require_redefine();
    var toString = require_object_to_string();
    if (!TO_STRING_TAG_SUPPORT) {
      redefine(Object.prototype, "toString", toString, { unsafe: true });
    }
  }
});

// node_modules/core-js/modules/es.object.values.js
var require_es_object_values = __commonJS({
  "node_modules/core-js/modules/es.object.values.js"() {
    "use strict";
    var $ = require_export();
    var $values = require_object_to_array().values;
    $({ target: "Object", stat: true }, {
      values: function values(O) {
        return $values(O);
      }
    });
  }
});

// node_modules/core-js/modules/es.parse-float.js
var require_es_parse_float = __commonJS({
  "node_modules/core-js/modules/es.parse-float.js"() {
    "use strict";
    var $ = require_export();
    var $parseFloat = require_number_parse_float();
    $({ global: true, forced: parseFloat != $parseFloat }, {
      parseFloat: $parseFloat
    });
  }
});

// node_modules/core-js/modules/es.parse-int.js
var require_es_parse_int = __commonJS({
  "node_modules/core-js/modules/es.parse-int.js"() {
    "use strict";
    var $ = require_export();
    var $parseInt = require_number_parse_int();
    $({ global: true, forced: parseInt != $parseInt }, {
      parseInt: $parseInt
    });
  }
});

// node_modules/core-js/internals/native-promise-constructor.js
var require_native_promise_constructor = __commonJS({
  "node_modules/core-js/internals/native-promise-constructor.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    module2.exports = global2.Promise;
  }
});

// node_modules/core-js/internals/engine-is-ios.js
var require_engine_is_ios = __commonJS({
  "node_modules/core-js/internals/engine-is-ios.js"(exports, module2) {
    "use strict";
    var userAgent = require_engine_user_agent();
    module2.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
  }
});

// node_modules/core-js/internals/task.js
var require_task = __commonJS({
  "node_modules/core-js/internals/task.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var apply = require_function_apply();
    var bind = require_function_bind_context();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var fails = require_fails();
    var html = require_html();
    var arraySlice = require_array_slice();
    var createElement = require_document_create_element();
    var IS_IOS = require_engine_is_ios();
    var IS_NODE = require_engine_is_node();
    var set = global2.setImmediate;
    var clear = global2.clearImmediate;
    var process2 = global2.process;
    var Dispatch = global2.Dispatch;
    var Function2 = global2.Function;
    var MessageChannel2 = global2.MessageChannel;
    var String2 = global2.String;
    var counter = 0;
    var queue = {};
    var ONREADYSTATECHANGE = "onreadystatechange";
    var location;
    var defer;
    var channel;
    var port;
    try {
      location = global2.location;
    } catch (error) {
    }
    var run = function(id) {
      if (hasOwn(queue, id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var runner = function(id) {
      return function() {
        run(id);
      };
    };
    var listener = function(event) {
      run(event.data);
    };
    var post = function(id) {
      global2.postMessage(String2(id), location.protocol + "//" + location.host);
    };
    if (!set || !clear) {
      set = function setImmediate2(fn) {
        var args = arraySlice(arguments, 1);
        queue[++counter] = function() {
          apply(isCallable(fn) ? fn : Function2(fn), void 0, args);
        };
        defer(counter);
        return counter;
      };
      clear = function clearImmediate(id) {
        delete queue[id];
      };
      if (IS_NODE) {
        defer = function(id) {
          process2.nextTick(runner(id));
        };
      } else if (Dispatch && Dispatch.now) {
        defer = function(id) {
          Dispatch.now(runner(id));
        };
      } else if (MessageChannel2 && !IS_IOS) {
        channel = new MessageChannel2();
        port = channel.port2;
        channel.port1.onmessage = listener;
        defer = bind(port.postMessage, port);
      } else if (global2.addEventListener && isCallable(global2.postMessage) && !global2.importScripts && location && location.protocol !== "file:" && !fails(post)) {
        defer = post;
        global2.addEventListener("message", listener, false);
      } else if (ONREADYSTATECHANGE in createElement("script")) {
        defer = function(id) {
          html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(runner(id), 0);
        };
      }
    }
    module2.exports = {
      set,
      clear
    };
  }
});

// node_modules/core-js/internals/engine-is-ios-pebble.js
var require_engine_is_ios_pebble = __commonJS({
  "node_modules/core-js/internals/engine-is-ios-pebble.js"(exports, module2) {
    "use strict";
    var userAgent = require_engine_user_agent();
    var global2 = require_global();
    module2.exports = /ipad|iphone|ipod/i.test(userAgent) && global2.Pebble !== void 0;
  }
});

// node_modules/core-js/internals/engine-is-webos-webkit.js
var require_engine_is_webos_webkit = __commonJS({
  "node_modules/core-js/internals/engine-is-webos-webkit.js"(exports, module2) {
    "use strict";
    var userAgent = require_engine_user_agent();
    module2.exports = /web0s(?!.*chrome)/i.test(userAgent);
  }
});

// node_modules/core-js/internals/microtask.js
var require_microtask = __commonJS({
  "node_modules/core-js/internals/microtask.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var bind = require_function_bind_context();
    var getOwnPropertyDescriptor3 = require_object_get_own_property_descriptor().f;
    var macrotask = require_task().set;
    var IS_IOS = require_engine_is_ios();
    var IS_IOS_PEBBLE = require_engine_is_ios_pebble();
    var IS_WEBOS_WEBKIT = require_engine_is_webos_webkit();
    var IS_NODE = require_engine_is_node();
    var MutationObserver = global2.MutationObserver || global2.WebKitMutationObserver;
    var document2 = global2.document;
    var process2 = global2.process;
    var Promise2 = global2.Promise;
    var queueMicrotaskDescriptor = getOwnPropertyDescriptor3(global2, "queueMicrotask");
    var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
    var flush;
    var head;
    var last;
    var notify;
    var toggle;
    var node;
    var promise;
    var then;
    if (!queueMicrotask) {
      flush = function() {
        var parent, fn;
        if (IS_NODE && (parent = process2.domain))
          parent.exit();
        while (head) {
          fn = head.fn;
          head = head.next;
          try {
            fn();
          } catch (error) {
            if (head)
              notify();
            else
              last = void 0;
            throw error;
          }
        }
        last = void 0;
        if (parent)
          parent.enter();
      };
      if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document2) {
        toggle = true;
        node = document2.createTextNode("");
        new MutationObserver(flush).observe(node, { characterData: true });
        notify = function() {
          node.data = toggle = !toggle;
        };
      } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
        promise = Promise2.resolve(void 0);
        promise.constructor = Promise2;
        then = bind(promise.then, promise);
        notify = function() {
          then(flush);
        };
      } else if (IS_NODE) {
        notify = function() {
          process2.nextTick(flush);
        };
      } else {
        macrotask = bind(macrotask, global2);
        notify = function() {
          macrotask(flush);
        };
      }
    }
    module2.exports = queueMicrotask || function(fn) {
      var task = { fn, next: void 0 };
      if (last)
        last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  }
});

// node_modules/core-js/internals/new-promise-capability.js
var require_new_promise_capability = __commonJS({
  "node_modules/core-js/internals/new-promise-capability.js"(exports, module2) {
    "use strict";
    var aCallable = require_a_callable();
    var PromiseCapability = function(C) {
      var resolve2, reject;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve2 !== void 0 || reject !== void 0)
          throw TypeError("Bad Promise constructor");
        resolve2 = $$resolve;
        reject = $$reject;
      });
      this.resolve = aCallable(resolve2);
      this.reject = aCallable(reject);
    };
    module2.exports.f = function(C) {
      return new PromiseCapability(C);
    };
  }
});

// node_modules/core-js/internals/promise-resolve.js
var require_promise_resolve = __commonJS({
  "node_modules/core-js/internals/promise-resolve.js"(exports, module2) {
    "use strict";
    var anObject = require_an_object();
    var isObject = require_is_object();
    var newPromiseCapability = require_new_promise_capability();
    module2.exports = function(C, x) {
      anObject(C);
      if (isObject(x) && x.constructor === C)
        return x;
      var promiseCapability = newPromiseCapability.f(C);
      var resolve2 = promiseCapability.resolve;
      resolve2(x);
      return promiseCapability.promise;
    };
  }
});

// node_modules/core-js/internals/host-report-errors.js
var require_host_report_errors = __commonJS({
  "node_modules/core-js/internals/host-report-errors.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    module2.exports = function(a, b) {
      var console2 = global2.console;
      if (console2 && console2.error) {
        arguments.length == 1 ? console2.error(a) : console2.error(a, b);
      }
    };
  }
});

// node_modules/core-js/internals/perform.js
var require_perform = __commonJS({
  "node_modules/core-js/internals/perform.js"(exports, module2) {
    "use strict";
    module2.exports = function(exec) {
      try {
        return { error: false, value: exec() };
      } catch (error) {
        return { error: true, value: error };
      }
    };
  }
});

// node_modules/core-js/internals/engine-is-browser.js
var require_engine_is_browser = __commonJS({
  "node_modules/core-js/internals/engine-is-browser.js"(exports, module2) {
    "use strict";
    module2.exports = typeof window == "object";
  }
});

// node_modules/core-js/modules/es.promise.js
var require_es_promise = __commonJS({
  "node_modules/core-js/modules/es.promise.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var global2 = require_global();
    var getBuiltIn = require_get_built_in();
    var call = require_function_call();
    var NativePromise = require_native_promise_constructor();
    var redefine = require_redefine();
    var redefineAll = require_redefine_all();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var setSpecies = require_set_species();
    var aCallable = require_a_callable();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var anInstance = require_an_instance();
    var inspectSource = require_inspect_source();
    var iterate = require_iterate();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var speciesConstructor = require_species_constructor();
    var task = require_task().set;
    var microtask = require_microtask();
    var promiseResolve = require_promise_resolve();
    var hostReportErrors = require_host_report_errors();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var InternalStateModule = require_internal_state();
    var isForced = require_is_forced();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_BROWSER = require_engine_is_browser();
    var IS_NODE = require_engine_is_node();
    var V8_VERSION = require_engine_v8_version();
    var SPECIES = wellKnownSymbol("species");
    var PROMISE = "Promise";
    var getInternalState = InternalStateModule.getterFor(PROMISE);
    var setInternalState = InternalStateModule.set;
    var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
    var NativePromisePrototype = NativePromise && NativePromise.prototype;
    var PromiseConstructor = NativePromise;
    var PromisePrototype = NativePromisePrototype;
    var TypeError2 = global2.TypeError;
    var document2 = global2.document;
    var process2 = global2.process;
    var newPromiseCapability = newPromiseCapabilityModule.f;
    var newGenericPromiseCapability = newPromiseCapability;
    var DISPATCH_EVENT = !!(document2 && document2.createEvent && global2.dispatchEvent);
    var NATIVE_REJECTION_EVENT = isCallable(global2.PromiseRejectionEvent);
    var UNHANDLED_REJECTION = "unhandledrejection";
    var REJECTION_HANDLED = "rejectionhandled";
    var PENDING = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    var HANDLED = 1;
    var UNHANDLED = 2;
    var SUBCLASSING = false;
    var Internal;
    var OwnPromiseCapability;
    var PromiseWrapper;
    var nativeThen;
    var FORCED = isForced(PROMISE, function() {
      var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
      var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
      if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
        return true;
      if (IS_PURE && !PromisePrototype["finally"])
        return true;
      if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE))
        return false;
      var promise = new PromiseConstructor(function(resolve2) {
        resolve2(1);
      });
      var FakePromise = function(exec) {
        exec(function() {
        }, function() {
        });
      };
      var constructor = promise.constructor = {};
      constructor[SPECIES] = FakePromise;
      SUBCLASSING = promise.then(function() {
      }) instanceof FakePromise;
      if (!SUBCLASSING)
        return true;
      return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;
    });
    var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function(iterable) {
      PromiseConstructor.all(iterable)["catch"](function() {
      });
    });
    var isThenable = function(it) {
      var then;
      return isObject(it) && isCallable(then = it.then) ? then : false;
    };
    var notify = function(state, isReject) {
      if (state.notified)
        return;
      state.notified = true;
      var chain = state.reactions;
      microtask(function() {
        var value = state.value;
        var ok = state.state == FULFILLED;
        var index2 = 0;
        while (chain.length > index2) {
          var reaction = chain[index2++];
          var handler = ok ? reaction.ok : reaction.fail;
          var resolve2 = reaction.resolve;
          var reject = reaction.reject;
          var domain = reaction.domain;
          var result, then, exited;
          try {
            if (handler) {
              if (!ok) {
                if (state.rejection === UNHANDLED)
                  onHandleUnhandled(state);
                state.rejection = HANDLED;
              }
              if (handler === true)
                result = value;
              else {
                if (domain)
                  domain.enter();
                result = handler(value);
                if (domain) {
                  domain.exit();
                  exited = true;
                }
              }
              if (result === reaction.promise) {
                reject(TypeError2("Promise-chain cycle"));
              } else if (then = isThenable(result)) {
                call(then, result, resolve2, reject);
              } else
                resolve2(result);
            } else
              reject(value);
          } catch (error) {
            if (domain && !exited)
              domain.exit();
            reject(error);
          }
        }
        state.reactions = [];
        state.notified = false;
        if (isReject && !state.rejection)
          onUnhandled(state);
      });
    };
    var dispatchEvent = function(name, promise, reason) {
      var event, handler;
      if (DISPATCH_EVENT) {
        event = document2.createEvent("Event");
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name, false, true);
        global2.dispatchEvent(event);
      } else
        event = { promise, reason };
      if (!NATIVE_REJECTION_EVENT && (handler = global2["on" + name]))
        handler(event);
      else if (name === UNHANDLED_REJECTION)
        hostReportErrors("Unhandled promise rejection", reason);
    };
    var onUnhandled = function(state) {
      call(task, global2, function() {
        var promise = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
          result = perform(function() {
            if (IS_NODE) {
              process2.emit("unhandledRejection", value, promise);
            } else
              dispatchEvent(UNHANDLED_REJECTION, promise, value);
          });
          state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
          if (result.error)
            throw result.value;
        }
      });
    };
    var isUnhandled = function(state) {
      return state.rejection !== HANDLED && !state.parent;
    };
    var onHandleUnhandled = function(state) {
      call(task, global2, function() {
        var promise = state.facade;
        if (IS_NODE) {
          process2.emit("rejectionHandled", promise);
        } else
          dispatchEvent(REJECTION_HANDLED, promise, state.value);
      });
    };
    var bind = function(fn, state, unwrap) {
      return function(value) {
        fn(state, value, unwrap);
      };
    };
    var internalReject = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      state.value = value;
      state.state = REJECTED;
      notify(state, true);
    };
    var internalResolve = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      try {
        if (state.facade === value)
          throw TypeError2("Promise can't be resolved itself");
        var then = isThenable(value);
        if (then) {
          microtask(function() {
            var wrapper = { done: false };
            try {
              call(
                then,
                value,
                bind(internalResolve, wrapper, state),
                bind(internalReject, wrapper, state)
              );
            } catch (error) {
              internalReject(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED;
          notify(state, false);
        }
      } catch (error) {
        internalReject({ done: false }, error, state);
      }
    };
    if (FORCED) {
      PromiseConstructor = function Promise2(executor) {
        anInstance(this, PromisePrototype);
        aCallable(executor);
        call(Internal, this);
        var state = getInternalState(this);
        try {
          executor(bind(internalResolve, state), bind(internalReject, state));
        } catch (error) {
          internalReject(state, error);
        }
      };
      PromisePrototype = PromiseConstructor.prototype;
      Internal = function Promise2(executor) {
        setInternalState(this, {
          type: PROMISE,
          done: false,
          notified: false,
          parent: false,
          reactions: [],
          rejection: false,
          state: PENDING,
          value: void 0
        });
      };
      Internal.prototype = redefineAll(PromisePrototype, {
        // `Promise.prototype.then` method
        // https://tc39.es/ecma262/#sec-promise.prototype.then
        then: function then(onFulfilled, onRejected) {
          var state = getInternalPromiseState(this);
          var reactions = state.reactions;
          var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
          reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
          reaction.fail = isCallable(onRejected) && onRejected;
          reaction.domain = IS_NODE ? process2.domain : void 0;
          state.parent = true;
          reactions[reactions.length] = reaction;
          if (state.state != PENDING)
            notify(state, false);
          return reaction.promise;
        },
        // `Promise.prototype.catch` method
        // https://tc39.es/ecma262/#sec-promise.prototype.catch
        "catch": function(onRejected) {
          return this.then(void 0, onRejected);
        }
      });
      OwnPromiseCapability = function() {
        var promise = new Internal();
        var state = getInternalState(promise);
        this.promise = promise;
        this.resolve = bind(internalResolve, state);
        this.reject = bind(internalReject, state);
      };
      newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
      };
      if (!IS_PURE && isCallable(NativePromise) && NativePromisePrototype !== Object.prototype) {
        nativeThen = NativePromisePrototype.then;
        if (!SUBCLASSING) {
          redefine(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function(resolve2, reject) {
              call(nativeThen, that, resolve2, reject);
            }).then(onFulfilled, onRejected);
          }, { unsafe: true });
          redefine(NativePromisePrototype, "catch", PromisePrototype["catch"], { unsafe: true });
        }
        try {
          delete NativePromisePrototype.constructor;
        } catch (error) {
        }
        if (setPrototypeOf) {
          setPrototypeOf(NativePromisePrototype, PromisePrototype);
        }
      }
    }
    $({ global: true, wrap: true, forced: FORCED }, {
      Promise: PromiseConstructor
    });
    setToStringTag(PromiseConstructor, PROMISE, false, true);
    setSpecies(PROMISE);
    PromiseWrapper = getBuiltIn(PROMISE);
    $({ target: PROMISE, stat: true, forced: FORCED }, {
      // `Promise.reject` method
      // https://tc39.es/ecma262/#sec-promise.reject
      reject: function reject(r) {
        var capability = newPromiseCapability(this);
        call(capability.reject, void 0, r);
        return capability.promise;
      }
    });
    $({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
      // `Promise.resolve` method
      // https://tc39.es/ecma262/#sec-promise.resolve
      resolve: function resolve2(x) {
        return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
      }
    });
    $({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
      // `Promise.all` method
      // https://tc39.es/ecma262/#sec-promise.all
      all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var resolve2 = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function(promise) {
            var index2 = counter++;
            var alreadyCalled = false;
            remaining++;
            call($promiseResolve, C, promise).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values[index2] = value;
              --remaining || resolve2(values);
            }, reject);
          });
          --remaining || resolve2(values);
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      },
      // `Promise.race` method
      // https://tc39.es/ecma262/#sec-promise.race
      race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C.resolve);
          iterate(iterable, function(promise) {
            call($promiseResolve, C, promise).then(capability.resolve, reject);
          });
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.all-settled.js
var require_es_promise_all_settled = __commonJS({
  "node_modules/core-js/modules/es.promise.all-settled.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    $({ target: "Promise", stat: true }, {
      allSettled: function allSettled(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve2 = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var promiseResolve = aCallable(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function(promise) {
            var index2 = counter++;
            var alreadyCalled = false;
            remaining++;
            call(promiseResolve, C, promise).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values[index2] = { status: "fulfilled", value };
              --remaining || resolve2(values);
            }, function(error) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values[index2] = { status: "rejected", reason: error };
              --remaining || resolve2(values);
            });
          });
          --remaining || resolve2(values);
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.any.js
var require_es_promise_any = __commonJS({
  "node_modules/core-js/modules/es.promise.any.js"() {
    "use strict";
    var $ = require_export();
    var aCallable = require_a_callable();
    var getBuiltIn = require_get_built_in();
    var call = require_function_call();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_ANY_ERROR = "No one promise resolved";
    $({ target: "Promise", stat: true }, {
      any: function any(iterable) {
        var C = this;
        var AggregateError2 = getBuiltIn("AggregateError");
        var capability = newPromiseCapabilityModule.f(C);
        var resolve2 = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var promiseResolve = aCallable(C.resolve);
          var errors = [];
          var counter = 0;
          var remaining = 1;
          var alreadyResolved = false;
          iterate(iterable, function(promise) {
            var index2 = counter++;
            var alreadyRejected = false;
            remaining++;
            call(promiseResolve, C, promise).then(function(value) {
              if (alreadyRejected || alreadyResolved)
                return;
              alreadyResolved = true;
              resolve2(value);
            }, function(error) {
              if (alreadyRejected || alreadyResolved)
                return;
              alreadyRejected = true;
              errors[index2] = error;
              --remaining || reject(new AggregateError2(errors, PROMISE_ANY_ERROR));
            });
          });
          --remaining || reject(new AggregateError2(errors, PROMISE_ANY_ERROR));
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.finally.js
var require_es_promise_finally = __commonJS({
  "node_modules/core-js/modules/es.promise.finally.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var NativePromise = require_native_promise_constructor();
    var fails = require_fails();
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var speciesConstructor = require_species_constructor();
    var promiseResolve = require_promise_resolve();
    var redefine = require_redefine();
    var NON_GENERIC = !!NativePromise && fails(function() {
      NativePromise.prototype["finally"].call({ then: function() {
      } }, function() {
      });
    });
    $({ target: "Promise", proto: true, real: true, forced: NON_GENERIC }, {
      "finally": function(onFinally) {
        var C = speciesConstructor(this, getBuiltIn("Promise"));
        var isFunction = isCallable(onFinally);
        return this.then(
          isFunction ? function(x) {
            return promiseResolve(C, onFinally()).then(function() {
              return x;
            });
          } : onFinally,
          isFunction ? function(e) {
            return promiseResolve(C, onFinally()).then(function() {
              throw e;
            });
          } : onFinally
        );
      }
    });
    if (!IS_PURE && isCallable(NativePromise)) {
      method = getBuiltIn("Promise").prototype["finally"];
      if (NativePromise.prototype["finally"] !== method) {
        redefine(NativePromise.prototype, "finally", method, { unsafe: true });
      }
    }
    var method;
  }
});

// node_modules/core-js/modules/es.reflect.apply.js
var require_es_reflect_apply = __commonJS({
  "node_modules/core-js/modules/es.reflect.apply.js"() {
    "use strict";
    var $ = require_export();
    var functionApply = require_function_apply();
    var aCallable = require_a_callable();
    var anObject = require_an_object();
    var fails = require_fails();
    var OPTIONAL_ARGUMENTS_LIST = !fails(function() {
      Reflect.apply(function() {
      });
    });
    $({ target: "Reflect", stat: true, forced: OPTIONAL_ARGUMENTS_LIST }, {
      apply: function apply(target, thisArgument, argumentsList) {
        return functionApply(aCallable(target), thisArgument, anObject(argumentsList));
      }
    });
  }
});

// node_modules/core-js/modules/es.reflect.construct.js
var require_es_reflect_construct = __commonJS({
  "node_modules/core-js/modules/es.reflect.construct.js"() {
    "use strict";
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var apply = require_function_apply();
    var bind = require_function_bind();
    var aConstructor = require_a_constructor();
    var anObject = require_an_object();
    var isObject = require_is_object();
    var create3 = require_object_create();
    var fails = require_fails();
    var nativeConstruct = getBuiltIn("Reflect", "construct");
    var ObjectPrototype = Object.prototype;
    var push = [].push;
    var NEW_TARGET_BUG = fails(function() {
      function F() {
      }
      return !(nativeConstruct(function() {
      }, [], F) instanceof F);
    });
    var ARGS_BUG = !fails(function() {
      nativeConstruct(function() {
      });
    });
    var FORCED = NEW_TARGET_BUG || ARGS_BUG;
    $({ target: "Reflect", stat: true, forced: FORCED, sham: FORCED }, {
      construct: function construct(Target, args) {
        aConstructor(Target);
        anObject(args);
        var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
        if (ARGS_BUG && !NEW_TARGET_BUG)
          return nativeConstruct(Target, args, newTarget);
        if (Target == newTarget) {
          switch (args.length) {
            case 0:
              return new Target();
            case 1:
              return new Target(args[0]);
            case 2:
              return new Target(args[0], args[1]);
            case 3:
              return new Target(args[0], args[1], args[2]);
            case 4:
              return new Target(args[0], args[1], args[2], args[3]);
          }
          var $args = [null];
          apply(push, $args, args);
          return new (apply(bind, Target, $args))();
        }
        var proto = newTarget.prototype;
        var instance = create3(isObject(proto) ? proto : ObjectPrototype);
        var result = apply(Target, instance, args);
        return isObject(result) ? result : instance;
      }
    });
  }
});

// node_modules/core-js/modules/es.reflect.define-property.js
var require_es_reflect_define_property = __commonJS({
  "node_modules/core-js/modules/es.reflect.define-property.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var anObject = require_an_object();
    var toPropertyKey2 = require_to_property_key();
    var definePropertyModule = require_object_define_property();
    var fails = require_fails();
    var ERROR_INSTEAD_OF_FALSE = fails(function() {
      Reflect.defineProperty(definePropertyModule.f({}, 1, { value: 1 }), 1, { value: 2 });
    });
    $({ target: "Reflect", stat: true, forced: ERROR_INSTEAD_OF_FALSE, sham: !DESCRIPTORS }, {
      defineProperty: function defineProperty3(target, propertyKey, attributes) {
        anObject(target);
        var key = toPropertyKey2(propertyKey);
        anObject(attributes);
        try {
          definePropertyModule.f(target, key, attributes);
          return true;
        } catch (error) {
          return false;
        }
      }
    });
  }
});

// node_modules/core-js/modules/es.reflect.delete-property.js
var require_es_reflect_delete_property = __commonJS({
  "node_modules/core-js/modules/es.reflect.delete-property.js"() {
    "use strict";
    var $ = require_export();
    var anObject = require_an_object();
    var getOwnPropertyDescriptor3 = require_object_get_own_property_descriptor().f;
    $({ target: "Reflect", stat: true }, {
      deleteProperty: function deleteProperty(target, propertyKey) {
        var descriptor = getOwnPropertyDescriptor3(anObject(target), propertyKey);
        return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
      }
    });
  }
});

// node_modules/core-js/internals/is-data-descriptor.js
var require_is_data_descriptor = __commonJS({
  "node_modules/core-js/internals/is-data-descriptor.js"(exports, module2) {
    "use strict";
    var hasOwn = require_has_own_property();
    module2.exports = function(descriptor) {
      return descriptor !== void 0 && (hasOwn(descriptor, "value") || hasOwn(descriptor, "writable"));
    };
  }
});

// node_modules/core-js/modules/es.reflect.get.js
var require_es_reflect_get = __commonJS({
  "node_modules/core-js/modules/es.reflect.get.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var isObject = require_is_object();
    var anObject = require_an_object();
    var isDataDescriptor = require_is_data_descriptor();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var getPrototypeOf3 = require_object_get_prototype_of();
    function get(target, propertyKey) {
      var receiver = arguments.length < 3 ? target : arguments[2];
      var descriptor, prototype;
      if (anObject(target) === receiver)
        return target[propertyKey];
      descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey);
      if (descriptor)
        return isDataDescriptor(descriptor) ? descriptor.value : descriptor.get === void 0 ? void 0 : call(descriptor.get, receiver);
      if (isObject(prototype = getPrototypeOf3(target)))
        return get(prototype, propertyKey, receiver);
    }
    $({ target: "Reflect", stat: true }, {
      get
    });
  }
});

// node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js
var require_es_reflect_get_own_property_descriptor = __commonJS({
  "node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js"() {
    "use strict";
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var anObject = require_an_object();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    $({ target: "Reflect", stat: true, sham: !DESCRIPTORS }, {
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor3(target, propertyKey) {
        return getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
      }
    });
  }
});

// node_modules/core-js/modules/es.reflect.get-prototype-of.js
var require_es_reflect_get_prototype_of = __commonJS({
  "node_modules/core-js/modules/es.reflect.get-prototype-of.js"() {
    "use strict";
    var $ = require_export();
    var anObject = require_an_object();
    var objectGetPrototypeOf = require_object_get_prototype_of();
    var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
    $({ target: "Reflect", stat: true, sham: !CORRECT_PROTOTYPE_GETTER }, {
      getPrototypeOf: function getPrototypeOf3(target) {
        return objectGetPrototypeOf(anObject(target));
      }
    });
  }
});

// node_modules/core-js/modules/es.reflect.has.js
var require_es_reflect_has = __commonJS({
  "node_modules/core-js/modules/es.reflect.has.js"() {
    "use strict";
    var $ = require_export();
    $({ target: "Reflect", stat: true }, {
      has: function has(target, propertyKey) {
        return propertyKey in target;
      }
    });
  }
});

// node_modules/core-js/modules/es.reflect.is-extensible.js
var require_es_reflect_is_extensible = __commonJS({
  "node_modules/core-js/modules/es.reflect.is-extensible.js"() {
    "use strict";
    var $ = require_export();
    var anObject = require_an_object();
    var $isExtensible = require_object_is_extensible();
    $({ target: "Reflect", stat: true }, {
      isExtensible: function isExtensible(target) {
        anObject(target);
        return $isExtensible(target);
      }
    });
  }
});

// node_modules/core-js/modules/es.reflect.own-keys.js
var require_es_reflect_own_keys = __commonJS({
  "node_modules/core-js/modules/es.reflect.own-keys.js"() {
    "use strict";
    var $ = require_export();
    var ownKeys3 = require_own_keys();
    $({ target: "Reflect", stat: true }, {
      ownKeys: ownKeys3
    });
  }
});

// node_modules/core-js/modules/es.reflect.prevent-extensions.js
var require_es_reflect_prevent_extensions = __commonJS({
  "node_modules/core-js/modules/es.reflect.prevent-extensions.js"() {
    "use strict";
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var anObject = require_an_object();
    var FREEZING = require_freezing();
    $({ target: "Reflect", stat: true, sham: !FREEZING }, {
      preventExtensions: function preventExtensions(target) {
        anObject(target);
        try {
          var objectPreventExtensions = getBuiltIn("Object", "preventExtensions");
          if (objectPreventExtensions)
            objectPreventExtensions(target);
          return true;
        } catch (error) {
          return false;
        }
      }
    });
  }
});

// node_modules/core-js/modules/es.reflect.set.js
var require_es_reflect_set = __commonJS({
  "node_modules/core-js/modules/es.reflect.set.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var anObject = require_an_object();
    var isObject = require_is_object();
    var isDataDescriptor = require_is_data_descriptor();
    var fails = require_fails();
    var definePropertyModule = require_object_define_property();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var getPrototypeOf3 = require_object_get_prototype_of();
    var createPropertyDescriptor = require_create_property_descriptor();
    function set(target, propertyKey, V) {
      var receiver = arguments.length < 4 ? target : arguments[3];
      var ownDescriptor = getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
      var existingDescriptor, prototype, setter;
      if (!ownDescriptor) {
        if (isObject(prototype = getPrototypeOf3(target))) {
          return set(prototype, propertyKey, V, receiver);
        }
        ownDescriptor = createPropertyDescriptor(0);
      }
      if (isDataDescriptor(ownDescriptor)) {
        if (ownDescriptor.writable === false || !isObject(receiver))
          return false;
        if (existingDescriptor = getOwnPropertyDescriptorModule.f(receiver, propertyKey)) {
          if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false)
            return false;
          existingDescriptor.value = V;
          definePropertyModule.f(receiver, propertyKey, existingDescriptor);
        } else
          definePropertyModule.f(receiver, propertyKey, createPropertyDescriptor(0, V));
      } else {
        setter = ownDescriptor.set;
        if (setter === void 0)
          return false;
        call(setter, receiver, V);
      }
      return true;
    }
    var MS_EDGE_BUG = fails(function() {
      var Constructor = function() {
      };
      var object = definePropertyModule.f(new Constructor(), "a", { configurable: true });
      return Reflect.set(Constructor.prototype, "a", 1, object) !== false;
    });
    $({ target: "Reflect", stat: true, forced: MS_EDGE_BUG }, {
      set
    });
  }
});

// node_modules/core-js/modules/es.reflect.set-prototype-of.js
var require_es_reflect_set_prototype_of = __commonJS({
  "node_modules/core-js/modules/es.reflect.set-prototype-of.js"() {
    "use strict";
    var $ = require_export();
    var anObject = require_an_object();
    var aPossiblePrototype = require_a_possible_prototype();
    var objectSetPrototypeOf = require_object_set_prototype_of();
    if (objectSetPrototypeOf)
      $({ target: "Reflect", stat: true }, {
        setPrototypeOf: function setPrototypeOf(target, proto) {
          anObject(target);
          aPossiblePrototype(proto);
          try {
            objectSetPrototypeOf(target, proto);
            return true;
          } catch (error) {
            return false;
          }
        }
      });
  }
});

// node_modules/core-js/modules/es.reflect.to-string-tag.js
var require_es_reflect_to_string_tag = __commonJS({
  "node_modules/core-js/modules/es.reflect.to-string-tag.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var setToStringTag = require_set_to_string_tag();
    $({ global: true }, { Reflect: {} });
    setToStringTag(global2.Reflect, "Reflect", true);
  }
});

// node_modules/core-js/internals/is-regexp.js
var require_is_regexp = __commonJS({
  "node_modules/core-js/internals/is-regexp.js"(exports, module2) {
    "use strict";
    var isObject = require_is_object();
    var classof = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var MATCH = wellKnownSymbol("match");
    module2.exports = function(it) {
      var isRegExp;
      return isObject(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) == "RegExp");
    };
  }
});

// node_modules/core-js/internals/regexp-flags.js
var require_regexp_flags = __commonJS({
  "node_modules/core-js/internals/regexp-flags.js"(exports, module2) {
    "use strict";
    var anObject = require_an_object();
    module2.exports = function() {
      var that = anObject(this);
      var result = "";
      if (that.global)
        result += "g";
      if (that.ignoreCase)
        result += "i";
      if (that.multiline)
        result += "m";
      if (that.dotAll)
        result += "s";
      if (that.unicode)
        result += "u";
      if (that.sticky)
        result += "y";
      return result;
    };
  }
});

// node_modules/core-js/internals/regexp-sticky-helpers.js
var require_regexp_sticky_helpers = __commonJS({
  "node_modules/core-js/internals/regexp-sticky-helpers.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    var global2 = require_global();
    var $RegExp = global2.RegExp;
    var UNSUPPORTED_Y = fails(function() {
      var re = $RegExp("a", "y");
      re.lastIndex = 2;
      return re.exec("abcd") != null;
    });
    var MISSED_STICKY = UNSUPPORTED_Y || fails(function() {
      return !$RegExp("a", "y").sticky;
    });
    var BROKEN_CARET = UNSUPPORTED_Y || fails(function() {
      var re = $RegExp("^r", "gy");
      re.lastIndex = 2;
      return re.exec("str") != null;
    });
    module2.exports = {
      BROKEN_CARET,
      MISSED_STICKY,
      UNSUPPORTED_Y
    };
  }
});

// node_modules/core-js/internals/regexp-unsupported-dot-all.js
var require_regexp_unsupported_dot_all = __commonJS({
  "node_modules/core-js/internals/regexp-unsupported-dot-all.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    var global2 = require_global();
    var $RegExp = global2.RegExp;
    module2.exports = fails(function() {
      var re = $RegExp(".", "s");
      return !(re.dotAll && re.exec("\n") && re.flags === "s");
    });
  }
});

// node_modules/core-js/internals/regexp-unsupported-ncg.js
var require_regexp_unsupported_ncg = __commonJS({
  "node_modules/core-js/internals/regexp-unsupported-ncg.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    var global2 = require_global();
    var $RegExp = global2.RegExp;
    module2.exports = fails(function() {
      var re = $RegExp("(?<a>b)", "g");
      return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
    });
  }
});

// node_modules/core-js/modules/es.regexp.constructor.js
var require_es_regexp_constructor = __commonJS({
  "node_modules/core-js/modules/es.regexp.constructor.js"() {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var isForced = require_is_forced();
    var inheritIfRequired = require_inherit_if_required();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineProperty3 = require_object_define_property().f;
    var getOwnPropertyNames3 = require_object_get_own_property_names().f;
    var isPrototypeOf = require_object_is_prototype_of();
    var isRegExp = require_is_regexp();
    var toString = require_to_string();
    var regExpFlags = require_regexp_flags();
    var stickyHelpers = require_regexp_sticky_helpers();
    var redefine = require_redefine();
    var fails = require_fails();
    var hasOwn = require_has_own_property();
    var enforceInternalState = require_internal_state().enforce;
    var setSpecies = require_set_species();
    var wellKnownSymbol = require_well_known_symbol();
    var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
    var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
    var MATCH = wellKnownSymbol("match");
    var NativeRegExp = global2.RegExp;
    var RegExpPrototype = NativeRegExp.prototype;
    var SyntaxError2 = global2.SyntaxError;
    var getFlags = uncurryThis(regExpFlags);
    var exec = uncurryThis(RegExpPrototype.exec);
    var charAt = uncurryThis("".charAt);
    var replace = uncurryThis("".replace);
    var stringIndexOf = uncurryThis("".indexOf);
    var stringSlice = uncurryThis("".slice);
    var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
    var re1 = /a/g;
    var re2 = /a/g;
    var CORRECT_NEW = new NativeRegExp(re1) !== re1;
    var MISSED_STICKY = stickyHelpers.MISSED_STICKY;
    var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
    var BASE_FORCED = DESCRIPTORS && (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function() {
      re2[MATCH] = false;
      return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, "i") != "/a/i";
    }));
    var handleDotAll = function(string) {
      var length = string.length;
      var index3 = 0;
      var result = "";
      var brackets = false;
      var chr;
      for (; index3 <= length; index3++) {
        chr = charAt(string, index3);
        if (chr === "\\") {
          result += chr + charAt(string, ++index3);
          continue;
        }
        if (!brackets && chr === ".") {
          result += "[\\s\\S]";
        } else {
          if (chr === "[") {
            brackets = true;
          } else if (chr === "]") {
            brackets = false;
          }
          result += chr;
        }
      }
      return result;
    };
    var handleNCG = function(string) {
      var length = string.length;
      var index3 = 0;
      var result = "";
      var named = [];
      var names = {};
      var brackets = false;
      var ncg = false;
      var groupid = 0;
      var groupname = "";
      var chr;
      for (; index3 <= length; index3++) {
        chr = charAt(string, index3);
        if (chr === "\\") {
          chr = chr + charAt(string, ++index3);
        } else if (chr === "]") {
          brackets = false;
        } else if (!brackets)
          switch (true) {
            case chr === "[":
              brackets = true;
              break;
            case chr === "(":
              if (exec(IS_NCG, stringSlice(string, index3 + 1))) {
                index3 += 2;
                ncg = true;
              }
              result += chr;
              groupid++;
              continue;
            case (chr === ">" && ncg):
              if (groupname === "" || hasOwn(names, groupname)) {
                throw new SyntaxError2("Invalid capture group name");
              }
              names[groupname] = true;
              named[named.length] = [groupname, groupid];
              ncg = false;
              groupname = "";
              continue;
          }
        if (ncg)
          groupname += chr;
        else
          result += chr;
      }
      return [result, named];
    };
    if (isForced("RegExp", BASE_FORCED)) {
      RegExpWrapper = function RegExp2(pattern, flags) {
        var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
        var patternIsRegExp = isRegExp(pattern);
        var flagsAreUndefined = flags === void 0;
        var groups = [];
        var rawPattern = pattern;
        var rawFlags, dotAll, sticky, handled, result, state;
        if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
          return pattern;
        }
        if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
          pattern = pattern.source;
          if (flagsAreUndefined)
            flags = "flags" in rawPattern ? rawPattern.flags : getFlags(rawPattern);
        }
        pattern = pattern === void 0 ? "" : toString(pattern);
        flags = flags === void 0 ? "" : toString(flags);
        rawPattern = pattern;
        if (UNSUPPORTED_DOT_ALL && "dotAll" in re1) {
          dotAll = !!flags && stringIndexOf(flags, "s") > -1;
          if (dotAll)
            flags = replace(flags, /s/g, "");
        }
        rawFlags = flags;
        if (MISSED_STICKY && "sticky" in re1) {
          sticky = !!flags && stringIndexOf(flags, "y") > -1;
          if (sticky && UNSUPPORTED_Y)
            flags = replace(flags, /y/g, "");
        }
        if (UNSUPPORTED_NCG) {
          handled = handleNCG(pattern);
          pattern = handled[0];
          groups = handled[1];
        }
        result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
        if (dotAll || sticky || groups.length) {
          state = enforceInternalState(result);
          if (dotAll) {
            state.dotAll = true;
            state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
          }
          if (sticky)
            state.sticky = true;
          if (groups.length)
            state.groups = groups;
        }
        if (pattern !== rawPattern)
          try {
            createNonEnumerableProperty(result, "source", rawPattern === "" ? "(?:)" : rawPattern);
          } catch (error) {
          }
        return result;
      };
      proxy = function(key) {
        key in RegExpWrapper || defineProperty3(RegExpWrapper, key, {
          configurable: true,
          get: function() {
            return NativeRegExp[key];
          },
          set: function(it) {
            NativeRegExp[key] = it;
          }
        });
      };
      for (keys = getOwnPropertyNames3(NativeRegExp), index2 = 0; keys.length > index2; ) {
        proxy(keys[index2++]);
      }
      RegExpPrototype.constructor = RegExpWrapper;
      RegExpWrapper.prototype = RegExpPrototype;
      redefine(global2, "RegExp", RegExpWrapper);
    }
    var RegExpWrapper;
    var proxy;
    var keys;
    var index2;
    setSpecies("RegExp");
  }
});

// node_modules/core-js/modules/es.regexp.dot-all.js
var require_es_regexp_dot_all = __commonJS({
  "node_modules/core-js/modules/es.regexp.dot-all.js"() {
    "use strict";
    var global2 = require_global();
    var DESCRIPTORS = require_descriptors();
    var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
    var classof = require_classof_raw();
    var defineProperty3 = require_object_define_property().f;
    var getInternalState = require_internal_state().get;
    var RegExpPrototype = RegExp.prototype;
    var TypeError2 = global2.TypeError;
    if (DESCRIPTORS && UNSUPPORTED_DOT_ALL) {
      defineProperty3(RegExpPrototype, "dotAll", {
        configurable: true,
        get: function() {
          if (this === RegExpPrototype)
            return void 0;
          if (classof(this) === "RegExp") {
            return !!getInternalState(this).dotAll;
          }
          throw TypeError2("Incompatible receiver, RegExp required");
        }
      });
    }
  }
});

// node_modules/core-js/internals/regexp-exec.js
var require_regexp_exec = __commonJS({
  "node_modules/core-js/internals/regexp-exec.js"(exports, module2) {
    "use strict";
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var toString = require_to_string();
    var regexpFlags = require_regexp_flags();
    var stickyHelpers = require_regexp_sticky_helpers();
    var shared = require_shared();
    var create3 = require_object_create();
    var getInternalState = require_internal_state().get;
    var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
    var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
    var nativeReplace = shared("native-string-replace", String.prototype.replace);
    var nativeExec = RegExp.prototype.exec;
    var patchedExec = nativeExec;
    var charAt = uncurryThis("".charAt);
    var indexOf = uncurryThis("".indexOf);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var UPDATES_LAST_INDEX_WRONG = function() {
      var re1 = /a/;
      var re2 = /b*/g;
      call(nativeExec, re1, "a");
      call(nativeExec, re2, "a");
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    }();
    var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
    var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
    if (PATCH) {
      patchedExec = function exec(string) {
        var re = this;
        var state = getInternalState(re);
        var str = toString(string);
        var raw = state.raw;
        var result, reCopy, lastIndex, match, i, object, group;
        if (raw) {
          raw.lastIndex = re.lastIndex;
          result = call(patchedExec, raw, str);
          re.lastIndex = raw.lastIndex;
          return result;
        }
        var groups = state.groups;
        var sticky = UNSUPPORTED_Y && re.sticky;
        var flags = call(regexpFlags, re);
        var source = re.source;
        var charsAdded = 0;
        var strCopy = str;
        if (sticky) {
          flags = replace(flags, "y", "");
          if (indexOf(flags, "g") === -1) {
            flags += "g";
          }
          strCopy = stringSlice(str, re.lastIndex);
          if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== "\n")) {
            source = "(?: " + source + ")";
            strCopy = " " + strCopy;
            charsAdded++;
          }
          reCopy = new RegExp("^(?:" + source + ")", flags);
        }
        if (NPCG_INCLUDED) {
          reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
        }
        if (UPDATES_LAST_INDEX_WRONG)
          lastIndex = re.lastIndex;
        match = call(nativeExec, sticky ? reCopy : re, strCopy);
        if (sticky) {
          if (match) {
            match.input = stringSlice(match.input, charsAdded);
            match[0] = stringSlice(match[0], charsAdded);
            match.index = re.lastIndex;
            re.lastIndex += match[0].length;
          } else
            re.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG && match) {
          re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match && match.length > 1) {
          call(nativeReplace, match[0], reCopy, function() {
            for (i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === void 0)
                match[i] = void 0;
            }
          });
        }
        if (match && groups) {
          match.groups = object = create3(null);
          for (i = 0; i < groups.length; i++) {
            group = groups[i];
            object[group[0]] = match[group[1]];
          }
        }
        return match;
      };
    }
    module2.exports = patchedExec;
  }
});

// node_modules/core-js/modules/es.regexp.exec.js
var require_es_regexp_exec = __commonJS({
  "node_modules/core-js/modules/es.regexp.exec.js"() {
    "use strict";
    var $ = require_export();
    var exec = require_regexp_exec();
    $({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
      exec
    });
  }
});

// node_modules/core-js/modules/es.regexp.flags.js
var require_es_regexp_flags = __commonJS({
  "node_modules/core-js/modules/es.regexp.flags.js"() {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var objectDefinePropertyModule = require_object_define_property();
    var regExpFlags = require_regexp_flags();
    var fails = require_fails();
    var RegExpPrototype = RegExp.prototype;
    var FORCED = DESCRIPTORS && fails(function() {
      return Object.getOwnPropertyDescriptor(RegExpPrototype, "flags").get.call({ dotAll: true, sticky: true }) !== "sy";
    });
    if (FORCED)
      objectDefinePropertyModule.f(RegExpPrototype, "flags", {
        configurable: true,
        get: regExpFlags
      });
  }
});

// node_modules/core-js/modules/es.regexp.sticky.js
var require_es_regexp_sticky = __commonJS({
  "node_modules/core-js/modules/es.regexp.sticky.js"() {
    "use strict";
    var global2 = require_global();
    var DESCRIPTORS = require_descriptors();
    var MISSED_STICKY = require_regexp_sticky_helpers().MISSED_STICKY;
    var classof = require_classof_raw();
    var defineProperty3 = require_object_define_property().f;
    var getInternalState = require_internal_state().get;
    var RegExpPrototype = RegExp.prototype;
    var TypeError2 = global2.TypeError;
    if (DESCRIPTORS && MISSED_STICKY) {
      defineProperty3(RegExpPrototype, "sticky", {
        configurable: true,
        get: function() {
          if (this === RegExpPrototype)
            return void 0;
          if (classof(this) === "RegExp") {
            return !!getInternalState(this).sticky;
          }
          throw TypeError2("Incompatible receiver, RegExp required");
        }
      });
    }
  }
});

// node_modules/core-js/modules/es.regexp.test.js
var require_es_regexp_test = __commonJS({
  "node_modules/core-js/modules/es.regexp.test.js"() {
    "use strict";
    require_es_regexp_exec();
    var $ = require_export();
    var global2 = require_global();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var DELEGATES_TO_EXEC = function() {
      var execCalled = false;
      var re = /[ac]/;
      re.exec = function() {
        execCalled = true;
        return /./.exec.apply(this, arguments);
      };
      return re.test("abc") === true && execCalled;
    }();
    var Error2 = global2.Error;
    var un$Test = uncurryThis(/./.test);
    $({ target: "RegExp", proto: true, forced: !DELEGATES_TO_EXEC }, {
      test: function(str) {
        var exec = this.exec;
        if (!isCallable(exec))
          return un$Test(this, str);
        var result = call(exec, this, str);
        if (result !== null && !isObject(result)) {
          throw new Error2("RegExp exec method returned something other than an Object or null");
        }
        return !!result;
      }
    });
  }
});

// node_modules/core-js/modules/es.regexp.to-string.js
var require_es_regexp_to_string = __commonJS({
  "node_modules/core-js/modules/es.regexp.to-string.js"() {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var PROPER_FUNCTION_NAME = require_function_name().PROPER;
    var redefine = require_redefine();
    var anObject = require_an_object();
    var isPrototypeOf = require_object_is_prototype_of();
    var $toString = require_to_string();
    var fails = require_fails();
    var regExpFlags = require_regexp_flags();
    var TO_STRING = "toString";
    var RegExpPrototype = RegExp.prototype;
    var n$ToString = RegExpPrototype[TO_STRING];
    var getFlags = uncurryThis(regExpFlags);
    var NOT_GENERIC = fails(function() {
      return n$ToString.call({ source: "a", flags: "b" }) != "/a/b";
    });
    var INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;
    if (NOT_GENERIC || INCORRECT_NAME) {
      redefine(RegExp.prototype, TO_STRING, function toString() {
        var R = anObject(this);
        var p = $toString(R.source);
        var rf = R.flags;
        var f = $toString(rf === void 0 && isPrototypeOf(RegExpPrototype, R) && !("flags" in RegExpPrototype) ? getFlags(R) : rf);
        return "/" + p + "/" + f;
      }, { unsafe: true });
    }
  }
});

// node_modules/core-js/modules/es.set.js
var require_es_set = __commonJS({
  "node_modules/core-js/modules/es.set.js"() {
    "use strict";
    var collection = require_collection();
    var collectionStrong = require_collection_strong();
    collection("Set", function(init) {
      return function Set2() {
        return init(this, arguments.length ? arguments[0] : void 0);
      };
    }, collectionStrong);
  }
});

// node_modules/core-js/modules/es.string.at-alternative.js
var require_es_string_at_alternative = __commonJS({
  "node_modules/core-js/modules/es.string.at-alternative.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString = require_to_string();
    var fails = require_fails();
    var charAt = uncurryThis("".charAt);
    var FORCED = fails(function() {
      return "\u{20BB7}".at(-2) !== "\uD842";
    });
    $({ target: "String", proto: true, forced: FORCED }, {
      at: function at(index2) {
        var S = toString(requireObjectCoercible(this));
        var len = S.length;
        var relativeIndex = toIntegerOrInfinity(index2);
        var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
        return k < 0 || k >= len ? void 0 : charAt(S, k);
      }
    });
  }
});

// node_modules/core-js/internals/string-multibyte.js
var require_string_multibyte = __commonJS({
  "node_modules/core-js/internals/string-multibyte.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var stringSlice = uncurryThis("".slice);
    var createMethod = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S = toString(requireObjectCoercible($this));
        var position = toIntegerOrInfinity(pos);
        var size = S.length;
        var first, second;
        if (position < 0 || position >= size)
          return CONVERT_TO_STRING ? "" : void 0;
        first = charCodeAt(S, position);
        return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
      };
    };
    module2.exports = {
      // `String.prototype.codePointAt` method
      // https://tc39.es/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod(true)
    };
  }
});

// node_modules/core-js/modules/es.string.code-point-at.js
var require_es_string_code_point_at = __commonJS({
  "node_modules/core-js/modules/es.string.code-point-at.js"() {
    "use strict";
    var $ = require_export();
    var codeAt = require_string_multibyte().codeAt;
    $({ target: "String", proto: true }, {
      codePointAt: function codePointAt(pos) {
        return codeAt(this, pos);
      }
    });
  }
});

// node_modules/core-js/internals/not-a-regexp.js
var require_not_a_regexp = __commonJS({
  "node_modules/core-js/internals/not-a-regexp.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var isRegExp = require_is_regexp();
    var TypeError2 = global2.TypeError;
    module2.exports = function(it) {
      if (isRegExp(it)) {
        throw TypeError2("The method doesn't accept regular expressions");
      }
      return it;
    };
  }
});

// node_modules/core-js/internals/correct-is-regexp-logic.js
var require_correct_is_regexp_logic = __commonJS({
  "node_modules/core-js/internals/correct-is-regexp-logic.js"(exports, module2) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var MATCH = wellKnownSymbol("match");
    module2.exports = function(METHOD_NAME) {
      var regexp = /./;
      try {
        "/./"[METHOD_NAME](regexp);
      } catch (error1) {
        try {
          regexp[MATCH] = false;
          return "/./"[METHOD_NAME](regexp);
        } catch (error2) {
        }
      }
      return false;
    };
  }
});

// node_modules/core-js/modules/es.string.ends-with.js
var require_es_string_ends_with = __commonJS({
  "node_modules/core-js/modules/es.string.ends-with.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var getOwnPropertyDescriptor3 = require_object_get_own_property_descriptor().f;
    var toLength = require_to_length();
    var toString = require_to_string();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var IS_PURE = require_is_pure();
    var un$EndsWith = uncurryThis("".endsWith);
    var slice = uncurryThis("".slice);
    var min = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("endsWith");
    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
      var descriptor = getOwnPropertyDescriptor3(String.prototype, "endsWith");
      return descriptor && !descriptor.writable;
    }();
    $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
      endsWith: function endsWith(searchString) {
        var that = toString(requireObjectCoercible(this));
        notARegExp(searchString);
        var endPosition = arguments.length > 1 ? arguments[1] : void 0;
        var len = that.length;
        var end = endPosition === void 0 ? len : min(toLength(endPosition), len);
        var search = toString(searchString);
        return un$EndsWith ? un$EndsWith(that, search, end) : slice(that, end - search.length, end) === search;
      }
    });
  }
});

// node_modules/core-js/modules/es.string.from-code-point.js
var require_es_string_from_code_point = __commonJS({
  "node_modules/core-js/modules/es.string.from-code-point.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var toAbsoluteIndex = require_to_absolute_index();
    var RangeError2 = global2.RangeError;
    var fromCharCode = String.fromCharCode;
    var $fromCodePoint = String.fromCodePoint;
    var join = uncurryThis([].join);
    var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length != 1;
    $({ target: "String", stat: true, forced: INCORRECT_LENGTH }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      fromCodePoint: function fromCodePoint2(x) {
        var elements = [];
        var length = arguments.length;
        var i = 0;
        var code;
        while (length > i) {
          code = +arguments[i++];
          if (toAbsoluteIndex(code, 1114111) !== code)
            throw RangeError2(code + " is not a valid code point");
          elements[i] = code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320);
        }
        return join(elements, "");
      }
    });
  }
});

// node_modules/core-js/modules/es.string.includes.js
var require_es_string_includes = __commonJS({
  "node_modules/core-js/modules/es.string.includes.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var toString = require_to_string();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var stringIndexOf = uncurryThis("".indexOf);
    $({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
      includes: function includes(searchString) {
        return !!~stringIndexOf(
          toString(requireObjectCoercible(this)),
          toString(notARegExp(searchString)),
          arguments.length > 1 ? arguments[1] : void 0
        );
      }
    });
  }
});

// node_modules/core-js/modules/es.string.iterator.js
var require_es_string_iterator = __commonJS({
  "node_modules/core-js/modules/es.string.iterator.js"() {
    "use strict";
    var charAt = require_string_multibyte().charAt;
    var toString = require_to_string();
    var InternalStateModule = require_internal_state();
    var defineIterator = require_define_iterator();
    var STRING_ITERATOR = "String Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
    defineIterator(String, "String", function(iterated) {
      setInternalState(this, {
        type: STRING_ITERATOR,
        string: toString(iterated),
        index: 0
      });
    }, function next() {
      var state = getInternalState(this);
      var string = state.string;
      var index2 = state.index;
      var point;
      if (index2 >= string.length)
        return { value: void 0, done: true };
      point = charAt(string, index2);
      state.index += point.length;
      return { value: point, done: false };
    });
  }
});

// node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js
var require_fix_regexp_well_known_symbol_logic = __commonJS({
  "node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js"(exports, module2) {
    "use strict";
    require_es_regexp_exec();
    var uncurryThis = require_function_uncurry_this();
    var redefine = require_redefine();
    var regexpExec = require_regexp_exec();
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var SPECIES = wellKnownSymbol("species");
    var RegExpPrototype = RegExp.prototype;
    module2.exports = function(KEY, exec, FORCED, SHAM) {
      var SYMBOL = wellKnownSymbol(KEY);
      var DELEGATES_TO_SYMBOL = !fails(function() {
        var O = {};
        O[SYMBOL] = function() {
          return 7;
        };
        return ""[KEY](O) != 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
        var execCalled = false;
        var re = /a/;
        if (KEY === "split") {
          re = {};
          re.constructor = {};
          re.constructor[SPECIES] = function() {
            return re;
          };
          re.flags = "";
          re[SYMBOL] = /./[SYMBOL];
        }
        re.exec = function() {
          execCalled = true;
          return null;
        };
        re[SYMBOL]("");
        return !execCalled;
      });
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
        var uncurriedNativeRegExpMethod = uncurryThis(/./[SYMBOL]);
        var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
          var uncurriedNativeMethod = uncurryThis(nativeMethod);
          var $exec = regexp.exec;
          if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
            }
            return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
          }
          return { done: false };
        });
        redefine(String.prototype, KEY, methods[0]);
        redefine(RegExpPrototype, SYMBOL, methods[1]);
      }
      if (SHAM)
        createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
    };
  }
});

// node_modules/core-js/internals/advance-string-index.js
var require_advance_string_index = __commonJS({
  "node_modules/core-js/internals/advance-string-index.js"(exports, module2) {
    "use strict";
    var charAt = require_string_multibyte().charAt;
    module2.exports = function(S, index2, unicode) {
      return index2 + (unicode ? charAt(S, index2).length : 1);
    };
  }
});

// node_modules/core-js/internals/regexp-exec-abstract.js
var require_regexp_exec_abstract = __commonJS({
  "node_modules/core-js/internals/regexp-exec-abstract.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var call = require_function_call();
    var anObject = require_an_object();
    var isCallable = require_is_callable();
    var classof = require_classof_raw();
    var regexpExec = require_regexp_exec();
    var TypeError2 = global2.TypeError;
    module2.exports = function(R, S) {
      var exec = R.exec;
      if (isCallable(exec)) {
        var result = call(exec, R, S);
        if (result !== null)
          anObject(result);
        return result;
      }
      if (classof(R) === "RegExp")
        return call(regexpExec, R, S);
      throw TypeError2("RegExp#exec called on incompatible receiver");
    };
  }
});

// node_modules/core-js/modules/es.string.match.js
var require_es_string_match = __commonJS({
  "node_modules/core-js/modules/es.string.match.js"() {
    "use strict";
    var call = require_function_call();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var anObject = require_an_object();
    var toLength = require_to_length();
    var toString = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var getMethod = require_get_method();
    var advanceStringIndex = require_advance_string_index();
    var regExpExec = require_regexp_exec_abstract();
    fixRegExpWellKnownSymbolLogic("match", function(MATCH, nativeMatch, maybeCallNative) {
      return [
        // `String.prototype.match` method
        // https://tc39.es/ecma262/#sec-string.prototype.match
        function match(regexp) {
          var O = requireObjectCoercible(this);
          var matcher = regexp == void 0 ? void 0 : getMethod(regexp, MATCH);
          return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString(O));
        },
        // `RegExp.prototype[@@match]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
        function(string) {
          var rx = anObject(this);
          var S = toString(string);
          var res = maybeCallNative(nativeMatch, rx, S);
          if (res.done)
            return res.value;
          if (!rx.global)
            return regExpExec(rx, S);
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
          var A = [];
          var n = 0;
          var result;
          while ((result = regExpExec(rx, S)) !== null) {
            var matchStr = toString(result[0]);
            A[n] = matchStr;
            if (matchStr === "")
              rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
            n++;
          }
          return n === 0 ? null : A;
        }
      ];
    });
  }
});

// node_modules/core-js/modules/es.string.match-all.js
var require_es_string_match_all = __commonJS({
  "node_modules/core-js/modules/es.string.match-all.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var createIteratorConstructor = require_create_iterator_constructor();
    var requireObjectCoercible = require_require_object_coercible();
    var toLength = require_to_length();
    var toString = require_to_string();
    var anObject = require_an_object();
    var classof = require_classof_raw();
    var isPrototypeOf = require_object_is_prototype_of();
    var isRegExp = require_is_regexp();
    var regExpFlags = require_regexp_flags();
    var getMethod = require_get_method();
    var redefine = require_redefine();
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var speciesConstructor = require_species_constructor();
    var advanceStringIndex = require_advance_string_index();
    var regExpExec = require_regexp_exec_abstract();
    var InternalStateModule = require_internal_state();
    var IS_PURE = require_is_pure();
    var MATCH_ALL = wellKnownSymbol("matchAll");
    var REGEXP_STRING = "RegExp String";
    var REGEXP_STRING_ITERATOR = REGEXP_STRING + " Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(REGEXP_STRING_ITERATOR);
    var RegExpPrototype = RegExp.prototype;
    var TypeError2 = global2.TypeError;
    var getFlags = uncurryThis(regExpFlags);
    var stringIndexOf = uncurryThis("".indexOf);
    var un$MatchAll = uncurryThis("".matchAll);
    var WORKS_WITH_NON_GLOBAL_REGEX = !!un$MatchAll && !fails(function() {
      un$MatchAll("a", /./);
    });
    var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, $global, fullUnicode) {
      setInternalState(this, {
        type: REGEXP_STRING_ITERATOR,
        regexp,
        string,
        global: $global,
        unicode: fullUnicode,
        done: false
      });
    }, REGEXP_STRING, function next() {
      var state = getInternalState(this);
      if (state.done)
        return { value: void 0, done: true };
      var R = state.regexp;
      var S = state.string;
      var match = regExpExec(R, S);
      if (match === null)
        return { value: void 0, done: state.done = true };
      if (state.global) {
        if (toString(match[0]) === "")
          R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);
        return { value: match, done: false };
      }
      state.done = true;
      return { value: match, done: false };
    });
    var $matchAll = function(string) {
      var R = anObject(this);
      var S = toString(string);
      var C, flagsValue, flags, matcher, $global, fullUnicode;
      C = speciesConstructor(R, RegExp);
      flagsValue = R.flags;
      if (flagsValue === void 0 && isPrototypeOf(RegExpPrototype, R) && !("flags" in RegExpPrototype)) {
        flagsValue = getFlags(R);
      }
      flags = flagsValue === void 0 ? "" : toString(flagsValue);
      matcher = new C(C === RegExp ? R.source : R, flags);
      $global = !!~stringIndexOf(flags, "g");
      fullUnicode = !!~stringIndexOf(flags, "u");
      matcher.lastIndex = toLength(R.lastIndex);
      return new $RegExpStringIterator(matcher, S, $global, fullUnicode);
    };
    $({ target: "String", proto: true, forced: WORKS_WITH_NON_GLOBAL_REGEX }, {
      matchAll: function matchAll(regexp) {
        var O = requireObjectCoercible(this);
        var flags, S, matcher, rx;
        if (regexp != null) {
          if (isRegExp(regexp)) {
            flags = toString(requireObjectCoercible(
              "flags" in RegExpPrototype ? regexp.flags : getFlags(regexp)
            ));
            if (!~stringIndexOf(flags, "g"))
              throw TypeError2("`.matchAll` does not allow non-global regexes");
          }
          if (WORKS_WITH_NON_GLOBAL_REGEX)
            return un$MatchAll(O, regexp);
          matcher = getMethod(regexp, MATCH_ALL);
          if (matcher === void 0 && IS_PURE && classof(regexp) == "RegExp")
            matcher = $matchAll;
          if (matcher)
            return call(matcher, regexp, O);
        } else if (WORKS_WITH_NON_GLOBAL_REGEX)
          return un$MatchAll(O, regexp);
        S = toString(O);
        rx = new RegExp(regexp, "g");
        return IS_PURE ? call($matchAll, rx, S) : rx[MATCH_ALL](S);
      }
    });
    IS_PURE || MATCH_ALL in RegExpPrototype || redefine(RegExpPrototype, MATCH_ALL, $matchAll);
  }
});

// node_modules/core-js/internals/string-pad-webkit-bug.js
var require_string_pad_webkit_bug = __commonJS({
  "node_modules/core-js/internals/string-pad-webkit-bug.js"(exports, module2) {
    "use strict";
    var userAgent = require_engine_user_agent();
    module2.exports = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(userAgent);
  }
});

// node_modules/core-js/modules/es.string.pad-end.js
var require_es_string_pad_end = __commonJS({
  "node_modules/core-js/modules/es.string.pad-end.js"() {
    "use strict";
    var $ = require_export();
    var $padEnd = require_string_pad().end;
    var WEBKIT_BUG = require_string_pad_webkit_bug();
    $({ target: "String", proto: true, forced: WEBKIT_BUG }, {
      padEnd: function padEnd(maxLength) {
        return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js/modules/es.string.pad-start.js
var require_es_string_pad_start = __commonJS({
  "node_modules/core-js/modules/es.string.pad-start.js"() {
    "use strict";
    var $ = require_export();
    var $padStart = require_string_pad().start;
    var WEBKIT_BUG = require_string_pad_webkit_bug();
    $({ target: "String", proto: true, forced: WEBKIT_BUG }, {
      padStart: function padStart(maxLength) {
        return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js/modules/es.string.raw.js
var require_es_string_raw = __commonJS({
  "node_modules/core-js/modules/es.string.raw.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var toIndexedObject = require_to_indexed_object();
    var toObject = require_to_object();
    var toString = require_to_string();
    var lengthOfArrayLike = require_length_of_array_like();
    var push = uncurryThis([].push);
    var join = uncurryThis([].join);
    $({ target: "String", stat: true }, {
      raw: function raw(template) {
        var rawTemplate = toIndexedObject(toObject(template).raw);
        var literalSegments = lengthOfArrayLike(rawTemplate);
        var argumentsLength = arguments.length;
        var elements = [];
        var i = 0;
        while (literalSegments > i) {
          push(elements, toString(rawTemplate[i++]));
          if (i === literalSegments)
            return join(elements, "");
          if (i < argumentsLength)
            push(elements, toString(arguments[i]));
        }
      }
    });
  }
});

// node_modules/core-js/modules/es.string.repeat.js
var require_es_string_repeat = __commonJS({
  "node_modules/core-js/modules/es.string.repeat.js"() {
    "use strict";
    var $ = require_export();
    var repeat = require_string_repeat();
    $({ target: "String", proto: true }, {
      repeat
    });
  }
});

// node_modules/core-js/internals/get-substitution.js
var require_get_substitution = __commonJS({
  "node_modules/core-js/internals/get-substitution.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var floor = Math.floor;
    var charAt = uncurryThis("".charAt);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
    module2.exports = function(matched, str, position, captures, namedCaptures, replacement) {
      var tailPos = position + matched.length;
      var m = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== void 0) {
        namedCaptures = toObject(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }
      return replace(replacement, symbols, function(match, ch) {
        var capture;
        switch (charAt(ch, 0)) {
          case "$":
            return "$";
          case "&":
            return matched;
          case "`":
            return stringSlice(str, 0, position);
          case "'":
            return stringSlice(str, tailPos);
          case "<":
            capture = namedCaptures[stringSlice(ch, 1, -1)];
            break;
          default:
            var n = +ch;
            if (n === 0)
              return match;
            if (n > m) {
              var f = floor(n / 10);
              if (f === 0)
                return match;
              if (f <= m)
                return captures[f - 1] === void 0 ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
              return match;
            }
            capture = captures[n - 1];
        }
        return capture === void 0 ? "" : capture;
      });
    };
  }
});

// node_modules/core-js/modules/es.string.replace.js
var require_es_string_replace = __commonJS({
  "node_modules/core-js/modules/es.string.replace.js"() {
    "use strict";
    var apply = require_function_apply();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var fails = require_fails();
    var anObject = require_an_object();
    var isCallable = require_is_callable();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toLength = require_to_length();
    var toString = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var advanceStringIndex = require_advance_string_index();
    var getMethod = require_get_method();
    var getSubstitution = require_get_substitution();
    var regExpExec = require_regexp_exec_abstract();
    var wellKnownSymbol = require_well_known_symbol();
    var REPLACE = wellKnownSymbol("replace");
    var max = Math.max;
    var min = Math.min;
    var concat = uncurryThis([].concat);
    var push = uncurryThis([].push);
    var stringIndexOf = uncurryThis("".indexOf);
    var stringSlice = uncurryThis("".slice);
    var maybeToString = function(it) {
      return it === void 0 ? it : String(it);
    };
    var REPLACE_KEEPS_$0 = function() {
      return "a".replace(/./, "$0") === "$0";
    }();
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
      if (/./[REPLACE]) {
        return /./[REPLACE]("a", "$0") === "";
      }
      return false;
    }();
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
      var re = /./;
      re.exec = function() {
        var result = [];
        result.groups = { a: "7" };
        return result;
      };
      return "".replace(re, "$<a>") !== "7";
    });
    fixRegExpWellKnownSymbolLogic("replace", function(_, nativeReplace, maybeCallNative) {
      var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
      return [
        // `String.prototype.replace` method
        // https://tc39.es/ecma262/#sec-string.prototype.replace
        function replace(searchValue, replaceValue) {
          var O = requireObjectCoercible(this);
          var replacer = searchValue == void 0 ? void 0 : getMethod(searchValue, REPLACE);
          return replacer ? call(replacer, searchValue, O, replaceValue) : call(nativeReplace, toString(O), searchValue, replaceValue);
        },
        // `RegExp.prototype[@@replace]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
        function(string, replaceValue) {
          var rx = anObject(this);
          var S = toString(string);
          if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
            var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
            if (res.done)
              return res.value;
          }
          var functionalReplace = isCallable(replaceValue);
          if (!functionalReplace)
            replaceValue = toString(replaceValue);
          var global2 = rx.global;
          if (global2) {
            var fullUnicode = rx.unicode;
            rx.lastIndex = 0;
          }
          var results = [];
          while (true) {
            var result = regExpExec(rx, S);
            if (result === null)
              break;
            push(results, result);
            if (!global2)
              break;
            var matchStr = toString(result[0]);
            if (matchStr === "")
              rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          }
          var accumulatedResult = "";
          var nextSourcePosition = 0;
          for (var i = 0; i < results.length; i++) {
            result = results[i];
            var matched = toString(result[0]);
            var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
            var captures = [];
            for (var j = 1; j < result.length; j++)
              push(captures, maybeToString(result[j]));
            var namedCaptures = result.groups;
            if (functionalReplace) {
              var replacerArgs = concat([matched], captures, position, S);
              if (namedCaptures !== void 0)
                push(replacerArgs, namedCaptures);
              var replacement = toString(apply(replaceValue, void 0, replacerArgs));
            } else {
              replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
            }
            if (position >= nextSourcePosition) {
              accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
              nextSourcePosition = position + matched.length;
            }
          }
          return accumulatedResult + stringSlice(S, nextSourcePosition);
        }
      ];
    }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
  }
});

// node_modules/core-js/modules/es.string.replace-all.js
var require_es_string_replace_all = __commonJS({
  "node_modules/core-js/modules/es.string.replace-all.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var isCallable = require_is_callable();
    var isRegExp = require_is_regexp();
    var toString = require_to_string();
    var getMethod = require_get_method();
    var regExpFlags = require_regexp_flags();
    var getSubstitution = require_get_substitution();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var REPLACE = wellKnownSymbol("replace");
    var RegExpPrototype = RegExp.prototype;
    var TypeError2 = global2.TypeError;
    var getFlags = uncurryThis(regExpFlags);
    var indexOf = uncurryThis("".indexOf);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var max = Math.max;
    var stringIndexOf = function(string, searchValue, fromIndex) {
      if (fromIndex > string.length)
        return -1;
      if (searchValue === "")
        return fromIndex;
      return indexOf(string, searchValue, fromIndex);
    };
    $({ target: "String", proto: true }, {
      replaceAll: function replaceAll(searchValue, replaceValue) {
        var O = requireObjectCoercible(this);
        var IS_REG_EXP, flags, replacer, string, searchString, functionalReplace, searchLength, advanceBy, replacement;
        var position = 0;
        var endOfLastMatch = 0;
        var result = "";
        if (searchValue != null) {
          IS_REG_EXP = isRegExp(searchValue);
          if (IS_REG_EXP) {
            flags = toString(requireObjectCoercible(
              "flags" in RegExpPrototype ? searchValue.flags : getFlags(searchValue)
            ));
            if (!~indexOf(flags, "g"))
              throw TypeError2("`.replaceAll` does not allow non-global regexes");
          }
          replacer = getMethod(searchValue, REPLACE);
          if (replacer) {
            return call(replacer, searchValue, O, replaceValue);
          } else if (IS_PURE && IS_REG_EXP) {
            return replace(toString(O), searchValue, replaceValue);
          }
        }
        string = toString(O);
        searchString = toString(searchValue);
        functionalReplace = isCallable(replaceValue);
        if (!functionalReplace)
          replaceValue = toString(replaceValue);
        searchLength = searchString.length;
        advanceBy = max(1, searchLength);
        position = stringIndexOf(string, searchString, 0);
        while (position !== -1) {
          replacement = functionalReplace ? toString(replaceValue(searchString, position, string)) : getSubstitution(searchString, string, position, [], void 0, replaceValue);
          result += stringSlice(string, endOfLastMatch, position) + replacement;
          endOfLastMatch = position + searchLength;
          position = stringIndexOf(string, searchString, position + advanceBy);
        }
        if (endOfLastMatch < string.length) {
          result += stringSlice(string, endOfLastMatch);
        }
        return result;
      }
    });
  }
});

// node_modules/core-js/modules/es.string.search.js
var require_es_string_search = __commonJS({
  "node_modules/core-js/modules/es.string.search.js"() {
    "use strict";
    var call = require_function_call();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var anObject = require_an_object();
    var requireObjectCoercible = require_require_object_coercible();
    var sameValue = require_same_value();
    var toString = require_to_string();
    var getMethod = require_get_method();
    var regExpExec = require_regexp_exec_abstract();
    fixRegExpWellKnownSymbolLogic("search", function(SEARCH, nativeSearch, maybeCallNative) {
      return [
        // `String.prototype.search` method
        // https://tc39.es/ecma262/#sec-string.prototype.search
        function search(regexp) {
          var O = requireObjectCoercible(this);
          var searcher = regexp == void 0 ? void 0 : getMethod(regexp, SEARCH);
          return searcher ? call(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString(O));
        },
        // `RegExp.prototype[@@search]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
        function(string) {
          var rx = anObject(this);
          var S = toString(string);
          var res = maybeCallNative(nativeSearch, rx, S);
          if (res.done)
            return res.value;
          var previousLastIndex = rx.lastIndex;
          if (!sameValue(previousLastIndex, 0))
            rx.lastIndex = 0;
          var result = regExpExec(rx, S);
          if (!sameValue(rx.lastIndex, previousLastIndex))
            rx.lastIndex = previousLastIndex;
          return result === null ? -1 : result.index;
        }
      ];
    });
  }
});

// node_modules/core-js/modules/es.string.split.js
var require_es_string_split = __commonJS({
  "node_modules/core-js/modules/es.string.split.js"() {
    "use strict";
    var apply = require_function_apply();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var isRegExp = require_is_regexp();
    var anObject = require_an_object();
    var requireObjectCoercible = require_require_object_coercible();
    var speciesConstructor = require_species_constructor();
    var advanceStringIndex = require_advance_string_index();
    var toLength = require_to_length();
    var toString = require_to_string();
    var getMethod = require_get_method();
    var arraySlice = require_array_slice_simple();
    var callRegExpExec = require_regexp_exec_abstract();
    var regexpExec = require_regexp_exec();
    var stickyHelpers = require_regexp_sticky_helpers();
    var fails = require_fails();
    var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
    var MAX_UINT32 = 4294967295;
    var min = Math.min;
    var $push = [].push;
    var exec = uncurryThis(/./.exec);
    var push = uncurryThis($push);
    var stringSlice = uncurryThis("".slice);
    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
      var re = /(?:)/;
      var originalExec = re.exec;
      re.exec = function() {
        return originalExec.apply(this, arguments);
      };
      var result = "ab".split(re);
      return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
    });
    fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
      var internalSplit;
      if ("abbc".split(/(b)*/)[1] == "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
      "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
      ".".split(/()()/).length > 1 || "".split(/.?/).length) {
        internalSplit = function(separator, limit) {
          var string = toString(requireObjectCoercible(this));
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0)
            return [];
          if (separator === void 0)
            return [string];
          if (!isRegExp(separator)) {
            return call(nativeSplit, string, separator, lim);
          }
          var output = [];
          var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
          var lastLastIndex = 0;
          var separatorCopy = new RegExp(separator.source, flags + "g");
          var match, lastIndex, lastLength;
          while (match = call(regexpExec, separatorCopy, string)) {
            lastIndex = separatorCopy.lastIndex;
            if (lastIndex > lastLastIndex) {
              push(output, stringSlice(string, lastLastIndex, match.index));
              if (match.length > 1 && match.index < string.length)
                apply($push, output, arraySlice(match, 1));
              lastLength = match[0].length;
              lastLastIndex = lastIndex;
              if (output.length >= lim)
                break;
            }
            if (separatorCopy.lastIndex === match.index)
              separatorCopy.lastIndex++;
          }
          if (lastLastIndex === string.length) {
            if (lastLength || !exec(separatorCopy, ""))
              push(output, "");
          } else
            push(output, stringSlice(string, lastLastIndex));
          return output.length > lim ? arraySlice(output, 0, lim) : output;
        };
      } else if ("0".split(void 0, 0).length) {
        internalSplit = function(separator, limit) {
          return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
        };
      } else
        internalSplit = nativeSplit;
      return [
        // `String.prototype.split` method
        // https://tc39.es/ecma262/#sec-string.prototype.split
        function split(separator, limit) {
          var O = requireObjectCoercible(this);
          var splitter = separator == void 0 ? void 0 : getMethod(separator, SPLIT);
          return splitter ? call(splitter, separator, O, limit) : call(internalSplit, toString(O), separator, limit);
        },
        // `RegExp.prototype[@@split]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
        //
        // NOTE: This cannot be properly polyfilled in engines that don't support
        // the 'y' flag.
        function(string, limit) {
          var rx = anObject(this);
          var S = toString(string);
          var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
          if (res.done)
            return res.value;
          var C = speciesConstructor(rx, RegExp);
          var unicodeMatching = rx.unicode;
          var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
          var splitter = new C(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0)
            return [];
          if (S.length === 0)
            return callRegExpExec(splitter, S) === null ? [S] : [];
          var p = 0;
          var q = 0;
          var A = [];
          while (q < S.length) {
            splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
            var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
            var e;
            if (z === null || (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p) {
              q = advanceStringIndex(S, q, unicodeMatching);
            } else {
              push(A, stringSlice(S, p, q));
              if (A.length === lim)
                return A;
              for (var i = 1; i <= z.length - 1; i++) {
                push(A, z[i]);
                if (A.length === lim)
                  return A;
              }
              q = p = e;
            }
          }
          push(A, stringSlice(S, p));
          return A;
        }
      ];
    }, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
  }
});

// node_modules/core-js/modules/es.string.starts-with.js
var require_es_string_starts_with = __commonJS({
  "node_modules/core-js/modules/es.string.starts-with.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var getOwnPropertyDescriptor3 = require_object_get_own_property_descriptor().f;
    var toLength = require_to_length();
    var toString = require_to_string();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var IS_PURE = require_is_pure();
    var un$StartsWith = uncurryThis("".startsWith);
    var stringSlice = uncurryThis("".slice);
    var min = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
      var descriptor = getOwnPropertyDescriptor3(String.prototype, "startsWith");
      return descriptor && !descriptor.writable;
    }();
    $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
      startsWith: function startsWith(searchString) {
        var that = toString(requireObjectCoercible(this));
        notARegExp(searchString);
        var index2 = toLength(min(arguments.length > 1 ? arguments[1] : void 0, that.length));
        var search = toString(searchString);
        return un$StartsWith ? un$StartsWith(that, search, index2) : stringSlice(that, index2, index2 + search.length) === search;
      }
    });
  }
});

// node_modules/core-js/modules/es.string.substr.js
var require_es_string_substr = __commonJS({
  "node_modules/core-js/modules/es.string.substr.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString = require_to_string();
    var stringSlice = uncurryThis("".slice);
    var max = Math.max;
    var min = Math.min;
    var FORCED = !"".substr || "ab".substr(-1) !== "b";
    $({ target: "String", proto: true, forced: FORCED }, {
      substr: function substr(start, length) {
        var that = toString(requireObjectCoercible(this));
        var size = that.length;
        var intStart = toIntegerOrInfinity(start);
        var intLength, intEnd;
        if (intStart === Infinity)
          intStart = 0;
        if (intStart < 0)
          intStart = max(size + intStart, 0);
        intLength = length === void 0 ? size : toIntegerOrInfinity(length);
        if (intLength <= 0 || intLength === Infinity)
          return "";
        intEnd = min(intStart + intLength, size);
        return intStart >= intEnd ? "" : stringSlice(that, intStart, intEnd);
      }
    });
  }
});

// node_modules/core-js/internals/string-trim-forced.js
var require_string_trim_forced = __commonJS({
  "node_modules/core-js/internals/string-trim-forced.js"(exports, module2) {
    "use strict";
    var PROPER_FUNCTION_NAME = require_function_name().PROPER;
    var fails = require_fails();
    var whitespaces = require_whitespaces();
    var non = "\u200B\x85\u180E";
    module2.exports = function(METHOD_NAME) {
      return fails(function() {
        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
      });
    };
  }
});

// node_modules/core-js/modules/es.string.trim.js
var require_es_string_trim = __commonJS({
  "node_modules/core-js/modules/es.string.trim.js"() {
    "use strict";
    var $ = require_export();
    var $trim = require_string_trim().trim;
    var forcedStringTrimMethod = require_string_trim_forced();
    $({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
      trim: function trim() {
        return $trim(this);
      }
    });
  }
});

// node_modules/core-js/modules/es.string.trim-end.js
var require_es_string_trim_end = __commonJS({
  "node_modules/core-js/modules/es.string.trim-end.js"() {
    "use strict";
    var $ = require_export();
    var $trimEnd = require_string_trim().end;
    var forcedStringTrimMethod = require_string_trim_forced();
    var FORCED = forcedStringTrimMethod("trimEnd");
    var trimEnd = FORCED ? function trimEnd2() {
      return $trimEnd(this);
    } : "".trimEnd;
    $({ target: "String", proto: true, name: "trimEnd", forced: FORCED }, {
      trimEnd,
      trimRight: trimEnd
    });
  }
});

// node_modules/core-js/modules/es.string.trim-start.js
var require_es_string_trim_start = __commonJS({
  "node_modules/core-js/modules/es.string.trim-start.js"() {
    "use strict";
    var $ = require_export();
    var $trimStart = require_string_trim().start;
    var forcedStringTrimMethod = require_string_trim_forced();
    var FORCED = forcedStringTrimMethod("trimStart");
    var trimStart = FORCED ? function trimStart2() {
      return $trimStart(this);
    } : "".trimStart;
    $({ target: "String", proto: true, name: "trimStart", forced: FORCED }, {
      trimStart,
      trimLeft: trimStart
    });
  }
});

// node_modules/core-js/internals/create-html.js
var require_create_html = __commonJS({
  "node_modules/core-js/internals/create-html.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var toString = require_to_string();
    var quot = /"/g;
    var replace = uncurryThis("".replace);
    module2.exports = function(string, tag, attribute, value) {
      var S = toString(requireObjectCoercible(string));
      var p1 = "<" + tag;
      if (attribute !== "")
        p1 += " " + attribute + '="' + replace(toString(value), quot, "&quot;") + '"';
      return p1 + ">" + S + "</" + tag + ">";
    };
  }
});

// node_modules/core-js/internals/string-html-forced.js
var require_string_html_forced = __commonJS({
  "node_modules/core-js/internals/string-html-forced.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    module2.exports = function(METHOD_NAME) {
      return fails(function() {
        var test = ""[METHOD_NAME]('"');
        return test !== test.toLowerCase() || test.split('"').length > 3;
      });
    };
  }
});

// node_modules/core-js/modules/es.string.anchor.js
var require_es_string_anchor = __commonJS({
  "node_modules/core-js/modules/es.string.anchor.js"() {
    "use strict";
    var $ = require_export();
    var createHTML = require_create_html();
    var forcedStringHTMLMethod = require_string_html_forced();
    $({ target: "String", proto: true, forced: forcedStringHTMLMethod("anchor") }, {
      anchor: function anchor(name) {
        return createHTML(this, "a", "name", name);
      }
    });
  }
});

// node_modules/core-js/modules/es.string.big.js
var require_es_string_big = __commonJS({
  "node_modules/core-js/modules/es.string.big.js"() {
    "use strict";
    var $ = require_export();
    var createHTML = require_create_html();
    var forcedStringHTMLMethod = require_string_html_forced();
    $({ target: "String", proto: true, forced: forcedStringHTMLMethod("big") }, {
      big: function big() {
        return createHTML(this, "big", "", "");
      }
    });
  }
});

// node_modules/core-js/modules/es.string.blink.js
var require_es_string_blink = __commonJS({
  "node_modules/core-js/modules/es.string.blink.js"() {
    "use strict";
    var $ = require_export();
    var createHTML = require_create_html();
    var forcedStringHTMLMethod = require_string_html_forced();
    $({ target: "String", proto: true, forced: forcedStringHTMLMethod("blink") }, {
      blink: function blink() {
        return createHTML(this, "blink", "", "");
      }
    });
  }
});

// node_modules/core-js/modules/es.string.bold.js
var require_es_string_bold = __commonJS({
  "node_modules/core-js/modules/es.string.bold.js"() {
    "use strict";
    var $ = require_export();
    var createHTML = require_create_html();
    var forcedStringHTMLMethod = require_string_html_forced();
    $({ target: "String", proto: true, forced: forcedStringHTMLMethod("bold") }, {
      bold: function bold() {
        return createHTML(this, "b", "", "");
      }
    });
  }
});

// node_modules/core-js/modules/es.string.fixed.js
var require_es_string_fixed = __commonJS({
  "node_modules/core-js/modules/es.string.fixed.js"() {
    "use strict";
    var $ = require_export();
    var createHTML = require_create_html();
    var forcedStringHTMLMethod = require_string_html_forced();
    $({ target: "String", proto: true, forced: forcedStringHTMLMethod("fixed") }, {
      fixed: function fixed() {
        return createHTML(this, "tt", "", "");
      }
    });
  }
});

// node_modules/core-js/modules/es.string.fontcolor.js
var require_es_string_fontcolor = __commonJS({
  "node_modules/core-js/modules/es.string.fontcolor.js"() {
    "use strict";
    var $ = require_export();
    var createHTML = require_create_html();
    var forcedStringHTMLMethod = require_string_html_forced();
    $({ target: "String", proto: true, forced: forcedStringHTMLMethod("fontcolor") }, {
      fontcolor: function fontcolor(color) {
        return createHTML(this, "font", "color", color);
      }
    });
  }
});

// node_modules/core-js/modules/es.string.fontsize.js
var require_es_string_fontsize = __commonJS({
  "node_modules/core-js/modules/es.string.fontsize.js"() {
    "use strict";
    var $ = require_export();
    var createHTML = require_create_html();
    var forcedStringHTMLMethod = require_string_html_forced();
    $({ target: "String", proto: true, forced: forcedStringHTMLMethod("fontsize") }, {
      fontsize: function fontsize(size) {
        return createHTML(this, "font", "size", size);
      }
    });
  }
});

// node_modules/core-js/modules/es.string.italics.js
var require_es_string_italics = __commonJS({
  "node_modules/core-js/modules/es.string.italics.js"() {
    "use strict";
    var $ = require_export();
    var createHTML = require_create_html();
    var forcedStringHTMLMethod = require_string_html_forced();
    $({ target: "String", proto: true, forced: forcedStringHTMLMethod("italics") }, {
      italics: function italics() {
        return createHTML(this, "i", "", "");
      }
    });
  }
});

// node_modules/core-js/modules/es.string.link.js
var require_es_string_link = __commonJS({
  "node_modules/core-js/modules/es.string.link.js"() {
    "use strict";
    var $ = require_export();
    var createHTML = require_create_html();
    var forcedStringHTMLMethod = require_string_html_forced();
    $({ target: "String", proto: true, forced: forcedStringHTMLMethod("link") }, {
      link: function link(url) {
        return createHTML(this, "a", "href", url);
      }
    });
  }
});

// node_modules/core-js/modules/es.string.small.js
var require_es_string_small = __commonJS({
  "node_modules/core-js/modules/es.string.small.js"() {
    "use strict";
    var $ = require_export();
    var createHTML = require_create_html();
    var forcedStringHTMLMethod = require_string_html_forced();
    $({ target: "String", proto: true, forced: forcedStringHTMLMethod("small") }, {
      small: function small() {
        return createHTML(this, "small", "", "");
      }
    });
  }
});

// node_modules/core-js/modules/es.string.strike.js
var require_es_string_strike = __commonJS({
  "node_modules/core-js/modules/es.string.strike.js"() {
    "use strict";
    var $ = require_export();
    var createHTML = require_create_html();
    var forcedStringHTMLMethod = require_string_html_forced();
    $({ target: "String", proto: true, forced: forcedStringHTMLMethod("strike") }, {
      strike: function strike() {
        return createHTML(this, "strike", "", "");
      }
    });
  }
});

// node_modules/core-js/modules/es.string.sub.js
var require_es_string_sub = __commonJS({
  "node_modules/core-js/modules/es.string.sub.js"() {
    "use strict";
    var $ = require_export();
    var createHTML = require_create_html();
    var forcedStringHTMLMethod = require_string_html_forced();
    $({ target: "String", proto: true, forced: forcedStringHTMLMethod("sub") }, {
      sub: function sub() {
        return createHTML(this, "sub", "", "");
      }
    });
  }
});

// node_modules/core-js/modules/es.string.sup.js
var require_es_string_sup = __commonJS({
  "node_modules/core-js/modules/es.string.sup.js"() {
    "use strict";
    var $ = require_export();
    var createHTML = require_create_html();
    var forcedStringHTMLMethod = require_string_html_forced();
    $({ target: "String", proto: true, forced: forcedStringHTMLMethod("sup") }, {
      sup: function sup() {
        return createHTML(this, "sup", "", "");
      }
    });
  }
});

// node_modules/core-js/internals/typed-array-constructors-require-wrappers.js
var require_typed_array_constructors_require_wrappers = __commonJS({
  "node_modules/core-js/internals/typed-array-constructors-require-wrappers.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var fails = require_fails();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var NATIVE_ARRAY_BUFFER_VIEWS = require_array_buffer_view_core().NATIVE_ARRAY_BUFFER_VIEWS;
    var ArrayBuffer2 = global2.ArrayBuffer;
    var Int8Array2 = global2.Int8Array;
    module2.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function() {
      Int8Array2(1);
    }) || !fails(function() {
      new Int8Array2(-1);
    }) || !checkCorrectnessOfIteration(function(iterable) {
      new Int8Array2();
      new Int8Array2(null);
      new Int8Array2(1.5);
      new Int8Array2(iterable);
    }, true) || fails(function() {
      return new Int8Array2(new ArrayBuffer2(2), 1, void 0).length !== 1;
    });
  }
});

// node_modules/core-js/internals/to-positive-integer.js
var require_to_positive_integer = __commonJS({
  "node_modules/core-js/internals/to-positive-integer.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var RangeError2 = global2.RangeError;
    module2.exports = function(it) {
      var result = toIntegerOrInfinity(it);
      if (result < 0)
        throw RangeError2("The argument can't be less than 0");
      return result;
    };
  }
});

// node_modules/core-js/internals/to-offset.js
var require_to_offset = __commonJS({
  "node_modules/core-js/internals/to-offset.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var toPositiveInteger = require_to_positive_integer();
    var RangeError2 = global2.RangeError;
    module2.exports = function(it, BYTES) {
      var offset = toPositiveInteger(it);
      if (offset % BYTES)
        throw RangeError2("Wrong offset");
      return offset;
    };
  }
});

// node_modules/core-js/internals/typed-array-from.js
var require_typed_array_from = __commonJS({
  "node_modules/core-js/internals/typed-array-from.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind_context();
    var call = require_function_call();
    var aConstructor = require_a_constructor();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var aTypedArrayConstructor = require_array_buffer_view_core().aTypedArrayConstructor;
    module2.exports = function from(source) {
      var C = aConstructor(this);
      var O = toObject(source);
      var argumentsLength = arguments.length;
      var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
      var mapping = mapfn !== void 0;
      var iteratorMethod = getIteratorMethod(O);
      var i, length, result, step, iterator, next;
      if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
        iterator = getIterator(O, iteratorMethod);
        next = iterator.next;
        O = [];
        while (!(step = call(next, iterator)).done) {
          O.push(step.value);
        }
      }
      if (mapping && argumentsLength > 2) {
        mapfn = bind(mapfn, arguments[2]);
      }
      length = lengthOfArrayLike(O);
      result = new (aTypedArrayConstructor(C))(length);
      for (i = 0; length > i; i++) {
        result[i] = mapping ? mapfn(O[i], i) : O[i];
      }
      return result;
    };
  }
});

// node_modules/core-js/internals/typed-array-constructor.js
var require_typed_array_constructor = __commonJS({
  "node_modules/core-js/internals/typed-array-constructor.js"(exports, module2) {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var call = require_function_call();
    var DESCRIPTORS = require_descriptors();
    var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require_typed_array_constructors_require_wrappers();
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var ArrayBufferModule = require_array_buffer();
    var anInstance = require_an_instance();
    var createPropertyDescriptor = require_create_property_descriptor();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var isIntegralNumber = require_is_integral_number();
    var toLength = require_to_length();
    var toIndex = require_to_index();
    var toOffset = require_to_offset();
    var toPropertyKey2 = require_to_property_key();
    var hasOwn = require_has_own_property();
    var classof = require_classof();
    var isObject = require_is_object();
    var isSymbol = require_is_symbol();
    var create3 = require_object_create();
    var isPrototypeOf = require_object_is_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var getOwnPropertyNames3 = require_object_get_own_property_names().f;
    var typedArrayFrom = require_typed_array_from();
    var forEach = require_array_iteration().forEach;
    var setSpecies = require_set_species();
    var definePropertyModule = require_object_define_property();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var InternalStateModule = require_internal_state();
    var inheritIfRequired = require_inherit_if_required();
    var getInternalState = InternalStateModule.get;
    var setInternalState = InternalStateModule.set;
    var nativeDefineProperty = definePropertyModule.f;
    var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var round = Math.round;
    var RangeError2 = global2.RangeError;
    var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
    var ArrayBufferPrototype = ArrayBuffer2.prototype;
    var DataView2 = ArrayBufferModule.DataView;
    var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
    var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
    var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
    var TypedArray = ArrayBufferViewCore.TypedArray;
    var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
    var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
    var isTypedArray = ArrayBufferViewCore.isTypedArray;
    var BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
    var WRONG_LENGTH = "Wrong length";
    var fromList = function(C, list) {
      aTypedArrayConstructor(C);
      var index2 = 0;
      var length = list.length;
      var result = new C(length);
      while (length > index2)
        result[index2] = list[index2++];
      return result;
    };
    var addGetter = function(it, key) {
      nativeDefineProperty(it, key, { get: function() {
        return getInternalState(this)[key];
      } });
    };
    var isArrayBuffer = function(it) {
      var klass;
      return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) == "ArrayBuffer" || klass == "SharedArrayBuffer";
    };
    var isTypedArrayIndex = function(target, key) {
      return isTypedArray(target) && !isSymbol(key) && key in target && isIntegralNumber(+key) && key >= 0;
    };
    var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor3(target, key) {
      key = toPropertyKey2(key);
      return isTypedArrayIndex(target, key) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
    };
    var wrappedDefineProperty = function defineProperty3(target, key, descriptor) {
      key = toPropertyKey2(key);
      if (isTypedArrayIndex(target, key) && isObject(descriptor) && hasOwn(descriptor, "value") && !hasOwn(descriptor, "get") && !hasOwn(descriptor, "set") && !descriptor.configurable && (!hasOwn(descriptor, "writable") || descriptor.writable) && (!hasOwn(descriptor, "enumerable") || descriptor.enumerable)) {
        target[key] = descriptor.value;
        return target;
      }
      return nativeDefineProperty(target, key, descriptor);
    };
    if (DESCRIPTORS) {
      if (!NATIVE_ARRAY_BUFFER_VIEWS) {
        getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
        definePropertyModule.f = wrappedDefineProperty;
        addGetter(TypedArrayPrototype, "buffer");
        addGetter(TypedArrayPrototype, "byteOffset");
        addGetter(TypedArrayPrototype, "byteLength");
        addGetter(TypedArrayPrototype, "length");
      }
      $({ target: "Object", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
        getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
        defineProperty: wrappedDefineProperty
      });
      module2.exports = function(TYPE2, wrapper, CLAMPED) {
        var BYTES = TYPE2.match(/\d+$/)[0] / 8;
        var CONSTRUCTOR_NAME = TYPE2 + (CLAMPED ? "Clamped" : "") + "Array";
        var GETTER = "get" + TYPE2;
        var SETTER = "set" + TYPE2;
        var NativeTypedArrayConstructor = global2[CONSTRUCTOR_NAME];
        var TypedArrayConstructor = NativeTypedArrayConstructor;
        var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
        var exported = {};
        var getter = function(that, index2) {
          var data = getInternalState(that);
          return data.view[GETTER](index2 * BYTES + data.byteOffset, true);
        };
        var setter = function(that, index2, value) {
          var data = getInternalState(that);
          if (CLAMPED)
            value = (value = round(value)) < 0 ? 0 : value > 255 ? 255 : value & 255;
          data.view[SETTER](index2 * BYTES + data.byteOffset, value, true);
        };
        var addElement = function(that, index2) {
          nativeDefineProperty(that, index2, {
            get: function() {
              return getter(this, index2);
            },
            set: function(value) {
              return setter(this, index2, value);
            },
            enumerable: true
          });
        };
        if (!NATIVE_ARRAY_BUFFER_VIEWS) {
          TypedArrayConstructor = wrapper(function(that, data, offset, $length) {
            anInstance(that, TypedArrayConstructorPrototype);
            var index2 = 0;
            var byteOffset = 0;
            var buffer, byteLength, length;
            if (!isObject(data)) {
              length = toIndex(data);
              byteLength = length * BYTES;
              buffer = new ArrayBuffer2(byteLength);
            } else if (isArrayBuffer(data)) {
              buffer = data;
              byteOffset = toOffset(offset, BYTES);
              var $len = data.byteLength;
              if ($length === void 0) {
                if ($len % BYTES)
                  throw RangeError2(WRONG_LENGTH);
                byteLength = $len - byteOffset;
                if (byteLength < 0)
                  throw RangeError2(WRONG_LENGTH);
              } else {
                byteLength = toLength($length) * BYTES;
                if (byteLength + byteOffset > $len)
                  throw RangeError2(WRONG_LENGTH);
              }
              length = byteLength / BYTES;
            } else if (isTypedArray(data)) {
              return fromList(TypedArrayConstructor, data);
            } else {
              return call(typedArrayFrom, TypedArrayConstructor, data);
            }
            setInternalState(that, {
              buffer,
              byteOffset,
              byteLength,
              length,
              view: new DataView2(buffer)
            });
            while (index2 < length)
              addElement(that, index2++);
          });
          if (setPrototypeOf)
            setPrototypeOf(TypedArrayConstructor, TypedArray);
          TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create3(TypedArrayPrototype);
        } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
          TypedArrayConstructor = wrapper(function(dummy, data, typedArrayOffset, $length) {
            anInstance(dummy, TypedArrayConstructorPrototype);
            return inheritIfRequired(function() {
              if (!isObject(data))
                return new NativeTypedArrayConstructor(toIndex(data));
              if (isArrayBuffer(data))
                return $length !== void 0 ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== void 0 ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
              if (isTypedArray(data))
                return fromList(TypedArrayConstructor, data);
              return call(typedArrayFrom, TypedArrayConstructor, data);
            }(), dummy, TypedArrayConstructor);
          });
          if (setPrototypeOf)
            setPrototypeOf(TypedArrayConstructor, TypedArray);
          forEach(getOwnPropertyNames3(NativeTypedArrayConstructor), function(key) {
            if (!(key in TypedArrayConstructor)) {
              createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
            }
          });
          TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
        }
        if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
          createNonEnumerableProperty(TypedArrayConstructorPrototype, "constructor", TypedArrayConstructor);
        }
        createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_CONSTRUCTOR, TypedArrayConstructor);
        if (TYPED_ARRAY_TAG) {
          createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
        }
        exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
        $({
          global: true,
          forced: TypedArrayConstructor != NativeTypedArrayConstructor,
          sham: !NATIVE_ARRAY_BUFFER_VIEWS
        }, exported);
        if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
          createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
        }
        if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
          createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
        }
        setSpecies(CONSTRUCTOR_NAME);
      };
    } else
      module2.exports = function() {
      };
  }
});

// node_modules/core-js/modules/es.typed-array.float32-array.js
var require_es_typed_array_float32_array = __commonJS({
  "node_modules/core-js/modules/es.typed-array.float32-array.js"() {
    "use strict";
    var createTypedArrayConstructor = require_typed_array_constructor();
    createTypedArrayConstructor("Float32", function(init) {
      return function Float32Array2(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    });
  }
});

// node_modules/core-js/modules/es.typed-array.float64-array.js
var require_es_typed_array_float64_array = __commonJS({
  "node_modules/core-js/modules/es.typed-array.float64-array.js"() {
    "use strict";
    var createTypedArrayConstructor = require_typed_array_constructor();
    createTypedArrayConstructor("Float64", function(init) {
      return function Float64Array2(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    });
  }
});

// node_modules/core-js/modules/es.typed-array.int8-array.js
var require_es_typed_array_int8_array = __commonJS({
  "node_modules/core-js/modules/es.typed-array.int8-array.js"() {
    "use strict";
    var createTypedArrayConstructor = require_typed_array_constructor();
    createTypedArrayConstructor("Int8", function(init) {
      return function Int8Array2(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    });
  }
});

// node_modules/core-js/modules/es.typed-array.int16-array.js
var require_es_typed_array_int16_array = __commonJS({
  "node_modules/core-js/modules/es.typed-array.int16-array.js"() {
    "use strict";
    var createTypedArrayConstructor = require_typed_array_constructor();
    createTypedArrayConstructor("Int16", function(init) {
      return function Int16Array2(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    });
  }
});

// node_modules/core-js/modules/es.typed-array.int32-array.js
var require_es_typed_array_int32_array = __commonJS({
  "node_modules/core-js/modules/es.typed-array.int32-array.js"() {
    "use strict";
    var createTypedArrayConstructor = require_typed_array_constructor();
    createTypedArrayConstructor("Int32", function(init) {
      return function Int32Array2(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    });
  }
});

// node_modules/core-js/modules/es.typed-array.uint8-array.js
var require_es_typed_array_uint8_array = __commonJS({
  "node_modules/core-js/modules/es.typed-array.uint8-array.js"() {
    "use strict";
    var createTypedArrayConstructor = require_typed_array_constructor();
    createTypedArrayConstructor("Uint8", function(init) {
      return function Uint8Array2(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    });
  }
});

// node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js
var require_es_typed_array_uint8_clamped_array = __commonJS({
  "node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js"() {
    "use strict";
    var createTypedArrayConstructor = require_typed_array_constructor();
    createTypedArrayConstructor("Uint8", function(init) {
      return function Uint8ClampedArray2(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    }, true);
  }
});

// node_modules/core-js/modules/es.typed-array.uint16-array.js
var require_es_typed_array_uint16_array = __commonJS({
  "node_modules/core-js/modules/es.typed-array.uint16-array.js"() {
    "use strict";
    var createTypedArrayConstructor = require_typed_array_constructor();
    createTypedArrayConstructor("Uint16", function(init) {
      return function Uint16Array2(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    });
  }
});

// node_modules/core-js/modules/es.typed-array.uint32-array.js
var require_es_typed_array_uint32_array = __commonJS({
  "node_modules/core-js/modules/es.typed-array.uint32-array.js"() {
    "use strict";
    var createTypedArrayConstructor = require_typed_array_constructor();
    createTypedArrayConstructor("Uint32", function(init) {
      return function Uint32Array2(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    });
  }
});

// node_modules/core-js/modules/es.typed-array.at.js
var require_es_typed_array_at = __commonJS({
  "node_modules/core-js/modules/es.typed-array.at.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var lengthOfArrayLike = require_length_of_array_like();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("at", function at(index2) {
      var O = aTypedArray(this);
      var len = lengthOfArrayLike(O);
      var relativeIndex = toIntegerOrInfinity(index2);
      var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
      return k < 0 || k >= len ? void 0 : O[k];
    });
  }
});

// node_modules/core-js/modules/es.typed-array.copy-within.js
var require_es_typed_array_copy_within = __commonJS({
  "node_modules/core-js/modules/es.typed-array.copy-within.js"() {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $ArrayCopyWithin = require_array_copy_within();
    var u$ArrayCopyWithin = uncurryThis($ArrayCopyWithin);
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("copyWithin", function copyWithin(target, start) {
      return u$ArrayCopyWithin(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.every.js
var require_es_typed_array_every = __commonJS({
  "node_modules/core-js/modules/es.typed-array.every.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $every = require_array_iteration().every;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("every", function every(callbackfn) {
      return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.fill.js
var require_es_typed_array_fill = __commonJS({
  "node_modules/core-js/modules/es.typed-array.fill.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var call = require_function_call();
    var $fill = require_array_fill();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("fill", function fill(value) {
      var length = arguments.length;
      return call(
        $fill,
        aTypedArray(this),
        value,
        length > 1 ? arguments[1] : void 0,
        length > 2 ? arguments[2] : void 0
      );
    });
  }
});

// node_modules/core-js/internals/array-from-constructor-and-list.js
var require_array_from_constructor_and_list = __commonJS({
  "node_modules/core-js/internals/array-from-constructor-and-list.js"(exports, module2) {
    "use strict";
    var lengthOfArrayLike = require_length_of_array_like();
    module2.exports = function(Constructor, list) {
      var index2 = 0;
      var length = lengthOfArrayLike(list);
      var result = new Constructor(length);
      while (length > index2)
        result[index2] = list[index2++];
      return result;
    };
  }
});

// node_modules/core-js/internals/typed-array-species-constructor.js
var require_typed_array_species_constructor = __commonJS({
  "node_modules/core-js/internals/typed-array-species-constructor.js"(exports, module2) {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var speciesConstructor = require_species_constructor();
    var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
    var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
    module2.exports = function(originalArray) {
      return aTypedArrayConstructor(speciesConstructor(originalArray, originalArray[TYPED_ARRAY_CONSTRUCTOR]));
    };
  }
});

// node_modules/core-js/internals/typed-array-from-species-and-list.js
var require_typed_array_from_species_and_list = __commonJS({
  "node_modules/core-js/internals/typed-array-from-species-and-list.js"(exports, module2) {
    "use strict";
    var arrayFromConstructorAndList = require_array_from_constructor_and_list();
    var typedArraySpeciesConstructor = require_typed_array_species_constructor();
    module2.exports = function(instance, list) {
      return arrayFromConstructorAndList(typedArraySpeciesConstructor(instance), list);
    };
  }
});

// node_modules/core-js/modules/es.typed-array.filter.js
var require_es_typed_array_filter = __commonJS({
  "node_modules/core-js/modules/es.typed-array.filter.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $filter = require_array_iteration().filter;
    var fromSpeciesAndList = require_typed_array_from_species_and_list();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("filter", function filter3(callbackfn) {
      var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      return fromSpeciesAndList(this, list);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.find.js
var require_es_typed_array_find = __commonJS({
  "node_modules/core-js/modules/es.typed-array.find.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $find = require_array_iteration().find;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("find", function find4(predicate) {
      return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.find-index.js
var require_es_typed_array_find_index = __commonJS({
  "node_modules/core-js/modules/es.typed-array.find-index.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $findIndex = require_array_iteration().findIndex;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("findIndex", function findIndex(predicate) {
      return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.for-each.js
var require_es_typed_array_for_each = __commonJS({
  "node_modules/core-js/modules/es.typed-array.for-each.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $forEach = require_array_iteration().forEach;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("forEach", function forEach(callbackfn) {
      $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.from.js
var require_es_typed_array_from = __commonJS({
  "node_modules/core-js/modules/es.typed-array.from.js"() {
    "use strict";
    var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require_typed_array_constructors_require_wrappers();
    var exportTypedArrayStaticMethod = require_array_buffer_view_core().exportTypedArrayStaticMethod;
    var typedArrayFrom = require_typed_array_from();
    exportTypedArrayStaticMethod("from", typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);
  }
});

// node_modules/core-js/modules/es.typed-array.includes.js
var require_es_typed_array_includes = __commonJS({
  "node_modules/core-js/modules/es.typed-array.includes.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $includes = require_array_includes().includes;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("includes", function includes(searchElement) {
      return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.index-of.js
var require_es_typed_array_index_of = __commonJS({
  "node_modules/core-js/modules/es.typed-array.index-of.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $indexOf = require_array_includes().indexOf;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("indexOf", function indexOf(searchElement) {
      return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.iterator.js
var require_es_typed_array_iterator = __commonJS({
  "node_modules/core-js/modules/es.typed-array.iterator.js"() {
    "use strict";
    var global2 = require_global();
    var fails = require_fails();
    var uncurryThis = require_function_uncurry_this();
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var ArrayIterators = require_es_array_iterator();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var Uint8Array2 = global2.Uint8Array;
    var arrayValues = uncurryThis(ArrayIterators.values);
    var arrayKeys = uncurryThis(ArrayIterators.keys);
    var arrayEntries = uncurryThis(ArrayIterators.entries);
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var TypedArrayPrototype = Uint8Array2 && Uint8Array2.prototype;
    var GENERIC = !fails(function() {
      TypedArrayPrototype[ITERATOR].call([1]);
    });
    var ITERATOR_IS_VALUES = !!TypedArrayPrototype && TypedArrayPrototype.values && TypedArrayPrototype[ITERATOR] === TypedArrayPrototype.values && TypedArrayPrototype.values.name === "values";
    var typedArrayValues = function values() {
      return arrayValues(aTypedArray(this));
    };
    exportTypedArrayMethod("entries", function entries() {
      return arrayEntries(aTypedArray(this));
    }, GENERIC);
    exportTypedArrayMethod("keys", function keys() {
      return arrayKeys(aTypedArray(this));
    }, GENERIC);
    exportTypedArrayMethod("values", typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
    exportTypedArrayMethod(ITERATOR, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
  }
});

// node_modules/core-js/modules/es.typed-array.join.js
var require_es_typed_array_join = __commonJS({
  "node_modules/core-js/modules/es.typed-array.join.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var uncurryThis = require_function_uncurry_this();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var $join = uncurryThis([].join);
    exportTypedArrayMethod("join", function join(separator) {
      return $join(aTypedArray(this), separator);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.last-index-of.js
var require_es_typed_array_last_index_of = __commonJS({
  "node_modules/core-js/modules/es.typed-array.last-index-of.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var apply = require_function_apply();
    var $lastIndexOf = require_array_last_index_of();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("lastIndexOf", function lastIndexOf(searchElement) {
      var length = arguments.length;
      return apply($lastIndexOf, aTypedArray(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.map.js
var require_es_typed_array_map = __commonJS({
  "node_modules/core-js/modules/es.typed-array.map.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $map = require_array_iteration().map;
    var typedArraySpeciesConstructor = require_typed_array_species_constructor();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("map", function map(mapfn) {
      return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : void 0, function(O, length) {
        return new (typedArraySpeciesConstructor(O))(length);
      });
    });
  }
});

// node_modules/core-js/modules/es.typed-array.of.js
var require_es_typed_array_of = __commonJS({
  "node_modules/core-js/modules/es.typed-array.of.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require_typed_array_constructors_require_wrappers();
    var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
    var exportTypedArrayStaticMethod = ArrayBufferViewCore.exportTypedArrayStaticMethod;
    exportTypedArrayStaticMethod("of", function of() {
      var index2 = 0;
      var length = arguments.length;
      var result = new (aTypedArrayConstructor(this))(length);
      while (length > index2)
        result[index2] = arguments[index2++];
      return result;
    }, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);
  }
});

// node_modules/core-js/modules/es.typed-array.reduce.js
var require_es_typed_array_reduce = __commonJS({
  "node_modules/core-js/modules/es.typed-array.reduce.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $reduce = require_array_reduce().left;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("reduce", function reduce(callbackfn) {
      var length = arguments.length;
      return $reduce(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.reduce-right.js
var require_es_typed_array_reduce_right = __commonJS({
  "node_modules/core-js/modules/es.typed-array.reduce-right.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $reduceRight = require_array_reduce().right;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("reduceRight", function reduceRight(callbackfn) {
      var length = arguments.length;
      return $reduceRight(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.reverse.js
var require_es_typed_array_reverse = __commonJS({
  "node_modules/core-js/modules/es.typed-array.reverse.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var floor = Math.floor;
    exportTypedArrayMethod("reverse", function reverse() {
      var that = this;
      var length = aTypedArray(that).length;
      var middle = floor(length / 2);
      var index2 = 0;
      var value;
      while (index2 < middle) {
        value = that[index2];
        that[index2++] = that[--length];
        that[length] = value;
      }
      return that;
    });
  }
});

// node_modules/core-js/modules/es.typed-array.set.js
var require_es_typed_array_set = __commonJS({
  "node_modules/core-js/modules/es.typed-array.set.js"() {
    "use strict";
    var global2 = require_global();
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var lengthOfArrayLike = require_length_of_array_like();
    var toOffset = require_to_offset();
    var toObject = require_to_object();
    var fails = require_fails();
    var RangeError2 = global2.RangeError;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var FORCED = fails(function() {
      new Int8Array(1).set({});
    });
    exportTypedArrayMethod("set", function set(arrayLike) {
      aTypedArray(this);
      var offset = toOffset(arguments.length > 1 ? arguments[1] : void 0, 1);
      var length = this.length;
      var src = toObject(arrayLike);
      var len = lengthOfArrayLike(src);
      var index2 = 0;
      if (len + offset > length)
        throw RangeError2("Wrong length");
      while (index2 < len)
        this[offset + index2] = src[index2++];
    }, FORCED);
  }
});

// node_modules/core-js/modules/es.typed-array.slice.js
var require_es_typed_array_slice = __commonJS({
  "node_modules/core-js/modules/es.typed-array.slice.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var typedArraySpeciesConstructor = require_typed_array_species_constructor();
    var fails = require_fails();
    var arraySlice = require_array_slice();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var FORCED = fails(function() {
      new Int8Array(1).slice();
    });
    exportTypedArrayMethod("slice", function slice(start, end) {
      var list = arraySlice(aTypedArray(this), start, end);
      var C = typedArraySpeciesConstructor(this);
      var index2 = 0;
      var length = list.length;
      var result = new C(length);
      while (length > index2)
        result[index2] = list[index2++];
      return result;
    }, FORCED);
  }
});

// node_modules/core-js/modules/es.typed-array.some.js
var require_es_typed_array_some = __commonJS({
  "node_modules/core-js/modules/es.typed-array.some.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var $some = require_array_iteration().some;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("some", function some(callbackfn) {
      return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    });
  }
});

// node_modules/core-js/modules/es.typed-array.sort.js
var require_es_typed_array_sort = __commonJS({
  "node_modules/core-js/modules/es.typed-array.sort.js"() {
    "use strict";
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var aCallable = require_a_callable();
    var internalSort = require_array_sort();
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var FF = require_engine_ff_version();
    var IE_OR_EDGE = require_engine_is_ie_or_edge();
    var V8 = require_engine_v8_version();
    var WEBKIT = require_engine_webkit_version();
    var Array2 = global2.Array;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var Uint16Array2 = global2.Uint16Array;
    var un$Sort = Uint16Array2 && uncurryThis(Uint16Array2.prototype.sort);
    var ACCEPT_INCORRECT_ARGUMENTS = !!un$Sort && !(fails(function() {
      un$Sort(new Uint16Array2(2), null);
    }) && fails(function() {
      un$Sort(new Uint16Array2(2), {});
    }));
    var STABLE_SORT = !!un$Sort && !fails(function() {
      if (V8)
        return V8 < 74;
      if (FF)
        return FF < 67;
      if (IE_OR_EDGE)
        return true;
      if (WEBKIT)
        return WEBKIT < 602;
      var array = new Uint16Array2(516);
      var expected = Array2(516);
      var index2, mod;
      for (index2 = 0; index2 < 516; index2++) {
        mod = index2 % 4;
        array[index2] = 515 - index2;
        expected[index2] = index2 - 2 * mod + 3;
      }
      un$Sort(array, function(a, b) {
        return (a / 4 | 0) - (b / 4 | 0);
      });
      for (index2 = 0; index2 < 516; index2++) {
        if (array[index2] !== expected[index2])
          return true;
      }
    });
    var getSortCompare = function(comparefn) {
      return function(x, y) {
        if (comparefn !== void 0)
          return +comparefn(x, y) || 0;
        if (y !== y)
          return -1;
        if (x !== x)
          return 1;
        if (x === 0 && y === 0)
          return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
        return x > y;
      };
    };
    exportTypedArrayMethod("sort", function sort(comparefn) {
      if (comparefn !== void 0)
        aCallable(comparefn);
      if (STABLE_SORT)
        return un$Sort(this, comparefn);
      return internalSort(aTypedArray(this), getSortCompare(comparefn));
    }, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);
  }
});

// node_modules/core-js/modules/es.typed-array.subarray.js
var require_es_typed_array_subarray = __commonJS({
  "node_modules/core-js/modules/es.typed-array.subarray.js"() {
    "use strict";
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var toLength = require_to_length();
    var toAbsoluteIndex = require_to_absolute_index();
    var typedArraySpeciesConstructor = require_typed_array_species_constructor();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod("subarray", function subarray(begin, end) {
      var O = aTypedArray(this);
      var length = O.length;
      var beginIndex = toAbsoluteIndex(begin, length);
      var C = typedArraySpeciesConstructor(O);
      return new C(
        O.buffer,
        O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
        toLength((end === void 0 ? length : toAbsoluteIndex(end, length)) - beginIndex)
      );
    });
  }
});

// node_modules/core-js/modules/es.typed-array.to-locale-string.js
var require_es_typed_array_to_locale_string = __commonJS({
  "node_modules/core-js/modules/es.typed-array.to-locale-string.js"() {
    "use strict";
    var global2 = require_global();
    var apply = require_function_apply();
    var ArrayBufferViewCore = require_array_buffer_view_core();
    var fails = require_fails();
    var arraySlice = require_array_slice();
    var Int8Array2 = global2.Int8Array;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var $toLocaleString = [].toLocaleString;
    var TO_LOCALE_STRING_BUG = !!Int8Array2 && fails(function() {
      $toLocaleString.call(new Int8Array2(1));
    });
    var FORCED = fails(function() {
      return [1, 2].toLocaleString() != new Int8Array2([1, 2]).toLocaleString();
    }) || !fails(function() {
      Int8Array2.prototype.toLocaleString.call([1, 2]);
    });
    exportTypedArrayMethod("toLocaleString", function toLocaleString() {
      return apply(
        $toLocaleString,
        TO_LOCALE_STRING_BUG ? arraySlice(aTypedArray(this)) : aTypedArray(this),
        arraySlice(arguments)
      );
    }, FORCED);
  }
});

// node_modules/core-js/modules/es.typed-array.to-string.js
var require_es_typed_array_to_string = __commonJS({
  "node_modules/core-js/modules/es.typed-array.to-string.js"() {
    "use strict";
    var exportTypedArrayMethod = require_array_buffer_view_core().exportTypedArrayMethod;
    var fails = require_fails();
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var Uint8Array2 = global2.Uint8Array;
    var Uint8ArrayPrototype = Uint8Array2 && Uint8Array2.prototype || {};
    var arrayToString = [].toString;
    var join = uncurryThis([].join);
    if (fails(function() {
      arrayToString.call({});
    })) {
      arrayToString = function toString() {
        return join(this);
      };
    }
    var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;
    exportTypedArrayMethod("toString", arrayToString, IS_NOT_ARRAY_METHOD);
  }
});

// node_modules/core-js/modules/es.unescape.js
var require_es_unescape = __commonJS({
  "node_modules/core-js/modules/es.unescape.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var toString = require_to_string();
    var fromCharCode = String.fromCharCode;
    var charAt = uncurryThis("".charAt);
    var exec = uncurryThis(/./.exec);
    var stringSlice = uncurryThis("".slice);
    var hex2 = /^[\da-f]{2}$/i;
    var hex4 = /^[\da-f]{4}$/i;
    $({ global: true }, {
      unescape: function unescape2(string) {
        var str = toString(string);
        var result = "";
        var length = str.length;
        var index2 = 0;
        var chr, part;
        while (index2 < length) {
          chr = charAt(str, index2++);
          if (chr === "%") {
            if (charAt(str, index2) === "u") {
              part = stringSlice(str, index2 + 1, index2 + 5);
              if (exec(hex4, part)) {
                result += fromCharCode(parseInt(part, 16));
                index2 += 5;
                continue;
              }
            } else {
              part = stringSlice(str, index2, index2 + 2);
              if (exec(hex2, part)) {
                result += fromCharCode(parseInt(part, 16));
                index2 += 2;
                continue;
              }
            }
          }
          result += chr;
        }
        return result;
      }
    });
  }
});

// node_modules/core-js/internals/collection-weak.js
var require_collection_weak = __commonJS({
  "node_modules/core-js/internals/collection-weak.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var redefineAll = require_redefine_all();
    var getWeakData = require_internal_metadata().getWeakData;
    var anObject = require_an_object();
    var isObject = require_is_object();
    var anInstance = require_an_instance();
    var iterate = require_iterate();
    var ArrayIterationModule = require_array_iteration();
    var hasOwn = require_has_own_property();
    var InternalStateModule = require_internal_state();
    var setInternalState = InternalStateModule.set;
    var internalStateGetterFor = InternalStateModule.getterFor;
    var find4 = ArrayIterationModule.find;
    var findIndex = ArrayIterationModule.findIndex;
    var splice = uncurryThis([].splice);
    var id = 0;
    var uncaughtFrozenStore = function(store2) {
      return store2.frozen || (store2.frozen = new UncaughtFrozenStore());
    };
    var UncaughtFrozenStore = function() {
      this.entries = [];
    };
    var findUncaughtFrozen = function(store2, key) {
      return find4(store2.entries, function(it) {
        return it[0] === key;
      });
    };
    UncaughtFrozenStore.prototype = {
      get: function(key) {
        var entry = findUncaughtFrozen(this, key);
        if (entry)
          return entry[1];
      },
      has: function(key) {
        return !!findUncaughtFrozen(this, key);
      },
      set: function(key, value) {
        var entry = findUncaughtFrozen(this, key);
        if (entry)
          entry[1] = value;
        else
          this.entries.push([key, value]);
      },
      "delete": function(key) {
        var index2 = findIndex(this.entries, function(it) {
          return it[0] === key;
        });
        if (~index2)
          splice(this.entries, index2, 1);
        return !!~index2;
      }
    };
    module2.exports = {
      getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var Constructor = wrapper(function(that, iterable) {
          anInstance(that, Prototype);
          setInternalState(that, {
            type: CONSTRUCTOR_NAME,
            id: id++,
            frozen: void 0
          });
          if (iterable != void 0)
            iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
        });
        var Prototype = Constructor.prototype;
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var define2 = function(that, key, value) {
          var state = getInternalState(that);
          var data = getWeakData(anObject(key), true);
          if (data === true)
            uncaughtFrozenStore(state).set(key, value);
          else
            data[state.id] = value;
          return that;
        };
        redefineAll(Prototype, {
          // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
          // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
          // https://tc39.es/ecma262/#sec-weakset.prototype.delete
          "delete": function(key) {
            var state = getInternalState(this);
            if (!isObject(key))
              return false;
            var data = getWeakData(key);
            if (data === true)
              return uncaughtFrozenStore(state)["delete"](key);
            return data && hasOwn(data, state.id) && delete data[state.id];
          },
          // `{ WeakMap, WeakSet }.prototype.has(key)` methods
          // https://tc39.es/ecma262/#sec-weakmap.prototype.has
          // https://tc39.es/ecma262/#sec-weakset.prototype.has
          has: function has(key) {
            var state = getInternalState(this);
            if (!isObject(key))
              return false;
            var data = getWeakData(key);
            if (data === true)
              return uncaughtFrozenStore(state).has(key);
            return data && hasOwn(data, state.id);
          }
        });
        redefineAll(Prototype, IS_MAP ? {
          // `WeakMap.prototype.get(key)` method
          // https://tc39.es/ecma262/#sec-weakmap.prototype.get
          get: function get(key) {
            var state = getInternalState(this);
            if (isObject(key)) {
              var data = getWeakData(key);
              if (data === true)
                return uncaughtFrozenStore(state).get(key);
              return data ? data[state.id] : void 0;
            }
          },
          // `WeakMap.prototype.set(key, value)` method
          // https://tc39.es/ecma262/#sec-weakmap.prototype.set
          set: function set(key, value) {
            return define2(this, key, value);
          }
        } : {
          // `WeakSet.prototype.add(value)` method
          // https://tc39.es/ecma262/#sec-weakset.prototype.add
          add: function add(value) {
            return define2(this, value, true);
          }
        });
        return Constructor;
      }
    };
  }
});

// node_modules/core-js/modules/es.weak-map.js
var require_es_weak_map = __commonJS({
  "node_modules/core-js/modules/es.weak-map.js"() {
    "use strict";
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var redefineAll = require_redefine_all();
    var InternalMetadataModule = require_internal_metadata();
    var collection = require_collection();
    var collectionWeak = require_collection_weak();
    var isObject = require_is_object();
    var isExtensible = require_object_is_extensible();
    var enforceIternalState = require_internal_state().enforce;
    var NATIVE_WEAK_MAP = require_native_weak_map();
    var IS_IE11 = !global2.ActiveXObject && "ActiveXObject" in global2;
    var InternalWeakMap;
    var wrapper = function(init) {
      return function WeakMap2() {
        return init(this, arguments.length ? arguments[0] : void 0);
      };
    };
    var $WeakMap = collection("WeakMap", wrapper, collectionWeak);
    if (NATIVE_WEAK_MAP && IS_IE11) {
      InternalWeakMap = collectionWeak.getConstructor(wrapper, "WeakMap", true);
      InternalMetadataModule.enable();
      WeakMapPrototype = $WeakMap.prototype;
      nativeDelete = uncurryThis(WeakMapPrototype["delete"]);
      nativeHas = uncurryThis(WeakMapPrototype.has);
      nativeGet = uncurryThis(WeakMapPrototype.get);
      nativeSet = uncurryThis(WeakMapPrototype.set);
      redefineAll(WeakMapPrototype, {
        "delete": function(key) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceIternalState(this);
            if (!state.frozen)
              state.frozen = new InternalWeakMap();
            return nativeDelete(this, key) || state.frozen["delete"](key);
          }
          return nativeDelete(this, key);
        },
        has: function has(key) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceIternalState(this);
            if (!state.frozen)
              state.frozen = new InternalWeakMap();
            return nativeHas(this, key) || state.frozen.has(key);
          }
          return nativeHas(this, key);
        },
        get: function get(key) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceIternalState(this);
            if (!state.frozen)
              state.frozen = new InternalWeakMap();
            return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
          }
          return nativeGet(this, key);
        },
        set: function set(key, value) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceIternalState(this);
            if (!state.frozen)
              state.frozen = new InternalWeakMap();
            nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
          } else
            nativeSet(this, key, value);
          return this;
        }
      });
    }
    var WeakMapPrototype;
    var nativeDelete;
    var nativeHas;
    var nativeGet;
    var nativeSet;
  }
});

// node_modules/core-js/modules/es.weak-set.js
var require_es_weak_set = __commonJS({
  "node_modules/core-js/modules/es.weak-set.js"() {
    "use strict";
    var collection = require_collection();
    var collectionWeak = require_collection_weak();
    collection("WeakSet", function(init) {
      return function WeakSet2() {
        return init(this, arguments.length ? arguments[0] : void 0);
      };
    }, collectionWeak);
  }
});

// node_modules/core-js/internals/dom-iterables.js
var require_dom_iterables = __commonJS({
  "node_modules/core-js/internals/dom-iterables.js"(exports, module2) {
    "use strict";
    module2.exports = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
  }
});

// node_modules/core-js/internals/dom-token-list-prototype.js
var require_dom_token_list_prototype = __commonJS({
  "node_modules/core-js/internals/dom-token-list-prototype.js"(exports, module2) {
    "use strict";
    var documentCreateElement = require_document_create_element();
    var classList = documentCreateElement("span").classList;
    var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
    module2.exports = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
  }
});

// node_modules/core-js/modules/web.dom-collections.for-each.js
var require_web_dom_collections_for_each = __commonJS({
  "node_modules/core-js/modules/web.dom-collections.for-each.js"() {
    "use strict";
    var global2 = require_global();
    var DOMIterables = require_dom_iterables();
    var DOMTokenListPrototype = require_dom_token_list_prototype();
    var forEach = require_array_for_each();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var handlePrototype = function(CollectionPrototype) {
      if (CollectionPrototype && CollectionPrototype.forEach !== forEach)
        try {
          createNonEnumerableProperty(CollectionPrototype, "forEach", forEach);
        } catch (error) {
          CollectionPrototype.forEach = forEach;
        }
    };
    for (COLLECTION_NAME in DOMIterables) {
      if (DOMIterables[COLLECTION_NAME]) {
        handlePrototype(global2[COLLECTION_NAME] && global2[COLLECTION_NAME].prototype);
      }
    }
    var COLLECTION_NAME;
    handlePrototype(DOMTokenListPrototype);
  }
});

// node_modules/core-js/modules/web.dom-collections.iterator.js
var require_web_dom_collections_iterator = __commonJS({
  "node_modules/core-js/modules/web.dom-collections.iterator.js"() {
    "use strict";
    var global2 = require_global();
    var DOMIterables = require_dom_iterables();
    var DOMTokenListPrototype = require_dom_token_list_prototype();
    var ArrayIteratorMethods = require_es_array_iterator();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var ArrayValues = ArrayIteratorMethods.values;
    var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
      if (CollectionPrototype) {
        if (CollectionPrototype[ITERATOR] !== ArrayValues)
          try {
            createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
          } catch (error) {
            CollectionPrototype[ITERATOR] = ArrayValues;
          }
        if (!CollectionPrototype[TO_STRING_TAG]) {
          createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME2);
        }
        if (DOMIterables[COLLECTION_NAME2])
          for (var METHOD_NAME in ArrayIteratorMethods) {
            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
              try {
                createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
              } catch (error) {
                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
              }
          }
      }
    };
    for (COLLECTION_NAME in DOMIterables) {
      handlePrototype(global2[COLLECTION_NAME] && global2[COLLECTION_NAME].prototype, COLLECTION_NAME);
    }
    var COLLECTION_NAME;
    handlePrototype(DOMTokenListPrototype, "DOMTokenList");
  }
});

// node_modules/core-js/internals/try-node-require.js
var require_try_node_require = __commonJS({
  "node_modules/core-js/internals/try-node-require.js"(exports, module2) {
    "use strict";
    var IS_NODE = require_engine_is_node();
    module2.exports = function(name) {
      try {
        if (IS_NODE)
          return Function('return require("' + name + '")')();
      } catch (error) {
      }
    };
  }
});

// node_modules/core-js/internals/dom-exception-constants.js
var require_dom_exception_constants = __commonJS({
  "node_modules/core-js/internals/dom-exception-constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 },
      DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 },
      HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 },
      WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 },
      InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 },
      NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 },
      NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 },
      NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 },
      NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 },
      InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 },
      InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 },
      SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 },
      InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 },
      NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 },
      InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 },
      ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 },
      TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 },
      SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 },
      NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 },
      AbortError: { s: "ABORT_ERR", c: 20, m: 1 },
      URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 },
      QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 },
      TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 },
      InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 },
      DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 }
    };
  }
});

// node_modules/core-js/modules/web.dom-exception.constructor.js
var require_web_dom_exception_constructor = __commonJS({
  "node_modules/core-js/modules/web.dom-exception.constructor.js"() {
    "use strict";
    var $ = require_export();
    var tryNodeRequire = require_try_node_require();
    var getBuiltIn = require_get_built_in();
    var fails = require_fails();
    var create3 = require_object_create();
    var createPropertyDescriptor = require_create_property_descriptor();
    var defineProperty3 = require_object_define_property().f;
    var defineProperties = require_object_define_properties();
    var redefine = require_redefine();
    var hasOwn = require_has_own_property();
    var anInstance = require_an_instance();
    var anObject = require_an_object();
    var errorToString = require_error_to_string();
    var normalizeStringArgument = require_normalize_string_argument();
    var DOMExceptionConstants = require_dom_exception_constants();
    var clearErrorStack = require_clear_error_stack();
    var InternalStateModule = require_internal_state();
    var DESCRIPTORS = require_descriptors();
    var IS_PURE = require_is_pure();
    var DOM_EXCEPTION = "DOMException";
    var DATA_CLONE_ERR = "DATA_CLONE_ERR";
    var Error2 = getBuiltIn("Error");
    var NativeDOMException = getBuiltIn(DOM_EXCEPTION) || function() {
      try {
        var MessageChannel2 = getBuiltIn("MessageChannel") || tryNodeRequire("worker_threads").MessageChannel;
        new MessageChannel2().port1.postMessage(/* @__PURE__ */ new WeakMap());
      } catch (error) {
        if (error.name == DATA_CLONE_ERR && error.code == 25)
          return error.constructor;
      }
    }();
    var NativeDOMExceptionPrototype = NativeDOMException && NativeDOMException.prototype;
    var ErrorPrototype = Error2.prototype;
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(DOM_EXCEPTION);
    var HAS_STACK = "stack" in Error2(DOM_EXCEPTION);
    var codeFor = function(name) {
      return hasOwn(DOMExceptionConstants, name) && DOMExceptionConstants[name].m ? DOMExceptionConstants[name].c : 0;
    };
    var $DOMException = function DOMException() {
      anInstance(this, DOMExceptionPrototype);
      var argumentsLength = arguments.length;
      var message = normalizeStringArgument(argumentsLength < 1 ? void 0 : arguments[0]);
      var name = normalizeStringArgument(argumentsLength < 2 ? void 0 : arguments[1], "Error");
      var code = codeFor(name);
      setInternalState(this, {
        type: DOM_EXCEPTION,
        name,
        message,
        code
      });
      if (!DESCRIPTORS) {
        this.name = name;
        this.message = message;
        this.code = code;
      }
      if (HAS_STACK) {
        var error = Error2(message);
        error.name = DOM_EXCEPTION;
        defineProperty3(this, "stack", createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
      }
    };
    var DOMExceptionPrototype = $DOMException.prototype = create3(ErrorPrototype);
    var createGetterDescriptor = function(get) {
      return { enumerable: true, configurable: true, get };
    };
    var getterFor = function(key2) {
      return createGetterDescriptor(function() {
        return getInternalState(this)[key2];
      });
    };
    if (DESCRIPTORS)
      defineProperties(DOMExceptionPrototype, {
        name: getterFor("name"),
        message: getterFor("message"),
        code: getterFor("code")
      });
    defineProperty3(DOMExceptionPrototype, "constructor", createPropertyDescriptor(1, $DOMException));
    var INCORRECT_CONSTRUCTOR = fails(function() {
      return !(new NativeDOMException() instanceof Error2);
    });
    var INCORRECT_TO_STRING = INCORRECT_CONSTRUCTOR || fails(function() {
      return ErrorPrototype.toString !== errorToString || String(new NativeDOMException(1, 2)) !== "2: 1";
    });
    var INCORRECT_CODE = INCORRECT_CONSTRUCTOR || fails(function() {
      return new NativeDOMException(1, "DataCloneError").code !== 25;
    });
    var MISSED_CONSTANTS = INCORRECT_CONSTRUCTOR || NativeDOMException[DATA_CLONE_ERR] !== 25 || NativeDOMExceptionPrototype[DATA_CLONE_ERR] !== 25;
    var FORCED_CONSTRUCTOR = IS_PURE ? INCORRECT_TO_STRING || INCORRECT_CODE || MISSED_CONSTANTS : INCORRECT_CONSTRUCTOR;
    $({ global: true, forced: FORCED_CONSTRUCTOR }, {
      DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
    });
    var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
    var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
    if (INCORRECT_TO_STRING && (IS_PURE || NativeDOMException === PolyfilledDOMException)) {
      redefine(PolyfilledDOMExceptionPrototype, "toString", errorToString);
    }
    if (INCORRECT_CODE && DESCRIPTORS && NativeDOMException === PolyfilledDOMException) {
      defineProperty3(PolyfilledDOMExceptionPrototype, "code", createGetterDescriptor(function() {
        return codeFor(anObject(this).name);
      }));
    }
    for (key in DOMExceptionConstants)
      if (hasOwn(DOMExceptionConstants, key)) {
        constant = DOMExceptionConstants[key];
        constantName = constant.s;
        descriptor = createPropertyDescriptor(6, constant.c);
        if (!hasOwn(PolyfilledDOMException, constantName)) {
          defineProperty3(PolyfilledDOMException, constantName, descriptor);
        }
        if (!hasOwn(PolyfilledDOMExceptionPrototype, constantName)) {
          defineProperty3(PolyfilledDOMExceptionPrototype, constantName, descriptor);
        }
      }
    var constant;
    var constantName;
    var descriptor;
    var key;
  }
});

// node_modules/core-js/modules/web.dom-exception.stack.js
var require_web_dom_exception_stack = __commonJS({
  "node_modules/core-js/modules/web.dom-exception.stack.js"() {
    "use strict";
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var createPropertyDescriptor = require_create_property_descriptor();
    var defineProperty3 = require_object_define_property().f;
    var hasOwn = require_has_own_property();
    var anInstance = require_an_instance();
    var inheritIfRequired = require_inherit_if_required();
    var normalizeStringArgument = require_normalize_string_argument();
    var DOMExceptionConstants = require_dom_exception_constants();
    var clearErrorStack = require_clear_error_stack();
    var IS_PURE = require_is_pure();
    var DOM_EXCEPTION = "DOMException";
    var Error2 = getBuiltIn("Error");
    var NativeDOMException = getBuiltIn(DOM_EXCEPTION);
    var $DOMException = function DOMException() {
      anInstance(this, DOMExceptionPrototype);
      var argumentsLength = arguments.length;
      var message = normalizeStringArgument(argumentsLength < 1 ? void 0 : arguments[0]);
      var name = normalizeStringArgument(argumentsLength < 2 ? void 0 : arguments[1], "Error");
      var that = new NativeDOMException(message, name);
      var error = Error2(message);
      error.name = DOM_EXCEPTION;
      defineProperty3(that, "stack", createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
      inheritIfRequired(that, this, $DOMException);
      return that;
    };
    var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;
    var ERROR_HAS_STACK = "stack" in Error2(DOM_EXCEPTION);
    var DOM_EXCEPTION_HAS_STACK = "stack" in new NativeDOMException(1, 2);
    var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !DOM_EXCEPTION_HAS_STACK;
    $({ global: true, forced: IS_PURE || FORCED_CONSTRUCTOR }, {
      // TODO: fix export logic
      DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
    });
    var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
    var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
    if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {
      if (!IS_PURE) {
        defineProperty3(PolyfilledDOMExceptionPrototype, "constructor", createPropertyDescriptor(1, PolyfilledDOMException));
      }
      for (key in DOMExceptionConstants)
        if (hasOwn(DOMExceptionConstants, key)) {
          constant = DOMExceptionConstants[key];
          constantName = constant.s;
          if (!hasOwn(PolyfilledDOMException, constantName)) {
            defineProperty3(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));
          }
        }
    }
    var constant;
    var constantName;
    var key;
  }
});

// node_modules/core-js/modules/web.dom-exception.to-string-tag.js
var require_web_dom_exception_to_string_tag = __commonJS({
  "node_modules/core-js/modules/web.dom-exception.to-string-tag.js"() {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var setToStringTag = require_set_to_string_tag();
    var DOM_EXCEPTION = "DOMException";
    setToStringTag(getBuiltIn(DOM_EXCEPTION), DOM_EXCEPTION);
  }
});

// node_modules/core-js/modules/web.immediate.js
var require_web_immediate = __commonJS({
  "node_modules/core-js/modules/web.immediate.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var task = require_task();
    var FORCED = !global2.setImmediate || !global2.clearImmediate;
    $({ global: true, bind: true, enumerable: true, forced: FORCED }, {
      // `setImmediate` method
      // http://w3c.github.io/setImmediate/#si-setImmediate
      setImmediate: task.set,
      // `clearImmediate` method
      // http://w3c.github.io/setImmediate/#si-clearImmediate
      clearImmediate: task.clear
    });
  }
});

// node_modules/core-js/modules/web.queue-microtask.js
var require_web_queue_microtask = __commonJS({
  "node_modules/core-js/modules/web.queue-microtask.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var microtask = require_microtask();
    var IS_NODE = require_engine_is_node();
    var process2 = global2.process;
    $({ global: true, enumerable: true, noTargetGet: true }, {
      queueMicrotask: function queueMicrotask(fn) {
        var domain = IS_NODE && process2.domain;
        microtask(domain ? domain.bind(fn) : fn);
      }
    });
  }
});

// node_modules/core-js/modules/web.structured-clone.js
var require_web_structured_clone = __commonJS({
  "node_modules/core-js/modules/web.structured-clone.js"() {
    "use strict";
    var IS_PURE = require_is_pure();
    var $ = require_export();
    var global2 = require_global();
    var getBuiltin = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var uid = require_uid();
    var isCallable = require_is_callable();
    var isConstructor = require_is_constructor();
    var isObject = require_is_object();
    var isSymbol = require_is_symbol();
    var iterate = require_iterate();
    var anObject = require_an_object();
    var classof = require_classof();
    var hasOwn = require_has_own_property();
    var createProperty = require_create_property();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var lengthOfArrayLike = require_length_of_array_like();
    var regExpFlags = require_regexp_flags();
    var ERROR_STACK_INSTALLABLE = require_error_stack_installable();
    var Object2 = global2.Object;
    var Date2 = global2.Date;
    var Error2 = global2.Error;
    var EvalError2 = global2.EvalError;
    var RangeError2 = global2.RangeError;
    var ReferenceError2 = global2.ReferenceError;
    var SyntaxError2 = global2.SyntaxError;
    var TypeError2 = global2.TypeError;
    var URIError2 = global2.URIError;
    var PerformanceMark = global2.PerformanceMark;
    var WebAssembly = global2.WebAssembly;
    var CompileError = WebAssembly && WebAssembly.CompileError || Error2;
    var LinkError = WebAssembly && WebAssembly.LinkError || Error2;
    var RuntimeError = WebAssembly && WebAssembly.RuntimeError || Error2;
    var DOMException = getBuiltin("DOMException");
    var Set2 = getBuiltin("Set");
    var Map2 = getBuiltin("Map");
    var MapPrototype = Map2.prototype;
    var mapHas = uncurryThis(MapPrototype.has);
    var mapGet = uncurryThis(MapPrototype.get);
    var mapSet = uncurryThis(MapPrototype.set);
    var setAdd = uncurryThis(Set2.prototype.add);
    var objectKeys = getBuiltin("Object", "keys");
    var push = uncurryThis([].push);
    var bolleanValueOf = uncurryThis(true.valueOf);
    var numberValueOf = uncurryThis(1 .valueOf);
    var stringValueOf = uncurryThis("".valueOf);
    var getFlags = uncurryThis(regExpFlags);
    var getTime = uncurryThis(Date2.prototype.getTime);
    var PERFORMANCE_MARK = uid("structuredClone");
    var DATA_CLONE_ERROR = "DataCloneError";
    var TRANSFERRING = "Transferring";
    var checkBasicSemantic = function(structuredCloneImplementation) {
      return !fails(function() {
        var set1 = new global2.Set([7]);
        var set2 = structuredCloneImplementation(set1);
        var number = structuredCloneImplementation(Object2(7));
        return set2 == set1 || !set2.has(7) || typeof number != "object" || number != 7;
      }) && structuredCloneImplementation;
    };
    var checkNewErrorsSemantic = function(structuredCloneImplementation) {
      return !fails(function() {
        var test = structuredCloneImplementation(new global2.AggregateError([1], PERFORMANCE_MARK, { cause: 3 }));
        return test.name != "AggregateError" || test.errors[0] != 1 || test.message != PERFORMANCE_MARK || test.cause != 3;
      }) && structuredCloneImplementation;
    };
    var nativeStructuredClone = global2.structuredClone;
    var FORCED_REPLACEMENT = IS_PURE || !checkNewErrorsSemantic(nativeStructuredClone);
    var structuredCloneFromMark = !nativeStructuredClone && checkBasicSemantic(function(value) {
      return new PerformanceMark(PERFORMANCE_MARK, { detail: value }).detail;
    });
    var nativeRestrictedStructuredClone = checkBasicSemantic(nativeStructuredClone) || structuredCloneFromMark;
    var throwUncloneable = function(type) {
      throw new DOMException("Uncloneable type: " + type, DATA_CLONE_ERROR);
    };
    var throwUnpolyfillable = function(type, kind) {
      throw new DOMException((kind || "Cloning") + " of " + type + " cannot be properly polyfilled in this engine", DATA_CLONE_ERROR);
    };
    var structuredCloneInternal = function(value, map) {
      if (isSymbol(value))
        throwUncloneable("Symbol");
      if (!isObject(value))
        return value;
      if (map) {
        if (mapHas(map, value))
          return mapGet(map, value);
      } else
        map = new Map2();
      var type = classof(value);
      var deep = false;
      var C, name, cloned, dataTransfer, i, length, keys, key, source, target;
      switch (type) {
        case "Array":
          cloned = [];
          deep = true;
          break;
        case "Object":
          cloned = {};
          deep = true;
          break;
        case "Map":
          cloned = new Map2();
          deep = true;
          break;
        case "Set":
          cloned = new Set2();
          deep = true;
          break;
        case "RegExp":
          cloned = new RegExp(value.source, "flags" in value ? value.flags : getFlags(value));
          break;
        case "Error":
          name = value.name;
          switch (name) {
            case "AggregateError":
              cloned = getBuiltin("AggregateError")([]);
              break;
            case "EvalError":
              cloned = EvalError2();
              break;
            case "RangeError":
              cloned = RangeError2();
              break;
            case "ReferenceError":
              cloned = ReferenceError2();
              break;
            case "SyntaxError":
              cloned = SyntaxError2();
              break;
            case "TypeError":
              cloned = TypeError2();
              break;
            case "URIError":
              cloned = URIError2();
              break;
            case "CompileError":
              cloned = CompileError();
              break;
            case "LinkError":
              cloned = LinkError();
              break;
            case "RuntimeError":
              cloned = RuntimeError();
              break;
            default:
              cloned = Error2();
          }
          deep = true;
          break;
        case "DOMException":
          cloned = new DOMException(value.message, value.name);
          deep = true;
          break;
        case "DataView":
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array":
          C = global2[type];
          if (!isObject(C))
            throwUnpolyfillable(type);
          cloned = new C(
            // this is safe, since arraybuffer cannot have circular references
            structuredCloneInternal(value.buffer, map),
            value.byteOffset,
            type === "DataView" ? value.byteLength : value.length
          );
          break;
        case "DOMQuad":
          try {
            cloned = new DOMQuad(
              structuredCloneInternal(value.p1, map),
              structuredCloneInternal(value.p2, map),
              structuredCloneInternal(value.p3, map),
              structuredCloneInternal(value.p4, map)
            );
          } catch (error) {
            if (nativeRestrictedStructuredClone) {
              cloned = nativeRestrictedStructuredClone(value);
            } else
              throwUnpolyfillable(type);
          }
          break;
        case "FileList":
          C = global2.DataTransfer;
          if (isConstructor(C)) {
            dataTransfer = new C();
            for (i = 0, length = lengthOfArrayLike(value); i < length; i++) {
              dataTransfer.items.add(structuredCloneInternal(value[i], map));
            }
            cloned = dataTransfer.files;
          } else if (nativeRestrictedStructuredClone) {
            cloned = nativeRestrictedStructuredClone(value);
          } else
            throwUnpolyfillable(type);
          break;
        case "ImageData":
          try {
            cloned = new ImageData(
              structuredCloneInternal(value.data, map),
              value.width,
              value.height,
              { colorSpace: value.colorSpace }
            );
          } catch (error) {
            if (nativeRestrictedStructuredClone) {
              cloned = nativeRestrictedStructuredClone(value);
            } else
              throwUnpolyfillable(type);
          }
          break;
        default:
          if (nativeRestrictedStructuredClone) {
            cloned = nativeRestrictedStructuredClone(value);
          } else
            switch (type) {
              case "BigInt":
                cloned = Object2(value.valueOf());
                break;
              case "Boolean":
                cloned = Object2(bolleanValueOf(value));
                break;
              case "Number":
                cloned = Object2(numberValueOf(value));
                break;
              case "String":
                cloned = Object2(stringValueOf(value));
                break;
              case "Date":
                cloned = new Date2(getTime(value));
                break;
              case "ArrayBuffer":
                C = global2.DataView;
                if (!C && typeof value.slice != "function")
                  throwUnpolyfillable(type);
                try {
                  if (typeof value.slice == "function") {
                    cloned = value.slice(0);
                  } else {
                    length = value.byteLength;
                    cloned = new ArrayBuffer(length);
                    source = new C(value);
                    target = new C(cloned);
                    for (i = 0; i < length; i++) {
                      target.setUint8(i, source.getUint8(i));
                    }
                  }
                } catch (error) {
                  throw new DOMException("ArrayBuffer is deatched", DATA_CLONE_ERROR);
                }
                break;
              case "SharedArrayBuffer":
                cloned = value;
                break;
              case "Blob":
                try {
                  cloned = value.slice(0, value.size, value.type);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "DOMPoint":
              case "DOMPointReadOnly":
                C = global2[type];
                try {
                  cloned = C.fromPoint ? C.fromPoint(value) : new C(value.x, value.y, value.z, value.w);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "DOMRect":
              case "DOMRectReadOnly":
                C = global2[type];
                try {
                  cloned = C.fromRect ? C.fromRect(value) : new C(value.x, value.y, value.width, value.height);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "DOMMatrix":
              case "DOMMatrixReadOnly":
                C = global2[type];
                try {
                  cloned = C.fromMatrix ? C.fromMatrix(value) : new C(value);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "AudioData":
              case "VideoFrame":
                if (!isCallable(value.clone))
                  throwUnpolyfillable(type);
                try {
                  cloned = value.clone();
                } catch (error) {
                  throwUncloneable(type);
                }
                break;
              case "File":
                try {
                  cloned = new File([value], value.name, value);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "CryptoKey":
              case "GPUCompilationMessage":
              case "GPUCompilationInfo":
              case "ImageBitmap":
              case "RTCCertificate":
              case "WebAssembly.Module":
                throwUnpolyfillable(type);
              default:
                throwUncloneable(type);
            }
      }
      mapSet(map, value, cloned);
      if (deep)
        switch (type) {
          case "Array":
          case "Object":
            keys = objectKeys(value);
            for (i = 0, length = lengthOfArrayLike(keys); i < length; i++) {
              key = keys[i];
              createProperty(cloned, key, structuredCloneInternal(value[key], map));
            }
            break;
          case "Map":
            value.forEach(function(v, k) {
              mapSet(cloned, structuredCloneInternal(k, map), structuredCloneInternal(v, map));
            });
            break;
          case "Set":
            value.forEach(function(v) {
              setAdd(cloned, structuredCloneInternal(v, map));
            });
            break;
          case "Error":
            createNonEnumerableProperty(cloned, "message", structuredCloneInternal(value.message, map));
            if (hasOwn(value, "cause")) {
              createNonEnumerableProperty(cloned, "cause", structuredCloneInternal(value.cause, map));
            }
            if (name == "AggregateError") {
              cloned.errors = structuredCloneInternal(value.errors, map);
            }
          case "DOMException":
            if (ERROR_STACK_INSTALLABLE) {
              createNonEnumerableProperty(cloned, "stack", structuredCloneInternal(value.stack, map));
            }
        }
      return cloned;
    };
    var PROPER_TRANSFER = nativeStructuredClone && !fails(function() {
      var buffer = new ArrayBuffer(8);
      var clone2 = nativeStructuredClone(buffer, { transfer: [buffer] });
      return buffer.byteLength != 0 || clone2.byteLength != 8;
    });
    var tryToTransfer = function(rawTransfer, map) {
      if (!isObject(rawTransfer))
        throw TypeError2("Transfer option cannot be converted to a sequence");
      var transfer = [];
      iterate(rawTransfer, function(value2) {
        push(transfer, anObject(value2));
      });
      var i = 0;
      var length = lengthOfArrayLike(transfer);
      var value, type, C, transferredArray, transferred, canvas, context;
      if (PROPER_TRANSFER) {
        transferredArray = nativeStructuredClone(transfer, { transfer });
        while (i < length)
          mapSet(map, transfer[i], transferredArray[i++]);
      } else
        while (i < length) {
          value = transfer[i++];
          if (mapHas(map, value))
            throw new DOMException("Duplicate transferable", DATA_CLONE_ERROR);
          type = classof(value);
          switch (type) {
            case "ImageBitmap":
              C = global2.OffscreenCanvas;
              if (!isConstructor(C))
                throwUnpolyfillable(type, TRANSFERRING);
              try {
                canvas = new C(value.width, value.height);
                context = canvas.getContext("bitmaprenderer");
                context.transferFromImageBitmap(value);
                transferred = canvas.transferToImageBitmap();
              } catch (error) {
              }
              break;
            case "AudioData":
            case "VideoFrame":
              if (!isCallable(value.clone) || !isCallable(value.close))
                throwUnpolyfillable(type, TRANSFERRING);
              try {
                transferred = value.clone();
                value.close();
              } catch (error) {
              }
              break;
            case "ArrayBuffer":
            case "MessagePort":
            case "OffscreenCanvas":
            case "ReadableStream":
            case "TransformStream":
            case "WritableStream":
              throwUnpolyfillable(type, TRANSFERRING);
          }
          if (transferred === void 0)
            throw new DOMException("This object cannot be transferred: " + type, DATA_CLONE_ERROR);
          mapSet(map, value, transferred);
        }
    };
    $({ global: true, enumerable: true, sham: !PROPER_TRANSFER, forced: FORCED_REPLACEMENT }, {
      structuredClone: function structuredClone(value) {
        var options = arguments.length > 1 ? anObject(arguments[1]) : void 0;
        var transfer = options ? options.transfer : void 0;
        var map;
        if (transfer !== void 0) {
          map = new Map2();
          tryToTransfer(transfer, map);
        }
        return structuredCloneInternal(value, map);
      }
    });
  }
});

// node_modules/core-js/modules/web.timers.js
var require_web_timers = __commonJS({
  "node_modules/core-js/modules/web.timers.js"() {
    "use strict";
    var $ = require_export();
    var global2 = require_global();
    var apply = require_function_apply();
    var isCallable = require_is_callable();
    var userAgent = require_engine_user_agent();
    var arraySlice = require_array_slice();
    var MSIE = /MSIE .\./.test(userAgent);
    var Function2 = global2.Function;
    var wrap = function(scheduler) {
      return function(handler, timeout) {
        var boundArgs = arguments.length > 2;
        var args = boundArgs ? arraySlice(arguments, 2) : void 0;
        return scheduler(boundArgs ? function() {
          apply(isCallable(handler) ? handler : Function2(handler), this, args);
        } : handler, timeout);
      };
    };
    $({ global: true, bind: true, forced: MSIE }, {
      // `setTimeout` method
      // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
      setTimeout: wrap(global2.setTimeout),
      // `setInterval` method
      // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
      setInterval: wrap(global2.setInterval)
    });
  }
});

// node_modules/core-js/internals/native-url.js
var require_native_url = __commonJS({
  "node_modules/core-js/internals/native-url.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var ITERATOR = wellKnownSymbol("iterator");
    module2.exports = !fails(function() {
      var url = new URL("b?a=1&b=2&c=3", "http://a");
      var searchParams = url.searchParams;
      var result = "";
      url.pathname = "c%20d";
      searchParams.forEach(function(value, key) {
        searchParams["delete"]("b");
        result += key + value;
      });
      return IS_PURE && !url.toJSON || !searchParams.sort || url.href !== "http://a/c%20d?a=1&c=3" || searchParams.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !searchParams[ITERATOR] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("http://\u0442\u0435\u0441\u0442").host !== "xn--e1aybc" || new URL("http://a#\u0431").hash !== "#%D0%B1" || result !== "a1c3" || new URL("http://x", void 0).host !== "x";
    });
  }
});

// node_modules/core-js/internals/string-punycode-to-ascii.js
var require_string_punycode_to_ascii = __commonJS({
  "node_modules/core-js/internals/string-punycode-to-ascii.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexNonASCII = /[^\0-\u007E]/;
    var regexSeparators = /[.\u3002\uFF0E\uFF61]/g;
    var OVERFLOW_ERROR = "Overflow: input needs wider integers to process";
    var baseMinusTMin = base - tMin;
    var RangeError2 = global2.RangeError;
    var exec = uncurryThis(regexSeparators.exec);
    var floor = Math.floor;
    var fromCharCode = String.fromCharCode;
    var charCodeAt = uncurryThis("".charCodeAt);
    var join = uncurryThis([].join);
    var push = uncurryThis([].push);
    var replace = uncurryThis("".replace);
    var split = uncurryThis("".split);
    var toLowerCase = uncurryThis("".toLowerCase);
    var ucs2decode = function(string) {
      var output = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = charCodeAt(string, counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = charCodeAt(string, counter++);
          if ((extra & 64512) == 56320) {
            push(output, ((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            push(output, value);
            counter--;
          }
        } else {
          push(output, value);
        }
      }
      return output;
    };
    var digitToBasic = function(digit) {
      return digit + 22 + 75 * (digit < 26);
    };
    var adapt = function(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      while (delta > baseMinusTMin * tMax >> 1) {
        delta = floor(delta / baseMinusTMin);
        k += base;
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var encode = function(input) {
      var output = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var i, currentValue;
      for (i = 0; i < input.length; i++) {
        currentValue = input[i];
        if (currentValue < 128) {
          push(output, fromCharCode(currentValue));
        }
      }
      var basicLength = output.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        push(output, delimiter);
      }
      while (handledCPCount < inputLength) {
        var m = maxInt;
        for (i = 0; i < input.length; i++) {
          currentValue = input[i];
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          throw RangeError2(OVERFLOW_ERROR);
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (i = 0; i < input.length; i++) {
          currentValue = input[i];
          if (currentValue < n && ++delta > maxInt) {
            throw RangeError2(OVERFLOW_ERROR);
          }
          if (currentValue == n) {
            var q = delta;
            var k = base;
            while (true) {
              var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t)
                break;
              var qMinusT = q - t;
              var baseMinusT = base - t;
              push(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
              q = floor(qMinusT / baseMinusT);
              k += base;
            }
            push(output, fromCharCode(digitToBasic(q)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            handledCPCount++;
          }
        }
        delta++;
        n++;
      }
      return join(output, "");
    };
    module2.exports = function(input) {
      var encoded = [];
      var labels = split(replace(toLowerCase(input), regexSeparators, "."), ".");
      var i, label;
      for (i = 0; i < labels.length; i++) {
        label = labels[i];
        push(encoded, exec(regexNonASCII, label) ? "xn--" + encode(label) : label);
      }
      return join(encoded, ".");
    };
  }
});

// node_modules/core-js/modules/web.url-search-params.js
var require_web_url_search_params = __commonJS({
  "node_modules/core-js/modules/web.url-search-params.js"(exports, module2) {
    "use strict";
    require_es_array_iterator();
    var $ = require_export();
    var global2 = require_global();
    var getBuiltIn = require_get_built_in();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var USE_NATIVE_URL = require_native_url();
    var redefine = require_redefine();
    var redefineAll = require_redefine_all();
    var setToStringTag = require_set_to_string_tag();
    var createIteratorConstructor = require_create_iterator_constructor();
    var InternalStateModule = require_internal_state();
    var anInstance = require_an_instance();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var bind = require_function_bind_context();
    var classof = require_classof();
    var anObject = require_an_object();
    var isObject = require_is_object();
    var $toString = require_to_string();
    var create3 = require_object_create();
    var createPropertyDescriptor = require_create_property_descriptor();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var wellKnownSymbol = require_well_known_symbol();
    var arraySort = require_array_sort();
    var ITERATOR = wellKnownSymbol("iterator");
    var URL_SEARCH_PARAMS = "URLSearchParams";
    var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + "Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
    var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
    var n$Fetch = getBuiltIn("fetch");
    var N$Request = getBuiltIn("Request");
    var Headers2 = getBuiltIn("Headers");
    var RequestPrototype = N$Request && N$Request.prototype;
    var HeadersPrototype = Headers2 && Headers2.prototype;
    var RegExp2 = global2.RegExp;
    var TypeError2 = global2.TypeError;
    var decodeURIComponent2 = global2.decodeURIComponent;
    var encodeURIComponent2 = global2.encodeURIComponent;
    var charAt = uncurryThis("".charAt);
    var join = uncurryThis([].join);
    var push = uncurryThis([].push);
    var replace = uncurryThis("".replace);
    var shift = uncurryThis([].shift);
    var splice = uncurryThis([].splice);
    var split = uncurryThis("".split);
    var stringSlice = uncurryThis("".slice);
    var plus = /\+/g;
    var sequences = Array(4);
    var percentSequence = function(bytes) {
      return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp2("((?:%[\\da-f]{2}){" + bytes + "})", "gi"));
    };
    var percentDecode = function(sequence) {
      try {
        return decodeURIComponent2(sequence);
      } catch (error) {
        return sequence;
      }
    };
    var deserialize = function(it) {
      var result = replace(it, plus, " ");
      var bytes = 4;
      try {
        return decodeURIComponent2(result);
      } catch (error) {
        while (bytes) {
          result = replace(result, percentSequence(bytes--), percentDecode);
        }
        return result;
      }
    };
    var find4 = /[!'()~]|%20/g;
    var replacements = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+"
    };
    var replacer = function(match) {
      return replacements[match];
    };
    var serialize = function(it) {
      return replace(encodeURIComponent2(it), find4, replacer);
    };
    var validateArgumentsLength = function(passed, required) {
      if (passed < required)
        throw TypeError2("Not enough arguments");
    };
    var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
      setInternalState(this, {
        type: URL_SEARCH_PARAMS_ITERATOR,
        iterator: getIterator(getInternalParamsState(params).entries),
        kind
      });
    }, "Iterator", function next() {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var step = state.iterator.next();
      var entry = step.value;
      if (!step.done) {
        step.value = kind === "keys" ? entry.key : kind === "values" ? entry.value : [entry.key, entry.value];
      }
      return step;
    }, true);
    var URLSearchParamsState = function(init) {
      this.entries = [];
      this.url = null;
      if (init !== void 0) {
        if (isObject(init))
          this.parseObject(init);
        else
          this.parseQuery(typeof init == "string" ? charAt(init, 0) === "?" ? stringSlice(init, 1) : init : $toString(init));
      }
    };
    URLSearchParamsState.prototype = {
      type: URL_SEARCH_PARAMS,
      bindURL: function(url) {
        this.url = url;
        this.update();
      },
      parseObject: function(object) {
        var iteratorMethod = getIteratorMethod(object);
        var iterator, next, step, entryIterator, entryNext, first, second;
        if (iteratorMethod) {
          iterator = getIterator(object, iteratorMethod);
          next = iterator.next;
          while (!(step = call(next, iterator)).done) {
            entryIterator = getIterator(anObject(step.value));
            entryNext = entryIterator.next;
            if ((first = call(entryNext, entryIterator)).done || (second = call(entryNext, entryIterator)).done || !call(entryNext, entryIterator).done)
              throw TypeError2("Expected sequence with length 2");
            push(this.entries, { key: $toString(first.value), value: $toString(second.value) });
          }
        } else
          for (var key in object)
            if (hasOwn(object, key)) {
              push(this.entries, { key, value: $toString(object[key]) });
            }
      },
      parseQuery: function(query2) {
        if (query2) {
          var attributes = split(query2, "&");
          var index2 = 0;
          var attribute, entry;
          while (index2 < attributes.length) {
            attribute = attributes[index2++];
            if (attribute.length) {
              entry = split(attribute, "=");
              push(this.entries, {
                key: deserialize(shift(entry)),
                value: deserialize(join(entry, "="))
              });
            }
          }
        }
      },
      serialize: function() {
        var entries = this.entries;
        var result = [];
        var index2 = 0;
        var entry;
        while (index2 < entries.length) {
          entry = entries[index2++];
          push(result, serialize(entry.key) + "=" + serialize(entry.value));
        }
        return join(result, "&");
      },
      update: function() {
        this.entries.length = 0;
        this.parseQuery(this.url.query);
      },
      updateURL: function() {
        if (this.url)
          this.url.update();
      }
    };
    var URLSearchParamsConstructor = function URLSearchParams2() {
      anInstance(this, URLSearchParamsPrototype);
      var init = arguments.length > 0 ? arguments[0] : void 0;
      setInternalState(this, new URLSearchParamsState(init));
    };
    var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
    redefineAll(URLSearchParamsPrototype, {
      // `URLSearchParams.prototype.append` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-append
      append: function append2(name, value) {
        validateArgumentsLength(arguments.length, 2);
        var state = getInternalParamsState(this);
        push(state.entries, { key: $toString(name), value: $toString(value) });
        state.updateURL();
      },
      // `URLSearchParams.prototype.delete` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
      "delete": function(name) {
        validateArgumentsLength(arguments.length, 1);
        var state = getInternalParamsState(this);
        var entries = state.entries;
        var key = $toString(name);
        var index2 = 0;
        while (index2 < entries.length) {
          if (entries[index2].key === key)
            splice(entries, index2, 1);
          else
            index2++;
        }
        state.updateURL();
      },
      // `URLSearchParams.prototype.get` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-get
      get: function get(name) {
        validateArgumentsLength(arguments.length, 1);
        var entries = getInternalParamsState(this).entries;
        var key = $toString(name);
        var index2 = 0;
        for (; index2 < entries.length; index2++) {
          if (entries[index2].key === key)
            return entries[index2].value;
        }
        return null;
      },
      // `URLSearchParams.prototype.getAll` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
      getAll: function getAll(name) {
        validateArgumentsLength(arguments.length, 1);
        var entries = getInternalParamsState(this).entries;
        var key = $toString(name);
        var result = [];
        var index2 = 0;
        for (; index2 < entries.length; index2++) {
          if (entries[index2].key === key)
            push(result, entries[index2].value);
        }
        return result;
      },
      // `URLSearchParams.prototype.has` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-has
      has: function has(name) {
        validateArgumentsLength(arguments.length, 1);
        var entries = getInternalParamsState(this).entries;
        var key = $toString(name);
        var index2 = 0;
        while (index2 < entries.length) {
          if (entries[index2++].key === key)
            return true;
        }
        return false;
      },
      // `URLSearchParams.prototype.set` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-set
      set: function set(name, value) {
        validateArgumentsLength(arguments.length, 1);
        var state = getInternalParamsState(this);
        var entries = state.entries;
        var found = false;
        var key = $toString(name);
        var val = $toString(value);
        var index2 = 0;
        var entry;
        for (; index2 < entries.length; index2++) {
          entry = entries[index2];
          if (entry.key === key) {
            if (found)
              splice(entries, index2--, 1);
            else {
              found = true;
              entry.value = val;
            }
          }
        }
        if (!found)
          push(entries, { key, value: val });
        state.updateURL();
      },
      // `URLSearchParams.prototype.sort` method
      // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
      sort: function sort() {
        var state = getInternalParamsState(this);
        arraySort(state.entries, function(a, b) {
          return a.key > b.key ? 1 : -1;
        });
        state.updateURL();
      },
      // `URLSearchParams.prototype.forEach` method
      forEach: function forEach(callback2) {
        var entries = getInternalParamsState(this).entries;
        var boundFunction = bind(callback2, arguments.length > 1 ? arguments[1] : void 0);
        var index2 = 0;
        var entry;
        while (index2 < entries.length) {
          entry = entries[index2++];
          boundFunction(entry.value, entry.key, this);
        }
      },
      // `URLSearchParams.prototype.keys` method
      keys: function keys() {
        return new URLSearchParamsIterator(this, "keys");
      },
      // `URLSearchParams.prototype.values` method
      values: function values() {
        return new URLSearchParamsIterator(this, "values");
      },
      // `URLSearchParams.prototype.entries` method
      entries: function entries() {
        return new URLSearchParamsIterator(this, "entries");
      }
    }, { enumerable: true });
    redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: "entries" });
    redefine(URLSearchParamsPrototype, "toString", function toString() {
      return getInternalParamsState(this).serialize();
    }, { enumerable: true });
    setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
    $({ global: true, forced: !USE_NATIVE_URL }, {
      URLSearchParams: URLSearchParamsConstructor
    });
    if (!USE_NATIVE_URL && isCallable(Headers2)) {
      headersHas = uncurryThis(HeadersPrototype.has);
      headersSet = uncurryThis(HeadersPrototype.set);
      wrapRequestOptions = function(init) {
        if (isObject(init)) {
          var body = init.body;
          var headers;
          if (classof(body) === URL_SEARCH_PARAMS) {
            headers = init.headers ? new Headers2(init.headers) : new Headers2();
            if (!headersHas(headers, "content-type")) {
              headersSet(headers, "content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
            return create3(init, {
              body: createPropertyDescriptor(0, $toString(body)),
              headers: createPropertyDescriptor(0, headers)
            });
          }
        }
        return init;
      };
      if (isCallable(n$Fetch)) {
        $({ global: true, enumerable: true, forced: true }, {
          fetch: function fetch4(input) {
            return n$Fetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
          }
        });
      }
      if (isCallable(N$Request)) {
        RequestConstructor = function Request2(input) {
          anInstance(this, RequestPrototype);
          return new N$Request(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
        };
        RequestPrototype.constructor = RequestConstructor;
        RequestConstructor.prototype = RequestPrototype;
        $({ global: true, forced: true }, {
          Request: RequestConstructor
        });
      }
    }
    var headersHas;
    var headersSet;
    var wrapRequestOptions;
    var RequestConstructor;
    module2.exports = {
      URLSearchParams: URLSearchParamsConstructor,
      getState: getInternalParamsState
    };
  }
});

// node_modules/core-js/modules/web.url.js
var require_web_url = __commonJS({
  "node_modules/core-js/modules/web.url.js"() {
    "use strict";
    require_es_string_iterator();
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var USE_NATIVE_URL = require_native_url();
    var global2 = require_global();
    var bind = require_function_bind_context();
    var uncurryThis = require_function_uncurry_this();
    var defineProperties = require_object_define_properties();
    var redefine = require_redefine();
    var anInstance = require_an_instance();
    var hasOwn = require_has_own_property();
    var assign2 = require_object_assign();
    var arrayFrom = require_array_from();
    var arraySlice = require_array_slice_simple();
    var codeAt = require_string_multibyte().codeAt;
    var toASCII = require_string_punycode_to_ascii();
    var $toString = require_to_string();
    var setToStringTag = require_set_to_string_tag();
    var URLSearchParamsModule = require_web_url_search_params();
    var InternalStateModule = require_internal_state();
    var setInternalState = InternalStateModule.set;
    var getInternalURLState = InternalStateModule.getterFor("URL");
    var URLSearchParams2 = URLSearchParamsModule.URLSearchParams;
    var getInternalSearchParamsState = URLSearchParamsModule.getState;
    var NativeURL = global2.URL;
    var TypeError2 = global2.TypeError;
    var parseInt2 = global2.parseInt;
    var floor = Math.floor;
    var pow = Math.pow;
    var charAt = uncurryThis("".charAt);
    var exec = uncurryThis(/./.exec);
    var join = uncurryThis([].join);
    var numberToString = uncurryThis(1 .toString);
    var pop = uncurryThis([].pop);
    var push = uncurryThis([].push);
    var replace = uncurryThis("".replace);
    var shift = uncurryThis([].shift);
    var split = uncurryThis("".split);
    var stringSlice = uncurryThis("".slice);
    var toLowerCase = uncurryThis("".toLowerCase);
    var unshift = uncurryThis([].unshift);
    var INVALID_AUTHORITY = "Invalid authority";
    var INVALID_SCHEME = "Invalid scheme";
    var INVALID_HOST = "Invalid host";
    var INVALID_PORT = "Invalid port";
    var ALPHA = /[a-z]/i;
    var ALPHANUMERIC = /[\d+-.a-z]/i;
    var DIGIT = /\d/;
    var HEX_START = /^0x/i;
    var OCT = /^[0-7]+$/;
    var DEC = /^\d+$/;
    var HEX = /^[\da-f]+$/i;
    var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
    var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
    var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+|[\u0000-\u0020]+$/g;
    var TAB_AND_NEW_LINE = /[\t\n\r]/g;
    var EOF;
    var parseIPv4 = function(input) {
      var parts = split(input, ".");
      var partsLength, numbers, index2, part, radix, number, ipv4;
      if (parts.length && parts[parts.length - 1] == "") {
        parts.length--;
      }
      partsLength = parts.length;
      if (partsLength > 4)
        return input;
      numbers = [];
      for (index2 = 0; index2 < partsLength; index2++) {
        part = parts[index2];
        if (part == "")
          return input;
        radix = 10;
        if (part.length > 1 && charAt(part, 0) == "0") {
          radix = exec(HEX_START, part) ? 16 : 8;
          part = stringSlice(part, radix == 8 ? 1 : 2);
        }
        if (part === "") {
          number = 0;
        } else {
          if (!exec(radix == 10 ? DEC : radix == 8 ? OCT : HEX, part))
            return input;
          number = parseInt2(part, radix);
        }
        push(numbers, number);
      }
      for (index2 = 0; index2 < partsLength; index2++) {
        number = numbers[index2];
        if (index2 == partsLength - 1) {
          if (number >= pow(256, 5 - partsLength))
            return null;
        } else if (number > 255)
          return null;
      }
      ipv4 = pop(numbers);
      for (index2 = 0; index2 < numbers.length; index2++) {
        ipv4 += numbers[index2] * pow(256, 3 - index2);
      }
      return ipv4;
    };
    var parseIPv6 = function(input) {
      var address = [0, 0, 0, 0, 0, 0, 0, 0];
      var pieceIndex = 0;
      var compress = null;
      var pointer = 0;
      var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
      var chr = function() {
        return charAt(input, pointer);
      };
      if (chr() == ":") {
        if (charAt(input, 1) != ":")
          return;
        pointer += 2;
        pieceIndex++;
        compress = pieceIndex;
      }
      while (chr()) {
        if (pieceIndex == 8)
          return;
        if (chr() == ":") {
          if (compress !== null)
            return;
          pointer++;
          pieceIndex++;
          compress = pieceIndex;
          continue;
        }
        value = length = 0;
        while (length < 4 && exec(HEX, chr())) {
          value = value * 16 + parseInt2(chr(), 16);
          pointer++;
          length++;
        }
        if (chr() == ".") {
          if (length == 0)
            return;
          pointer -= length;
          if (pieceIndex > 6)
            return;
          numbersSeen = 0;
          while (chr()) {
            ipv4Piece = null;
            if (numbersSeen > 0) {
              if (chr() == "." && numbersSeen < 4)
                pointer++;
              else
                return;
            }
            if (!exec(DIGIT, chr()))
              return;
            while (exec(DIGIT, chr())) {
              number = parseInt2(chr(), 10);
              if (ipv4Piece === null)
                ipv4Piece = number;
              else if (ipv4Piece == 0)
                return;
              else
                ipv4Piece = ipv4Piece * 10 + number;
              if (ipv4Piece > 255)
                return;
              pointer++;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            numbersSeen++;
            if (numbersSeen == 2 || numbersSeen == 4)
              pieceIndex++;
          }
          if (numbersSeen != 4)
            return;
          break;
        } else if (chr() == ":") {
          pointer++;
          if (!chr())
            return;
        } else if (chr())
          return;
        address[pieceIndex++] = value;
      }
      if (compress !== null) {
        swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex != 0 && swaps > 0) {
          swap = address[pieceIndex];
          address[pieceIndex--] = address[compress + swaps - 1];
          address[compress + --swaps] = swap;
        }
      } else if (pieceIndex != 8)
        return;
      return address;
    };
    var findLongestZeroSequence = function(ipv6) {
      var maxIndex = null;
      var maxLength = 1;
      var currStart = null;
      var currLength = 0;
      var index2 = 0;
      for (; index2 < 8; index2++) {
        if (ipv6[index2] !== 0) {
          if (currLength > maxLength) {
            maxIndex = currStart;
            maxLength = currLength;
          }
          currStart = null;
          currLength = 0;
        } else {
          if (currStart === null)
            currStart = index2;
          ++currLength;
        }
      }
      if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }
      return maxIndex;
    };
    var serializeHost = function(host) {
      var result, index2, compress, ignore0;
      if (typeof host == "number") {
        result = [];
        for (index2 = 0; index2 < 4; index2++) {
          unshift(result, host % 256);
          host = floor(host / 256);
        }
        return join(result, ".");
      } else if (typeof host == "object") {
        result = "";
        compress = findLongestZeroSequence(host);
        for (index2 = 0; index2 < 8; index2++) {
          if (ignore0 && host[index2] === 0)
            continue;
          if (ignore0)
            ignore0 = false;
          if (compress === index2) {
            result += index2 ? ":" : "::";
            ignore0 = true;
          } else {
            result += numberToString(host[index2], 16);
            if (index2 < 7)
              result += ":";
          }
        }
        return "[" + result + "]";
      }
      return host;
    };
    var C0ControlPercentEncodeSet = {};
    var fragmentPercentEncodeSet = assign2({}, C0ControlPercentEncodeSet, {
      " ": 1,
      '"': 1,
      "<": 1,
      ">": 1,
      "`": 1
    });
    var pathPercentEncodeSet = assign2({}, fragmentPercentEncodeSet, {
      "#": 1,
      "?": 1,
      "{": 1,
      "}": 1
    });
    var userinfoPercentEncodeSet = assign2({}, pathPercentEncodeSet, {
      "/": 1,
      ":": 1,
      ";": 1,
      "=": 1,
      "@": 1,
      "[": 1,
      "\\": 1,
      "]": 1,
      "^": 1,
      "|": 1
    });
    var percentEncode = function(chr, set) {
      var code = codeAt(chr, 0);
      return code > 32 && code < 127 && !hasOwn(set, chr) ? chr : encodeURIComponent(chr);
    };
    var specialSchemes = {
      ftp: 21,
      file: null,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var isWindowsDriveLetter = function(string, normalized) {
      var second;
      return string.length == 2 && exec(ALPHA, charAt(string, 0)) && ((second = charAt(string, 1)) == ":" || !normalized && second == "|");
    };
    var startsWithWindowsDriveLetter = function(string) {
      var third;
      return string.length > 1 && isWindowsDriveLetter(stringSlice(string, 0, 2)) && (string.length == 2 || ((third = charAt(string, 2)) === "/" || third === "\\" || third === "?" || third === "#"));
    };
    var isSingleDot = function(segment) {
      return segment === "." || toLowerCase(segment) === "%2e";
    };
    var isDoubleDot = function(segment) {
      segment = toLowerCase(segment);
      return segment === ".." || segment === "%2e." || segment === ".%2e" || segment === "%2e%2e";
    };
    var SCHEME_START = {};
    var SCHEME = {};
    var NO_SCHEME = {};
    var SPECIAL_RELATIVE_OR_AUTHORITY = {};
    var PATH_OR_AUTHORITY = {};
    var RELATIVE = {};
    var RELATIVE_SLASH = {};
    var SPECIAL_AUTHORITY_SLASHES = {};
    var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
    var AUTHORITY = {};
    var HOST = {};
    var HOSTNAME = {};
    var PORT = {};
    var FILE = {};
    var FILE_SLASH = {};
    var FILE_HOST = {};
    var PATH_START = {};
    var PATH = {};
    var CANNOT_BE_A_BASE_URL_PATH = {};
    var QUERY = {};
    var FRAGMENT = {};
    var URLState = function(url, isBase, base) {
      var urlString = $toString(url);
      var baseState, failure, searchParams;
      if (isBase) {
        failure = this.parse(urlString);
        if (failure)
          throw TypeError2(failure);
        this.searchParams = null;
      } else {
        if (base !== void 0)
          baseState = new URLState(base, true);
        failure = this.parse(urlString, null, baseState);
        if (failure)
          throw TypeError2(failure);
        searchParams = getInternalSearchParamsState(new URLSearchParams2());
        searchParams.bindURL(this);
        this.searchParams = searchParams;
      }
    };
    URLState.prototype = {
      type: "URL",
      // https://url.spec.whatwg.org/#url-parsing
      // eslint-disable-next-line max-statements -- TODO
      parse: function(input, stateOverride, base) {
        var url = this;
        var state = stateOverride || SCHEME_START;
        var pointer = 0;
        var buffer = "";
        var seenAt = false;
        var seenBracket = false;
        var seenPasswordToken = false;
        var codePoints, chr, bufferCodePoints, failure;
        input = $toString(input);
        if (!stateOverride) {
          url.scheme = "";
          url.username = "";
          url.password = "";
          url.host = null;
          url.port = null;
          url.path = [];
          url.query = null;
          url.fragment = null;
          url.cannotBeABaseURL = false;
          input = replace(input, LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, "");
        }
        input = replace(input, TAB_AND_NEW_LINE, "");
        codePoints = arrayFrom(input);
        while (pointer <= codePoints.length) {
          chr = codePoints[pointer];
          switch (state) {
            case SCHEME_START:
              if (chr && exec(ALPHA, chr)) {
                buffer += toLowerCase(chr);
                state = SCHEME;
              } else if (!stateOverride) {
                state = NO_SCHEME;
                continue;
              } else
                return INVALID_SCHEME;
              break;
            case SCHEME:
              if (chr && (exec(ALPHANUMERIC, chr) || chr == "+" || chr == "-" || chr == ".")) {
                buffer += toLowerCase(chr);
              } else if (chr == ":") {
                if (stateOverride && (url.isSpecial() != hasOwn(specialSchemes, buffer) || buffer == "file" && (url.includesCredentials() || url.port !== null) || url.scheme == "file" && !url.host))
                  return;
                url.scheme = buffer;
                if (stateOverride) {
                  if (url.isSpecial() && specialSchemes[url.scheme] == url.port)
                    url.port = null;
                  return;
                }
                buffer = "";
                if (url.scheme == "file") {
                  state = FILE;
                } else if (url.isSpecial() && base && base.scheme == url.scheme) {
                  state = SPECIAL_RELATIVE_OR_AUTHORITY;
                } else if (url.isSpecial()) {
                  state = SPECIAL_AUTHORITY_SLASHES;
                } else if (codePoints[pointer + 1] == "/") {
                  state = PATH_OR_AUTHORITY;
                  pointer++;
                } else {
                  url.cannotBeABaseURL = true;
                  push(url.path, "");
                  state = CANNOT_BE_A_BASE_URL_PATH;
                }
              } else if (!stateOverride) {
                buffer = "";
                state = NO_SCHEME;
                pointer = 0;
                continue;
              } else
                return INVALID_SCHEME;
              break;
            case NO_SCHEME:
              if (!base || base.cannotBeABaseURL && chr != "#")
                return INVALID_SCHEME;
              if (base.cannotBeABaseURL && chr == "#") {
                url.scheme = base.scheme;
                url.path = arraySlice(base.path);
                url.query = base.query;
                url.fragment = "";
                url.cannotBeABaseURL = true;
                state = FRAGMENT;
                break;
              }
              state = base.scheme == "file" ? FILE : RELATIVE;
              continue;
            case SPECIAL_RELATIVE_OR_AUTHORITY:
              if (chr == "/" && codePoints[pointer + 1] == "/") {
                state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                pointer++;
              } else {
                state = RELATIVE;
                continue;
              }
              break;
            case PATH_OR_AUTHORITY:
              if (chr == "/") {
                state = AUTHORITY;
                break;
              } else {
                state = PATH;
                continue;
              }
            case RELATIVE:
              url.scheme = base.scheme;
              if (chr == EOF) {
                url.username = base.username;
                url.password = base.password;
                url.host = base.host;
                url.port = base.port;
                url.path = arraySlice(base.path);
                url.query = base.query;
              } else if (chr == "/" || chr == "\\" && url.isSpecial()) {
                state = RELATIVE_SLASH;
              } else if (chr == "?") {
                url.username = base.username;
                url.password = base.password;
                url.host = base.host;
                url.port = base.port;
                url.path = arraySlice(base.path);
                url.query = "";
                state = QUERY;
              } else if (chr == "#") {
                url.username = base.username;
                url.password = base.password;
                url.host = base.host;
                url.port = base.port;
                url.path = arraySlice(base.path);
                url.query = base.query;
                url.fragment = "";
                state = FRAGMENT;
              } else {
                url.username = base.username;
                url.password = base.password;
                url.host = base.host;
                url.port = base.port;
                url.path = arraySlice(base.path);
                url.path.length--;
                state = PATH;
                continue;
              }
              break;
            case RELATIVE_SLASH:
              if (url.isSpecial() && (chr == "/" || chr == "\\")) {
                state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
              } else if (chr == "/") {
                state = AUTHORITY;
              } else {
                url.username = base.username;
                url.password = base.password;
                url.host = base.host;
                url.port = base.port;
                state = PATH;
                continue;
              }
              break;
            case SPECIAL_AUTHORITY_SLASHES:
              state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
              if (chr != "/" || charAt(buffer, pointer + 1) != "/")
                continue;
              pointer++;
              break;
            case SPECIAL_AUTHORITY_IGNORE_SLASHES:
              if (chr != "/" && chr != "\\") {
                state = AUTHORITY;
                continue;
              }
              break;
            case AUTHORITY:
              if (chr == "@") {
                if (seenAt)
                  buffer = "%40" + buffer;
                seenAt = true;
                bufferCodePoints = arrayFrom(buffer);
                for (var i = 0; i < bufferCodePoints.length; i++) {
                  var codePoint = bufferCodePoints[i];
                  if (codePoint == ":" && !seenPasswordToken) {
                    seenPasswordToken = true;
                    continue;
                  }
                  var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
                  if (seenPasswordToken)
                    url.password += encodedCodePoints;
                  else
                    url.username += encodedCodePoints;
                }
                buffer = "";
              } else if (chr == EOF || chr == "/" || chr == "?" || chr == "#" || chr == "\\" && url.isSpecial()) {
                if (seenAt && buffer == "")
                  return INVALID_AUTHORITY;
                pointer -= arrayFrom(buffer).length + 1;
                buffer = "";
                state = HOST;
              } else
                buffer += chr;
              break;
            case HOST:
            case HOSTNAME:
              if (stateOverride && url.scheme == "file") {
                state = FILE_HOST;
                continue;
              } else if (chr == ":" && !seenBracket) {
                if (buffer == "")
                  return INVALID_HOST;
                failure = url.parseHost(buffer);
                if (failure)
                  return failure;
                buffer = "";
                state = PORT;
                if (stateOverride == HOSTNAME)
                  return;
              } else if (chr == EOF || chr == "/" || chr == "?" || chr == "#" || chr == "\\" && url.isSpecial()) {
                if (url.isSpecial() && buffer == "")
                  return INVALID_HOST;
                if (stateOverride && buffer == "" && (url.includesCredentials() || url.port !== null))
                  return;
                failure = url.parseHost(buffer);
                if (failure)
                  return failure;
                buffer = "";
                state = PATH_START;
                if (stateOverride)
                  return;
                continue;
              } else {
                if (chr == "[")
                  seenBracket = true;
                else if (chr == "]")
                  seenBracket = false;
                buffer += chr;
              }
              break;
            case PORT:
              if (exec(DIGIT, chr)) {
                buffer += chr;
              } else if (chr == EOF || chr == "/" || chr == "?" || chr == "#" || chr == "\\" && url.isSpecial() || stateOverride) {
                if (buffer != "") {
                  var port = parseInt2(buffer, 10);
                  if (port > 65535)
                    return INVALID_PORT;
                  url.port = url.isSpecial() && port === specialSchemes[url.scheme] ? null : port;
                  buffer = "";
                }
                if (stateOverride)
                  return;
                state = PATH_START;
                continue;
              } else
                return INVALID_PORT;
              break;
            case FILE:
              url.scheme = "file";
              if (chr == "/" || chr == "\\")
                state = FILE_SLASH;
              else if (base && base.scheme == "file") {
                if (chr == EOF) {
                  url.host = base.host;
                  url.path = arraySlice(base.path);
                  url.query = base.query;
                } else if (chr == "?") {
                  url.host = base.host;
                  url.path = arraySlice(base.path);
                  url.query = "";
                  state = QUERY;
                } else if (chr == "#") {
                  url.host = base.host;
                  url.path = arraySlice(base.path);
                  url.query = base.query;
                  url.fragment = "";
                  state = FRAGMENT;
                } else {
                  if (!startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ""))) {
                    url.host = base.host;
                    url.path = arraySlice(base.path);
                    url.shortenPath();
                  }
                  state = PATH;
                  continue;
                }
              } else {
                state = PATH;
                continue;
              }
              break;
            case FILE_SLASH:
              if (chr == "/" || chr == "\\") {
                state = FILE_HOST;
                break;
              }
              if (base && base.scheme == "file" && !startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ""))) {
                if (isWindowsDriveLetter(base.path[0], true))
                  push(url.path, base.path[0]);
                else
                  url.host = base.host;
              }
              state = PATH;
              continue;
            case FILE_HOST:
              if (chr == EOF || chr == "/" || chr == "\\" || chr == "?" || chr == "#") {
                if (!stateOverride && isWindowsDriveLetter(buffer)) {
                  state = PATH;
                } else if (buffer == "") {
                  url.host = "";
                  if (stateOverride)
                    return;
                  state = PATH_START;
                } else {
                  failure = url.parseHost(buffer);
                  if (failure)
                    return failure;
                  if (url.host == "localhost")
                    url.host = "";
                  if (stateOverride)
                    return;
                  buffer = "";
                  state = PATH_START;
                }
                continue;
              } else
                buffer += chr;
              break;
            case PATH_START:
              if (url.isSpecial()) {
                state = PATH;
                if (chr != "/" && chr != "\\")
                  continue;
              } else if (!stateOverride && chr == "?") {
                url.query = "";
                state = QUERY;
              } else if (!stateOverride && chr == "#") {
                url.fragment = "";
                state = FRAGMENT;
              } else if (chr != EOF) {
                state = PATH;
                if (chr != "/")
                  continue;
              }
              break;
            case PATH:
              if (chr == EOF || chr == "/" || chr == "\\" && url.isSpecial() || !stateOverride && (chr == "?" || chr == "#")) {
                if (isDoubleDot(buffer)) {
                  url.shortenPath();
                  if (chr != "/" && !(chr == "\\" && url.isSpecial())) {
                    push(url.path, "");
                  }
                } else if (isSingleDot(buffer)) {
                  if (chr != "/" && !(chr == "\\" && url.isSpecial())) {
                    push(url.path, "");
                  }
                } else {
                  if (url.scheme == "file" && !url.path.length && isWindowsDriveLetter(buffer)) {
                    if (url.host)
                      url.host = "";
                    buffer = charAt(buffer, 0) + ":";
                  }
                  push(url.path, buffer);
                }
                buffer = "";
                if (url.scheme == "file" && (chr == EOF || chr == "?" || chr == "#")) {
                  while (url.path.length > 1 && url.path[0] === "") {
                    shift(url.path);
                  }
                }
                if (chr == "?") {
                  url.query = "";
                  state = QUERY;
                } else if (chr == "#") {
                  url.fragment = "";
                  state = FRAGMENT;
                }
              } else {
                buffer += percentEncode(chr, pathPercentEncodeSet);
              }
              break;
            case CANNOT_BE_A_BASE_URL_PATH:
              if (chr == "?") {
                url.query = "";
                state = QUERY;
              } else if (chr == "#") {
                url.fragment = "";
                state = FRAGMENT;
              } else if (chr != EOF) {
                url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
              }
              break;
            case QUERY:
              if (!stateOverride && chr == "#") {
                url.fragment = "";
                state = FRAGMENT;
              } else if (chr != EOF) {
                if (chr == "'" && url.isSpecial())
                  url.query += "%27";
                else if (chr == "#")
                  url.query += "%23";
                else
                  url.query += percentEncode(chr, C0ControlPercentEncodeSet);
              }
              break;
            case FRAGMENT:
              if (chr != EOF)
                url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
              break;
          }
          pointer++;
        }
      },
      // https://url.spec.whatwg.org/#host-parsing
      parseHost: function(input) {
        var result, codePoints, index2;
        if (charAt(input, 0) == "[") {
          if (charAt(input, input.length - 1) != "]")
            return INVALID_HOST;
          result = parseIPv6(stringSlice(input, 1, -1));
          if (!result)
            return INVALID_HOST;
          this.host = result;
        } else if (!this.isSpecial()) {
          if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input))
            return INVALID_HOST;
          result = "";
          codePoints = arrayFrom(input);
          for (index2 = 0; index2 < codePoints.length; index2++) {
            result += percentEncode(codePoints[index2], C0ControlPercentEncodeSet);
          }
          this.host = result;
        } else {
          input = toASCII(input);
          if (exec(FORBIDDEN_HOST_CODE_POINT, input))
            return INVALID_HOST;
          result = parseIPv4(input);
          if (result === null)
            return INVALID_HOST;
          this.host = result;
        }
      },
      // https://url.spec.whatwg.org/#cannot-have-a-username-password-port
      cannotHaveUsernamePasswordPort: function() {
        return !this.host || this.cannotBeABaseURL || this.scheme == "file";
      },
      // https://url.spec.whatwg.org/#include-credentials
      includesCredentials: function() {
        return this.username != "" || this.password != "";
      },
      // https://url.spec.whatwg.org/#is-special
      isSpecial: function() {
        return hasOwn(specialSchemes, this.scheme);
      },
      // https://url.spec.whatwg.org/#shorten-a-urls-path
      shortenPath: function() {
        var path = this.path;
        var pathSize = path.length;
        if (pathSize && (this.scheme != "file" || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
          path.length--;
        }
      },
      // https://url.spec.whatwg.org/#concept-url-serializer
      serialize: function() {
        var url = this;
        var scheme = url.scheme;
        var username = url.username;
        var password2 = url.password;
        var host = url.host;
        var port = url.port;
        var path = url.path;
        var query2 = url.query;
        var fragment = url.fragment;
        var output = scheme + ":";
        if (host !== null) {
          output += "//";
          if (url.includesCredentials()) {
            output += username + (password2 ? ":" + password2 : "") + "@";
          }
          output += serializeHost(host);
          if (port !== null)
            output += ":" + port;
        } else if (scheme == "file")
          output += "//";
        output += url.cannotBeABaseURL ? path[0] : path.length ? "/" + join(path, "/") : "";
        if (query2 !== null)
          output += "?" + query2;
        if (fragment !== null)
          output += "#" + fragment;
        return output;
      },
      // https://url.spec.whatwg.org/#dom-url-href
      setHref: function(href) {
        var failure = this.parse(href);
        if (failure)
          throw TypeError2(failure);
        this.searchParams.update();
      },
      // https://url.spec.whatwg.org/#dom-url-origin
      getOrigin: function() {
        var scheme = this.scheme;
        var port = this.port;
        if (scheme == "blob")
          try {
            return new URLConstructor(scheme.path[0]).origin;
          } catch (error) {
            return "null";
          }
        if (scheme == "file" || !this.isSpecial())
          return "null";
        return scheme + "://" + serializeHost(this.host) + (port !== null ? ":" + port : "");
      },
      // https://url.spec.whatwg.org/#dom-url-protocol
      getProtocol: function() {
        return this.scheme + ":";
      },
      setProtocol: function(protocol) {
        this.parse($toString(protocol) + ":", SCHEME_START);
      },
      // https://url.spec.whatwg.org/#dom-url-username
      getUsername: function() {
        return this.username;
      },
      setUsername: function(username) {
        var codePoints = arrayFrom($toString(username));
        if (this.cannotHaveUsernamePasswordPort())
          return;
        this.username = "";
        for (var i = 0; i < codePoints.length; i++) {
          this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
        }
      },
      // https://url.spec.whatwg.org/#dom-url-password
      getPassword: function() {
        return this.password;
      },
      setPassword: function(password2) {
        var codePoints = arrayFrom($toString(password2));
        if (this.cannotHaveUsernamePasswordPort())
          return;
        this.password = "";
        for (var i = 0; i < codePoints.length; i++) {
          this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
        }
      },
      // https://url.spec.whatwg.org/#dom-url-host
      getHost: function() {
        var host = this.host;
        var port = this.port;
        return host === null ? "" : port === null ? serializeHost(host) : serializeHost(host) + ":" + port;
      },
      setHost: function(host) {
        if (this.cannotBeABaseURL)
          return;
        this.parse(host, HOST);
      },
      // https://url.spec.whatwg.org/#dom-url-hostname
      getHostname: function() {
        var host = this.host;
        return host === null ? "" : serializeHost(host);
      },
      setHostname: function(hostname) {
        if (this.cannotBeABaseURL)
          return;
        this.parse(hostname, HOSTNAME);
      },
      // https://url.spec.whatwg.org/#dom-url-port
      getPort: function() {
        var port = this.port;
        return port === null ? "" : $toString(port);
      },
      setPort: function(port) {
        if (this.cannotHaveUsernamePasswordPort())
          return;
        port = $toString(port);
        if (port == "")
          this.port = null;
        else
          this.parse(port, PORT);
      },
      // https://url.spec.whatwg.org/#dom-url-pathname
      getPathname: function() {
        var path = this.path;
        return this.cannotBeABaseURL ? path[0] : path.length ? "/" + join(path, "/") : "";
      },
      setPathname: function(pathname) {
        if (this.cannotBeABaseURL)
          return;
        this.path = [];
        this.parse(pathname, PATH_START);
      },
      // https://url.spec.whatwg.org/#dom-url-search
      getSearch: function() {
        var query2 = this.query;
        return query2 ? "?" + query2 : "";
      },
      setSearch: function(search) {
        search = $toString(search);
        if (search == "") {
          this.query = null;
        } else {
          if ("?" == charAt(search, 0))
            search = stringSlice(search, 1);
          this.query = "";
          this.parse(search, QUERY);
        }
        this.searchParams.update();
      },
      // https://url.spec.whatwg.org/#dom-url-searchparams
      getSearchParams: function() {
        return this.searchParams.facade;
      },
      // https://url.spec.whatwg.org/#dom-url-hash
      getHash: function() {
        var fragment = this.fragment;
        return fragment ? "#" + fragment : "";
      },
      setHash: function(hash) {
        hash = $toString(hash);
        if (hash == "") {
          this.fragment = null;
          return;
        }
        if ("#" == charAt(hash, 0))
          hash = stringSlice(hash, 1);
        this.fragment = "";
        this.parse(hash, FRAGMENT);
      },
      update: function() {
        this.query = this.searchParams.serialize() || null;
      }
    };
    var URLConstructor = function URL4(url) {
      var that = anInstance(this, URLPrototype);
      var base = arguments.length > 1 ? arguments[1] : void 0;
      var state = setInternalState(that, new URLState(url, false, base));
      if (!DESCRIPTORS) {
        that.href = state.serialize();
        that.origin = state.getOrigin();
        that.protocol = state.getProtocol();
        that.username = state.getUsername();
        that.password = state.getPassword();
        that.host = state.getHost();
        that.hostname = state.getHostname();
        that.port = state.getPort();
        that.pathname = state.getPathname();
        that.search = state.getSearch();
        that.searchParams = state.getSearchParams();
        that.hash = state.getHash();
      }
    };
    var URLPrototype = URLConstructor.prototype;
    var accessorDescriptor = function(getter, setter) {
      return {
        get: function() {
          return getInternalURLState(this)[getter]();
        },
        set: setter && function(value) {
          return getInternalURLState(this)[setter](value);
        },
        configurable: true,
        enumerable: true
      };
    };
    if (DESCRIPTORS) {
      defineProperties(URLPrototype, {
        // `URL.prototype.href` accessors pair
        // https://url.spec.whatwg.org/#dom-url-href
        href: accessorDescriptor("serialize", "setHref"),
        // `URL.prototype.origin` getter
        // https://url.spec.whatwg.org/#dom-url-origin
        origin: accessorDescriptor("getOrigin"),
        // `URL.prototype.protocol` accessors pair
        // https://url.spec.whatwg.org/#dom-url-protocol
        protocol: accessorDescriptor("getProtocol", "setProtocol"),
        // `URL.prototype.username` accessors pair
        // https://url.spec.whatwg.org/#dom-url-username
        username: accessorDescriptor("getUsername", "setUsername"),
        // `URL.prototype.password` accessors pair
        // https://url.spec.whatwg.org/#dom-url-password
        password: accessorDescriptor("getPassword", "setPassword"),
        // `URL.prototype.host` accessors pair
        // https://url.spec.whatwg.org/#dom-url-host
        host: accessorDescriptor("getHost", "setHost"),
        // `URL.prototype.hostname` accessors pair
        // https://url.spec.whatwg.org/#dom-url-hostname
        hostname: accessorDescriptor("getHostname", "setHostname"),
        // `URL.prototype.port` accessors pair
        // https://url.spec.whatwg.org/#dom-url-port
        port: accessorDescriptor("getPort", "setPort"),
        // `URL.prototype.pathname` accessors pair
        // https://url.spec.whatwg.org/#dom-url-pathname
        pathname: accessorDescriptor("getPathname", "setPathname"),
        // `URL.prototype.search` accessors pair
        // https://url.spec.whatwg.org/#dom-url-search
        search: accessorDescriptor("getSearch", "setSearch"),
        // `URL.prototype.searchParams` getter
        // https://url.spec.whatwg.org/#dom-url-searchparams
        searchParams: accessorDescriptor("getSearchParams"),
        // `URL.prototype.hash` accessors pair
        // https://url.spec.whatwg.org/#dom-url-hash
        hash: accessorDescriptor("getHash", "setHash")
      });
    }
    redefine(URLPrototype, "toJSON", function toJSON() {
      return getInternalURLState(this).serialize();
    }, { enumerable: true });
    redefine(URLPrototype, "toString", function toString() {
      return getInternalURLState(this).serialize();
    }, { enumerable: true });
    if (NativeURL) {
      nativeCreateObjectURL = NativeURL.createObjectURL;
      nativeRevokeObjectURL = NativeURL.revokeObjectURL;
      if (nativeCreateObjectURL)
        redefine(URLConstructor, "createObjectURL", bind(nativeCreateObjectURL, NativeURL));
      if (nativeRevokeObjectURL)
        redefine(URLConstructor, "revokeObjectURL", bind(nativeRevokeObjectURL, NativeURL));
    }
    var nativeCreateObjectURL;
    var nativeRevokeObjectURL;
    setToStringTag(URLConstructor, "URL");
    $({ global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
      URL: URLConstructor
    });
  }
});

// node_modules/core-js/modules/web.url.to-json.js
var require_web_url_to_json = __commonJS({
  "node_modules/core-js/modules/web.url.to-json.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    $({ target: "URL", proto: true, enumerable: true }, {
      toJSON: function toJSON() {
        return call(URL.prototype.toString, this);
      }
    });
  }
});

// node_modules/core-js/stable/index.js
var require_stable = __commonJS({
  "node_modules/core-js/stable/index.js"(exports, module2) {
    "use strict";
    require_es_symbol();
    require_es_symbol_description();
    require_es_symbol_async_iterator();
    require_es_symbol_has_instance();
    require_es_symbol_is_concat_spreadable();
    require_es_symbol_iterator();
    require_es_symbol_match();
    require_es_symbol_match_all();
    require_es_symbol_replace();
    require_es_symbol_search();
    require_es_symbol_species();
    require_es_symbol_split();
    require_es_symbol_to_primitive();
    require_es_symbol_to_string_tag();
    require_es_symbol_unscopables();
    require_es_error_cause();
    require_es_error_to_string();
    require_es_aggregate_error();
    require_es_aggregate_error_cause();
    require_es_array_at();
    require_es_array_concat();
    require_es_array_copy_within();
    require_es_array_every();
    require_es_array_fill();
    require_es_array_filter();
    require_es_array_find();
    require_es_array_find_index();
    require_es_array_flat();
    require_es_array_flat_map();
    require_es_array_for_each();
    require_es_array_from();
    require_es_array_includes();
    require_es_array_index_of();
    require_es_array_is_array();
    require_es_array_iterator();
    require_es_array_join();
    require_es_array_last_index_of();
    require_es_array_map();
    require_es_array_of();
    require_es_array_reduce();
    require_es_array_reduce_right();
    require_es_array_reverse();
    require_es_array_slice();
    require_es_array_some();
    require_es_array_sort();
    require_es_array_species();
    require_es_array_splice();
    require_es_array_unscopables_flat();
    require_es_array_unscopables_flat_map();
    require_es_array_buffer_constructor();
    require_es_array_buffer_is_view();
    require_es_array_buffer_slice();
    require_es_data_view();
    require_es_date_get_year();
    require_es_date_now();
    require_es_date_set_year();
    require_es_date_to_gmt_string();
    require_es_date_to_iso_string();
    require_es_date_to_json();
    require_es_date_to_primitive();
    require_es_date_to_string();
    require_es_escape();
    require_es_function_bind();
    require_es_function_has_instance();
    require_es_function_name();
    require_es_global_this();
    require_es_json_stringify();
    require_es_json_to_string_tag();
    require_es_map();
    require_es_math_acosh();
    require_es_math_asinh();
    require_es_math_atanh();
    require_es_math_cbrt();
    require_es_math_clz32();
    require_es_math_cosh();
    require_es_math_expm1();
    require_es_math_fround();
    require_es_math_hypot();
    require_es_math_imul();
    require_es_math_log10();
    require_es_math_log1p();
    require_es_math_log2();
    require_es_math_sign();
    require_es_math_sinh();
    require_es_math_tanh();
    require_es_math_to_string_tag();
    require_es_math_trunc();
    require_es_number_constructor();
    require_es_number_epsilon();
    require_es_number_is_finite();
    require_es_number_is_integer();
    require_es_number_is_nan();
    require_es_number_is_safe_integer();
    require_es_number_max_safe_integer();
    require_es_number_min_safe_integer();
    require_es_number_parse_float();
    require_es_number_parse_int();
    require_es_number_to_exponential();
    require_es_number_to_fixed();
    require_es_number_to_precision();
    require_es_object_assign();
    require_es_object_create();
    require_es_object_define_getter();
    require_es_object_define_properties();
    require_es_object_define_property();
    require_es_object_define_setter();
    require_es_object_entries();
    require_es_object_freeze();
    require_es_object_from_entries();
    require_es_object_get_own_property_descriptor();
    require_es_object_get_own_property_descriptors();
    require_es_object_get_own_property_names();
    require_es_object_get_prototype_of();
    require_es_object_has_own();
    require_es_object_is();
    require_es_object_is_extensible();
    require_es_object_is_frozen();
    require_es_object_is_sealed();
    require_es_object_keys();
    require_es_object_lookup_getter();
    require_es_object_lookup_setter();
    require_es_object_prevent_extensions();
    require_es_object_seal();
    require_es_object_set_prototype_of();
    require_es_object_to_string();
    require_es_object_values();
    require_es_parse_float();
    require_es_parse_int();
    require_es_promise();
    require_es_promise_all_settled();
    require_es_promise_any();
    require_es_promise_finally();
    require_es_reflect_apply();
    require_es_reflect_construct();
    require_es_reflect_define_property();
    require_es_reflect_delete_property();
    require_es_reflect_get();
    require_es_reflect_get_own_property_descriptor();
    require_es_reflect_get_prototype_of();
    require_es_reflect_has();
    require_es_reflect_is_extensible();
    require_es_reflect_own_keys();
    require_es_reflect_prevent_extensions();
    require_es_reflect_set();
    require_es_reflect_set_prototype_of();
    require_es_reflect_to_string_tag();
    require_es_regexp_constructor();
    require_es_regexp_dot_all();
    require_es_regexp_exec();
    require_es_regexp_flags();
    require_es_regexp_sticky();
    require_es_regexp_test();
    require_es_regexp_to_string();
    require_es_set();
    require_es_string_at_alternative();
    require_es_string_code_point_at();
    require_es_string_ends_with();
    require_es_string_from_code_point();
    require_es_string_includes();
    require_es_string_iterator();
    require_es_string_match();
    require_es_string_match_all();
    require_es_string_pad_end();
    require_es_string_pad_start();
    require_es_string_raw();
    require_es_string_repeat();
    require_es_string_replace();
    require_es_string_replace_all();
    require_es_string_search();
    require_es_string_split();
    require_es_string_starts_with();
    require_es_string_substr();
    require_es_string_trim();
    require_es_string_trim_end();
    require_es_string_trim_start();
    require_es_string_anchor();
    require_es_string_big();
    require_es_string_blink();
    require_es_string_bold();
    require_es_string_fixed();
    require_es_string_fontcolor();
    require_es_string_fontsize();
    require_es_string_italics();
    require_es_string_link();
    require_es_string_small();
    require_es_string_strike();
    require_es_string_sub();
    require_es_string_sup();
    require_es_typed_array_float32_array();
    require_es_typed_array_float64_array();
    require_es_typed_array_int8_array();
    require_es_typed_array_int16_array();
    require_es_typed_array_int32_array();
    require_es_typed_array_uint8_array();
    require_es_typed_array_uint8_clamped_array();
    require_es_typed_array_uint16_array();
    require_es_typed_array_uint32_array();
    require_es_typed_array_at();
    require_es_typed_array_copy_within();
    require_es_typed_array_every();
    require_es_typed_array_fill();
    require_es_typed_array_filter();
    require_es_typed_array_find();
    require_es_typed_array_find_index();
    require_es_typed_array_for_each();
    require_es_typed_array_from();
    require_es_typed_array_includes();
    require_es_typed_array_index_of();
    require_es_typed_array_iterator();
    require_es_typed_array_join();
    require_es_typed_array_last_index_of();
    require_es_typed_array_map();
    require_es_typed_array_of();
    require_es_typed_array_reduce();
    require_es_typed_array_reduce_right();
    require_es_typed_array_reverse();
    require_es_typed_array_set();
    require_es_typed_array_slice();
    require_es_typed_array_some();
    require_es_typed_array_sort();
    require_es_typed_array_subarray();
    require_es_typed_array_to_locale_string();
    require_es_typed_array_to_string();
    require_es_unescape();
    require_es_weak_map();
    require_es_weak_set();
    require_web_dom_collections_for_each();
    require_web_dom_collections_iterator();
    require_web_dom_exception_constructor();
    require_web_dom_exception_stack();
    require_web_dom_exception_to_string_tag();
    require_web_immediate();
    require_web_queue_microtask();
    require_web_structured_clone();
    require_web_timers();
    require_web_url();
    require_web_url_to_json();
    require_web_url_search_params();
    module2.exports = require_path();
  }
});

// node_modules/regenerator-runtime/runtime.js
var require_runtime = __commonJS({
  "node_modules/regenerator-runtime/runtime.js"(exports, module2) {
    "use strict";
    var runtime = function(exports2) {
      "use strict";
      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined2;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj, key, value) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }
      try {
        define2({}, "");
      } catch (err) {
        define2 = function(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        generator._invoke = makeInvokeMethod(innerFn, self2, context);
        return generator;
      }
      exports2.wrap = wrap;
      function tryCatch(fn, obj, arg) {
        try {
          return { type: "normal", arg: fn.call(obj, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define2(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      define2(Gp, "constructor", GeneratorFunctionPrototype);
      define2(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
      GeneratorFunction.displayName = define2(
        GeneratorFunctionPrototype,
        toStringTagSymbol,
        "GeneratorFunction"
      );
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define2(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      exports2.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      exports2.mark = function(genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define2(genFun, toStringTagSymbol, "GeneratorFunction");
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };
      exports2.awrap = function(arg) {
        return { __await: arg };
      };
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve2, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve2, reject);
              }, function(err) {
                invoke("throw", err, resolve2, reject);
              });
            }
            return PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped;
              resolve2(result);
            }, function(error) {
              return invoke("throw", error, resolve2, reject);
            });
          }
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve2, reject) {
              invoke(method, arg, resolve2, reject);
            });
          }
          return previousPromise = // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
        }
        this._invoke = enqueue;
      }
      defineIteratorMethods(AsyncIterator.prototype);
      define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      });
      exports2.AsyncIterator = AsyncIterator;
      exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0)
          PromiseImpl = Promise;
        var iter = new AsyncIterator(
          wrap(innerFn, outerFn, self2, tryLocsList),
          PromiseImpl
        );
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self2, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          context.method = method;
          context.arg = arg;
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if (context.method === "next") {
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }
              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self2, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              if (record.arg === ContinueSentinel) {
                continue;
              }
              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (method === undefined2) {
          context.delegate = null;
          if (context.method === "throw") {
            if (delegate.iterator["return"]) {
              context.method = "return";
              context.arg = undefined2;
              maybeInvokeDelegate(delegate, context);
              if (context.method === "throw") {
                return ContinueSentinel;
              }
            }
            context.method = "throw";
            context.arg = new TypeError(
              "The iterator does not provide a 'throw' method"
            );
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }
        var info = record.arg;
        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }
        if (info.done) {
          context[delegate.resultName] = info.value;
          context.next = delegate.nextLoc;
          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined2;
          }
        } else {
          return info;
        }
        context.delegate = null;
        return ContinueSentinel;
      }
      defineIteratorMethods(Gp);
      define2(Gp, toStringTagSymbol, "Generator");
      define2(Gp, iteratorSymbol, function() {
        return this;
      });
      define2(Gp, "toString", function() {
        return "[object Generator]";
      });
      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{ tryLoc: "root" }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      exports2.keys = function(object) {
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key2 = keys.pop();
            if (key2 in object) {
              next.value = key2;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next2.value = iterable[i];
                  next2.done = false;
                  return next2;
                }
              }
              next2.value = undefined2;
              next2.done = true;
              return next2;
            };
            return next.next = next;
          }
        }
        return { next: doneResult };
      }
      exports2.values = values;
      function doneResult() {
        return { value: undefined2, done: true };
      }
      Context.prototype = {
        constructor: Context,
        reset: function(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined2;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined2;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined2;
              }
            }
          }
        },
        stop: function() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            if (caught) {
              context.method = "next";
              context.arg = undefined2;
            }
            return !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record);
        },
        complete: function(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        },
        finish: function(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          };
          if (this.method === "next") {
            this.arg = undefined2;
          }
          return ContinueSentinel;
        }
      };
      return exports2;
    }(
      // If this script is executing as a CommonJS module, use module.exports
      // as the regeneratorRuntime namespace. Otherwise create a new empty
      // object. Either way, the resulting object will be used to initialize
      // the regeneratorRuntime variable at the top of this file.
      typeof module2 === "object" ? module2.exports : {}
    );
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS({
  "node_modules/performance-now/lib/performance-now.js"(exports, module2) {
    "use strict";
    (function() {
      var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
      if (typeof performance !== "undefined" && performance !== null && performance.now) {
        module2.exports = function() {
          return performance.now();
        };
      } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
        module2.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module2.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module2.exports = function() {
          return (/* @__PURE__ */ new Date()).getTime() - loadTime;
        };
        loadTime = (/* @__PURE__ */ new Date()).getTime();
      }
    }).call(exports);
  }
});

// node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js"(exports, module2) {
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign(x) {
      return x < 0 ? -1 : 1;
    }
    function evenRound(x) {
      if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
      } else {
        return Math.round(x);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V, opts) {
        if (!opts)
          opts = {};
        let x = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite number");
          }
          x = sign(x) * Math.floor(Math.abs(x));
          if (x < lowerBound || x > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x;
        }
        if (!isNaN(x) && opts.clamp) {
          x = evenRound(x);
          if (x < lowerBound)
            x = lowerBound;
          if (x > upperBound)
            x = upperBound;
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
          return x - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x < 0) {
            x += moduloVal;
          } else if (x === -0) {
            return 0;
          }
        }
        return x;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V) {
      const x = +V;
      if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x;
    };
    conversions["unrestricted double"] = function(V) {
      const x = +V;
      if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
      }
      return x;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V, opts) {
      if (!opts)
        opts = {};
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      return String(V);
    };
    conversions["ByteString"] = function(V, opts) {
      const x = String(V);
      let c = void 0;
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x;
    };
    conversions["USVString"] = function(V) {
      const S = String(V);
      const n = S.length;
      const U = [];
      for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else {
          if (i === n - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d = S.charCodeAt(i + 1);
            if (56320 <= d && d <= 57343) {
              const a = c & 1023;
              const b = d & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U.join("");
    };
    conversions["Date"] = function(V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V)) {
        return void 0;
      }
      return V;
    };
    conversions["RegExp"] = function(V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V);
      }
      return V;
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js"(exports, module2) {
    "use strict";
    module2.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i = 0; i < keys.length; ++i) {
        Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// node_modules/node-fetch/node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/node-fetch/node_modules/tr46/lib/mappingTable.json"(exports, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// node_modules/node-fetch/node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/node-fetch/node_modules/tr46/index.js"(exports, module2) {
    "use strict";
    var punycode = require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s) {
        return s.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i = 0; i < len; ++i) {
        var codePoint = domain_name.codePointAt(i);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i = 0; i < len; ++i) {
        var status = findStatus(label.codePointAt(i));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i = 0; i < labels.length; ++i) {
        try {
          var validation = validateLabel(labels[i]);
          labels[i] = validation.label;
          result.error = result.error || validation.error;
        } catch (e) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l) {
        try {
          return punycode.toASCII(l);
        } catch (e) {
          result.error = true;
          return l;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i = 0; i < labels.length; ++i) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error)
        return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js"(exports, module2) {
    "use strict";
    var punycode = require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha2(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha2(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha2(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha2(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha2(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c) {
      const buf = new Buffer(c);
      let str = "";
      for (let i = 0; i < buf.length; ++i) {
        str += percentEncode(buf[i]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i = 0; i < input.length; ++i) {
        if (input[i] !== 37) {
          output.push(input[i]);
        } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
          output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
          i += 2;
        } else {
          output.push(input[i]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
          return input;
        }
        numbers.push(n);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i = 1; i <= 4; ++i) {
        output = String(n % 256) + output;
        if (i !== 4) {
          output = "." + output;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i = 0; i < decoded.length; ++i) {
        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i = 0; i < arr.length; ++i) {
        if (arr[i] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path = url.path;
      if (path.length === 0) {
        return;
      }
      if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return;
      }
      path.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (isASCIIAlpha2(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i = 0; i < buffer.length; ++i) {
          if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
            this.url.query += percentEncode(buffer[i]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string of url.path) {
          output += "/" + string;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url.path[0]));
          } catch (e) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i = 0; i < decoded.length; ++i) {
        url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url, password2) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password2);
      for (let i = 0; i < decoded.length; ++i) {
        url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module2.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js"(exports) {
    "use strict";
    var usm = require_url_state_machine();
    exports.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v) {
        const url = this._url;
        if (v === "") {
          url.query = null;
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js"(exports, module2) {
    "use strict";
    var conversions = require_lib();
    var utils = require_utils();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL4(url) {
      if (!this || this[impl] || !(this instanceof URL4)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 2; ++i) {
        args[i] = arguments[i];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL4.prototype.toJSON = function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 0; ++i) {
        args[i] = arguments[i];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL4.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true
    });
    URL4.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL4.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL4.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL4.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData)
          privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL4,
      expose: {
        Window: { URL: URL4 },
        Worker: { URL: URL4 }
      }
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js"(exports) {
    "use strict";
    exports.URL = require_URL().interface;
    exports.serializeURL = require_url_state_machine().serializeURL;
    exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports.basicURLParse = require_url_state_machine().basicURLParse;
    exports.setTheUsername = require_url_state_machine().setTheUsername;
    exports.setThePassword = require_url_state_machine().setThePassword;
    exports.serializeHost = require_url_state_machine().serializeHost;
    exports.serializeInteger = require_url_state_machine().serializeInteger;
    exports.parseURL = require_url_state_machine().parseURL;
  }
});

// node_modules/node-fetch/lib/index.mjs
var lib_exports = {};
__export(lib_exports, {
  FetchError: () => FetchError,
  Headers: () => Headers,
  Request: () => Request,
  Response: () => Response,
  default: () => lib_default
});
function FetchError(message, type, systemError) {
  Error.call(this, message);
  this.message = message;
  this.type = type;
  if (systemError) {
    this.code = this.errno = systemError.code;
  }
  Error.captureStackTrace(this, this.constructor);
}
function Body(body) {
  var _this = this;
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
  let size = _ref$size === void 0 ? 0 : _ref$size;
  var _ref$timeout = _ref.timeout;
  let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
  if (body == null) {
    body = null;
  } else if (isURLSearchParams(body)) {
    body = Buffer.from(body.toString());
  } else if (isBlob(body))
    ;
  else if (Buffer.isBuffer(body))
    ;
  else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    body = Buffer.from(body);
  } else if (ArrayBuffer.isView(body)) {
    body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
  } else if (body instanceof import_stream.default)
    ;
  else {
    body = Buffer.from(String(body));
  }
  this[INTERNALS] = {
    body,
    disturbed: false,
    error: null
  };
  this.size = size;
  this.timeout = timeout;
  if (body instanceof import_stream.default) {
    body.on("error", function(err) {
      const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
      _this[INTERNALS].error = error;
    });
  }
}
function consumeBody() {
  var _this4 = this;
  if (this[INTERNALS].disturbed) {
    return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
  }
  this[INTERNALS].disturbed = true;
  if (this[INTERNALS].error) {
    return Body.Promise.reject(this[INTERNALS].error);
  }
  let body = this.body;
  if (body === null) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return Body.Promise.resolve(body);
  }
  if (!(body instanceof import_stream.default)) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  let accum = [];
  let accumBytes = 0;
  let abort = false;
  return new Body.Promise(function(resolve2, reject) {
    let resTimeout;
    if (_this4.timeout) {
      resTimeout = setTimeout(function() {
        abort = true;
        reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
      }, _this4.timeout);
    }
    body.on("error", function(err) {
      if (err.name === "AbortError") {
        abort = true;
        reject(err);
      } else {
        reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
      }
    });
    body.on("data", function(chunk) {
      if (abort || chunk === null) {
        return;
      }
      if (_this4.size && accumBytes + chunk.length > _this4.size) {
        abort = true;
        reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
        return;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    });
    body.on("end", function() {
      if (abort) {
        return;
      }
      clearTimeout(resTimeout);
      try {
        resolve2(Buffer.concat(accum, accumBytes));
      } catch (err) {
        reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
      }
    });
  });
}
function convertBody(buffer, headers) {
  if (typeof convert !== "function") {
    throw new Error("The package `encoding` must be installed to use the textConverted() function");
  }
  const ct = headers.get("content-type");
  let charset = "utf-8";
  let res, str;
  if (ct) {
    res = /charset=([^;]*)/i.exec(ct);
  }
  str = buffer.slice(0, 1024).toString();
  if (!res && str) {
    res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
  }
  if (!res && str) {
    res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
    if (!res) {
      res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
      if (res) {
        res.pop();
      }
    }
    if (res) {
      res = /charset=(.*)/i.exec(res.pop());
    }
  }
  if (!res && str) {
    res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
  }
  if (res) {
    charset = res.pop();
    if (charset === "gb2312" || charset === "gbk") {
      charset = "gb18030";
    }
  }
  return convert(buffer, "UTF-8", charset).toString();
}
function isURLSearchParams(obj) {
  if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
    return false;
  }
  return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
}
function isBlob(obj) {
  return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}
function clone(instance) {
  let p1, p2;
  let body = instance.body;
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
    p1 = new PassThrough();
    p2 = new PassThrough();
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS].body = p1;
    body = p2;
  }
  return body;
}
function extractContentType(body) {
  if (body === null) {
    return null;
  } else if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  } else if (isURLSearchParams(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  } else if (isBlob(body)) {
    return body.type || null;
  } else if (Buffer.isBuffer(body)) {
    return null;
  } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    return null;
  } else if (ArrayBuffer.isView(body)) {
    return null;
  } else if (typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${body.getBoundary()}`;
  } else if (body instanceof import_stream.default) {
    return null;
  } else {
    return "text/plain;charset=UTF-8";
  }
}
function getTotalBytes(instance) {
  const body = instance.body;
  if (body === null) {
    return 0;
  } else if (isBlob(body)) {
    return body.size;
  } else if (Buffer.isBuffer(body)) {
    return body.length;
  } else if (body && typeof body.getLengthSync === "function") {
    if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
    body.hasKnownLength && body.hasKnownLength()) {
      return body.getLengthSync();
    }
    return null;
  } else {
    return null;
  }
}
function writeToStream(dest, instance) {
  const body = instance.body;
  if (body === null) {
    dest.end();
  } else if (isBlob(body)) {
    body.stream().pipe(dest);
  } else if (Buffer.isBuffer(body)) {
    dest.write(body);
    dest.end();
  } else {
    body.pipe(dest);
  }
}
function validateName(name) {
  name = `${name}`;
  if (invalidTokenRegex.test(name) || name === "") {
    throw new TypeError(`${name} is not a legal HTTP header name`);
  }
}
function validateValue(value) {
  value = `${value}`;
  if (invalidHeaderCharRegex.test(value)) {
    throw new TypeError(`${value} is not a legal HTTP header value`);
  }
}
function find(map, name) {
  name = name.toLowerCase();
  for (const key in map) {
    if (key.toLowerCase() === name) {
      return key;
    }
  }
  return void 0;
}
function getHeaders(headers) {
  let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
  const keys = Object.keys(headers[MAP]).sort();
  return keys.map(kind === "key" ? function(k) {
    return k.toLowerCase();
  } : kind === "value" ? function(k) {
    return headers[MAP][k].join(", ");
  } : function(k) {
    return [k.toLowerCase(), headers[MAP][k].join(", ")];
  });
}
function createHeadersIterator(target, kind) {
  const iterator = Object.create(HeadersIteratorPrototype);
  iterator[INTERNAL] = {
    target,
    kind,
    index: 0
  };
  return iterator;
}
function exportNodeCompatibleHeaders(headers) {
  const obj = Object.assign({ __proto__: null }, headers[MAP]);
  const hostHeaderKey = find(headers[MAP], "Host");
  if (hostHeaderKey !== void 0) {
    obj[hostHeaderKey] = obj[hostHeaderKey][0];
  }
  return obj;
}
function createHeadersLenient(obj) {
  const headers = new Headers();
  for (const name of Object.keys(obj)) {
    if (invalidTokenRegex.test(name)) {
      continue;
    }
    if (Array.isArray(obj[name])) {
      for (const val of obj[name]) {
        if (invalidHeaderCharRegex.test(val)) {
          continue;
        }
        if (headers[MAP][name] === void 0) {
          headers[MAP][name] = [val];
        } else {
          headers[MAP][name].push(val);
        }
      }
    } else if (!invalidHeaderCharRegex.test(obj[name])) {
      headers[MAP][name] = [obj[name]];
    }
  }
  return headers;
}
function parseURL(urlStr) {
  if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
    urlStr = new URL2(urlStr).toString();
  }
  return parse_url(urlStr);
}
function isRequest(input) {
  return typeof input === "object" && typeof input[INTERNALS$2] === "object";
}
function isAbortSignal(signal) {
  const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
  return !!(proto && proto.constructor.name === "AbortSignal");
}
function getNodeRequestOptions(request) {
  const parsedURL = request[INTERNALS$2].parsedURL;
  const headers = new Headers(request[INTERNALS$2].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  if (!parsedURL.protocol || !parsedURL.hostname) {
    throw new TypeError("Only absolute URLs are supported");
  }
  if (!/^https?:$/.test(parsedURL.protocol)) {
    throw new TypeError("Only HTTP(S) protocols are supported");
  }
  if (request.signal && request.body instanceof import_stream.default.Readable && !streamDestructionSupported) {
    throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
  }
  let contentLengthValue = null;
  if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body != null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number") {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate");
  }
  let agent = request.agent;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  if (!headers.has("Connection") && !agent) {
    headers.set("Connection", "close");
  }
  return Object.assign({}, parsedURL, {
    method: request.method,
    headers: exportNodeCompatibleHeaders(headers),
    agent
  });
}
function AbortError(message) {
  Error.call(this, message);
  this.type = "aborted";
  this.message = message;
  Error.captureStackTrace(this, this.constructor);
}
function fetch2(url, opts) {
  if (!fetch2.Promise) {
    throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
  }
  Body.Promise = fetch2.Promise;
  return new fetch2.Promise(function(resolve2, reject) {
    const request = new Request(url, opts);
    const options = getNodeRequestOptions(request);
    const send = (options.protocol === "https:" ? import_https.default : import_http.default).request;
    const signal = request.signal;
    let response = null;
    const abort = function abort2() {
      let error = new AbortError("The user aborted a request.");
      reject(error);
      if (request.body && request.body instanceof import_stream.default.Readable) {
        request.body.destroy(error);
      }
      if (!response || !response.body)
        return;
      response.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = function abortAndFinalize2() {
      abort();
      finalize();
    };
    const req = send(options);
    let reqTimeout;
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    function finalize() {
      req.abort();
      if (signal)
        signal.removeEventListener("abort", abortAndFinalize);
      clearTimeout(reqTimeout);
    }
    if (request.timeout) {
      req.once("socket", function(socket) {
        reqTimeout = setTimeout(function() {
          reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
          finalize();
        }, request.timeout);
      });
    }
    req.on("error", function(err) {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      finalize();
    });
    req.on("response", function(res) {
      clearTimeout(reqTimeout);
      const headers = createHeadersLenient(res.headers);
      if (fetch2.isRedirect(res.statusCode)) {
        const location = headers.get("Location");
        let locationURL = null;
        try {
          locationURL = location === null ? null : new URL$1(location, request.url).toString();
        } catch (err) {
          if (request.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (err) {
                reject(err);
              }
            }
            break;
          case "follow":
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOpts = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              timeout: request.timeout,
              size: request.size
            };
            if (!isDomainOrSubdomain(request.url, locationURL)) {
              for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                requestOpts.headers.delete(name);
              }
            }
            if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
              requestOpts.method = "GET";
              requestOpts.body = void 0;
              requestOpts.headers.delete("content-length");
            }
            resolve2(fetch2(new Request(locationURL, requestOpts)));
            finalize();
            return;
        }
      }
      res.once("end", function() {
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
      });
      let body = res.pipe(new PassThrough$1());
      const response_options = {
        url: request.url,
        status: res.statusCode,
        statusText: res.statusMessage,
        headers,
        size: request.size,
        timeout: request.timeout,
        counter: request.counter
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
        response = new Response(body, response_options);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings == "gzip" || codings == "x-gzip") {
        body = body.pipe(import_zlib.default.createGunzip(zlibOptions));
        response = new Response(body, response_options);
        resolve2(response);
        return;
      }
      if (codings == "deflate" || codings == "x-deflate") {
        const raw = res.pipe(new PassThrough$1());
        raw.once("data", function(chunk) {
          if ((chunk[0] & 15) === 8) {
            body = body.pipe(import_zlib.default.createInflate());
          } else {
            body = body.pipe(import_zlib.default.createInflateRaw());
          }
          response = new Response(body, response_options);
          resolve2(response);
        });
        return;
      }
      if (codings == "br" && typeof import_zlib.default.createBrotliDecompress === "function") {
        body = body.pipe(import_zlib.default.createBrotliDecompress());
        response = new Response(body, response_options);
        resolve2(response);
        return;
      }
      response = new Response(body, response_options);
      resolve2(response);
    });
    writeToStream(req, request);
  });
}
var import_stream, import_http, import_url, import_whatwg_url, import_https, import_zlib, Readable, BUFFER, TYPE, Blob2, convert, INTERNALS, PassThrough, invalidTokenRegex, invalidHeaderCharRegex, MAP, Headers, INTERNAL, HeadersIteratorPrototype, INTERNALS$1, STATUS_CODES, Response, INTERNALS$2, URL2, parse_url, format_url, streamDestructionSupported, Request, URL$1, PassThrough$1, isDomainOrSubdomain, lib_default;
var init_lib = __esm({
  "node_modules/node-fetch/lib/index.mjs"() {
    "use strict";
    import_stream = __toESM(require("stream"), 1);
    import_http = __toESM(require("http"), 1);
    import_url = __toESM(require("url"), 1);
    import_whatwg_url = __toESM(require_public_api(), 1);
    import_https = __toESM(require("https"), 1);
    import_zlib = __toESM(require("zlib"), 1);
    Readable = import_stream.default.Readable;
    BUFFER = Symbol("buffer");
    TYPE = Symbol("type");
    Blob2 = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob2.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    try {
      convert = require("encoding").convert;
    } catch (e) {
    }
    INTERNALS = Symbol("Body internals");
    PassThrough = import_stream.default.PassThrough;
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob2([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    Body.Promise = global.Promise;
    invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    MAP = Symbol("map");
    Headers = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof _Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null)
          ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback2) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback2.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    INTERNAL = Symbol("internal");
    HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index2 = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index2 >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index2 + 1;
        return {
          value: values[index2],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    INTERNALS$1 = Symbol("Response internals");
    STATUS_CODES = import_http.default.STATUS_CODES;
    Response = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    INTERNALS$2 = Symbol("Request internals");
    URL2 = import_url.default.URL || import_whatwg_url.default.URL;
    parse_url = import_url.default.parse;
    format_url = import_url.default.format;
    streamDestructionSupported = "destroy" in import_stream.default.Readable.prototype;
    Request = class _Request {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init)
          signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    URL$1 = import_url.default.URL || import_whatwg_url.default.URL;
    PassThrough$1 = import_stream.default.PassThrough;
    isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    fetch2.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch2.Promise = global.Promise;
    lib_default = fetch2;
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee7542 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    "use strict";
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee7542();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy2 = new Uint8Array(arrayView);
        return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer2(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/axios/lib/utils.js"(exports, module2) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray3(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer2(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return toString.call(val) === "[object FormData]";
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString2(val) {
      return typeof val === "string";
    }
    function isNumber3(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject2(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob2(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams2(val) {
      return toString.call(val) === "[object URLSearchParams]";
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray3(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject2(result[key]) && isPlainObject2(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject2(val)) {
          result[key] = merge({}, val);
        } else if (isArray3(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module2.exports = {
      isArray: isArray3,
      isArrayBuffer,
      isBuffer: isBuffer2,
      isFormData,
      isArrayBufferView,
      isString: isString2,
      isNumber: isNumber3,
      isObject,
      isPlainObject: isPlainObject2,
      isUndefined,
      isDate,
      isFile,
      isBlob: isBlob2,
      isFunction,
      isStream,
      isURLSearchParams: isURLSearchParams2,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/axios/lib/core/enhanceError.js"(exports, module2) {
    "use strict";
    module2.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// node_modules/axios/lib/defaults/transitional.js
var require_transitional = __commonJS({
  "node_modules/axios/lib/defaults/transitional.js"(exports, module2) {
    "use strict";
    module2.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/axios/lib/core/createError.js"(exports, module2) {
    "use strict";
    var enhanceError = require_enhanceError();
    module2.exports = function createError2(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports, module2) {
    "use strict";
    var createError2 = require_createError();
    module2.exports = function settle(resolve2, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve2(response);
      } else {
        reject(createError2(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie2 = [];
            cookie2.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie2.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie2.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie2.push("domain=" + domain);
            }
            if (secure === true) {
              cookie2.push("secure");
            }
            document.cookie = cookie2.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders2(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/axios/lib/cancel/Cancel.js"(exports, module2) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module2.exports = Cancel;
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders2 = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError2 = require_createError();
    var transitionalDefaults = require_transitional();
    var Cancel = require_Cancel();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve2, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password2 = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password2);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders2(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve2(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError2("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError2() {
          reject(createError2("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError2(
            timeoutErrorMessage,
            config,
            transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    "use strict";
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace2) {
        let hash = 0;
        for (let i = 0; i < namespace2.length; i++) {
          hash = (hash << 5) - hash + namespace2.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace2) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index2];
              match = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace2;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace2);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace2);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace2, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace2);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    "use strict";
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module2) {
    "use strict";
    var tty = require("tty");
    var util = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports, module2) {
    "use strict";
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports, module2) {
    "use strict";
    var url = require("url");
    var URL4 = url.URL;
    var http2 = require("http");
    var https2 = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded"
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback2) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString2(data) && !isBuffer2(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding)) {
        callback2 = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback2) {
          callback2();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback2);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback2) {
      if (isFunction(data)) {
        callback2 = data;
        data = encoding = null;
      } else if (isFunction(encoding)) {
        callback2 = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback2);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback2);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback2) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback2) {
          self2.removeListener("timeout", callback2);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback2) {
        this.on("timeout", callback2);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, []
        // a client MUST send the target URI in absolute-form [].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      abortRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = url.parse(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl;
      try {
        redirectUrl = url.resolve(currentUrl, location);
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
        return;
      }
      debug("redirecting to", redirectUrl);
      this._isRedirect = true;
      var redirectUrlParts = url.parse(redirectUrl);
      Object.assign(this._options, redirectUrlParts);
      if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {
        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        try {
          beforeRedirect(this._options, responseDetails, requestDetails);
        } catch (err) {
          this.emit("error", err);
          return;
        }
        this._sanitizeOptions(this._options);
      }
      try {
        this._performRequest();
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
      }
    };
    function wrap(protocols) {
      var exports2 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback2) {
          if (isString2(input)) {
            var parsed;
            try {
              parsed = urlToOptions(new URL4(input));
            } catch (err) {
              parsed = url.parse(input);
            }
            if (!isString2(parsed.protocol)) {
              throw new InvalidUrlError({ input });
            }
            input = parsed;
          } else if (URL4 && input instanceof URL4) {
            input = urlToOptions(input);
          } else {
            callback2 = options;
            options = input;
            input = { protocol };
          }
          if (isFunction(options)) {
            callback2 = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports2.maxRedirects,
            maxBodyLength: exports2.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString2(options.host) && !isString2(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback2);
        }
        function get(input, options, callback2) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback2);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports2;
    }
    function noop2() {
    }
    function urlToOptions(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? (
          /* istanbul ignore next */
          urlObject.hostname.slice(1, -1)
        ) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
      }
      return options;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        Error.captureStackTrace(this, this.constructor);
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      return CustomError;
    }
    function abortRequest(request) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop2);
      request.abort();
    }
    function isSubdomain(subdomain, domain) {
      assert(isString2(subdomain) && isString2(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString2(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isBuffer2(value) {
      return typeof value === "object" && "length" in value;
    }
    module2.exports = wrap({ http: http2, https: https2 });
    module2.exports.wrap = wrap;
  }
});

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "version": "0.26.1"
    };
  }
});

// node_modules/axios/lib/adapters/http.js
var require_http = __commonJS({
  "node_modules/axios/lib/adapters/http.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    var settle = require_settle();
    var buildFullPath = require_buildFullPath();
    var buildURL = require_buildURL();
    var http2 = require("http");
    var https2 = require("https");
    var httpFollow = require_follow_redirects().http;
    var httpsFollow = require_follow_redirects().https;
    var url = require("url");
    var zlib2 = require("zlib");
    var VERSION = require_data().version;
    var createError2 = require_createError();
    var enhanceError = require_enhanceError();
    var transitionalDefaults = require_transitional();
    var Cancel = require_Cancel();
    var isHttps = /https:?/;
    function setProxy(options, proxy, location) {
      options.hostname = proxy.host;
      options.host = proxy.host;
      options.port = proxy.port;
      options.path = location;
      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
      };
    }
    module2.exports = function httpAdapter(config) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        var resolve2 = function resolve3(value) {
          done();
          resolvePromise(value);
        };
        var rejected = false;
        var reject = function reject2(value) {
          done();
          rejected = true;
          rejectPromise(value);
        };
        var data = config.data;
        var headers = config.headers;
        var headerNames = {};
        Object.keys(headers).forEach(function storeLowerName(name) {
          headerNames[name.toLowerCase()] = name;
        });
        if ("user-agent" in headerNames) {
          if (!headers[headerNames["user-agent"]]) {
            delete headers[headerNames["user-agent"]];
          }
        } else {
          headers["User-Agent"] = "axios/" + VERSION;
        }
        if (data && !utils.isStream(data)) {
          if (Buffer.isBuffer(data)) {
          } else if (utils.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(createError2(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              config
            ));
          }
          if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
            return reject(createError2("Request body larger than maxBodyLength limit", config));
          }
          if (!headerNames["content-length"]) {
            headers["Content-Length"] = data.length;
          }
        }
        var auth = void 0;
        if (config.auth) {
          var username = config.auth.username || "";
          var password2 = config.auth.password || "";
          auth = username + ":" + password2;
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || "http:";
        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(":");
          var urlUsername = urlAuth[0] || "";
          var urlPassword = urlAuth[1] || "";
          auth = urlUsername + ":" + urlPassword;
        }
        if (auth && headerNames.authorization) {
          delete headers[headerNames.authorization];
        }
        var isHttpsRequest = isHttps.test(protocol);
        var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        try {
          buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, "");
        } catch (err) {
          var customErr = new Error(err.message);
          customErr.config = config;
          customErr.url = config.url;
          customErr.exists = true;
          reject(customErr);
        }
        var options = {
          path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
          method: config.method.toUpperCase(),
          headers,
          agent,
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth
        };
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname;
          options.port = parsed.port;
        }
        var proxy = config.proxy;
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol.slice(0, -1) + "_proxy";
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl);
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
            var shouldProxy = true;
            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(",").map(function trim(s) {
                return s.trim();
              });
              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false;
                }
                if (proxyElement === "*") {
                  return true;
                }
                if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true;
                }
                return parsed.hostname === proxyElement;
              });
            }
            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              };
              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                };
              }
            }
          }
        }
        if (proxy) {
          options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
          setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsProxy ? https2 : http2;
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        }
        if (config.insecureHTTPParser) {
          options.insecureHTTPParser = config.insecureHTTPParser;
        }
        var req = transport.request(options, function handleResponse(res) {
          if (req.aborted)
            return;
          var stream = res;
          var lastRequest = res.req || req;
          if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
            switch (res.headers["content-encoding"]) {
              case "gzip":
              case "compress":
              case "deflate":
                stream = stream.pipe(zlib2.createUnzip());
                delete res.headers["content-encoding"];
                break;
            }
          }
          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config,
            request: lastRequest
          };
          if (config.responseType === "stream") {
            response.data = stream;
            settle(resolve2, reject, response);
          } else {
            var responseBuffer = [];
            var totalResponseBytes = 0;
            stream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                rejected = true;
                stream.destroy();
                reject(createError2(
                  "maxContentLength size of " + config.maxContentLength + " exceeded",
                  config,
                  null,
                  lastRequest
                ));
              }
            });
            stream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              stream.destroy();
              reject(createError2("error request aborted", config, "ERR_REQUEST_ABORTED", lastRequest));
            });
            stream.on("error", function handleStreamError(err) {
              if (req.aborted)
                return;
              reject(enhanceError(err, config, null, lastRequest));
            });
            stream.on("end", function handleStreamEnd() {
              try {
                var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (config.responseType !== "arraybuffer") {
                  responseData = responseData.toString(config.responseEncoding);
                  if (!config.responseEncoding || config.responseEncoding === "utf8") {
                    responseData = utils.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                reject(enhanceError(err, config, err.code, response.request, response));
              }
              settle(resolve2, reject, response);
            });
          }
        });
        req.on("error", function handleRequestError(err) {
          if (req.aborted && err.code !== "ERR_FR_TOO_MANY_REDIRECTS")
            return;
          reject(enhanceError(err, config, null, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config.timeout) {
          var timeout = parseInt(config.timeout, 10);
          if (isNaN(timeout)) {
            reject(createError2(
              "error trying to parse `config.timeout` to int",
              config,
              "ERR_PARSE_TIMEOUT",
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            req.abort();
            var timeoutErrorMessage = "";
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            } else {
              timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
            }
            var transitional = config.transitional || transitionalDefaults;
            reject(createError2(
              timeoutErrorMessage,
              config,
              transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
              req
            ));
          });
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (req.aborted)
              return;
            req.abort();
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (utils.isStream(data)) {
          data.on("error", function handleStreamError(err) {
            reject(enhanceError(err, config, null, req));
          }).pipe(req);
        } else {
          req.end(data);
        }
      });
    };
  }
});

// node_modules/axios/lib/defaults/index.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults/index.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var transitionalDefaults = require_transitional();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_http();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    var defaults = require_defaults();
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports, module2) {
    "use strict";
    var VERSION = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module2.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios3(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios3.prototype.request = function request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios3.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios3.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios3.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module2.exports = Axios3;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports, module2) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve2) {
        resolvePromise = resolve2;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve2) {
          token.subscribe(resolve2);
          _resolve = resolve2;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index2 = this._listeners.indexOf(listener);
      if (index2 !== -1) {
        this._listeners.splice(index2, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports, module2) {
    "use strict";
    module2.exports = function spread(callback2) {
      return function wrap(arr) {
        return callback2.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    var bind = require_bind();
    var Axios3 = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios3(defaultConfig);
      var instance = bind(Axios3.prototype.request, context);
      utils.extend(instance, Axios3.prototype, context);
      utils.extend(instance, context);
      instance.create = function create3(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios2 = createInstance(defaults);
    axios2.Axios = Axios3;
    axios2.Cancel = require_Cancel();
    axios2.CancelToken = require_CancelToken();
    axios2.isCancel = require_isCancel();
    axios2.VERSION = require_data().version;
    axios2.all = function all(promises) {
      return Promise.all(promises);
    };
    axios2.spread = require_spread();
    axios2.isAxiosError = require_isAxiosError();
    module2.exports = axios2;
    module2.exports.default = axios2;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_axios();
  }
});

// node_modules/@sendgrid/client/package.json
var require_package = __commonJS({
  "node_modules/@sendgrid/client/package.json"(exports, module2) {
    module2.exports = {
      name: "@sendgrid/client",
      description: "Twilio SendGrid NodeJS API client",
      version: "7.7.0",
      author: "Twilio SendGrid <help@twilio.com> (sendgrid.com)",
      contributors: [
        "Kyle Partridge <kyle.partridge@sendgrid.com>",
        "David Tomberlin <david.tomberlin@sendgrid.com>",
        "Swift <swift@sendgrid.com>",
        "Brandon West <brandon.west@sendgrid.com>",
        "Scott Motte <scott.motte@sendgrid.com>",
        "Robert Acosta <robert.acosta@sendgrid.com>",
        "Elmer Thomas <ethomas@twilio.com>",
        "Adam Reis <adam@reis.nz>"
      ],
      license: "MIT",
      homepage: "https://sendgrid.com",
      repository: {
        type: "git",
        url: "git://github.com/sendgrid/sendgrid-nodejs.git"
      },
      publishConfig: {
        access: "public"
      },
      main: "index.js",
      engines: {
        node: "6.* || 8.* || >=10.*"
      },
      dependencies: {
        "@sendgrid/helpers": "^7.7.0",
        axios: "^0.26.0"
      },
      devDependencies: {
        chai: "4.2.0",
        nock: "^10.0.6"
      },
      resolutions: {
        chai: "4.2.0"
      },
      tags: [
        "http",
        "rest",
        "api",
        "mail",
        "sendgrid"
      ],
      gitHead: "30eebb16a51b51e6a2df1b3596044db6f5fdbe92"
    };
  }
});

// node_modules/@sendgrid/helpers/helpers/convert-keys.js
var require_convert_keys = __commonJS({
  "node_modules/@sendgrid/helpers/helpers/convert-keys.js"(exports, module2) {
    "use strict";
    module2.exports = function convertKeys(obj, converter, ignored) {
      if (typeof obj !== "object" || obj === null) {
        throw new Error("Non object passed to convertKeys: " + obj);
      }
      if (Array.isArray(obj)) {
        return obj;
      }
      if (!Array.isArray(ignored)) {
        ignored = [];
      }
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          const converted = converter(key);
          if (typeof obj[key] === "object" && obj[key] !== null) {
            if (!ignored.includes(key) && !ignored.includes(converted)) {
              obj[key] = convertKeys(obj[key], converter, ignored);
            }
          }
          if (converted !== key) {
            obj[converted] = obj[key];
            delete obj[key];
          }
        }
      }
      return obj;
    };
  }
});

// node_modules/@sendgrid/helpers/helpers/str-to-camel-case.js
var require_str_to_camel_case = __commonJS({
  "node_modules/@sendgrid/helpers/helpers/str-to-camel-case.js"(exports, module2) {
    "use strict";
    module2.exports = function strToCamelCase(str) {
      if (typeof str !== "string") {
        throw new Error("String expected for conversion to snake case");
      }
      return str.trim().replace(/_+|\-+/g, " ").replace(/(?:^\w|[A-Z]|\b\w|\s+)/g, function(match, index2) {
        if (Number(match) === 0) {
          return "";
        }
        return index2 === 0 ? match.toLowerCase() : match.toUpperCase();
      });
    };
  }
});

// node_modules/@sendgrid/helpers/helpers/to-camel-case.js
var require_to_camel_case = __commonJS({
  "node_modules/@sendgrid/helpers/helpers/to-camel-case.js"(exports, module2) {
    "use strict";
    var convertKeys = require_convert_keys();
    var strToCamelCase = require_str_to_camel_case();
    module2.exports = function toCamelCase(obj, ignored) {
      return convertKeys(obj, strToCamelCase, ignored);
    };
  }
});

// node_modules/@sendgrid/helpers/helpers/str-to-snake-case.js
var require_str_to_snake_case = __commonJS({
  "node_modules/@sendgrid/helpers/helpers/str-to-snake-case.js"(exports, module2) {
    "use strict";
    module2.exports = function strToSnakeCase(str) {
      if (typeof str !== "string") {
        throw new Error("String expected for conversion to snake case");
      }
      return str.trim().replace(/(\s*\-*\b\w|[A-Z])/g, function($1) {
        $1 = $1.trim().toLowerCase().replace("-", "");
        return ($1[0] === "_" ? "" : "_") + $1;
      }).slice(1);
    };
  }
});

// node_modules/@sendgrid/helpers/helpers/to-snake-case.js
var require_to_snake_case = __commonJS({
  "node_modules/@sendgrid/helpers/helpers/to-snake-case.js"(exports, module2) {
    "use strict";
    var convertKeys = require_convert_keys();
    var strToSnakeCase = require_str_to_snake_case();
    module2.exports = function toSnakeCase(obj, ignored) {
      return convertKeys(obj, strToSnakeCase, ignored);
    };
  }
});

// node_modules/@sendgrid/helpers/helpers/deep-clone.js
var require_deep_clone = __commonJS({
  "node_modules/@sendgrid/helpers/helpers/deep-clone.js"(exports, module2) {
    "use strict";
    module2.exports = function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    };
  }
});

// node_modules/@sendgrid/helpers/classes/attachment.js
var require_attachment = __commonJS({
  "node_modules/@sendgrid/helpers/classes/attachment.js"(exports, module2) {
    "use strict";
    var toCamelCase = require_to_camel_case();
    var toSnakeCase = require_to_snake_case();
    var deepClone = require_deep_clone();
    var fs = require("fs");
    var path = require("path");
    var Attachment = class {
      /**
       * Constructor
       */
      constructor(data) {
        if (data) {
          this.fromData(data);
        }
      }
      /**
       * From data
       */
      fromData(data) {
        if (typeof data !== "object") {
          throw new Error("Expecting object for Mail data");
        }
        data = deepClone(data);
        data = toCamelCase(data);
        const {
          content,
          filename,
          type,
          disposition,
          contentId,
          filePath
        } = data;
        if (typeof content !== "undefined" && typeof filePath !== "undefined") {
          throw new Error(
            "The props 'content' and 'filePath' cannot be used together."
          );
        }
        this.setFilename(filename);
        this.setType(type);
        this.setDisposition(disposition);
        this.setContentId(contentId);
        this.setContent(filePath ? this.readFile(filePath) : content);
      }
      /**
       * Read a file and return its content as base64
       */
      readFile(filePath) {
        return fs.readFileSync(path.resolve(filePath));
      }
      /**
       * Set content
       */
      setContent(content) {
        if (typeof content === "string") {
          this.content = content;
          return;
        } else if (content instanceof Buffer && content.toString !== void 0) {
          this.content = content.toString();
          if (this.disposition === "attachment") {
            this.content = content.toString("base64");
          }
          return;
        }
        throw new Error("`content` expected to be either Buffer or string");
      }
      /**
       * Set content
       */
      setFileContent(content) {
        if (content instanceof Buffer && content.toString !== void 0) {
          this.content = content.toString("base64");
          return;
        }
        throw new Error("`content` expected to be Buffer");
      }
      /**
       * Set filename
       */
      setFilename(filename) {
        if (typeof filename === "undefined") {
          return;
        }
        if (filename && typeof filename !== "string") {
          throw new Error("String expected for `filename`");
        }
        this.filename = filename;
      }
      /**
       * Set type
       */
      setType(type) {
        if (typeof type === "undefined") {
          return;
        }
        if (typeof type !== "string") {
          throw new Error("String expected for `type`");
        }
        this.type = type;
      }
      /**
       * Set disposition
       */
      setDisposition(disposition) {
        if (typeof disposition === "undefined") {
          return;
        }
        if (typeof disposition !== "string") {
          throw new Error("String expected for `disposition`");
        }
        this.disposition = disposition;
      }
      /**
       * Set content ID
       */
      setContentId(contentId) {
        if (typeof contentId === "undefined") {
          return;
        }
        if (typeof contentId !== "string") {
          throw new Error("String expected for `contentId`");
        }
        this.contentId = contentId;
      }
      /**
       * To JSON
       */
      toJSON() {
        const { content, filename, type, disposition, contentId } = this;
        const json = { content, filename };
        if (typeof type !== "undefined") {
          json.type = type;
        }
        if (typeof disposition !== "undefined") {
          json.disposition = disposition;
        }
        if (typeof contentId !== "undefined") {
          json.contentId = contentId;
        }
        return toSnakeCase(json);
      }
    };
    module2.exports = Attachment;
  }
});

// node_modules/@sendgrid/helpers/helpers/split-name-email.js
var require_split_name_email = __commonJS({
  "node_modules/@sendgrid/helpers/helpers/split-name-email.js"(exports, module2) {
    "use strict";
    module2.exports = function splitNameEmail(str) {
      if (str.indexOf("<") === -1) {
        return ["", str];
      }
      let [name, email] = str.split("<");
      name = name.trim();
      email = email.replace(">", "").trim();
      return [name, email];
    };
  }
});

// node_modules/@sendgrid/helpers/classes/email-address.js
var require_email_address = __commonJS({
  "node_modules/@sendgrid/helpers/classes/email-address.js"(exports, module2) {
    "use strict";
    var splitNameEmail = require_split_name_email();
    var EmailAddress = class _EmailAddress {
      /**
      * Constructor
      */
      constructor(data) {
        if (data) {
          this.fromData(data);
        }
      }
      /**
       * From data
       */
      fromData(data) {
        if (typeof data === "string") {
          const [name2, email2] = splitNameEmail(data);
          data = { name: name2, email: email2 };
        }
        if (typeof data !== "object") {
          throw new Error("Expecting object or string for EmailAddress data");
        }
        const { name, email } = data;
        this.setEmail(email);
        this.setName(name);
      }
      /**
       * Set name
       */
      setName(name) {
        if (typeof name === "undefined") {
          return;
        }
        if (typeof name !== "string") {
          throw new Error("String expected for `name`");
        }
        this.name = name;
      }
      /**
       * Set email (mandatory)
       */
      setEmail(email) {
        if (typeof email === "undefined") {
          throw new Error("Must provide `email`");
        }
        if (typeof email !== "string") {
          throw new Error("String expected for `email`");
        }
        this.email = email;
      }
      /**
      * To JSON
      */
      toJSON() {
        const { email, name } = this;
        const json = { email };
        if (name !== "") {
          json.name = name;
        }
        return json;
      }
      /**************************************************************************
       * Static helpers
       ***/
      /**
       * Create an EmailAddress instance from given data
       */
      static create(data) {
        if (Array.isArray(data)) {
          return data.filter((item) => !!item).map((item) => this.create(item));
        }
        if (data instanceof _EmailAddress) {
          return data;
        }
        return new _EmailAddress(data);
      }
    };
    module2.exports = EmailAddress;
  }
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports, module2) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return target.propertyIsEnumerable(symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module2.exports = deepmerge_1;
  }
});

// node_modules/@sendgrid/helpers/helpers/wrap-substitutions.js
var require_wrap_substitutions = __commonJS({
  "node_modules/@sendgrid/helpers/helpers/wrap-substitutions.js"(exports, module2) {
    "use strict";
    module2.exports = function wrap(substitutions, left = "{{", right = "}}") {
      if (Array.isArray(substitutions)) {
        return substitutions.map((subs) => wrap(subs, left, right));
      }
      const wrapped = {};
      for (const key in substitutions) {
        if (substitutions.hasOwnProperty(key)) {
          wrapped[left + key + right] = String(substitutions[key]);
        }
      }
      return wrapped;
    };
  }
});

// node_modules/@sendgrid/helpers/classes/personalization.js
var require_personalization = __commonJS({
  "node_modules/@sendgrid/helpers/classes/personalization.js"(exports, module2) {
    "use strict";
    var EmailAddress = require_email_address();
    var toCamelCase = require_to_camel_case();
    var toSnakeCase = require_to_snake_case();
    var deepClone = require_deep_clone();
    var deepMerge = require_cjs();
    var wrapSubstitutions = require_wrap_substitutions();
    var Personalization = class {
      /**
       * Constructor
       */
      constructor(data) {
        this.to = [];
        this.cc = [];
        this.bcc = [];
        this.headers = {};
        this.customArgs = {};
        this.substitutions = {};
        this.substitutionWrappers = ["{{", "}}"];
        this.dynamicTemplateData = {};
        if (data) {
          this.fromData(data);
        }
      }
      /**
       * From data
       */
      fromData(data) {
        if (typeof data !== "object") {
          throw new Error("Expecting object for Mail data");
        }
        data = deepClone(data);
        data = toCamelCase(data, ["substitutions", "dynamicTemplateData", "customArgs", "headers"]);
        const {
          to,
          from,
          cc,
          bcc,
          subject,
          headers,
          customArgs,
          sendAt,
          substitutions,
          substitutionWrappers,
          dynamicTemplateData
        } = data;
        this.setTo(to);
        this.setFrom(from);
        this.setCc(cc);
        this.setBcc(bcc);
        this.setSubject(subject);
        this.setHeaders(headers);
        this.setSubstitutions(substitutions);
        this.setSubstitutionWrappers(substitutionWrappers);
        this.setCustomArgs(customArgs);
        this.setDynamicTemplateData(dynamicTemplateData);
        this.setSendAt(sendAt);
      }
      /**
       * Set subject
       */
      setSubject(subject) {
        if (typeof subject === "undefined") {
          return;
        }
        if (typeof subject !== "string") {
          throw new Error("String expected for `subject`");
        }
        this.subject = subject;
      }
      /**
       * Set send at
       */
      setSendAt(sendAt) {
        if (typeof sendAt === "undefined") {
          return;
        }
        if (!Number.isInteger(sendAt)) {
          throw new Error("Integer expected for `sendAt`");
        }
        this.sendAt = sendAt;
      }
      /**
       * Set to
       */
      setTo(to) {
        if (typeof to === "undefined") {
          return;
        }
        if (!Array.isArray(to)) {
          to = [to];
        }
        this.to = EmailAddress.create(to);
      }
      /**
       * Set from
       * */
      setFrom(from) {
        if (typeof from === "undefined") {
          return;
        }
        this.from = EmailAddress.create(from);
      }
      /**
       * Add a single to
       */
      addTo(to) {
        if (typeof to === "undefined") {
          return;
        }
        this.to.push(EmailAddress.create(to));
      }
      /**
       * Set cc
       */
      setCc(cc) {
        if (typeof cc === "undefined") {
          return;
        }
        if (!Array.isArray(cc)) {
          cc = [cc];
        }
        this.cc = EmailAddress.create(cc);
      }
      /**
       * Add a single cc
       */
      addCc(cc) {
        if (typeof cc === "undefined") {
          return;
        }
        this.cc.push(EmailAddress.create(cc));
      }
      /**
       * Set bcc
       */
      setBcc(bcc) {
        if (typeof bcc === "undefined") {
          return;
        }
        if (!Array.isArray(bcc)) {
          bcc = [bcc];
        }
        this.bcc = EmailAddress.create(bcc);
      }
      /**
       * Add a single bcc
       */
      addBcc(bcc) {
        if (typeof bcc === "undefined") {
          return;
        }
        this.bcc.push(EmailAddress.create(bcc));
      }
      /**
       * Set headers
       */
      setHeaders(headers) {
        if (typeof headers === "undefined") {
          return;
        }
        if (typeof headers !== "object" || headers === null) {
          throw new Error("Object expected for `headers`");
        }
        this.headers = headers;
      }
      /**
       * Add a header
       */
      addHeader(key, value) {
        if (typeof key !== "string") {
          throw new Error("String expected for header key");
        }
        if (typeof value !== "string") {
          throw new Error("String expected for header value");
        }
        this.headers[key] = value;
      }
      /**
       * Set custom args
       */
      setCustomArgs(customArgs) {
        if (typeof customArgs === "undefined") {
          return;
        }
        if (typeof customArgs !== "object" || customArgs === null) {
          throw new Error("Object expected for `customArgs`");
        }
        this.customArgs = customArgs;
      }
      /**
       * Add a custom arg
       */
      addCustomArg(key, value) {
        if (typeof key !== "string") {
          throw new Error("String expected for custom arg key");
        }
        if (typeof value !== "string") {
          throw new Error("String expected for custom arg value");
        }
        this.customArgs[key] = value;
      }
      /**
       * Set substitutions
       */
      setSubstitutions(substitutions) {
        if (typeof substitutions === "undefined") {
          return;
        }
        if (typeof substitutions !== "object") {
          throw new Error("Object expected for `substitutions`");
        }
        this.substitutions = substitutions;
      }
      /**
       * Add a substitution
       */
      addSubstitution(key, value) {
        if (typeof key !== "string") {
          throw new Error("String expected for substitution key");
        }
        if (typeof value !== "string" && typeof value !== "number") {
          throw new Error("String or Number expected for substitution value");
        }
        this.substitutions[key] = value;
      }
      /**
       * Reverse merge substitutions, preserving existing ones
       */
      reverseMergeSubstitutions(substitutions) {
        if (typeof substitutions === "undefined" || substitutions === null) {
          return;
        }
        if (typeof substitutions !== "object") {
          throw new Error(
            "Object expected for `substitutions` in reverseMergeSubstitutions"
          );
        }
        this.substitutions = Object.assign({}, substitutions, this.substitutions);
      }
      /**
       * Set substitution wrappers
       */
      setSubstitutionWrappers(wrappers) {
        if (typeof wrappers === "undefined" || wrappers === null) {
          return;
        }
        if (!Array.isArray(wrappers) || wrappers.length !== 2) {
          throw new Error(
            "Array expected with two elements for `substitutionWrappers`"
          );
        }
        this.substitutionWrappers = wrappers;
      }
      /**
       * Reverse merge dynamic template data, preserving existing ones
       */
      deepMergeDynamicTemplateData(dynamicTemplateData) {
        if (typeof dynamicTemplateData === "undefined" || dynamicTemplateData === null) {
          return;
        }
        if (typeof dynamicTemplateData !== "object") {
          throw new Error(
            "Object expected for `dynamicTemplateData` in deepMergeDynamicTemplateData"
          );
        }
        this.dynamicTemplateData = deepMerge(dynamicTemplateData, this.dynamicTemplateData);
      }
      /**
       * Set dynamic template data
       */
      setDynamicTemplateData(dynamicTemplateData) {
        if (typeof dynamicTemplateData === "undefined") {
          return;
        }
        if (typeof dynamicTemplateData !== "object") {
          throw new Error("Object expected for `dynamicTemplateData`");
        }
        this.dynamicTemplateData = dynamicTemplateData;
      }
      /**
       * To JSON
       */
      toJSON() {
        const {
          to,
          from,
          cc,
          bcc,
          subject,
          headers,
          customArgs,
          sendAt,
          substitutions,
          substitutionWrappers,
          dynamicTemplateData
        } = this;
        const json = { to };
        if (Array.isArray(cc) && cc.length > 0) {
          json.cc = cc;
        }
        if (Array.isArray(bcc) && bcc.length > 0) {
          json.bcc = bcc;
        }
        if (Object.keys(headers).length > 0) {
          json.headers = headers;
        }
        if (substitutions && Object.keys(substitutions).length > 0) {
          const [left, right] = substitutionWrappers;
          json.substitutions = wrapSubstitutions(substitutions, left, right);
        }
        if (Object.keys(customArgs).length > 0) {
          json.customArgs = customArgs;
        }
        if (dynamicTemplateData && Object.keys(dynamicTemplateData).length > 0) {
          json.dynamicTemplateData = dynamicTemplateData;
        }
        if (typeof subject !== "undefined") {
          json.subject = subject;
        }
        if (typeof sendAt !== "undefined") {
          json.sendAt = sendAt;
        }
        if (typeof from !== "undefined") {
          json.from = from;
        }
        return toSnakeCase(json, ["substitutions", "dynamicTemplateData", "customArgs", "headers"]);
      }
    };
    module2.exports = Personalization;
  }
});

// node_modules/@sendgrid/helpers/helpers/array-to-json.js
var require_array_to_json = __commonJS({
  "node_modules/@sendgrid/helpers/helpers/array-to-json.js"(exports, module2) {
    "use strict";
    module2.exports = function arrayToJSON(arr) {
      return arr.map((item) => {
        if (typeof item === "object" && item !== null && typeof item.toJSON === "function") {
          return item.toJSON();
        }
        return item;
      });
    };
  }
});

// node_modules/@sendgrid/helpers/constants/index.js
var require_constants = __commonJS({
  "node_modules/@sendgrid/helpers/constants/index.js"(exports, module2) {
    "use strict";
    var DYNAMIC_TEMPLATE_CHAR_WARNING = `
Content with characters ', " or & may need to be escaped with three brackets
{{{ content }}}
See https://sendgrid.com/docs/for-developers/sending-email/using-handlebars/ for more information.`;
    module2.exports = {
      DYNAMIC_TEMPLATE_CHAR_WARNING
    };
  }
});

// node_modules/@sendgrid/helpers/helpers/validate-settings.js
var require_validate_settings = __commonJS({
  "node_modules/@sendgrid/helpers/helpers/validate-settings.js"(exports, module2) {
    "use strict";
    var validate3 = (parent, parentName, childName, childType) => {
      if (typeof parent === "undefined" || typeof parent[childName] === "undefined") {
        return;
      }
      if (typeof parent[childName] !== childType) {
        throw new Error(`${childType} expected for \`${parentName}.${childName}\``);
      }
    };
    module2.exports = {
      validateMailSettings(settings) {
        if (typeof settings !== "object") {
          throw new Error("Object expected for `mailSettings`");
        }
        const {
          bcc,
          bypassListManagement,
          bypassSpamManagement,
          bypassBounceManagement,
          bypassUnsubscribeManagement,
          footer,
          sandboxMode,
          spamCheck
        } = settings;
        validate3(bcc, "bcc", "enable", "boolean");
        validate3(bcc, "bcc", "email", "string");
        validate3(bypassListManagement, "bypassListManagement", "enable", "boolean");
        validate3(bypassSpamManagement, "bypassSpamManagement", "enable", "boolean");
        validate3(bypassBounceManagement, "bypassBounceManagement", "enable", "boolean");
        validate3(bypassUnsubscribeManagement, "bypassUnsubscribeManagement", "enable", "boolean");
        validate3(footer, "footer", "enable", "boolean");
        validate3(footer, "footer", "text", "string");
        validate3(footer, "footer", "html", "string");
        validate3(sandboxMode, "sandboxMode", "enable", "boolean");
        validate3(spamCheck, "spamCheck", "enable", "boolean");
        validate3(spamCheck, "spamCheck", "threshold", "number");
        validate3(spamCheck, "spamCheck", "postToUrl", "string");
      },
      validateTrackingSettings(settings) {
        if (typeof settings !== "object") {
          throw new Error("Object expected for `trackingSettings`");
        }
        const {
          clickTracking,
          openTracking,
          subscriptionTracking,
          ganalytics
        } = settings;
        validate3(clickTracking, "clickTracking", "enable", "boolean");
        validate3(clickTracking, "clickTracking", "enableText", "boolean");
        validate3(openTracking, "openTracking", "enable", "boolean");
        validate3(openTracking, "openTracking", "substitutionTag", "string");
        validate3(subscriptionTracking, "subscriptionTracking", "enable", "boolean");
        validate3(subscriptionTracking, "subscriptionTracking", "text", "string");
        validate3(subscriptionTracking, "subscriptionTracking", "html", "string");
        validate3(subscriptionTracking, "subscriptionTracking", "substitutionTag", "string");
        validate3(ganalytics, "ganalytics", "enable", "boolean");
        validate3(ganalytics, "ganalytics", "utm_source", "string");
        validate3(ganalytics, "ganalytics", "utm_medium", "string");
        validate3(ganalytics, "ganalytics", "utm_term", "string");
        validate3(ganalytics, "ganalytics", "utm_content", "string");
        validate3(ganalytics, "ganalytics", "utm_campaign", "string");
      }
    };
  }
});

// node_modules/@sendgrid/helpers/classes/mail.js
var require_mail = __commonJS({
  "node_modules/@sendgrid/helpers/classes/mail.js"(exports, module2) {
    "use strict";
    var EmailAddress = require_email_address();
    var Personalization = require_personalization();
    var toCamelCase = require_to_camel_case();
    var toSnakeCase = require_to_snake_case();
    var deepClone = require_deep_clone();
    var arrayToJSON = require_array_to_json();
    var { DYNAMIC_TEMPLATE_CHAR_WARNING } = require_constants();
    var { validateMailSettings, validateTrackingSettings } = require_validate_settings();
    var Mail = class _Mail {
      /**
       * Constructor
       */
      constructor(data) {
        this.isDynamic = false;
        this.hideWarnings = false;
        this.personalizations = [];
        this.attachments = [];
        this.content = [];
        this.categories = [];
        this.headers = {};
        this.sections = {};
        this.customArgs = {};
        this.trackingSettings = {};
        this.mailSettings = {};
        this.asm = {};
        this.substitutions = null;
        this.substitutionWrappers = null;
        this.dynamicTemplateData = null;
        if (data) {
          this.fromData(data);
        }
      }
      /**
       * Build from data
       */
      fromData(data) {
        if (typeof data !== "object") {
          throw new Error("Expecting object for Mail data");
        }
        data = deepClone(data);
        data = toCamelCase(data, ["substitutions", "dynamicTemplateData", "customArgs", "headers", "sections"]);
        const {
          to,
          from,
          replyTo,
          cc,
          bcc,
          sendAt,
          subject,
          text,
          html,
          content,
          templateId,
          personalizations,
          attachments,
          ipPoolName,
          batchId,
          sections,
          headers,
          categories,
          category,
          customArgs,
          asm,
          mailSettings,
          trackingSettings,
          substitutions,
          substitutionWrappers,
          dynamicTemplateData,
          isMultiple,
          hideWarnings,
          replyToList
        } = data;
        this.setFrom(from);
        this.setReplyTo(replyTo);
        this.setSubject(subject);
        this.setSendAt(sendAt);
        this.setTemplateId(templateId);
        this.setBatchId(batchId);
        this.setIpPoolName(ipPoolName);
        this.setAttachments(attachments);
        this.setContent(content);
        this.setSections(sections);
        this.setHeaders(headers);
        this.setCategories(category);
        this.setCategories(categories);
        this.setCustomArgs(customArgs);
        this.setAsm(asm);
        this.setMailSettings(mailSettings);
        this.setTrackingSettings(trackingSettings);
        this.setHideWarnings(hideWarnings);
        this.setReplyToList(replyToList);
        if (this.isDynamic) {
          this.setDynamicTemplateData(dynamicTemplateData);
        } else {
          this.setSubstitutions(substitutions);
          this.setSubstitutionWrappers(substitutionWrappers);
        }
        this.addTextContent(text);
        this.addHtmlContent(html);
        if (personalizations) {
          this.setPersonalizations(personalizations);
        } else if (isMultiple && Array.isArray(to)) {
          to.forEach((to2) => this.addTo(to2, cc, bcc));
        } else {
          this.addTo(to, cc, bcc);
        }
      }
      /**
       * Set from email
       */
      setFrom(from) {
        if (this._checkProperty("from", from, [this._checkUndefined])) {
          if (typeof from !== "string" && typeof from.email !== "string") {
            throw new Error("String or address object expected for `from`");
          }
          this.from = EmailAddress.create(from);
        }
      }
      /**
       * Set reply to
       */
      setReplyTo(replyTo) {
        if (this._checkProperty("replyTo", replyTo, [this._checkUndefined])) {
          if (typeof replyTo !== "string" && typeof replyTo.email !== "string") {
            throw new Error("String or address object expected for `replyTo`");
          }
          this.replyTo = EmailAddress.create(replyTo);
        }
      }
      /**
       * Set subject
       */
      setSubject(subject) {
        this._setProperty("subject", subject, "string");
      }
      /**
       * Set send at
       */
      setSendAt(sendAt) {
        if (this._checkProperty("sendAt", sendAt, [this._checkUndefined, this._createCheckThatThrows(Number.isInteger, "Integer expected for `sendAt`")])) {
          this.sendAt = sendAt;
        }
      }
      /**
       * Set template ID, also checks if the template is dynamic or legacy
       */
      setTemplateId(templateId) {
        if (this._setProperty("templateId", templateId, "string")) {
          if (templateId.indexOf("d-") === 0) {
            this.isDynamic = true;
          }
        }
      }
      /**
       * Set batch ID
       */
      setBatchId(batchId) {
        this._setProperty("batchId", batchId, "string");
      }
      /**
       * Set IP pool name
       */
      setIpPoolName(ipPoolName) {
        this._setProperty("ipPoolName", ipPoolName, "string");
      }
      /**
       * Set ASM
       */
      setAsm(asm) {
        if (this._checkProperty("asm", asm, [this._checkUndefined, this._createTypeCheck("object")])) {
          if (typeof asm.groupId !== "number") {
            throw new Error("Expected `asm` to include an integer in its `groupId` field");
          }
          if (asm.groupsToDisplay && (!Array.isArray(asm.groupsToDisplay) || !asm.groupsToDisplay.every((group) => typeof group === "number"))) {
            throw new Error("Array of integers expected for `asm.groupsToDisplay`");
          }
          this.asm = asm;
        }
      }
      /**
       * Set personalizations
       */
      setPersonalizations(personalizations) {
        if (!this._doArrayCheck("personalizations", personalizations)) {
          return;
        }
        if (!personalizations.every((personalization) => typeof personalization === "object")) {
          throw new Error("Array of objects expected for `personalizations`");
        }
        this.personalizations = [];
        personalizations.forEach((personalization) => this.addPersonalization(personalization));
      }
      /**
       * Add personalization
       */
      addPersonalization(personalization) {
        if (this.isDynamic && personalization.substitutions) {
          delete personalization.substitutions;
        } else if (!this.isDynamic && personalization.dynamicTemplateData) {
          delete personalization.dynamicTemplateData;
        }
        if (!(personalization instanceof Personalization)) {
          personalization = new Personalization(personalization);
        }
        if (this.isDynamic) {
          this.applyDynamicTemplateData(personalization);
        } else {
          this.applySubstitutions(personalization);
        }
        this.personalizations.push(personalization);
      }
      /**
       * Convenience method for quickly creating personalizations
       */
      addTo(to, cc, bcc) {
        if (typeof to === "undefined" && typeof cc === "undefined" && typeof bcc === "undefined") {
          throw new Error("Provide at least one of to, cc or bcc");
        }
        this.addPersonalization(new Personalization({ to, cc, bcc }));
      }
      /**
       * Set substitutions
       */
      setSubstitutions(substitutions) {
        this._setProperty("substitutions", substitutions, "object");
      }
      /**
       * Set substitution wrappers
       */
      setSubstitutionWrappers(substitutionWrappers) {
        let lengthCheck = (propertyName, value) => {
          if (!Array.isArray(value) || value.length !== 2) {
            throw new Error("Array expected with two elements for `" + propertyName + "`");
          }
        };
        if (this._checkProperty("substitutionWrappers", substitutionWrappers, [this._checkUndefined, lengthCheck])) {
          this.substitutionWrappers = substitutionWrappers;
        }
      }
      /**
       * Helper which applies globally set substitutions to personalizations
       */
      applySubstitutions(personalization) {
        if (personalization instanceof Personalization) {
          personalization.reverseMergeSubstitutions(this.substitutions);
          personalization.setSubstitutionWrappers(this.substitutionWrappers);
        }
      }
      /**
       * Helper which applies globally set dynamic_template_data to personalizations
       */
      applyDynamicTemplateData(personalization) {
        if (personalization instanceof Personalization) {
          personalization.deepMergeDynamicTemplateData(this.dynamicTemplateData);
        }
      }
      /**
       * Set dynamicTemplateData
       */
      setDynamicTemplateData(dynamicTemplateData) {
        if (typeof dynamicTemplateData === "undefined") {
          return;
        }
        if (typeof dynamicTemplateData !== "object") {
          throw new Error("Object expected for `dynamicTemplateData`");
        }
        if (!this.hideWarnings) {
          Object.values(dynamicTemplateData).forEach((value) => {
            if (/['"&]/.test(value)) {
              console.warn(DYNAMIC_TEMPLATE_CHAR_WARNING);
            }
          });
        }
        this.dynamicTemplateData = dynamicTemplateData;
      }
      /**
       * Set content
       */
      setContent(content) {
        if (this._doArrayCheck("content", content)) {
          if (!content.every((contentField) => typeof contentField === "object")) {
            throw new Error("Expected each entry in `content` to be an object");
          }
          if (!content.every((contentField) => typeof contentField.type === "string")) {
            throw new Error("Expected each `content` entry to contain a `type` string");
          }
          if (!content.every((contentField) => typeof contentField.value === "string")) {
            throw new Error("Expected each `content` entry to contain a `value` string");
          }
          this.content = content;
        }
      }
      /**
       * Add content
       */
      addContent(content) {
        if (this._checkProperty("content", content, [this._createTypeCheck("object")])) {
          this.content.push(content);
        }
      }
      /**
       * Add text content
       */
      addTextContent(text) {
        if (this._checkProperty("text", text, [this._checkUndefined, this._createTypeCheck("string")])) {
          this.addContent({
            value: text,
            type: "text/plain"
          });
        }
      }
      /**
       * Add HTML content
       */
      addHtmlContent(html) {
        if (this._checkProperty("html", html, [this._checkUndefined, this._createTypeCheck("string")])) {
          this.addContent({
            value: html,
            type: "text/html"
          });
        }
      }
      /**
       * Set attachments
       */
      setAttachments(attachments) {
        if (this._doArrayCheck("attachments", attachments)) {
          if (!attachments.every((attachment) => typeof attachment.content === "string")) {
            throw new Error("Expected each attachment to contain a `content` string");
          }
          if (!attachments.every((attachment) => typeof attachment.filename === "string")) {
            throw new Error("Expected each attachment to contain a `filename` string");
          }
          if (!attachments.every((attachment) => !attachment.type || typeof attachment.type === "string")) {
            throw new Error("Expected the attachment's `type` field to be a string");
          }
          if (!attachments.every((attachment) => !attachment.disposition || typeof attachment.disposition === "string")) {
            throw new Error("Expected the attachment's `disposition` field to be a string");
          }
          this.attachments = attachments;
        }
      }
      /**
       * Add attachment
       */
      addAttachment(attachment) {
        if (this._checkProperty("attachment", attachment, [this._checkUndefined, this._createTypeCheck("object")])) {
          this.attachments.push(attachment);
        }
      }
      /**
       * Set categories
       */
      setCategories(categories) {
        let allElementsAreStrings = (propertyName, value) => {
          if (!Array.isArray(value) || !value.every((item) => typeof item === "string")) {
            throw new Error("Array of strings expected for `" + propertyName + "`");
          }
        };
        if (typeof categories === "string") {
          categories = [categories];
        }
        if (this._checkProperty("categories", categories, [this._checkUndefined, allElementsAreStrings])) {
          this.categories = categories;
        }
      }
      /**
       * Add category
       */
      addCategory(category) {
        if (this._checkProperty("category", category, [this._createTypeCheck("string")])) {
          this.categories.push(category);
        }
      }
      /**
       * Set headers
       */
      setHeaders(headers) {
        this._setProperty("headers", headers, "object");
      }
      /**
       * Add a header
       */
      addHeader(key, value) {
        if (this._checkProperty("key", key, [this._createTypeCheck("string")]) && this._checkProperty("value", value, [this._createTypeCheck("string")])) {
          this.headers[key] = value;
        }
      }
      /**
       * Set sections
       */
      setSections(sections) {
        this._setProperty("sections", sections, "object");
      }
      /**
       * Set custom args
       */
      setCustomArgs(customArgs) {
        this._setProperty("customArgs", customArgs, "object");
      }
      /**
       * Set tracking settings
       */
      setTrackingSettings(settings) {
        if (typeof settings === "undefined") {
          return;
        }
        validateTrackingSettings(settings);
        this.trackingSettings = settings;
      }
      /**
       * Set mail settings
       */
      setMailSettings(settings) {
        if (typeof settings === "undefined") {
          return;
        }
        validateMailSettings(settings);
        this.mailSettings = settings;
      }
      /**
       * Set hide warnings
       */
      setHideWarnings(hide) {
        if (typeof hide === "undefined") {
          return;
        }
        if (typeof hide !== "boolean") {
          throw new Error("Boolean expected for `hideWarnings`");
        }
        this.hideWarnings = hide;
      }
      /**
       * To JSON
       */
      toJSON() {
        const {
          from,
          replyTo,
          sendAt,
          subject,
          content,
          templateId,
          personalizations,
          attachments,
          ipPoolName,
          batchId,
          asm,
          sections,
          headers,
          categories,
          customArgs,
          mailSettings,
          trackingSettings,
          replyToList
        } = this;
        const json = {
          from,
          subject,
          personalizations: arrayToJSON(personalizations)
        };
        if (Array.isArray(attachments) && attachments.length > 0) {
          json.attachments = arrayToJSON(attachments);
        }
        if (Array.isArray(categories) && categories.length > 0) {
          json.categories = categories.filter((cat) => cat !== "");
        }
        if (Array.isArray(content) && content.length > 0) {
          json.content = arrayToJSON(content);
        }
        if (Object.keys(headers).length > 0) {
          json.headers = headers;
        }
        if (Object.keys(mailSettings).length > 0) {
          json.mailSettings = mailSettings;
        }
        if (Object.keys(trackingSettings).length > 0) {
          json.trackingSettings = trackingSettings;
        }
        if (Object.keys(customArgs).length > 0) {
          json.customArgs = customArgs;
        }
        if (Object.keys(sections).length > 0) {
          json.sections = sections;
        }
        if (Object.keys(asm).length > 0) {
          json.asm = asm;
        }
        if (typeof replyTo !== "undefined") {
          json.replyTo = replyTo;
        }
        if (typeof sendAt !== "undefined") {
          json.sendAt = sendAt;
        }
        if (typeof batchId !== "undefined") {
          json.batchId = batchId;
        }
        if (typeof templateId !== "undefined") {
          json.templateId = templateId;
        }
        if (typeof ipPoolName !== "undefined") {
          json.ipPoolName = ipPoolName;
        }
        if (typeof replyToList !== "undefined") {
          json.replyToList = replyToList;
        }
        return toSnakeCase(json, ["substitutions", "dynamicTemplateData", "customArgs", "headers", "sections"]);
      }
      /**************************************************************************
       * Static helpers
       ***/
      /**
       * Create a Mail instance from given data
       */
      static create(data) {
        if (Array.isArray(data)) {
          return data.filter((item) => !!item).map((item) => this.create(item));
        }
        if (data instanceof _Mail) {
          return data;
        }
        return new _Mail(data);
      }
      /**************************************************************************
       * helpers for property-setting checks
       ***/
      /**
       * Perform a set of checks on the new property value. Returns true if all
       * checks complete successfully without throwing errors or returning true.
       */
      _checkProperty(propertyName, value, checks) {
        return !checks.some((e) => e(propertyName, value));
      }
      /**
       * Set a property with normal undefined and type-checks
       */
      _setProperty(propertyName, value, propertyType) {
        let propertyChecksPassed = this._checkProperty(
          propertyName,
          value,
          [this._checkUndefined, this._createTypeCheck(propertyType)]
        );
        if (propertyChecksPassed) {
          this[propertyName] = value;
        }
        return propertyChecksPassed;
      }
      /**
       * Fail if the value is undefined.
       */
      _checkUndefined(propertyName, value) {
        return typeof value === "undefined";
      }
      /**
       * Create and return a function that checks for a given type
       */
      _createTypeCheck(propertyType) {
        return (propertyName, value) => {
          if (typeof value !== propertyType) {
            throw new Error(propertyType + " expected for `" + propertyName + "`");
          }
        };
      }
      /**
       * Create a check out of a callback. If the callback
       * returns false, the check will throw an error.
       */
      _createCheckThatThrows(check, errorString) {
        return (propertyName, value) => {
          if (!check(value)) {
            throw new Error(errorString);
          }
        };
      }
      /**
       * Set an array property after checking that the new value is an
       * array.
       */
      _setArrayProperty(propertyName, value) {
        if (this._doArrayCheck(propertyName, value)) {
          this[propertyName] = value;
        }
      }
      /**
       * Check that a value isn't undefined and is an array.
       */
      _doArrayCheck(propertyName, value) {
        return this._checkProperty(
          propertyName,
          value,
          [this._checkUndefined, this._createCheckThatThrows(Array.isArray, "Array expected for`" + propertyName + "`")]
        );
      }
      /**
       * Set the replyToList from email body
       */
      setReplyToList(replyToList) {
        if (this._doArrayCheck("replyToList", replyToList) && replyToList.length) {
          if (!replyToList.every((replyTo) => replyTo && typeof replyTo.email === "string")) {
            throw new Error("Expected each replyTo to contain an `email` string");
          }
          this.replyToList = replyToList;
        }
      }
    };
    module2.exports = Mail;
  }
});

// node_modules/@sendgrid/helpers/classes/response.js
var require_response = __commonJS({
  "node_modules/@sendgrid/helpers/classes/response.js"(exports, module2) {
    "use strict";
    var Response2 = class {
      constructor(statusCode, body, headers) {
        this.statusCode = statusCode;
        this.body = body;
        this.headers = headers;
      }
      toString() {
        return "HTTP " + this.statusCode + " " + this.body;
      }
    };
    module2.exports = Response2;
  }
});

// node_modules/@sendgrid/helpers/classes/response-error.js
var require_response_error = __commonJS({
  "node_modules/@sendgrid/helpers/classes/response-error.js"(exports, module2) {
    "use strict";
    var ResponseError = class extends Error {
      /**
       * Constructor
       */
      constructor(response) {
        super();
        const { headers, status, statusText, data } = response;
        this.code = status;
        this.message = statusText;
        this.response = { headers, body: data };
        if (!this.stack) {
          Error.captureStackTrace(this, this.constructor);
        }
        const regex = new RegExp(process.cwd() + "/", "gi");
        this.stack = this.stack.replace(regex, "");
      }
      /**
       * Convert to string
       */
      toString() {
        const { body } = this.response;
        let err = `${this.message} (${this.code})`;
        if (body && Array.isArray(body.errors)) {
          body.errors.forEach((error) => {
            const message = error.message;
            const field = error.field;
            const help = error.help;
            err += `
  ${message}
    ${field}
    ${help}`;
          });
        }
        return err;
      }
      /**
       * Convert to simple object for JSON responses
       */
      toJSON() {
        const { message, code, response } = this;
        return { message, code, response };
      }
    };
    module2.exports = ResponseError;
  }
});

// node_modules/@sendgrid/helpers/classes/statistics.js
var require_statistics = __commonJS({
  "node_modules/@sendgrid/helpers/classes/statistics.js"(exports, module2) {
    "use strict";
    var toCamelCase = require_to_camel_case();
    var deepClone = require_deep_clone();
    var AggregatedByOptions = ["day", "week", "month"];
    var CountryOptions = ["us", "ca"];
    var SortByDirection = ["desc", "asc"];
    var Statistics = class {
      constructor(data) {
        this.startDate = null;
        this.endDate = null;
        this.aggregatedBy = null;
        if (data) {
          this.fromData(data);
        }
      }
      /**
       * Build from data
       */
      fromData(data) {
        if (typeof data !== "object") {
          throw new Error("Expecting object for Statistics data");
        }
        data = deepClone(data);
        data = toCamelCase(data, ["substitutions", "customArgs"]);
        const {
          startDate,
          endDate,
          aggregatedBy
        } = data;
        this.setStartDate(startDate);
        this.setEndDate(endDate);
        this.setAggregatedBy(aggregatedBy);
      }
      /**
       * Set startDate
       */
      setStartDate(startDate) {
        if (typeof startDate === "undefined") {
          throw new Error("Date expected for `startDate`");
        }
        if (new Date(startDate) === "Invalid Date" || isNaN(new Date(startDate))) {
          throw new Error("Date expected for `startDate`");
        }
        console.log(startDate);
        this.startDate = new Date(startDate).toISOString().slice(0, 10);
      }
      /**
       * Set endDate
       */
      setEndDate(endDate) {
        if (typeof endDate === "undefined") {
          this.endDate = (/* @__PURE__ */ new Date()).toISOString().slice(0, 10);
          return;
        }
        if (new Date(endDate) === "Invalid Date" || isNaN(new Date(endDate))) {
          throw new Error("Date expected for `endDate`");
        }
        this.endDate = new Date(endDate).toISOString().slice(0, 10);
      }
      /**
       * Set aggregatedBy
       */
      setAggregatedBy(aggregatedBy) {
        if (typeof aggregatedBy === "undefined") {
          return;
        }
        if (typeof aggregatedBy === "string" && AggregatedByOptions.includes(aggregatedBy.toLowerCase())) {
          this.aggregatedBy = aggregatedBy;
        } else {
          throw new Error("Incorrect value for `aggregatedBy`");
        }
      }
      /**
       * Get Global
       */
      getGlobal() {
        const { startDate, endDate, aggregatedBy } = this;
        return { startDate, endDate, aggregatedBy };
      }
      /**
       * Get Advanced
       */
      getAdvanced(country) {
        const json = this.getGlobal();
        if (typeof country === "undefined") {
          return json;
        }
        if (typeof country === "string" && CountryOptions.includes(country.toLowerCase())) {
          json.country = country;
        }
        return json;
      }
      /**
       * Get Advanced Mailbox Providers
       */
      getAdvancedMailboxProviders(mailBoxProviders) {
        const json = this.getGlobal();
        if (typeof mailBoxProviders === "undefined") {
          return json;
        }
        if (Array.isArray(mailBoxProviders) && mailBoxProviders.some((x) => typeof x !== "string")) {
          throw new Error("Array of strings expected for `mailboxProviders`");
        }
        json.mailBoxProviders = mailBoxProviders;
        return json;
      }
      /**
       * Get Advanced Browsers
       */
      getAdvancedBrowsers(browsers) {
        const json = this.getGlobal();
        if (typeof browsers === "undefined") {
          return json;
        }
        if (Array.isArray(browsers) && browsers.some((x) => typeof x !== "string")) {
          throw new Error("Array of strings expected for `browsers`");
        }
        json.browsers = browsers;
        return json;
      }
      /**
       * Get Categories
       */
      getCategories(categories) {
        if (typeof categories === "undefined") {
          throw new Error("Array of strings expected for `categories`");
        }
        if (!this._isValidArrayOfStrings(categories)) {
          throw new Error("Array of strings expected for `categories`");
        }
        const json = this.getGlobal();
        json.categories = categories;
        return json;
      }
      /**
       * Get Subuser
       */
      getSubuser(subusers) {
        if (typeof subusers === "undefined") {
          throw new Error("Array of strings expected for `subusers`");
        }
        if (!this._isValidArrayOfStrings(subusers)) {
          throw new Error("Array of strings expected for `subusers`");
        }
        const json = this.getGlobal();
        json.subusers = subusers;
        return json;
      }
      /**
       * Get Subuser Sum
       */
      getSubuserSum(sortByMetric = "delivered", sortByDirection = SortByDirection[0], limit = 5, offset = 0) {
        if (typeof sortByMetric !== "string") {
          throw new Error("string expected for `sortByMetric`");
        }
        if (!SortByDirection.includes(sortByDirection.toLowerCase())) {
          throw new Error("desc or asc expected for `sortByDirection`");
        }
        if (typeof limit !== "number") {
          throw new Error("number expected for `limit`");
        }
        if (typeof offset !== "number") {
          throw new Error("number expected for `offset`");
        }
        const json = this.getGlobal();
        json.sortByMetric = sortByMetric;
        json.sortByDirection = sortByDirection;
        json.limit = limit;
        json.offset = offset;
        return json;
      }
      /**
       * Get Subuser Monthly
       */
      getSubuserMonthly(sortByMetric = "delivered", sortByDirection = SortByDirection[0], limit = 5, offset = 0) {
        if (typeof sortByMetric !== "string") {
          throw new Error("string expected for `sortByMetric`");
        }
        if (!SortByDirection.includes(sortByDirection.toLowerCase())) {
          throw new Error("desc or asc expected for `sortByDirection`");
        }
        if (typeof limit !== "number") {
          throw new Error("number expected for `limit`");
        }
        if (typeof offset !== "number") {
          throw new Error("number expected for `offset`");
        }
        const json = this.getGlobal();
        json.sortByMetric = sortByMetric;
        json.sortByDirection = sortByDirection;
        json.limit = limit;
        json.offset = offset;
        return json;
      }
      _isValidArrayOfStrings(arr) {
        if (!Array.isArray(arr)) {
          return false;
        }
        if (arr.length < 1 || arr.some((x) => typeof x !== "string")) {
          return false;
        }
        return true;
      }
    };
    module2.exports = Statistics;
  }
});

// node_modules/@sendgrid/helpers/classes/index.js
var require_classes = __commonJS({
  "node_modules/@sendgrid/helpers/classes/index.js"(exports, module2) {
    "use strict";
    var Attachment = require_attachment();
    var EmailAddress = require_email_address();
    var Mail = require_mail();
    var Personalization = require_personalization();
    var Response2 = require_response();
    var ResponseError = require_response_error();
    var Statistics = require_statistics();
    module2.exports = {
      Attachment,
      EmailAddress,
      Mail,
      Personalization,
      Response: Response2,
      ResponseError,
      Statistics
    };
  }
});

// node_modules/@sendgrid/helpers/helpers/merge-data.js
var require_merge_data = __commonJS({
  "node_modules/@sendgrid/helpers/helpers/merge-data.js"(exports, module2) {
    "use strict";
    module2.exports = function mergeData(base, data) {
      if (typeof base !== "object" || base === null) {
        throw new Error("Not an object provided for base");
      }
      if (typeof data !== "object" || data === null) {
        throw new Error("Not an object provided for data");
      }
      const merged = Object.assign({}, base);
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          if (data[key] && Array.isArray(data[key])) {
            merged[key] = data[key];
          } else if (data[key] && typeof data[key] === "object") {
            merged[key] = Object.assign({}, data[key]);
          } else if (data[key]) {
            merged[key] = data[key];
          }
        }
      }
      return merged;
    };
  }
});

// node_modules/@sendgrid/helpers/helpers/index.js
var require_helpers = __commonJS({
  "node_modules/@sendgrid/helpers/helpers/index.js"(exports, module2) {
    "use strict";
    var arrayToJSON = require_array_to_json();
    var convertKeys = require_convert_keys();
    var deepClone = require_deep_clone();
    var mergeData = require_merge_data();
    var splitNameEmail = require_split_name_email();
    var toCamelCase = require_to_camel_case();
    var toSnakeCase = require_to_snake_case();
    var wrapSubstitutions = require_wrap_substitutions();
    module2.exports = {
      arrayToJSON,
      convertKeys,
      deepClone,
      mergeData,
      splitNameEmail,
      toCamelCase,
      toSnakeCase,
      wrapSubstitutions
    };
  }
});

// node_modules/@sendgrid/helpers/index.js
var require_helpers2 = __commonJS({
  "node_modules/@sendgrid/helpers/index.js"(exports, module2) {
    "use strict";
    var classes = require_classes();
    var helpers = require_helpers();
    module2.exports = { classes, helpers };
  }
});

// node_modules/@sendgrid/client/src/classes/client.js
var require_client = __commonJS({
  "node_modules/@sendgrid/client/src/classes/client.js"(exports, module2) {
    "use strict";
    var axios2 = require_axios2();
    var pkg = require_package();
    var {
      helpers: {
        mergeData
      },
      classes: {
        Response: Response2,
        ResponseError
      }
    } = require_helpers2();
    var API_KEY_PREFIX = "SG.";
    var SENDGRID_BASE_URL = "https://api.sendgrid.com/";
    var TWILIO_BASE_URL = "https://email.twilio.com/";
    var Client2 = class {
      constructor() {
        this.auth = "";
        this.impersonateSubuser = "";
        this.defaultHeaders = {
          Accept: "application/json",
          "Content-Type": "application/json",
          "User-Agent": "sendgrid/" + pkg.version + ";nodejs"
        };
        this.defaultRequest = {
          baseUrl: SENDGRID_BASE_URL,
          url: "",
          method: "GET",
          headers: {},
          maxContentLength: Infinity,
          // Don't limit the content length.
          maxBodyLength: Infinity
        };
      }
      setApiKey(apiKey) {
        this.auth = "Bearer " + apiKey;
        this.setDefaultRequest("baseUrl", SENDGRID_BASE_URL);
        if (!this.isValidApiKey(apiKey)) {
          console.warn(`API key does not start with "${API_KEY_PREFIX}".`);
        }
      }
      setTwilioEmailAuth(username, password2) {
        const b64Auth = Buffer.from(username + ":" + password2).toString("base64");
        this.auth = "Basic " + b64Auth;
        this.setDefaultRequest("baseUrl", TWILIO_BASE_URL);
        if (!this.isValidTwilioAuth(username, password2)) {
          console.warn("Twilio Email credentials must be non-empty strings.");
        }
      }
      isValidApiKey(apiKey) {
        return this.isString(apiKey) && apiKey.trim().startsWith(API_KEY_PREFIX);
      }
      isValidTwilioAuth(username, password2) {
        return this.isString(username) && username && this.isString(password2) && password2;
      }
      isString(value) {
        return typeof value === "string" || value instanceof String;
      }
      setImpersonateSubuser(subuser) {
        this.impersonateSubuser = subuser;
      }
      setDefaultHeader(key, value) {
        if (key !== null && typeof key === "object") {
          Object.assign(this.defaultHeaders, key);
          return this;
        }
        this.defaultHeaders[key] = value;
        return this;
      }
      setDefaultRequest(key, value) {
        if (key !== null && typeof key === "object") {
          Object.assign(this.defaultRequest, key);
          return this;
        }
        this.defaultRequest[key] = value;
        return this;
      }
      createHeaders(data) {
        const headers = mergeData(this.defaultHeaders, data);
        if (typeof headers.Authorization === "undefined" && this.auth) {
          headers.Authorization = this.auth;
        }
        if (this.impersonateSubuser) {
          headers["On-Behalf-Of"] = this.impersonateSubuser;
        }
        return headers;
      }
      createRequest(data) {
        let options = {
          url: data.uri || data.url,
          baseUrl: data.baseUrl,
          method: data.method,
          data: data.body,
          params: data.qs,
          headers: data.headers
        };
        options = mergeData(this.defaultRequest, options);
        options.headers = this.createHeaders(options.headers);
        options.baseURL = options.baseUrl;
        delete options.baseUrl;
        return options;
      }
      request(data, cb) {
        data = this.createRequest(data);
        const promise = new Promise((resolve2, reject) => {
          axios2(data).then((response) => {
            return resolve2([
              new Response2(response.status, response.data, response.headers),
              response.data
            ]);
          }).catch((error) => {
            if (error.response) {
              if (error.response.status >= 400) {
                return reject(new ResponseError(error.response));
              }
            }
            return reject(error);
          });
        });
        if (cb && typeof cb !== "function") {
          throw new Error("Callback passed is not a function.");
        }
        if (cb) {
          return promise.then((result) => cb(null, result)).catch((error) => cb(error, null));
        }
        return promise;
      }
    };
    module2.exports = Client2;
  }
});

// node_modules/@sendgrid/client/src/client.js
var require_client2 = __commonJS({
  "node_modules/@sendgrid/client/src/client.js"(exports, module2) {
    "use strict";
    var Client2 = require_client();
    module2.exports = new Client2();
  }
});

// node_modules/@sendgrid/client/index.js
var require_client3 = __commonJS({
  "node_modules/@sendgrid/client/index.js"(exports, module2) {
    "use strict";
    var client = require_client2();
    var Client2 = require_client();
    module2.exports = client;
    module2.exports.Client = Client2;
  }
});

// node_modules/@sendgrid/mail/src/classes/mail-service.js
var require_mail_service = __commonJS({
  "node_modules/@sendgrid/mail/src/classes/mail-service.js"(exports, module2) {
    "use strict";
    var { Client: Client2 } = require_client3();
    var { classes: { Mail } } = require_helpers2();
    var MailService = class {
      /**
       * Constructor
       */
      constructor() {
        this.setClient(new Client2());
        this.setSubstitutionWrappers("{{", "}}");
        this.secretRules = [];
      }
      /**
       * Set client
       */
      setClient(client) {
        this.client = client;
        return this;
      }
      /**
       * SendGrid API key passthrough for convenience.
       */
      setApiKey(apiKey) {
        this.client.setApiKey(apiKey);
        return this;
      }
      /**
       * Twilio Email Auth passthrough for convenience.
       */
      setTwilioEmailAuth(username, password2) {
        this.client.setTwilioEmailAuth(username, password2);
      }
      /**
       * Set client timeout
       */
      setTimeout(timeout) {
        if (typeof timeout === "undefined") {
          return;
        }
        this.client.setDefaultRequest("timeout", timeout);
      }
      /**
       * Set substitution wrappers
       */
      setSubstitutionWrappers(left, right) {
        if (typeof left === "undefined" || typeof right === "undefined") {
          throw new Error("Must provide both left and right side wrappers");
        }
        if (!Array.isArray(this.substitutionWrappers)) {
          this.substitutionWrappers = [];
        }
        this.substitutionWrappers[0] = left;
        this.substitutionWrappers[1] = right;
        return this;
      }
      /**
       * Set secret rules for filtering the e-mail content
       */
      setSecretRules(rules) {
        if (!(rules instanceof Array)) {
          rules = [rules];
        }
        const tmpRules = rules.map(function(rule) {
          const ruleType = typeof rule;
          if (ruleType === "string") {
            return {
              pattern: new RegExp(rule)
            };
          } else if (ruleType === "object") {
            if (rule instanceof RegExp) {
              rule = {
                pattern: rule
              };
            } else if (rule.hasOwnProperty("pattern") && typeof rule.pattern === "string") {
              rule.pattern = new RegExp(rule.pattern);
            }
            try {
              rule.pattern.test("");
              return rule;
            } catch (err) {
            }
          }
        });
        this.secretRules = tmpRules.filter(function(val) {
          return val;
        });
      }
      /**
       * Check if the e-mail is safe to be sent
       */
      filterSecrets(body) {
        if (typeof body === "object" && !body.hasOwnProperty("content")) {
          return;
        }
        const self2 = this;
        body.content.forEach(function(data) {
          self2.secretRules.forEach(function(rule) {
            if (rule.hasOwnProperty("pattern") && !rule.pattern.test(data.value)) {
              return;
            }
            let message = `The pattern '${rule.pattern}'`;
            if (rule.name) {
              message += `identified by '${rule.name}'`;
            }
            message += " was found in the Mail content!";
            throw new Error(message);
          });
        });
      }
      /**
       * Send email
       */
      send(data, isMultiple = false, cb) {
        if (typeof isMultiple === "function") {
          cb = isMultiple;
          isMultiple = false;
        }
        if (Array.isArray(data)) {
          const promise = Promise.all(data.map((item) => {
            return this.send(item, isMultiple);
          }));
          if (cb) {
            promise.then((result) => cb(null, result)).catch((error) => cb(error, null));
          }
          return promise;
        }
        try {
          if (typeof data.isMultiple === "undefined") {
            data.isMultiple = isMultiple;
          }
          if (typeof data.substitutionWrappers === "undefined") {
            data.substitutionWrappers = this.substitutionWrappers;
          }
          const mail = Mail.create(data);
          const body = mail.toJSON();
          this.filterSecrets(body);
          const request = {
            method: "POST",
            url: "/v3/mail/send",
            headers: mail.headers,
            body
          };
          return this.client.request(request, cb);
        } catch (error) {
          if (cb) {
            cb(error, null);
          }
          return Promise.reject(error);
        }
      }
      /**
       * Send multiple emails (shortcut)
       */
      sendMultiple(data, cb) {
        return this.send(data, true, cb);
      }
    };
    module2.exports = MailService;
  }
});

// node_modules/@sendgrid/mail/src/mail.js
var require_mail2 = __commonJS({
  "node_modules/@sendgrid/mail/src/mail.js"(exports, module2) {
    "use strict";
    var MailService = require_mail_service();
    module2.exports = new MailService();
  }
});

// node_modules/@sendgrid/mail/index.js
var require_mail3 = __commonJS({
  "node_modules/@sendgrid/mail/index.js"(exports, module2) {
    "use strict";
    var mailer = require_mail2();
    var MailService = require_mail_service();
    module2.exports = mailer;
    module2.exports.MailService = MailService;
  }
});

// node_modules/nodemailer/lib/fetch/cookies.js
var require_cookies2 = __commonJS({
  "node_modules/nodemailer/lib/fetch/cookies.js"(exports, module2) {
    "use strict";
    var urllib = require("url");
    var SESSION_TIMEOUT = 1800;
    var Cookies = class {
      constructor(options) {
        this.options = options || {};
        this.cookies = [];
      }
      /**
       * Stores a cookie string to the cookie storage
       *
       * @param {String} cookieStr Value from the 'Set-Cookie:' header
       * @param {String} url Current URL
       */
      set(cookieStr, url) {
        let urlparts = urllib.parse(url || "");
        let cookie2 = this.parse(cookieStr);
        let domain;
        if (cookie2.domain) {
          domain = cookie2.domain.replace(/^\./, "");
          if (
            // can't be valid if the requested domain is shorter than current hostname
            urlparts.hostname.length < domain.length || // prefix domains with dot to be sure that partial matches are not used
            ("." + urlparts.hostname).substr(-domain.length + 1) !== "." + domain
          ) {
            cookie2.domain = urlparts.hostname;
          }
        } else {
          cookie2.domain = urlparts.hostname;
        }
        if (!cookie2.path) {
          cookie2.path = this.getPath(urlparts.pathname);
        }
        if (!cookie2.expires) {
          cookie2.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1e3);
        }
        return this.add(cookie2);
      }
      /**
       * Returns cookie string for the 'Cookie:' header.
       *
       * @param {String} url URL to check for
       * @returns {String} Cookie header or empty string if no matches were found
       */
      get(url) {
        return this.list(url).map((cookie2) => cookie2.name + "=" + cookie2.value).join("; ");
      }
      /**
       * Lists all valied cookie objects for the specified URL
       *
       * @param {String} url URL to check for
       * @returns {Array} An array of cookie objects
       */
      list(url) {
        let result = [];
        let i;
        let cookie2;
        for (i = this.cookies.length - 1; i >= 0; i--) {
          cookie2 = this.cookies[i];
          if (this.isExpired(cookie2)) {
            this.cookies.splice(i, i);
            continue;
          }
          if (this.match(cookie2, url)) {
            result.unshift(cookie2);
          }
        }
        return result;
      }
      /**
       * Parses cookie string from the 'Set-Cookie:' header
       *
       * @param {String} cookieStr String from the 'Set-Cookie:' header
       * @returns {Object} Cookie object
       */
      parse(cookieStr) {
        let cookie2 = {};
        (cookieStr || "").toString().split(";").forEach((cookiePart) => {
          let valueParts = cookiePart.split("=");
          let key = valueParts.shift().trim().toLowerCase();
          let value = valueParts.join("=").trim();
          let domain;
          if (!key) {
            return;
          }
          switch (key) {
            case "expires":
              value = new Date(value);
              if (value.toString() !== "Invalid Date") {
                cookie2.expires = value;
              }
              break;
            case "path":
              cookie2.path = value;
              break;
            case "domain":
              domain = value.toLowerCase();
              if (domain.length && domain.charAt(0) !== ".") {
                domain = "." + domain;
              }
              cookie2.domain = domain;
              break;
            case "max-age":
              cookie2.expires = new Date(Date.now() + (Number(value) || 0) * 1e3);
              break;
            case "secure":
              cookie2.secure = true;
              break;
            case "httponly":
              cookie2.httponly = true;
              break;
            default:
              if (!cookie2.name) {
                cookie2.name = key;
                cookie2.value = value;
              }
          }
        });
        return cookie2;
      }
      /**
       * Checks if a cookie object is valid for a specified URL
       *
       * @param {Object} cookie Cookie object
       * @param {String} url URL to check for
       * @returns {Boolean} true if cookie is valid for specifiec URL
       */
      match(cookie2, url) {
        let urlparts = urllib.parse(url || "");
        if (urlparts.hostname !== cookie2.domain && (cookie2.domain.charAt(0) !== "." || ("." + urlparts.hostname).substr(-cookie2.domain.length) !== cookie2.domain)) {
          return false;
        }
        let path = this.getPath(urlparts.pathname);
        if (path.substr(0, cookie2.path.length) !== cookie2.path) {
          return false;
        }
        if (cookie2.secure && urlparts.protocol !== "https:") {
          return false;
        }
        return true;
      }
      /**
       * Adds (or updates/removes if needed) a cookie object to the cookie storage
       *
       * @param {Object} cookie Cookie value to be stored
       */
      add(cookie2) {
        let i;
        let len;
        if (!cookie2 || !cookie2.name) {
          return false;
        }
        for (i = 0, len = this.cookies.length; i < len; i++) {
          if (this.compare(this.cookies[i], cookie2)) {
            if (this.isExpired(cookie2)) {
              this.cookies.splice(i, 1);
              return false;
            }
            this.cookies[i] = cookie2;
            return true;
          }
        }
        if (!this.isExpired(cookie2)) {
          this.cookies.push(cookie2);
        }
        return true;
      }
      /**
       * Checks if two cookie objects are the same
       *
       * @param {Object} a Cookie to check against
       * @param {Object} b Cookie to check against
       * @returns {Boolean} True, if the cookies are the same
       */
      compare(a, b) {
        return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;
      }
      /**
       * Checks if a cookie is expired
       *
       * @param {Object} cookie Cookie object to check against
       * @returns {Boolean} True, if the cookie is expired
       */
      isExpired(cookie2) {
        return cookie2.expires && cookie2.expires < /* @__PURE__ */ new Date() || !cookie2.value;
      }
      /**
       * Returns normalized cookie path for an URL path argument
       *
       * @param {String} pathname
       * @returns {String} Normalized path
       */
      getPath(pathname) {
        let path = (pathname || "/").split("/");
        path.pop();
        path = path.join("/").trim();
        if (path.charAt(0) !== "/") {
          path = "/" + path;
        }
        if (path.substr(-1) !== "/") {
          path += "/";
        }
        return path;
      }
    };
    module2.exports = Cookies;
  }
});

// node_modules/nodemailer/package.json
var require_package2 = __commonJS({
  "node_modules/nodemailer/package.json"(exports, module2) {
    module2.exports = {
      name: "nodemailer",
      version: "6.9.10",
      description: "Easy as cake e-mail sending from your Node.js applications",
      main: "lib/nodemailer.js",
      scripts: {
        test: "node --test --test-concurrency=1 test/**/*.test.js test/**/*-test.js",
        "test:coverage": "c8 node --test --test-concurrency=1 test/**/*.test.js test/**/*-test.js",
        lint: "eslint .",
        update: "rm -rf node_modules/ package-lock.json && ncu -u && npm install"
      },
      repository: {
        type: "git",
        url: "https://github.com/nodemailer/nodemailer.git"
      },
      keywords: [
        "Nodemailer"
      ],
      author: "Andris Reinman",
      license: "MIT-0",
      bugs: {
        url: "https://github.com/nodemailer/nodemailer/issues"
      },
      homepage: "https://nodemailer.com/",
      devDependencies: {
        "@aws-sdk/client-ses": "3.484.0",
        bunyan: "1.8.15",
        c8: "8.0.1",
        eslint: "8.56.0",
        "eslint-config-nodemailer": "1.2.0",
        "eslint-config-prettier": "9.1.0",
        libbase64: "1.2.1",
        libmime: "5.2.1",
        libqp: "2.0.1",
        "nodemailer-ntlm-auth": "1.0.4",
        proxy: "1.0.2",
        "proxy-test-server": "1.0.0",
        "smtp-server": "3.13.0"
      },
      engines: {
        node: ">=6.0.0"
      }
    };
  }
});

// node_modules/nodemailer/lib/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/nodemailer/lib/fetch/index.js"(exports, module2) {
    "use strict";
    var http2 = require("http");
    var https2 = require("https");
    var urllib = require("url");
    var zlib2 = require("zlib");
    var PassThrough2 = require("stream").PassThrough;
    var Cookies = require_cookies2();
    var packageData = require_package2();
    var net = require("net");
    var MAX_REDIRECTS = 5;
    module2.exports = function(url, options) {
      return nmfetch(url, options);
    };
    module2.exports.Cookies = Cookies;
    function nmfetch(url, options) {
      options = options || {};
      options.fetchRes = options.fetchRes || new PassThrough2();
      options.cookies = options.cookies || new Cookies();
      options.redirects = options.redirects || 0;
      options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;
      if (options.cookie) {
        [].concat(options.cookie || []).forEach((cookie2) => {
          options.cookies.set(cookie2, url);
        });
        options.cookie = false;
      }
      let fetchRes = options.fetchRes;
      let parsed = urllib.parse(url);
      let method = (options.method || "").toString().trim().toUpperCase() || "GET";
      let finished = false;
      let cookies;
      let body;
      let handler = parsed.protocol === "https:" ? https2 : http2;
      let headers = {
        "accept-encoding": "gzip,deflate",
        "user-agent": "nodemailer/" + packageData.version
      };
      Object.keys(options.headers || {}).forEach((key) => {
        headers[key.toLowerCase().trim()] = options.headers[key];
      });
      if (options.userAgent) {
        headers["user-agent"] = options.userAgent;
      }
      if (parsed.auth) {
        headers.Authorization = "Basic " + Buffer.from(parsed.auth).toString("base64");
      }
      if (cookies = options.cookies.get(url)) {
        headers.cookie = cookies;
      }
      if (options.body) {
        if (options.contentType !== false) {
          headers["Content-Type"] = options.contentType || "application/x-www-form-urlencoded";
        }
        if (typeof options.body.pipe === "function") {
          headers["Transfer-Encoding"] = "chunked";
          body = options.body;
          body.on("error", (err) => {
            if (finished) {
              return;
            }
            finished = true;
            err.type = "FETCH";
            err.sourceUrl = url;
            fetchRes.emit("error", err);
          });
        } else {
          if (options.body instanceof Buffer) {
            body = options.body;
          } else if (typeof options.body === "object") {
            try {
              body = Buffer.from(
                Object.keys(options.body).map((key) => {
                  let value = options.body[key].toString().trim();
                  return encodeURIComponent(key) + "=" + encodeURIComponent(value);
                }).join("&")
              );
            } catch (E) {
              if (finished) {
                return;
              }
              finished = true;
              E.type = "FETCH";
              E.sourceUrl = url;
              fetchRes.emit("error", E);
              return;
            }
          } else {
            body = Buffer.from(options.body.toString().trim());
          }
          headers["Content-Type"] = options.contentType || "application/x-www-form-urlencoded";
          headers["Content-Length"] = body.length;
        }
        method = (options.method || "").toString().trim().toUpperCase() || "POST";
      }
      let req;
      let reqOptions = {
        method,
        host: parsed.hostname,
        path: parsed.path,
        port: parsed.port ? parsed.port : parsed.protocol === "https:" ? 443 : 80,
        headers,
        rejectUnauthorized: false,
        agent: false
      };
      if (options.tls) {
        Object.keys(options.tls).forEach((key) => {
          reqOptions[key] = options.tls[key];
        });
      }
      if (parsed.protocol === "https:" && parsed.hostname && parsed.hostname !== reqOptions.host && !net.isIP(parsed.hostname) && !reqOptions.servername) {
        reqOptions.servername = parsed.hostname;
      }
      try {
        req = handler.request(reqOptions);
      } catch (E) {
        finished = true;
        setImmediate(() => {
          E.type = "FETCH";
          E.sourceUrl = url;
          fetchRes.emit("error", E);
        });
        return fetchRes;
      }
      if (options.timeout) {
        req.setTimeout(options.timeout, () => {
          if (finished) {
            return;
          }
          finished = true;
          req.abort();
          let err = new Error("Request Timeout");
          err.type = "FETCH";
          err.sourceUrl = url;
          fetchRes.emit("error", err);
        });
      }
      req.on("error", (err) => {
        if (finished) {
          return;
        }
        finished = true;
        err.type = "FETCH";
        err.sourceUrl = url;
        fetchRes.emit("error", err);
      });
      req.on("response", (res) => {
        let inflate;
        if (finished) {
          return;
        }
        switch (res.headers["content-encoding"]) {
          case "gzip":
          case "deflate":
            inflate = zlib2.createUnzip();
            break;
        }
        if (res.headers["set-cookie"]) {
          [].concat(res.headers["set-cookie"] || []).forEach((cookie2) => {
            options.cookies.set(cookie2, url);
          });
        }
        if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {
          options.redirects++;
          if (options.redirects > options.maxRedirects) {
            finished = true;
            let err = new Error("Maximum redirect count exceeded");
            err.type = "FETCH";
            err.sourceUrl = url;
            fetchRes.emit("error", err);
            req.abort();
            return;
          }
          options.method = "GET";
          options.body = false;
          return nmfetch(urllib.resolve(url, res.headers.location), options);
        }
        fetchRes.statusCode = res.statusCode;
        fetchRes.headers = res.headers;
        if (res.statusCode >= 300 && !options.allowErrorResponse) {
          finished = true;
          let err = new Error("Invalid status code " + res.statusCode);
          err.type = "FETCH";
          err.sourceUrl = url;
          fetchRes.emit("error", err);
          req.abort();
          return;
        }
        res.on("error", (err) => {
          if (finished) {
            return;
          }
          finished = true;
          err.type = "FETCH";
          err.sourceUrl = url;
          fetchRes.emit("error", err);
          req.abort();
        });
        if (inflate) {
          res.pipe(inflate).pipe(fetchRes);
          inflate.on("error", (err) => {
            if (finished) {
              return;
            }
            finished = true;
            err.type = "FETCH";
            err.sourceUrl = url;
            fetchRes.emit("error", err);
            req.abort();
          });
        } else {
          res.pipe(fetchRes);
        }
      });
      setImmediate(() => {
        if (body) {
          try {
            if (typeof body.pipe === "function") {
              return body.pipe(req);
            } else {
              req.write(body);
            }
          } catch (err) {
            finished = true;
            err.type = "FETCH";
            err.sourceUrl = url;
            fetchRes.emit("error", err);
            return;
          }
        }
        req.end();
      });
      return fetchRes;
    }
  }
});

// node_modules/nodemailer/lib/shared/index.js
var require_shared2 = __commonJS({
  "node_modules/nodemailer/lib/shared/index.js"(exports, module2) {
    "use strict";
    var urllib = require("url");
    var util = require("util");
    var fs = require("fs");
    var nmfetch = require_fetch();
    var dns = require("dns");
    var net = require("net");
    var os = require("os");
    var DNS_TTL = 5 * 60 * 1e3;
    var networkInterfaces;
    try {
      networkInterfaces = os.networkInterfaces();
    } catch (err) {
    }
    module2.exports.networkInterfaces = networkInterfaces;
    var isFamilySupported = (family, allowInternal) => {
      let networkInterfaces2 = module2.exports.networkInterfaces;
      if (!networkInterfaces2) {
        return true;
      }
      const familySupported = (
        // crux that replaces Object.values(networkInterfaces) as Object.values is not supported in nodejs v6
        Object.keys(networkInterfaces2).map((key) => networkInterfaces2[key]).reduce((acc, val) => acc.concat(val), []).filter((i) => !i.internal || allowInternal).filter((i) => i.family === "IPv" + family || i.family === family).length > 0
      );
      return familySupported;
    };
    var resolver = (family, hostname, options, callback2) => {
      options = options || {};
      const familySupported = isFamilySupported(family, options.allowInternalNetworkInterfaces);
      if (!familySupported) {
        return callback2(null, []);
      }
      const resolver2 = dns.Resolver ? new dns.Resolver(options) : dns;
      resolver2["resolve" + family](hostname, (err, addresses) => {
        if (err) {
          switch (err.code) {
            case dns.NODATA:
            case dns.NOTFOUND:
            case dns.NOTIMP:
            case dns.SERVFAIL:
            case dns.CONNREFUSED:
            case dns.REFUSED:
            case "EAI_AGAIN":
              return callback2(null, []);
          }
          return callback2(err);
        }
        return callback2(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));
      });
    };
    var dnsCache = module2.exports.dnsCache = /* @__PURE__ */ new Map();
    var formatDNSValue = (value, extra) => {
      if (!value) {
        return Object.assign({}, extra || {});
      }
      return Object.assign(
        {
          servername: value.servername,
          host: !value.addresses || !value.addresses.length ? null : value.addresses.length === 1 ? value.addresses[0] : value.addresses[Math.floor(Math.random() * value.addresses.length)]
        },
        extra || {}
      );
    };
    module2.exports.resolveHostname = (options, callback2) => {
      options = options || {};
      if (!options.host && options.servername) {
        options.host = options.servername;
      }
      if (!options.host || net.isIP(options.host)) {
        let value = {
          addresses: [options.host],
          servername: options.servername || false
        };
        return callback2(
          null,
          formatDNSValue(value, {
            cached: false
          })
        );
      }
      let cached;
      if (dnsCache.has(options.host)) {
        cached = dnsCache.get(options.host);
        if (!cached.expires || cached.expires >= Date.now()) {
          return callback2(
            null,
            formatDNSValue(cached.value, {
              cached: true
            })
          );
        }
      }
      resolver(4, options.host, options, (err, addresses) => {
        if (err) {
          if (cached) {
            return callback2(
              null,
              formatDNSValue(cached.value, {
                cached: true,
                error: err
              })
            );
          }
          return callback2(err);
        }
        if (addresses && addresses.length) {
          let value = {
            addresses,
            servername: options.servername || options.host
          };
          dnsCache.set(options.host, {
            value,
            expires: Date.now() + (options.dnsTtl || DNS_TTL)
          });
          return callback2(
            null,
            formatDNSValue(value, {
              cached: false
            })
          );
        }
        resolver(6, options.host, options, (err2, addresses2) => {
          if (err2) {
            if (cached) {
              return callback2(
                null,
                formatDNSValue(cached.value, {
                  cached: true,
                  error: err2
                })
              );
            }
            return callback2(err2);
          }
          if (addresses2 && addresses2.length) {
            let value = {
              addresses: addresses2,
              servername: options.servername || options.host
            };
            dnsCache.set(options.host, {
              value,
              expires: Date.now() + (options.dnsTtl || DNS_TTL)
            });
            return callback2(
              null,
              formatDNSValue(value, {
                cached: false
              })
            );
          }
          try {
            dns.lookup(options.host, { all: true }, (err3, addresses3) => {
              if (err3) {
                if (cached) {
                  return callback2(
                    null,
                    formatDNSValue(cached.value, {
                      cached: true,
                      error: err3
                    })
                  );
                }
                return callback2(err3);
              }
              let address = addresses3 ? addresses3.filter((addr) => isFamilySupported(addr.family)).map((addr) => addr.address).shift() : false;
              if (addresses3 && addresses3.length && !address) {
                console.warn(`Failed to resolve IPv${addresses3[0].family} addresses with current network`);
              }
              if (!address && cached) {
                return callback2(
                  null,
                  formatDNSValue(cached.value, {
                    cached: true
                  })
                );
              }
              let value = {
                addresses: address ? [address] : [options.host],
                servername: options.servername || options.host
              };
              dnsCache.set(options.host, {
                value,
                expires: Date.now() + (options.dnsTtl || DNS_TTL)
              });
              return callback2(
                null,
                formatDNSValue(value, {
                  cached: false
                })
              );
            });
          } catch (err3) {
            if (cached) {
              return callback2(
                null,
                formatDNSValue(cached.value, {
                  cached: true,
                  error: err3
                })
              );
            }
            return callback2(err3);
          }
        });
      });
    };
    module2.exports.parseConnectionUrl = (str) => {
      str = str || "";
      let options = {};
      [urllib.parse(str, true)].forEach((url) => {
        let auth;
        switch (url.protocol) {
          case "smtp:":
            options.secure = false;
            break;
          case "smtps:":
            options.secure = true;
            break;
          case "direct:":
            options.direct = true;
            break;
        }
        if (!isNaN(url.port) && Number(url.port)) {
          options.port = Number(url.port);
        }
        if (url.hostname) {
          options.host = url.hostname;
        }
        if (url.auth) {
          auth = url.auth.split(":");
          if (!options.auth) {
            options.auth = {};
          }
          options.auth.user = auth.shift();
          options.auth.pass = auth.join(":");
        }
        Object.keys(url.query || {}).forEach((key) => {
          let obj = options;
          let lKey = key;
          let value = url.query[key];
          if (!isNaN(value)) {
            value = Number(value);
          }
          switch (value) {
            case "true":
              value = true;
              break;
            case "false":
              value = false;
              break;
          }
          if (key.indexOf("tls.") === 0) {
            lKey = key.substr(4);
            if (!options.tls) {
              options.tls = {};
            }
            obj = options.tls;
          } else if (key.indexOf(".") >= 0) {
            return;
          }
          if (!(lKey in obj)) {
            obj[lKey] = value;
          }
        });
      });
      return options;
    };
    module2.exports._logFunc = (logger, level, defaults, data, message, ...args) => {
      let entry = {};
      Object.keys(defaults || {}).forEach((key) => {
        if (key !== "level") {
          entry[key] = defaults[key];
        }
      });
      Object.keys(data || {}).forEach((key) => {
        if (key !== "level") {
          entry[key] = data[key];
        }
      });
      logger[level](entry, message, ...args);
    };
    module2.exports.getLogger = (options, defaults) => {
      options = options || {};
      let response = {};
      let levels = ["trace", "debug", "info", "warn", "error", "fatal"];
      if (!options.logger) {
        levels.forEach((level) => {
          response[level] = () => false;
        });
        return response;
      }
      let logger = options.logger;
      if (options.logger === true) {
        logger = createDefaultLogger(levels);
      }
      levels.forEach((level) => {
        response[level] = (data, message, ...args) => {
          module2.exports._logFunc(logger, level, defaults, data, message, ...args);
        };
      });
      return response;
    };
    module2.exports.callbackPromise = (resolve2, reject) => function() {
      let args = Array.from(arguments);
      let err = args.shift();
      if (err) {
        reject(err);
      } else {
        resolve2(...args);
      }
    };
    module2.exports.parseDataURI = (uri) => {
      let input = uri;
      let commaPos = input.indexOf(",");
      if (!commaPos) {
        return uri;
      }
      let data = input.substring(commaPos + 1);
      let metaStr = input.substring("data:".length, commaPos);
      let encoding;
      let metaEntries = metaStr.split(";");
      let lastMetaEntry = metaEntries.length > 1 ? metaEntries[metaEntries.length - 1] : false;
      if (lastMetaEntry && lastMetaEntry.indexOf("=") < 0) {
        encoding = lastMetaEntry.toLowerCase();
        metaEntries.pop();
      }
      let contentType = metaEntries.shift() || "application/octet-stream";
      let params = {};
      for (let entry of metaEntries) {
        let sep = entry.indexOf("=");
        if (sep >= 0) {
          let key = entry.substring(0, sep);
          let value = entry.substring(sep + 1);
          params[key] = value;
        }
      }
      switch (encoding) {
        case "base64":
          data = Buffer.from(data, "base64");
          break;
        case "utf8":
          data = Buffer.from(data);
          break;
        default:
          try {
            data = Buffer.from(decodeURIComponent(data));
          } catch (err) {
            data = Buffer.from(data);
          }
          data = Buffer.from(data);
      }
      return { data, encoding, contentType, params };
    };
    module2.exports.resolveContent = (data, key, callback2) => {
      let promise;
      if (!callback2) {
        promise = new Promise((resolve2, reject) => {
          callback2 = module2.exports.callbackPromise(resolve2, reject);
        });
      }
      let content = data && data[key] && data[key].content || data[key];
      let contentStream;
      let encoding = (typeof data[key] === "object" && data[key].encoding || "utf8").toString().toLowerCase().replace(/[-_\s]/g, "");
      if (!content) {
        return callback2(null, content);
      }
      if (typeof content === "object") {
        if (typeof content.pipe === "function") {
          return resolveStream(content, (err, value) => {
            if (err) {
              return callback2(err);
            }
            if (data[key].content) {
              data[key].content = value;
            } else {
              data[key] = value;
            }
            callback2(null, value);
          });
        } else if (/^https?:\/\//i.test(content.path || content.href)) {
          contentStream = nmfetch(content.path || content.href);
          return resolveStream(contentStream, callback2);
        } else if (/^data:/i.test(content.path || content.href)) {
          let parsedDataUri = module2.exports.parseDataURI(content.path || content.href);
          if (!parsedDataUri || !parsedDataUri.data) {
            return callback2(null, Buffer.from(0));
          }
          return callback2(null, parsedDataUri.data);
        } else if (content.path) {
          return resolveStream(fs.createReadStream(content.path), callback2);
        }
      }
      if (typeof data[key].content === "string" && !["utf8", "usascii", "ascii"].includes(encoding)) {
        content = Buffer.from(data[key].content, encoding);
      }
      setImmediate(() => callback2(null, content));
      return promise;
    };
    module2.exports.assign = function() {
      let args = Array.from(arguments);
      let target = args.shift() || {};
      args.forEach((source) => {
        Object.keys(source || {}).forEach((key) => {
          if (["tls", "auth"].includes(key) && source[key] && typeof source[key] === "object") {
            if (!target[key]) {
              target[key] = {};
            }
            Object.keys(source[key]).forEach((subKey) => {
              target[key][subKey] = source[key][subKey];
            });
          } else {
            target[key] = source[key];
          }
        });
      });
      return target;
    };
    module2.exports.encodeXText = (str) => {
      if (!/[^\x21-\x2A\x2C-\x3C\x3E-\x7E]/.test(str)) {
        return str;
      }
      let buf = Buffer.from(str);
      let result = "";
      for (let i = 0, len = buf.length; i < len; i++) {
        let c = buf[i];
        if (c < 33 || c > 126 || c === 43 || c === 61) {
          result += "+" + (c < 16 ? "0" : "") + c.toString(16).toUpperCase();
        } else {
          result += String.fromCharCode(c);
        }
      }
      return result;
    };
    function resolveStream(stream, callback2) {
      let responded = false;
      let chunks = [];
      let chunklen = 0;
      stream.on("error", (err) => {
        if (responded) {
          return;
        }
        responded = true;
        callback2(err);
      });
      stream.on("readable", () => {
        let chunk;
        while ((chunk = stream.read()) !== null) {
          chunks.push(chunk);
          chunklen += chunk.length;
        }
      });
      stream.on("end", () => {
        if (responded) {
          return;
        }
        responded = true;
        let value;
        try {
          value = Buffer.concat(chunks, chunklen);
        } catch (E) {
          return callback2(E);
        }
        callback2(null, value);
      });
    }
    function createDefaultLogger(levels) {
      let levelMaxLen = 0;
      let levelNames = /* @__PURE__ */ new Map();
      levels.forEach((level) => {
        if (level.length > levelMaxLen) {
          levelMaxLen = level.length;
        }
      });
      levels.forEach((level) => {
        let levelName = level.toUpperCase();
        if (levelName.length < levelMaxLen) {
          levelName += " ".repeat(levelMaxLen - levelName.length);
        }
        levelNames.set(level, levelName);
      });
      let print = (level, entry, message, ...args) => {
        let prefix = "";
        if (entry) {
          if (entry.tnx === "server") {
            prefix = "S: ";
          } else if (entry.tnx === "client") {
            prefix = "C: ";
          }
          if (entry.sid) {
            prefix = "[" + entry.sid + "] " + prefix;
          }
          if (entry.cid) {
            prefix = "[#" + entry.cid + "] " + prefix;
          }
        }
        message = util.format(message, ...args);
        message.split(/\r?\n/).forEach((line) => {
          console.log("[%s] %s %s", (/* @__PURE__ */ new Date()).toISOString().substr(0, 19).replace(/T/, " "), levelNames.get(level), prefix + line);
        });
      };
      let logger = {};
      levels.forEach((level) => {
        logger[level] = print.bind(null, level);
      });
      return logger;
    }
  }
});

// node_modules/nodemailer/lib/mime-funcs/mime-types.js
var require_mime_types = __commonJS({
  "node_modules/nodemailer/lib/mime-funcs/mime-types.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var defaultMimeType = "application/octet-stream";
    var defaultExtension = "bin";
    var mimeTypes = /* @__PURE__ */ new Map([
      ["application/acad", "dwg"],
      ["application/applixware", "aw"],
      ["application/arj", "arj"],
      ["application/atom+xml", "xml"],
      ["application/atomcat+xml", "atomcat"],
      ["application/atomsvc+xml", "atomsvc"],
      ["application/base64", ["mm", "mme"]],
      ["application/binhex", "hqx"],
      ["application/binhex4", "hqx"],
      ["application/book", ["book", "boo"]],
      ["application/ccxml+xml,", "ccxml"],
      ["application/cdf", "cdf"],
      ["application/cdmi-capability", "cdmia"],
      ["application/cdmi-container", "cdmic"],
      ["application/cdmi-domain", "cdmid"],
      ["application/cdmi-object", "cdmio"],
      ["application/cdmi-queue", "cdmiq"],
      ["application/clariscad", "ccad"],
      ["application/commonground", "dp"],
      ["application/cu-seeme", "cu"],
      ["application/davmount+xml", "davmount"],
      ["application/drafting", "drw"],
      ["application/dsptype", "tsp"],
      ["application/dssc+der", "dssc"],
      ["application/dssc+xml", "xdssc"],
      ["application/dxf", "dxf"],
      ["application/ecmascript", ["js", "es"]],
      ["application/emma+xml", "emma"],
      ["application/envoy", "evy"],
      ["application/epub+zip", "epub"],
      ["application/excel", ["xls", "xl", "xla", "xlb", "xlc", "xld", "xlk", "xll", "xlm", "xlt", "xlv", "xlw"]],
      ["application/exi", "exi"],
      ["application/font-tdpfr", "pfr"],
      ["application/fractals", "fif"],
      ["application/freeloader", "frl"],
      ["application/futuresplash", "spl"],
      ["application/gnutar", "tgz"],
      ["application/groupwise", "vew"],
      ["application/hlp", "hlp"],
      ["application/hta", "hta"],
      ["application/hyperstudio", "stk"],
      ["application/i-deas", "unv"],
      ["application/iges", ["iges", "igs"]],
      ["application/inf", "inf"],
      ["application/internet-property-stream", "acx"],
      ["application/ipfix", "ipfix"],
      ["application/java", "class"],
      ["application/java-archive", "jar"],
      ["application/java-byte-code", "class"],
      ["application/java-serialized-object", "ser"],
      ["application/java-vm", "class"],
      ["application/javascript", "js"],
      ["application/json", "json"],
      ["application/lha", "lha"],
      ["application/lzx", "lzx"],
      ["application/mac-binary", "bin"],
      ["application/mac-binhex", "hqx"],
      ["application/mac-binhex40", "hqx"],
      ["application/mac-compactpro", "cpt"],
      ["application/macbinary", "bin"],
      ["application/mads+xml", "mads"],
      ["application/marc", "mrc"],
      ["application/marcxml+xml", "mrcx"],
      ["application/mathematica", "ma"],
      ["application/mathml+xml", "mathml"],
      ["application/mbedlet", "mbd"],
      ["application/mbox", "mbox"],
      ["application/mcad", "mcd"],
      ["application/mediaservercontrol+xml", "mscml"],
      ["application/metalink4+xml", "meta4"],
      ["application/mets+xml", "mets"],
      ["application/mime", "aps"],
      ["application/mods+xml", "mods"],
      ["application/mp21", "m21"],
      ["application/mp4", "mp4"],
      ["application/mspowerpoint", ["ppt", "pot", "pps", "ppz"]],
      ["application/msword", ["doc", "dot", "w6w", "wiz", "word"]],
      ["application/mswrite", "wri"],
      ["application/mxf", "mxf"],
      ["application/netmc", "mcp"],
      ["application/octet-stream", ["*"]],
      ["application/oda", "oda"],
      ["application/oebps-package+xml", "opf"],
      ["application/ogg", "ogx"],
      ["application/olescript", "axs"],
      ["application/onenote", "onetoc"],
      ["application/patch-ops-error+xml", "xer"],
      ["application/pdf", "pdf"],
      ["application/pgp-encrypted", "asc"],
      ["application/pgp-signature", "pgp"],
      ["application/pics-rules", "prf"],
      ["application/pkcs-12", "p12"],
      ["application/pkcs-crl", "crl"],
      ["application/pkcs10", "p10"],
      ["application/pkcs7-mime", ["p7c", "p7m"]],
      ["application/pkcs7-signature", "p7s"],
      ["application/pkcs8", "p8"],
      ["application/pkix-attr-cert", "ac"],
      ["application/pkix-cert", ["cer", "crt"]],
      ["application/pkix-crl", "crl"],
      ["application/pkix-pkipath", "pkipath"],
      ["application/pkixcmp", "pki"],
      ["application/plain", "text"],
      ["application/pls+xml", "pls"],
      ["application/postscript", ["ps", "ai", "eps"]],
      ["application/powerpoint", "ppt"],
      ["application/pro_eng", ["part", "prt"]],
      ["application/prs.cww", "cww"],
      ["application/pskc+xml", "pskcxml"],
      ["application/rdf+xml", "rdf"],
      ["application/reginfo+xml", "rif"],
      ["application/relax-ng-compact-syntax", "rnc"],
      ["application/resource-lists+xml", "rl"],
      ["application/resource-lists-diff+xml", "rld"],
      ["application/ringing-tones", "rng"],
      ["application/rls-services+xml", "rs"],
      ["application/rsd+xml", "rsd"],
      ["application/rss+xml", "xml"],
      ["application/rtf", ["rtf", "rtx"]],
      ["application/sbml+xml", "sbml"],
      ["application/scvp-cv-request", "scq"],
      ["application/scvp-cv-response", "scs"],
      ["application/scvp-vp-request", "spq"],
      ["application/scvp-vp-response", "spp"],
      ["application/sdp", "sdp"],
      ["application/sea", "sea"],
      ["application/set", "set"],
      ["application/set-payment-initiation", "setpay"],
      ["application/set-registration-initiation", "setreg"],
      ["application/shf+xml", "shf"],
      ["application/sla", "stl"],
      ["application/smil", ["smi", "smil"]],
      ["application/smil+xml", "smi"],
      ["application/solids", "sol"],
      ["application/sounder", "sdr"],
      ["application/sparql-query", "rq"],
      ["application/sparql-results+xml", "srx"],
      ["application/srgs", "gram"],
      ["application/srgs+xml", "grxml"],
      ["application/sru+xml", "sru"],
      ["application/ssml+xml", "ssml"],
      ["application/step", ["step", "stp"]],
      ["application/streamingmedia", "ssm"],
      ["application/tei+xml", "tei"],
      ["application/thraud+xml", "tfi"],
      ["application/timestamped-data", "tsd"],
      ["application/toolbook", "tbk"],
      ["application/vda", "vda"],
      ["application/vnd.3gpp.pic-bw-large", "plb"],
      ["application/vnd.3gpp.pic-bw-small", "psb"],
      ["application/vnd.3gpp.pic-bw-var", "pvb"],
      ["application/vnd.3gpp2.tcap", "tcap"],
      ["application/vnd.3m.post-it-notes", "pwn"],
      ["application/vnd.accpac.simply.aso", "aso"],
      ["application/vnd.accpac.simply.imp", "imp"],
      ["application/vnd.acucobol", "acu"],
      ["application/vnd.acucorp", "atc"],
      ["application/vnd.adobe.air-application-installer-package+zip", "air"],
      ["application/vnd.adobe.fxp", "fxp"],
      ["application/vnd.adobe.xdp+xml", "xdp"],
      ["application/vnd.adobe.xfdf", "xfdf"],
      ["application/vnd.ahead.space", "ahead"],
      ["application/vnd.airzip.filesecure.azf", "azf"],
      ["application/vnd.airzip.filesecure.azs", "azs"],
      ["application/vnd.amazon.ebook", "azw"],
      ["application/vnd.americandynamics.acc", "acc"],
      ["application/vnd.amiga.ami", "ami"],
      ["application/vnd.android.package-archive", "apk"],
      ["application/vnd.anser-web-certificate-issue-initiation", "cii"],
      ["application/vnd.anser-web-funds-transfer-initiation", "fti"],
      ["application/vnd.antix.game-component", "atx"],
      ["application/vnd.apple.installer+xml", "mpkg"],
      ["application/vnd.apple.mpegurl", "m3u8"],
      ["application/vnd.aristanetworks.swi", "swi"],
      ["application/vnd.audiograph", "aep"],
      ["application/vnd.blueice.multipass", "mpm"],
      ["application/vnd.bmi", "bmi"],
      ["application/vnd.businessobjects", "rep"],
      ["application/vnd.chemdraw+xml", "cdxml"],
      ["application/vnd.chipnuts.karaoke-mmd", "mmd"],
      ["application/vnd.cinderella", "cdy"],
      ["application/vnd.claymore", "cla"],
      ["application/vnd.cloanto.rp9", "rp9"],
      ["application/vnd.clonk.c4group", "c4g"],
      ["application/vnd.cluetrust.cartomobile-config", "c11amc"],
      ["application/vnd.cluetrust.cartomobile-config-pkg", "c11amz"],
      ["application/vnd.commonspace", "csp"],
      ["application/vnd.contact.cmsg", "cdbcmsg"],
      ["application/vnd.cosmocaller", "cmc"],
      ["application/vnd.crick.clicker", "clkx"],
      ["application/vnd.crick.clicker.keyboard", "clkk"],
      ["application/vnd.crick.clicker.palette", "clkp"],
      ["application/vnd.crick.clicker.template", "clkt"],
      ["application/vnd.crick.clicker.wordbank", "clkw"],
      ["application/vnd.criticaltools.wbs+xml", "wbs"],
      ["application/vnd.ctc-posml", "pml"],
      ["application/vnd.cups-ppd", "ppd"],
      ["application/vnd.curl.car", "car"],
      ["application/vnd.curl.pcurl", "pcurl"],
      ["application/vnd.data-vision.rdz", "rdz"],
      ["application/vnd.denovo.fcselayout-link", "fe_launch"],
      ["application/vnd.dna", "dna"],
      ["application/vnd.dolby.mlp", "mlp"],
      ["application/vnd.dpgraph", "dpg"],
      ["application/vnd.dreamfactory", "dfac"],
      ["application/vnd.dvb.ait", "ait"],
      ["application/vnd.dvb.service", "svc"],
      ["application/vnd.dynageo", "geo"],
      ["application/vnd.ecowin.chart", "mag"],
      ["application/vnd.enliven", "nml"],
      ["application/vnd.epson.esf", "esf"],
      ["application/vnd.epson.msf", "msf"],
      ["application/vnd.epson.quickanime", "qam"],
      ["application/vnd.epson.salt", "slt"],
      ["application/vnd.epson.ssf", "ssf"],
      ["application/vnd.eszigno3+xml", "es3"],
      ["application/vnd.ezpix-album", "ez2"],
      ["application/vnd.ezpix-package", "ez3"],
      ["application/vnd.fdf", "fdf"],
      ["application/vnd.fdsn.seed", "seed"],
      ["application/vnd.flographit", "gph"],
      ["application/vnd.fluxtime.clip", "ftc"],
      ["application/vnd.framemaker", "fm"],
      ["application/vnd.frogans.fnc", "fnc"],
      ["application/vnd.frogans.ltf", "ltf"],
      ["application/vnd.fsc.weblaunch", "fsc"],
      ["application/vnd.fujitsu.oasys", "oas"],
      ["application/vnd.fujitsu.oasys2", "oa2"],
      ["application/vnd.fujitsu.oasys3", "oa3"],
      ["application/vnd.fujitsu.oasysgp", "fg5"],
      ["application/vnd.fujitsu.oasysprs", "bh2"],
      ["application/vnd.fujixerox.ddd", "ddd"],
      ["application/vnd.fujixerox.docuworks", "xdw"],
      ["application/vnd.fujixerox.docuworks.binder", "xbd"],
      ["application/vnd.fuzzysheet", "fzs"],
      ["application/vnd.genomatix.tuxedo", "txd"],
      ["application/vnd.geogebra.file", "ggb"],
      ["application/vnd.geogebra.tool", "ggt"],
      ["application/vnd.geometry-explorer", "gex"],
      ["application/vnd.geonext", "gxt"],
      ["application/vnd.geoplan", "g2w"],
      ["application/vnd.geospace", "g3w"],
      ["application/vnd.gmx", "gmx"],
      ["application/vnd.google-earth.kml+xml", "kml"],
      ["application/vnd.google-earth.kmz", "kmz"],
      ["application/vnd.grafeq", "gqf"],
      ["application/vnd.groove-account", "gac"],
      ["application/vnd.groove-help", "ghf"],
      ["application/vnd.groove-identity-message", "gim"],
      ["application/vnd.groove-injector", "grv"],
      ["application/vnd.groove-tool-message", "gtm"],
      ["application/vnd.groove-tool-template", "tpl"],
      ["application/vnd.groove-vcard", "vcg"],
      ["application/vnd.hal+xml", "hal"],
      ["application/vnd.handheld-entertainment+xml", "zmm"],
      ["application/vnd.hbci", "hbci"],
      ["application/vnd.hhe.lesson-player", "les"],
      ["application/vnd.hp-hpgl", ["hgl", "hpg", "hpgl"]],
      ["application/vnd.hp-hpid", "hpid"],
      ["application/vnd.hp-hps", "hps"],
      ["application/vnd.hp-jlyt", "jlt"],
      ["application/vnd.hp-pcl", "pcl"],
      ["application/vnd.hp-pclxl", "pclxl"],
      ["application/vnd.hydrostatix.sof-data", "sfd-hdstx"],
      ["application/vnd.hzn-3d-crossword", "x3d"],
      ["application/vnd.ibm.minipay", "mpy"],
      ["application/vnd.ibm.modcap", "afp"],
      ["application/vnd.ibm.rights-management", "irm"],
      ["application/vnd.ibm.secure-container", "sc"],
      ["application/vnd.iccprofile", "icc"],
      ["application/vnd.igloader", "igl"],
      ["application/vnd.immervision-ivp", "ivp"],
      ["application/vnd.immervision-ivu", "ivu"],
      ["application/vnd.insors.igm", "igm"],
      ["application/vnd.intercon.formnet", "xpw"],
      ["application/vnd.intergeo", "i2g"],
      ["application/vnd.intu.qbo", "qbo"],
      ["application/vnd.intu.qfx", "qfx"],
      ["application/vnd.ipunplugged.rcprofile", "rcprofile"],
      ["application/vnd.irepository.package+xml", "irp"],
      ["application/vnd.is-xpr", "xpr"],
      ["application/vnd.isac.fcs", "fcs"],
      ["application/vnd.jam", "jam"],
      ["application/vnd.jcp.javame.midlet-rms", "rms"],
      ["application/vnd.jisp", "jisp"],
      ["application/vnd.joost.joda-archive", "joda"],
      ["application/vnd.kahootz", "ktz"],
      ["application/vnd.kde.karbon", "karbon"],
      ["application/vnd.kde.kchart", "chrt"],
      ["application/vnd.kde.kformula", "kfo"],
      ["application/vnd.kde.kivio", "flw"],
      ["application/vnd.kde.kontour", "kon"],
      ["application/vnd.kde.kpresenter", "kpr"],
      ["application/vnd.kde.kspread", "ksp"],
      ["application/vnd.kde.kword", "kwd"],
      ["application/vnd.kenameaapp", "htke"],
      ["application/vnd.kidspiration", "kia"],
      ["application/vnd.kinar", "kne"],
      ["application/vnd.koan", "skp"],
      ["application/vnd.kodak-descriptor", "sse"],
      ["application/vnd.las.las+xml", "lasxml"],
      ["application/vnd.llamagraphics.life-balance.desktop", "lbd"],
      ["application/vnd.llamagraphics.life-balance.exchange+xml", "lbe"],
      ["application/vnd.lotus-1-2-3", "123"],
      ["application/vnd.lotus-approach", "apr"],
      ["application/vnd.lotus-freelance", "pre"],
      ["application/vnd.lotus-notes", "nsf"],
      ["application/vnd.lotus-organizer", "org"],
      ["application/vnd.lotus-screencam", "scm"],
      ["application/vnd.lotus-wordpro", "lwp"],
      ["application/vnd.macports.portpkg", "portpkg"],
      ["application/vnd.mcd", "mcd"],
      ["application/vnd.medcalcdata", "mc1"],
      ["application/vnd.mediastation.cdkey", "cdkey"],
      ["application/vnd.mfer", "mwf"],
      ["application/vnd.mfmp", "mfm"],
      ["application/vnd.micrografx.flo", "flo"],
      ["application/vnd.micrografx.igx", "igx"],
      ["application/vnd.mif", "mif"],
      ["application/vnd.mobius.daf", "daf"],
      ["application/vnd.mobius.dis", "dis"],
      ["application/vnd.mobius.mbk", "mbk"],
      ["application/vnd.mobius.mqy", "mqy"],
      ["application/vnd.mobius.msl", "msl"],
      ["application/vnd.mobius.plc", "plc"],
      ["application/vnd.mobius.txf", "txf"],
      ["application/vnd.mophun.application", "mpn"],
      ["application/vnd.mophun.certificate", "mpc"],
      ["application/vnd.mozilla.xul+xml", "xul"],
      ["application/vnd.ms-artgalry", "cil"],
      ["application/vnd.ms-cab-compressed", "cab"],
      ["application/vnd.ms-excel", ["xls", "xla", "xlc", "xlm", "xlt", "xlw", "xlb", "xll"]],
      ["application/vnd.ms-excel.addin.macroenabled.12", "xlam"],
      ["application/vnd.ms-excel.sheet.binary.macroenabled.12", "xlsb"],
      ["application/vnd.ms-excel.sheet.macroenabled.12", "xlsm"],
      ["application/vnd.ms-excel.template.macroenabled.12", "xltm"],
      ["application/vnd.ms-fontobject", "eot"],
      ["application/vnd.ms-htmlhelp", "chm"],
      ["application/vnd.ms-ims", "ims"],
      ["application/vnd.ms-lrm", "lrm"],
      ["application/vnd.ms-officetheme", "thmx"],
      ["application/vnd.ms-outlook", "msg"],
      ["application/vnd.ms-pki.certstore", "sst"],
      ["application/vnd.ms-pki.pko", "pko"],
      ["application/vnd.ms-pki.seccat", "cat"],
      ["application/vnd.ms-pki.stl", "stl"],
      ["application/vnd.ms-pkicertstore", "sst"],
      ["application/vnd.ms-pkiseccat", "cat"],
      ["application/vnd.ms-pkistl", "stl"],
      ["application/vnd.ms-powerpoint", ["ppt", "pot", "pps", "ppa", "pwz"]],
      ["application/vnd.ms-powerpoint.addin.macroenabled.12", "ppam"],
      ["application/vnd.ms-powerpoint.presentation.macroenabled.12", "pptm"],
      ["application/vnd.ms-powerpoint.slide.macroenabled.12", "sldm"],
      ["application/vnd.ms-powerpoint.slideshow.macroenabled.12", "ppsm"],
      ["application/vnd.ms-powerpoint.template.macroenabled.12", "potm"],
      ["application/vnd.ms-project", "mpp"],
      ["application/vnd.ms-word.document.macroenabled.12", "docm"],
      ["application/vnd.ms-word.template.macroenabled.12", "dotm"],
      ["application/vnd.ms-works", ["wks", "wcm", "wdb", "wps"]],
      ["application/vnd.ms-wpl", "wpl"],
      ["application/vnd.ms-xpsdocument", "xps"],
      ["application/vnd.mseq", "mseq"],
      ["application/vnd.musician", "mus"],
      ["application/vnd.muvee.style", "msty"],
      ["application/vnd.neurolanguage.nlu", "nlu"],
      ["application/vnd.noblenet-directory", "nnd"],
      ["application/vnd.noblenet-sealer", "nns"],
      ["application/vnd.noblenet-web", "nnw"],
      ["application/vnd.nokia.configuration-message", "ncm"],
      ["application/vnd.nokia.n-gage.data", "ngdat"],
      ["application/vnd.nokia.n-gage.symbian.install", "n-gage"],
      ["application/vnd.nokia.radio-preset", "rpst"],
      ["application/vnd.nokia.radio-presets", "rpss"],
      ["application/vnd.nokia.ringing-tone", "rng"],
      ["application/vnd.novadigm.edm", "edm"],
      ["application/vnd.novadigm.edx", "edx"],
      ["application/vnd.novadigm.ext", "ext"],
      ["application/vnd.oasis.opendocument.chart", "odc"],
      ["application/vnd.oasis.opendocument.chart-template", "otc"],
      ["application/vnd.oasis.opendocument.database", "odb"],
      ["application/vnd.oasis.opendocument.formula", "odf"],
      ["application/vnd.oasis.opendocument.formula-template", "odft"],
      ["application/vnd.oasis.opendocument.graphics", "odg"],
      ["application/vnd.oasis.opendocument.graphics-template", "otg"],
      ["application/vnd.oasis.opendocument.image", "odi"],
      ["application/vnd.oasis.opendocument.image-template", "oti"],
      ["application/vnd.oasis.opendocument.presentation", "odp"],
      ["application/vnd.oasis.opendocument.presentation-template", "otp"],
      ["application/vnd.oasis.opendocument.spreadsheet", "ods"],
      ["application/vnd.oasis.opendocument.spreadsheet-template", "ots"],
      ["application/vnd.oasis.opendocument.text", "odt"],
      ["application/vnd.oasis.opendocument.text-master", "odm"],
      ["application/vnd.oasis.opendocument.text-template", "ott"],
      ["application/vnd.oasis.opendocument.text-web", "oth"],
      ["application/vnd.olpc-sugar", "xo"],
      ["application/vnd.oma.dd2+xml", "dd2"],
      ["application/vnd.openofficeorg.extension", "oxt"],
      ["application/vnd.openxmlformats-officedocument.presentationml.presentation", "pptx"],
      ["application/vnd.openxmlformats-officedocument.presentationml.slide", "sldx"],
      ["application/vnd.openxmlformats-officedocument.presentationml.slideshow", "ppsx"],
      ["application/vnd.openxmlformats-officedocument.presentationml.template", "potx"],
      ["application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "xlsx"],
      ["application/vnd.openxmlformats-officedocument.spreadsheetml.template", "xltx"],
      ["application/vnd.openxmlformats-officedocument.wordprocessingml.document", "docx"],
      ["application/vnd.openxmlformats-officedocument.wordprocessingml.template", "dotx"],
      ["application/vnd.osgeo.mapguide.package", "mgp"],
      ["application/vnd.osgi.dp", "dp"],
      ["application/vnd.palm", "pdb"],
      ["application/vnd.pawaafile", "paw"],
      ["application/vnd.pg.format", "str"],
      ["application/vnd.pg.osasli", "ei6"],
      ["application/vnd.picsel", "efif"],
      ["application/vnd.pmi.widget", "wg"],
      ["application/vnd.pocketlearn", "plf"],
      ["application/vnd.powerbuilder6", "pbd"],
      ["application/vnd.previewsystems.box", "box"],
      ["application/vnd.proteus.magazine", "mgz"],
      ["application/vnd.publishare-delta-tree", "qps"],
      ["application/vnd.pvi.ptid1", "ptid"],
      ["application/vnd.quark.quarkxpress", "qxd"],
      ["application/vnd.realvnc.bed", "bed"],
      ["application/vnd.recordare.musicxml", "mxl"],
      ["application/vnd.recordare.musicxml+xml", "musicxml"],
      ["application/vnd.rig.cryptonote", "cryptonote"],
      ["application/vnd.rim.cod", "cod"],
      ["application/vnd.rn-realmedia", "rm"],
      ["application/vnd.rn-realplayer", "rnx"],
      ["application/vnd.route66.link66+xml", "link66"],
      ["application/vnd.sailingtracker.track", "st"],
      ["application/vnd.seemail", "see"],
      ["application/vnd.sema", "sema"],
      ["application/vnd.semd", "semd"],
      ["application/vnd.semf", "semf"],
      ["application/vnd.shana.informed.formdata", "ifm"],
      ["application/vnd.shana.informed.formtemplate", "itp"],
      ["application/vnd.shana.informed.interchange", "iif"],
      ["application/vnd.shana.informed.package", "ipk"],
      ["application/vnd.simtech-mindmapper", "twd"],
      ["application/vnd.smaf", "mmf"],
      ["application/vnd.smart.teacher", "teacher"],
      ["application/vnd.solent.sdkm+xml", "sdkm"],
      ["application/vnd.spotfire.dxp", "dxp"],
      ["application/vnd.spotfire.sfs", "sfs"],
      ["application/vnd.stardivision.calc", "sdc"],
      ["application/vnd.stardivision.draw", "sda"],
      ["application/vnd.stardivision.impress", "sdd"],
      ["application/vnd.stardivision.math", "smf"],
      ["application/vnd.stardivision.writer", "sdw"],
      ["application/vnd.stardivision.writer-global", "sgl"],
      ["application/vnd.stepmania.stepchart", "sm"],
      ["application/vnd.sun.xml.calc", "sxc"],
      ["application/vnd.sun.xml.calc.template", "stc"],
      ["application/vnd.sun.xml.draw", "sxd"],
      ["application/vnd.sun.xml.draw.template", "std"],
      ["application/vnd.sun.xml.impress", "sxi"],
      ["application/vnd.sun.xml.impress.template", "sti"],
      ["application/vnd.sun.xml.math", "sxm"],
      ["application/vnd.sun.xml.writer", "sxw"],
      ["application/vnd.sun.xml.writer.global", "sxg"],
      ["application/vnd.sun.xml.writer.template", "stw"],
      ["application/vnd.sus-calendar", "sus"],
      ["application/vnd.svd", "svd"],
      ["application/vnd.symbian.install", "sis"],
      ["application/vnd.syncml+xml", "xsm"],
      ["application/vnd.syncml.dm+wbxml", "bdm"],
      ["application/vnd.syncml.dm+xml", "xdm"],
      ["application/vnd.tao.intent-module-archive", "tao"],
      ["application/vnd.tmobile-livetv", "tmo"],
      ["application/vnd.trid.tpt", "tpt"],
      ["application/vnd.triscape.mxs", "mxs"],
      ["application/vnd.trueapp", "tra"],
      ["application/vnd.ufdl", "ufd"],
      ["application/vnd.uiq.theme", "utz"],
      ["application/vnd.umajin", "umj"],
      ["application/vnd.unity", "unityweb"],
      ["application/vnd.uoml+xml", "uoml"],
      ["application/vnd.vcx", "vcx"],
      ["application/vnd.visio", "vsd"],
      ["application/vnd.visionary", "vis"],
      ["application/vnd.vsf", "vsf"],
      ["application/vnd.wap.wbxml", "wbxml"],
      ["application/vnd.wap.wmlc", "wmlc"],
      ["application/vnd.wap.wmlscriptc", "wmlsc"],
      ["application/vnd.webturbo", "wtb"],
      ["application/vnd.wolfram.player", "nbp"],
      ["application/vnd.wordperfect", "wpd"],
      ["application/vnd.wqd", "wqd"],
      ["application/vnd.wt.stf", "stf"],
      ["application/vnd.xara", ["web", "xar"]],
      ["application/vnd.xfdl", "xfdl"],
      ["application/vnd.yamaha.hv-dic", "hvd"],
      ["application/vnd.yamaha.hv-script", "hvs"],
      ["application/vnd.yamaha.hv-voice", "hvp"],
      ["application/vnd.yamaha.openscoreformat", "osf"],
      ["application/vnd.yamaha.openscoreformat.osfpvg+xml", "osfpvg"],
      ["application/vnd.yamaha.smaf-audio", "saf"],
      ["application/vnd.yamaha.smaf-phrase", "spf"],
      ["application/vnd.yellowriver-custom-menu", "cmp"],
      ["application/vnd.zul", "zir"],
      ["application/vnd.zzazz.deck+xml", "zaz"],
      ["application/vocaltec-media-desc", "vmd"],
      ["application/vocaltec-media-file", "vmf"],
      ["application/voicexml+xml", "vxml"],
      ["application/widget", "wgt"],
      ["application/winhlp", "hlp"],
      ["application/wordperfect", ["wp", "wp5", "wp6", "wpd"]],
      ["application/wordperfect6.0", ["w60", "wp5"]],
      ["application/wordperfect6.1", "w61"],
      ["application/wsdl+xml", "wsdl"],
      ["application/wspolicy+xml", "wspolicy"],
      ["application/x-123", "wk1"],
      ["application/x-7z-compressed", "7z"],
      ["application/x-abiword", "abw"],
      ["application/x-ace-compressed", "ace"],
      ["application/x-aim", "aim"],
      ["application/x-authorware-bin", "aab"],
      ["application/x-authorware-map", "aam"],
      ["application/x-authorware-seg", "aas"],
      ["application/x-bcpio", "bcpio"],
      ["application/x-binary", "bin"],
      ["application/x-binhex40", "hqx"],
      ["application/x-bittorrent", "torrent"],
      ["application/x-bsh", ["bsh", "sh", "shar"]],
      ["application/x-bytecode.elisp", "elc"],
      ["application/x-bytecode.python", "pyc"],
      ["application/x-bzip", "bz"],
      ["application/x-bzip2", ["boz", "bz2"]],
      ["application/x-cdf", "cdf"],
      ["application/x-cdlink", "vcd"],
      ["application/x-chat", ["cha", "chat"]],
      ["application/x-chess-pgn", "pgn"],
      ["application/x-cmu-raster", "ras"],
      ["application/x-cocoa", "cco"],
      ["application/x-compactpro", "cpt"],
      ["application/x-compress", "z"],
      ["application/x-compressed", ["tgz", "gz", "z", "zip"]],
      ["application/x-conference", "nsc"],
      ["application/x-cpio", "cpio"],
      ["application/x-cpt", "cpt"],
      ["application/x-csh", "csh"],
      ["application/x-debian-package", "deb"],
      ["application/x-deepv", "deepv"],
      ["application/x-director", ["dir", "dcr", "dxr"]],
      ["application/x-doom", "wad"],
      ["application/x-dtbncx+xml", "ncx"],
      ["application/x-dtbook+xml", "dtb"],
      ["application/x-dtbresource+xml", "res"],
      ["application/x-dvi", "dvi"],
      ["application/x-elc", "elc"],
      ["application/x-envoy", ["env", "evy"]],
      ["application/x-esrehber", "es"],
      ["application/x-excel", ["xls", "xla", "xlb", "xlc", "xld", "xlk", "xll", "xlm", "xlt", "xlv", "xlw"]],
      ["application/x-font-bdf", "bdf"],
      ["application/x-font-ghostscript", "gsf"],
      ["application/x-font-linux-psf", "psf"],
      ["application/x-font-otf", "otf"],
      ["application/x-font-pcf", "pcf"],
      ["application/x-font-snf", "snf"],
      ["application/x-font-ttf", "ttf"],
      ["application/x-font-type1", "pfa"],
      ["application/x-font-woff", "woff"],
      ["application/x-frame", "mif"],
      ["application/x-freelance", "pre"],
      ["application/x-futuresplash", "spl"],
      ["application/x-gnumeric", "gnumeric"],
      ["application/x-gsp", "gsp"],
      ["application/x-gss", "gss"],
      ["application/x-gtar", "gtar"],
      ["application/x-gzip", ["gz", "gzip"]],
      ["application/x-hdf", "hdf"],
      ["application/x-helpfile", ["help", "hlp"]],
      ["application/x-httpd-imap", "imap"],
      ["application/x-ima", "ima"],
      ["application/x-internet-signup", ["ins", "isp"]],
      ["application/x-internett-signup", "ins"],
      ["application/x-inventor", "iv"],
      ["application/x-ip2", "ip"],
      ["application/x-iphone", "iii"],
      ["application/x-java-class", "class"],
      ["application/x-java-commerce", "jcm"],
      ["application/x-java-jnlp-file", "jnlp"],
      ["application/x-javascript", "js"],
      ["application/x-koan", ["skd", "skm", "skp", "skt"]],
      ["application/x-ksh", "ksh"],
      ["application/x-latex", ["latex", "ltx"]],
      ["application/x-lha", "lha"],
      ["application/x-lisp", "lsp"],
      ["application/x-livescreen", "ivy"],
      ["application/x-lotus", "wq1"],
      ["application/x-lotusscreencam", "scm"],
      ["application/x-lzh", "lzh"],
      ["application/x-lzx", "lzx"],
      ["application/x-mac-binhex40", "hqx"],
      ["application/x-macbinary", "bin"],
      ["application/x-magic-cap-package-1.0", "mc$"],
      ["application/x-mathcad", "mcd"],
      ["application/x-meme", "mm"],
      ["application/x-midi", ["mid", "midi"]],
      ["application/x-mif", "mif"],
      ["application/x-mix-transfer", "nix"],
      ["application/x-mobipocket-ebook", "prc"],
      ["application/x-mplayer2", "asx"],
      ["application/x-ms-application", "application"],
      ["application/x-ms-wmd", "wmd"],
      ["application/x-ms-wmz", "wmz"],
      ["application/x-ms-xbap", "xbap"],
      ["application/x-msaccess", "mdb"],
      ["application/x-msbinder", "obd"],
      ["application/x-mscardfile", "crd"],
      ["application/x-msclip", "clp"],
      ["application/x-msdownload", ["exe", "dll"]],
      ["application/x-msexcel", ["xls", "xla", "xlw"]],
      ["application/x-msmediaview", ["mvb", "m13", "m14"]],
      ["application/x-msmetafile", "wmf"],
      ["application/x-msmoney", "mny"],
      ["application/x-mspowerpoint", "ppt"],
      ["application/x-mspublisher", "pub"],
      ["application/x-msschedule", "scd"],
      ["application/x-msterminal", "trm"],
      ["application/x-mswrite", "wri"],
      ["application/x-navi-animation", "ani"],
      ["application/x-navidoc", "nvd"],
      ["application/x-navimap", "map"],
      ["application/x-navistyle", "stl"],
      ["application/x-netcdf", ["cdf", "nc"]],
      ["application/x-newton-compatible-pkg", "pkg"],
      ["application/x-nokia-9000-communicator-add-on-software", "aos"],
      ["application/x-omc", "omc"],
      ["application/x-omcdatamaker", "omcd"],
      ["application/x-omcregerator", "omcr"],
      ["application/x-pagemaker", ["pm4", "pm5"]],
      ["application/x-pcl", "pcl"],
      ["application/x-perfmon", ["pma", "pmc", "pml", "pmr", "pmw"]],
      ["application/x-pixclscript", "plx"],
      ["application/x-pkcs10", "p10"],
      ["application/x-pkcs12", ["p12", "pfx"]],
      ["application/x-pkcs7-certificates", ["p7b", "spc"]],
      ["application/x-pkcs7-certreqresp", "p7r"],
      ["application/x-pkcs7-mime", ["p7m", "p7c"]],
      ["application/x-pkcs7-signature", ["p7s", "p7a"]],
      ["application/x-pointplus", "css"],
      ["application/x-portable-anymap", "pnm"],
      ["application/x-project", ["mpc", "mpt", "mpv", "mpx"]],
      ["application/x-qpro", "wb1"],
      ["application/x-rar-compressed", "rar"],
      ["application/x-rtf", "rtf"],
      ["application/x-sdp", "sdp"],
      ["application/x-sea", "sea"],
      ["application/x-seelogo", "sl"],
      ["application/x-sh", "sh"],
      ["application/x-shar", ["shar", "sh"]],
      ["application/x-shockwave-flash", "swf"],
      ["application/x-silverlight-app", "xap"],
      ["application/x-sit", "sit"],
      ["application/x-sprite", ["spr", "sprite"]],
      ["application/x-stuffit", "sit"],
      ["application/x-stuffitx", "sitx"],
      ["application/x-sv4cpio", "sv4cpio"],
      ["application/x-sv4crc", "sv4crc"],
      ["application/x-tar", "tar"],
      ["application/x-tbook", ["sbk", "tbk"]],
      ["application/x-tcl", "tcl"],
      ["application/x-tex", "tex"],
      ["application/x-tex-tfm", "tfm"],
      ["application/x-texinfo", ["texi", "texinfo"]],
      ["application/x-troff", ["roff", "t", "tr"]],
      ["application/x-troff-man", "man"],
      ["application/x-troff-me", "me"],
      ["application/x-troff-ms", "ms"],
      ["application/x-troff-msvideo", "avi"],
      ["application/x-ustar", "ustar"],
      ["application/x-visio", ["vsd", "vst", "vsw"]],
      ["application/x-vnd.audioexplosion.mzz", "mzz"],
      ["application/x-vnd.ls-xpix", "xpix"],
      ["application/x-vrml", "vrml"],
      ["application/x-wais-source", ["src", "wsrc"]],
      ["application/x-winhelp", "hlp"],
      ["application/x-wintalk", "wtk"],
      ["application/x-world", ["wrl", "svr"]],
      ["application/x-wpwin", "wpd"],
      ["application/x-wri", "wri"],
      ["application/x-x509-ca-cert", ["cer", "crt", "der"]],
      ["application/x-x509-user-cert", "crt"],
      ["application/x-xfig", "fig"],
      ["application/x-xpinstall", "xpi"],
      ["application/x-zip-compressed", "zip"],
      ["application/xcap-diff+xml", "xdf"],
      ["application/xenc+xml", "xenc"],
      ["application/xhtml+xml", "xhtml"],
      ["application/xml", "xml"],
      ["application/xml-dtd", "dtd"],
      ["application/xop+xml", "xop"],
      ["application/xslt+xml", "xslt"],
      ["application/xspf+xml", "xspf"],
      ["application/xv+xml", "mxml"],
      ["application/yang", "yang"],
      ["application/yin+xml", "yin"],
      ["application/ynd.ms-pkipko", "pko"],
      ["application/zip", "zip"],
      ["audio/adpcm", "adp"],
      ["audio/aiff", ["aiff", "aif", "aifc"]],
      ["audio/basic", ["snd", "au"]],
      ["audio/it", "it"],
      ["audio/make", ["funk", "my", "pfunk"]],
      ["audio/make.my.funk", "pfunk"],
      ["audio/mid", ["mid", "rmi"]],
      ["audio/midi", ["midi", "kar", "mid"]],
      ["audio/mod", "mod"],
      ["audio/mp4", "mp4a"],
      ["audio/mpeg", ["mpga", "mp3", "m2a", "mp2", "mpa", "mpg"]],
      ["audio/mpeg3", "mp3"],
      ["audio/nspaudio", ["la", "lma"]],
      ["audio/ogg", "oga"],
      ["audio/s3m", "s3m"],
      ["audio/tsp-audio", "tsi"],
      ["audio/tsplayer", "tsp"],
      ["audio/vnd.dece.audio", "uva"],
      ["audio/vnd.digital-winds", "eol"],
      ["audio/vnd.dra", "dra"],
      ["audio/vnd.dts", "dts"],
      ["audio/vnd.dts.hd", "dtshd"],
      ["audio/vnd.lucent.voice", "lvp"],
      ["audio/vnd.ms-playready.media.pya", "pya"],
      ["audio/vnd.nuera.ecelp4800", "ecelp4800"],
      ["audio/vnd.nuera.ecelp7470", "ecelp7470"],
      ["audio/vnd.nuera.ecelp9600", "ecelp9600"],
      ["audio/vnd.qcelp", "qcp"],
      ["audio/vnd.rip", "rip"],
      ["audio/voc", "voc"],
      ["audio/voxware", "vox"],
      ["audio/wav", "wav"],
      ["audio/webm", "weba"],
      ["audio/x-aac", "aac"],
      ["audio/x-adpcm", "snd"],
      ["audio/x-aiff", ["aiff", "aif", "aifc"]],
      ["audio/x-au", "au"],
      ["audio/x-gsm", ["gsd", "gsm"]],
      ["audio/x-jam", "jam"],
      ["audio/x-liveaudio", "lam"],
      ["audio/x-mid", ["mid", "midi"]],
      ["audio/x-midi", ["midi", "mid"]],
      ["audio/x-mod", "mod"],
      ["audio/x-mpeg", "mp2"],
      ["audio/x-mpeg-3", "mp3"],
      ["audio/x-mpegurl", "m3u"],
      ["audio/x-mpequrl", "m3u"],
      ["audio/x-ms-wax", "wax"],
      ["audio/x-ms-wma", "wma"],
      ["audio/x-nspaudio", ["la", "lma"]],
      ["audio/x-pn-realaudio", ["ra", "ram", "rm", "rmm", "rmp"]],
      ["audio/x-pn-realaudio-plugin", ["ra", "rmp", "rpm"]],
      ["audio/x-psid", "sid"],
      ["audio/x-realaudio", "ra"],
      ["audio/x-twinvq", "vqf"],
      ["audio/x-twinvq-plugin", ["vqe", "vql"]],
      ["audio/x-vnd.audioexplosion.mjuicemediafile", "mjf"],
      ["audio/x-voc", "voc"],
      ["audio/x-wav", "wav"],
      ["audio/xm", "xm"],
      ["chemical/x-cdx", "cdx"],
      ["chemical/x-cif", "cif"],
      ["chemical/x-cmdf", "cmdf"],
      ["chemical/x-cml", "cml"],
      ["chemical/x-csml", "csml"],
      ["chemical/x-pdb", ["pdb", "xyz"]],
      ["chemical/x-xyz", "xyz"],
      ["drawing/x-dwf", "dwf"],
      ["i-world/i-vrml", "ivr"],
      ["image/bmp", ["bmp", "bm"]],
      ["image/cgm", "cgm"],
      ["image/cis-cod", "cod"],
      ["image/cmu-raster", ["ras", "rast"]],
      ["image/fif", "fif"],
      ["image/florian", ["flo", "turbot"]],
      ["image/g3fax", "g3"],
      ["image/gif", "gif"],
      ["image/ief", ["ief", "iefs"]],
      ["image/jpeg", ["jpeg", "jpe", "jpg", "jfif", "jfif-tbnl"]],
      ["image/jutvision", "jut"],
      ["image/ktx", "ktx"],
      ["image/naplps", ["nap", "naplps"]],
      ["image/pict", ["pic", "pict"]],
      ["image/pipeg", "jfif"],
      ["image/pjpeg", ["jfif", "jpe", "jpeg", "jpg"]],
      ["image/png", ["png", "x-png"]],
      ["image/prs.btif", "btif"],
      ["image/svg+xml", "svg"],
      ["image/tiff", ["tif", "tiff"]],
      ["image/vasa", "mcf"],
      ["image/vnd.adobe.photoshop", "psd"],
      ["image/vnd.dece.graphic", "uvi"],
      ["image/vnd.djvu", "djvu"],
      ["image/vnd.dvb.subtitle", "sub"],
      ["image/vnd.dwg", ["dwg", "dxf", "svf"]],
      ["image/vnd.dxf", "dxf"],
      ["image/vnd.fastbidsheet", "fbs"],
      ["image/vnd.fpx", "fpx"],
      ["image/vnd.fst", "fst"],
      ["image/vnd.fujixerox.edmics-mmr", "mmr"],
      ["image/vnd.fujixerox.edmics-rlc", "rlc"],
      ["image/vnd.ms-modi", "mdi"],
      ["image/vnd.net-fpx", ["fpx", "npx"]],
      ["image/vnd.rn-realflash", "rf"],
      ["image/vnd.rn-realpix", "rp"],
      ["image/vnd.wap.wbmp", "wbmp"],
      ["image/vnd.xiff", "xif"],
      ["image/webp", "webp"],
      ["image/x-cmu-raster", "ras"],
      ["image/x-cmx", "cmx"],
      ["image/x-dwg", ["dwg", "dxf", "svf"]],
      ["image/x-freehand", "fh"],
      ["image/x-icon", "ico"],
      ["image/x-jg", "art"],
      ["image/x-jps", "jps"],
      ["image/x-niff", ["niff", "nif"]],
      ["image/x-pcx", "pcx"],
      ["image/x-pict", ["pct", "pic"]],
      ["image/x-portable-anymap", "pnm"],
      ["image/x-portable-bitmap", "pbm"],
      ["image/x-portable-graymap", "pgm"],
      ["image/x-portable-greymap", "pgm"],
      ["image/x-portable-pixmap", "ppm"],
      ["image/x-quicktime", ["qif", "qti", "qtif"]],
      ["image/x-rgb", "rgb"],
      ["image/x-tiff", ["tif", "tiff"]],
      ["image/x-windows-bmp", "bmp"],
      ["image/x-xbitmap", "xbm"],
      ["image/x-xbm", "xbm"],
      ["image/x-xpixmap", ["xpm", "pm"]],
      ["image/x-xwd", "xwd"],
      ["image/x-xwindowdump", "xwd"],
      ["image/xbm", "xbm"],
      ["image/xpm", "xpm"],
      ["message/rfc822", ["eml", "mht", "mhtml", "nws", "mime"]],
      ["model/iges", ["iges", "igs"]],
      ["model/mesh", "msh"],
      ["model/vnd.collada+xml", "dae"],
      ["model/vnd.dwf", "dwf"],
      ["model/vnd.gdl", "gdl"],
      ["model/vnd.gtw", "gtw"],
      ["model/vnd.mts", "mts"],
      ["model/vnd.vtu", "vtu"],
      ["model/vrml", ["vrml", "wrl", "wrz"]],
      ["model/x-pov", "pov"],
      ["multipart/x-gzip", "gzip"],
      ["multipart/x-ustar", "ustar"],
      ["multipart/x-zip", "zip"],
      ["music/crescendo", ["mid", "midi"]],
      ["music/x-karaoke", "kar"],
      ["paleovu/x-pv", "pvu"],
      ["text/asp", "asp"],
      ["text/calendar", "ics"],
      ["text/css", "css"],
      ["text/csv", "csv"],
      ["text/ecmascript", "js"],
      ["text/h323", "323"],
      ["text/html", ["html", "htm", "stm", "acgi", "htmls", "htx", "shtml"]],
      ["text/iuls", "uls"],
      ["text/javascript", "js"],
      ["text/mcf", "mcf"],
      ["text/n3", "n3"],
      ["text/pascal", "pas"],
      [
        "text/plain",
        [
          "txt",
          "bas",
          "c",
          "h",
          "c++",
          "cc",
          "com",
          "conf",
          "cxx",
          "def",
          "f",
          "f90",
          "for",
          "g",
          "hh",
          "idc",
          "jav",
          "java",
          "list",
          "log",
          "lst",
          "m",
          "mar",
          "pl",
          "sdml",
          "text"
        ]
      ],
      ["text/plain-bas", "par"],
      ["text/prs.lines.tag", "dsc"],
      ["text/richtext", ["rtx", "rt", "rtf"]],
      ["text/scriplet", "wsc"],
      ["text/scriptlet", "sct"],
      ["text/sgml", ["sgm", "sgml"]],
      ["text/tab-separated-values", "tsv"],
      ["text/troff", "t"],
      ["text/turtle", "ttl"],
      ["text/uri-list", ["uni", "unis", "uri", "uris"]],
      ["text/vnd.abc", "abc"],
      ["text/vnd.curl", "curl"],
      ["text/vnd.curl.dcurl", "dcurl"],
      ["text/vnd.curl.mcurl", "mcurl"],
      ["text/vnd.curl.scurl", "scurl"],
      ["text/vnd.fly", "fly"],
      ["text/vnd.fmi.flexstor", "flx"],
      ["text/vnd.graphviz", "gv"],
      ["text/vnd.in3d.3dml", "3dml"],
      ["text/vnd.in3d.spot", "spot"],
      ["text/vnd.rn-realtext", "rt"],
      ["text/vnd.sun.j2me.app-descriptor", "jad"],
      ["text/vnd.wap.wml", "wml"],
      ["text/vnd.wap.wmlscript", "wmls"],
      ["text/webviewhtml", "htt"],
      ["text/x-asm", ["asm", "s"]],
      ["text/x-audiosoft-intra", "aip"],
      ["text/x-c", ["c", "cc", "cpp"]],
      ["text/x-component", "htc"],
      ["text/x-fortran", ["for", "f", "f77", "f90"]],
      ["text/x-h", ["h", "hh"]],
      ["text/x-java-source", ["java", "jav"]],
      ["text/x-java-source,java", "java"],
      ["text/x-la-asf", "lsx"],
      ["text/x-m", "m"],
      ["text/x-pascal", "p"],
      ["text/x-script", "hlb"],
      ["text/x-script.csh", "csh"],
      ["text/x-script.elisp", "el"],
      ["text/x-script.guile", "scm"],
      ["text/x-script.ksh", "ksh"],
      ["text/x-script.lisp", "lsp"],
      ["text/x-script.perl", "pl"],
      ["text/x-script.perl-module", "pm"],
      ["text/x-script.phyton", "py"],
      ["text/x-script.rexx", "rexx"],
      ["text/x-script.scheme", "scm"],
      ["text/x-script.sh", "sh"],
      ["text/x-script.tcl", "tcl"],
      ["text/x-script.tcsh", "tcsh"],
      ["text/x-script.zsh", "zsh"],
      ["text/x-server-parsed-html", ["shtml", "ssi"]],
      ["text/x-setext", "etx"],
      ["text/x-sgml", ["sgm", "sgml"]],
      ["text/x-speech", ["spc", "talk"]],
      ["text/x-uil", "uil"],
      ["text/x-uuencode", ["uu", "uue"]],
      ["text/x-vcalendar", "vcs"],
      ["text/x-vcard", "vcf"],
      ["text/xml", "xml"],
      ["video/3gpp", "3gp"],
      ["video/3gpp2", "3g2"],
      ["video/animaflex", "afl"],
      ["video/avi", "avi"],
      ["video/avs-video", "avs"],
      ["video/dl", "dl"],
      ["video/fli", "fli"],
      ["video/gl", "gl"],
      ["video/h261", "h261"],
      ["video/h263", "h263"],
      ["video/h264", "h264"],
      ["video/jpeg", "jpgv"],
      ["video/jpm", "jpm"],
      ["video/mj2", "mj2"],
      ["video/mp4", "mp4"],
      ["video/mpeg", ["mpeg", "mp2", "mpa", "mpe", "mpg", "mpv2", "m1v", "m2v", "mp3"]],
      ["video/msvideo", "avi"],
      ["video/ogg", "ogv"],
      ["video/quicktime", ["mov", "qt", "moov"]],
      ["video/vdo", "vdo"],
      ["video/vivo", ["viv", "vivo"]],
      ["video/vnd.dece.hd", "uvh"],
      ["video/vnd.dece.mobile", "uvm"],
      ["video/vnd.dece.pd", "uvp"],
      ["video/vnd.dece.sd", "uvs"],
      ["video/vnd.dece.video", "uvv"],
      ["video/vnd.fvt", "fvt"],
      ["video/vnd.mpegurl", "mxu"],
      ["video/vnd.ms-playready.media.pyv", "pyv"],
      ["video/vnd.rn-realvideo", "rv"],
      ["video/vnd.uvvu.mp4", "uvu"],
      ["video/vnd.vivo", ["viv", "vivo"]],
      ["video/vosaic", "vos"],
      ["video/webm", "webm"],
      ["video/x-amt-demorun", "xdr"],
      ["video/x-amt-showrun", "xsr"],
      ["video/x-atomic3d-feature", "fmf"],
      ["video/x-dl", "dl"],
      ["video/x-dv", ["dif", "dv"]],
      ["video/x-f4v", "f4v"],
      ["video/x-fli", "fli"],
      ["video/x-flv", "flv"],
      ["video/x-gl", "gl"],
      ["video/x-isvideo", "isu"],
      ["video/x-la-asf", ["lsf", "lsx"]],
      ["video/x-m4v", "m4v"],
      ["video/x-motion-jpeg", "mjpg"],
      ["video/x-mpeg", ["mp3", "mp2"]],
      ["video/x-mpeq2a", "mp2"],
      ["video/x-ms-asf", ["asf", "asr", "asx"]],
      ["video/x-ms-asf-plugin", "asx"],
      ["video/x-ms-wm", "wm"],
      ["video/x-ms-wmv", "wmv"],
      ["video/x-ms-wmx", "wmx"],
      ["video/x-ms-wvx", "wvx"],
      ["video/x-msvideo", "avi"],
      ["video/x-qtc", "qtc"],
      ["video/x-scm", "scm"],
      ["video/x-sgi-movie", ["movie", "mv"]],
      ["windows/metafile", "wmf"],
      ["www/mime", "mime"],
      ["x-conference/x-cooltalk", "ice"],
      ["x-music/x-midi", ["mid", "midi"]],
      ["x-world/x-3dmf", ["3dm", "3dmf", "qd3", "qd3d"]],
      ["x-world/x-svr", "svr"],
      ["x-world/x-vrml", ["flr", "vrml", "wrl", "wrz", "xaf", "xof"]],
      ["x-world/x-vrt", "vrt"],
      ["xgl/drawing", "xgz"],
      ["xgl/movie", "xmz"]
    ]);
    var extensions = /* @__PURE__ */ new Map([
      ["123", "application/vnd.lotus-1-2-3"],
      ["323", "text/h323"],
      ["*", "application/octet-stream"],
      ["3dm", "x-world/x-3dmf"],
      ["3dmf", "x-world/x-3dmf"],
      ["3dml", "text/vnd.in3d.3dml"],
      ["3g2", "video/3gpp2"],
      ["3gp", "video/3gpp"],
      ["7z", "application/x-7z-compressed"],
      ["a", "application/octet-stream"],
      ["aab", "application/x-authorware-bin"],
      ["aac", "audio/x-aac"],
      ["aam", "application/x-authorware-map"],
      ["aas", "application/x-authorware-seg"],
      ["abc", "text/vnd.abc"],
      ["abw", "application/x-abiword"],
      ["ac", "application/pkix-attr-cert"],
      ["acc", "application/vnd.americandynamics.acc"],
      ["ace", "application/x-ace-compressed"],
      ["acgi", "text/html"],
      ["acu", "application/vnd.acucobol"],
      ["acx", "application/internet-property-stream"],
      ["adp", "audio/adpcm"],
      ["aep", "application/vnd.audiograph"],
      ["afl", "video/animaflex"],
      ["afp", "application/vnd.ibm.modcap"],
      ["ahead", "application/vnd.ahead.space"],
      ["ai", "application/postscript"],
      ["aif", ["audio/aiff", "audio/x-aiff"]],
      ["aifc", ["audio/aiff", "audio/x-aiff"]],
      ["aiff", ["audio/aiff", "audio/x-aiff"]],
      ["aim", "application/x-aim"],
      ["aip", "text/x-audiosoft-intra"],
      ["air", "application/vnd.adobe.air-application-installer-package+zip"],
      ["ait", "application/vnd.dvb.ait"],
      ["ami", "application/vnd.amiga.ami"],
      ["ani", "application/x-navi-animation"],
      ["aos", "application/x-nokia-9000-communicator-add-on-software"],
      ["apk", "application/vnd.android.package-archive"],
      ["application", "application/x-ms-application"],
      ["apr", "application/vnd.lotus-approach"],
      ["aps", "application/mime"],
      ["arc", "application/octet-stream"],
      ["arj", ["application/arj", "application/octet-stream"]],
      ["art", "image/x-jg"],
      ["asf", "video/x-ms-asf"],
      ["asm", "text/x-asm"],
      ["aso", "application/vnd.accpac.simply.aso"],
      ["asp", "text/asp"],
      ["asr", "video/x-ms-asf"],
      ["asx", ["video/x-ms-asf", "application/x-mplayer2", "video/x-ms-asf-plugin"]],
      ["atc", "application/vnd.acucorp"],
      ["atomcat", "application/atomcat+xml"],
      ["atomsvc", "application/atomsvc+xml"],
      ["atx", "application/vnd.antix.game-component"],
      ["au", ["audio/basic", "audio/x-au"]],
      ["avi", ["video/avi", "video/msvideo", "application/x-troff-msvideo", "video/x-msvideo"]],
      ["avs", "video/avs-video"],
      ["aw", "application/applixware"],
      ["axs", "application/olescript"],
      ["azf", "application/vnd.airzip.filesecure.azf"],
      ["azs", "application/vnd.airzip.filesecure.azs"],
      ["azw", "application/vnd.amazon.ebook"],
      ["bas", "text/plain"],
      ["bcpio", "application/x-bcpio"],
      ["bdf", "application/x-font-bdf"],
      ["bdm", "application/vnd.syncml.dm+wbxml"],
      ["bed", "application/vnd.realvnc.bed"],
      ["bh2", "application/vnd.fujitsu.oasysprs"],
      ["bin", ["application/octet-stream", "application/mac-binary", "application/macbinary", "application/x-macbinary", "application/x-binary"]],
      ["bm", "image/bmp"],
      ["bmi", "application/vnd.bmi"],
      ["bmp", ["image/bmp", "image/x-windows-bmp"]],
      ["boo", "application/book"],
      ["book", "application/book"],
      ["box", "application/vnd.previewsystems.box"],
      ["boz", "application/x-bzip2"],
      ["bsh", "application/x-bsh"],
      ["btif", "image/prs.btif"],
      ["bz", "application/x-bzip"],
      ["bz2", "application/x-bzip2"],
      ["c", ["text/plain", "text/x-c"]],
      ["c++", "text/plain"],
      ["c11amc", "application/vnd.cluetrust.cartomobile-config"],
      ["c11amz", "application/vnd.cluetrust.cartomobile-config-pkg"],
      ["c4g", "application/vnd.clonk.c4group"],
      ["cab", "application/vnd.ms-cab-compressed"],
      ["car", "application/vnd.curl.car"],
      ["cat", ["application/vnd.ms-pkiseccat", "application/vnd.ms-pki.seccat"]],
      ["cc", ["text/plain", "text/x-c"]],
      ["ccad", "application/clariscad"],
      ["cco", "application/x-cocoa"],
      ["ccxml", "application/ccxml+xml,"],
      ["cdbcmsg", "application/vnd.contact.cmsg"],
      ["cdf", ["application/cdf", "application/x-cdf", "application/x-netcdf"]],
      ["cdkey", "application/vnd.mediastation.cdkey"],
      ["cdmia", "application/cdmi-capability"],
      ["cdmic", "application/cdmi-container"],
      ["cdmid", "application/cdmi-domain"],
      ["cdmio", "application/cdmi-object"],
      ["cdmiq", "application/cdmi-queue"],
      ["cdx", "chemical/x-cdx"],
      ["cdxml", "application/vnd.chemdraw+xml"],
      ["cdy", "application/vnd.cinderella"],
      ["cer", ["application/pkix-cert", "application/x-x509-ca-cert"]],
      ["cgm", "image/cgm"],
      ["cha", "application/x-chat"],
      ["chat", "application/x-chat"],
      ["chm", "application/vnd.ms-htmlhelp"],
      ["chrt", "application/vnd.kde.kchart"],
      ["cif", "chemical/x-cif"],
      ["cii", "application/vnd.anser-web-certificate-issue-initiation"],
      ["cil", "application/vnd.ms-artgalry"],
      ["cla", "application/vnd.claymore"],
      ["class", ["application/octet-stream", "application/java", "application/java-byte-code", "application/java-vm", "application/x-java-class"]],
      ["clkk", "application/vnd.crick.clicker.keyboard"],
      ["clkp", "application/vnd.crick.clicker.palette"],
      ["clkt", "application/vnd.crick.clicker.template"],
      ["clkw", "application/vnd.crick.clicker.wordbank"],
      ["clkx", "application/vnd.crick.clicker"],
      ["clp", "application/x-msclip"],
      ["cmc", "application/vnd.cosmocaller"],
      ["cmdf", "chemical/x-cmdf"],
      ["cml", "chemical/x-cml"],
      ["cmp", "application/vnd.yellowriver-custom-menu"],
      ["cmx", "image/x-cmx"],
      ["cod", ["image/cis-cod", "application/vnd.rim.cod"]],
      ["com", ["application/octet-stream", "text/plain"]],
      ["conf", "text/plain"],
      ["cpio", "application/x-cpio"],
      ["cpp", "text/x-c"],
      ["cpt", ["application/mac-compactpro", "application/x-compactpro", "application/x-cpt"]],
      ["crd", "application/x-mscardfile"],
      ["crl", ["application/pkix-crl", "application/pkcs-crl"]],
      ["crt", ["application/pkix-cert", "application/x-x509-user-cert", "application/x-x509-ca-cert"]],
      ["cryptonote", "application/vnd.rig.cryptonote"],
      ["csh", ["text/x-script.csh", "application/x-csh"]],
      ["csml", "chemical/x-csml"],
      ["csp", "application/vnd.commonspace"],
      ["css", ["text/css", "application/x-pointplus"]],
      ["csv", "text/csv"],
      ["cu", "application/cu-seeme"],
      ["curl", "text/vnd.curl"],
      ["cww", "application/prs.cww"],
      ["cxx", "text/plain"],
      ["dae", "model/vnd.collada+xml"],
      ["daf", "application/vnd.mobius.daf"],
      ["davmount", "application/davmount+xml"],
      ["dcr", "application/x-director"],
      ["dcurl", "text/vnd.curl.dcurl"],
      ["dd2", "application/vnd.oma.dd2+xml"],
      ["ddd", "application/vnd.fujixerox.ddd"],
      ["deb", "application/x-debian-package"],
      ["deepv", "application/x-deepv"],
      ["def", "text/plain"],
      ["der", "application/x-x509-ca-cert"],
      ["dfac", "application/vnd.dreamfactory"],
      ["dif", "video/x-dv"],
      ["dir", "application/x-director"],
      ["dis", "application/vnd.mobius.dis"],
      ["djvu", "image/vnd.djvu"],
      ["dl", ["video/dl", "video/x-dl"]],
      ["dll", "application/x-msdownload"],
      ["dms", "application/octet-stream"],
      ["dna", "application/vnd.dna"],
      ["doc", "application/msword"],
      ["docm", "application/vnd.ms-word.document.macroenabled.12"],
      ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
      ["dot", "application/msword"],
      ["dotm", "application/vnd.ms-word.template.macroenabled.12"],
      ["dotx", "application/vnd.openxmlformats-officedocument.wordprocessingml.template"],
      ["dp", ["application/commonground", "application/vnd.osgi.dp"]],
      ["dpg", "application/vnd.dpgraph"],
      ["dra", "audio/vnd.dra"],
      ["drw", "application/drafting"],
      ["dsc", "text/prs.lines.tag"],
      ["dssc", "application/dssc+der"],
      ["dtb", "application/x-dtbook+xml"],
      ["dtd", "application/xml-dtd"],
      ["dts", "audio/vnd.dts"],
      ["dtshd", "audio/vnd.dts.hd"],
      ["dump", "application/octet-stream"],
      ["dv", "video/x-dv"],
      ["dvi", "application/x-dvi"],
      ["dwf", ["model/vnd.dwf", "drawing/x-dwf"]],
      ["dwg", ["application/acad", "image/vnd.dwg", "image/x-dwg"]],
      ["dxf", ["application/dxf", "image/vnd.dwg", "image/vnd.dxf", "image/x-dwg"]],
      ["dxp", "application/vnd.spotfire.dxp"],
      ["dxr", "application/x-director"],
      ["ecelp4800", "audio/vnd.nuera.ecelp4800"],
      ["ecelp7470", "audio/vnd.nuera.ecelp7470"],
      ["ecelp9600", "audio/vnd.nuera.ecelp9600"],
      ["edm", "application/vnd.novadigm.edm"],
      ["edx", "application/vnd.novadigm.edx"],
      ["efif", "application/vnd.picsel"],
      ["ei6", "application/vnd.pg.osasli"],
      ["el", "text/x-script.elisp"],
      ["elc", ["application/x-elc", "application/x-bytecode.elisp"]],
      ["eml", "message/rfc822"],
      ["emma", "application/emma+xml"],
      ["env", "application/x-envoy"],
      ["eol", "audio/vnd.digital-winds"],
      ["eot", "application/vnd.ms-fontobject"],
      ["eps", "application/postscript"],
      ["epub", "application/epub+zip"],
      ["es", ["application/ecmascript", "application/x-esrehber"]],
      ["es3", "application/vnd.eszigno3+xml"],
      ["esf", "application/vnd.epson.esf"],
      ["etx", "text/x-setext"],
      ["evy", ["application/envoy", "application/x-envoy"]],
      ["exe", ["application/octet-stream", "application/x-msdownload"]],
      ["exi", "application/exi"],
      ["ext", "application/vnd.novadigm.ext"],
      ["ez2", "application/vnd.ezpix-album"],
      ["ez3", "application/vnd.ezpix-package"],
      ["f", ["text/plain", "text/x-fortran"]],
      ["f4v", "video/x-f4v"],
      ["f77", "text/x-fortran"],
      ["f90", ["text/plain", "text/x-fortran"]],
      ["fbs", "image/vnd.fastbidsheet"],
      ["fcs", "application/vnd.isac.fcs"],
      ["fdf", "application/vnd.fdf"],
      ["fe_launch", "application/vnd.denovo.fcselayout-link"],
      ["fg5", "application/vnd.fujitsu.oasysgp"],
      ["fh", "image/x-freehand"],
      ["fif", ["application/fractals", "image/fif"]],
      ["fig", "application/x-xfig"],
      ["fli", ["video/fli", "video/x-fli"]],
      ["flo", ["image/florian", "application/vnd.micrografx.flo"]],
      ["flr", "x-world/x-vrml"],
      ["flv", "video/x-flv"],
      ["flw", "application/vnd.kde.kivio"],
      ["flx", "text/vnd.fmi.flexstor"],
      ["fly", "text/vnd.fly"],
      ["fm", "application/vnd.framemaker"],
      ["fmf", "video/x-atomic3d-feature"],
      ["fnc", "application/vnd.frogans.fnc"],
      ["for", ["text/plain", "text/x-fortran"]],
      ["fpx", ["image/vnd.fpx", "image/vnd.net-fpx"]],
      ["frl", "application/freeloader"],
      ["fsc", "application/vnd.fsc.weblaunch"],
      ["fst", "image/vnd.fst"],
      ["ftc", "application/vnd.fluxtime.clip"],
      ["fti", "application/vnd.anser-web-funds-transfer-initiation"],
      ["funk", "audio/make"],
      ["fvt", "video/vnd.fvt"],
      ["fxp", "application/vnd.adobe.fxp"],
      ["fzs", "application/vnd.fuzzysheet"],
      ["g", "text/plain"],
      ["g2w", "application/vnd.geoplan"],
      ["g3", "image/g3fax"],
      ["g3w", "application/vnd.geospace"],
      ["gac", "application/vnd.groove-account"],
      ["gdl", "model/vnd.gdl"],
      ["geo", "application/vnd.dynageo"],
      ["gex", "application/vnd.geometry-explorer"],
      ["ggb", "application/vnd.geogebra.file"],
      ["ggt", "application/vnd.geogebra.tool"],
      ["ghf", "application/vnd.groove-help"],
      ["gif", "image/gif"],
      ["gim", "application/vnd.groove-identity-message"],
      ["gl", ["video/gl", "video/x-gl"]],
      ["gmx", "application/vnd.gmx"],
      ["gnumeric", "application/x-gnumeric"],
      ["gph", "application/vnd.flographit"],
      ["gqf", "application/vnd.grafeq"],
      ["gram", "application/srgs"],
      ["grv", "application/vnd.groove-injector"],
      ["grxml", "application/srgs+xml"],
      ["gsd", "audio/x-gsm"],
      ["gsf", "application/x-font-ghostscript"],
      ["gsm", "audio/x-gsm"],
      ["gsp", "application/x-gsp"],
      ["gss", "application/x-gss"],
      ["gtar", "application/x-gtar"],
      ["gtm", "application/vnd.groove-tool-message"],
      ["gtw", "model/vnd.gtw"],
      ["gv", "text/vnd.graphviz"],
      ["gxt", "application/vnd.geonext"],
      ["gz", ["application/x-gzip", "application/x-compressed"]],
      ["gzip", ["multipart/x-gzip", "application/x-gzip"]],
      ["h", ["text/plain", "text/x-h"]],
      ["h261", "video/h261"],
      ["h263", "video/h263"],
      ["h264", "video/h264"],
      ["hal", "application/vnd.hal+xml"],
      ["hbci", "application/vnd.hbci"],
      ["hdf", "application/x-hdf"],
      ["help", "application/x-helpfile"],
      ["hgl", "application/vnd.hp-hpgl"],
      ["hh", ["text/plain", "text/x-h"]],
      ["hlb", "text/x-script"],
      ["hlp", ["application/winhlp", "application/hlp", "application/x-helpfile", "application/x-winhelp"]],
      ["hpg", "application/vnd.hp-hpgl"],
      ["hpgl", "application/vnd.hp-hpgl"],
      ["hpid", "application/vnd.hp-hpid"],
      ["hps", "application/vnd.hp-hps"],
      [
        "hqx",
        [
          "application/mac-binhex40",
          "application/binhex",
          "application/binhex4",
          "application/mac-binhex",
          "application/x-binhex40",
          "application/x-mac-binhex40"
        ]
      ],
      ["hta", "application/hta"],
      ["htc", "text/x-component"],
      ["htke", "application/vnd.kenameaapp"],
      ["htm", "text/html"],
      ["html", "text/html"],
      ["htmls", "text/html"],
      ["htt", "text/webviewhtml"],
      ["htx", "text/html"],
      ["hvd", "application/vnd.yamaha.hv-dic"],
      ["hvp", "application/vnd.yamaha.hv-voice"],
      ["hvs", "application/vnd.yamaha.hv-script"],
      ["i2g", "application/vnd.intergeo"],
      ["icc", "application/vnd.iccprofile"],
      ["ice", "x-conference/x-cooltalk"],
      ["ico", "image/x-icon"],
      ["ics", "text/calendar"],
      ["idc", "text/plain"],
      ["ief", "image/ief"],
      ["iefs", "image/ief"],
      ["ifm", "application/vnd.shana.informed.formdata"],
      ["iges", ["application/iges", "model/iges"]],
      ["igl", "application/vnd.igloader"],
      ["igm", "application/vnd.insors.igm"],
      ["igs", ["application/iges", "model/iges"]],
      ["igx", "application/vnd.micrografx.igx"],
      ["iif", "application/vnd.shana.informed.interchange"],
      ["iii", "application/x-iphone"],
      ["ima", "application/x-ima"],
      ["imap", "application/x-httpd-imap"],
      ["imp", "application/vnd.accpac.simply.imp"],
      ["ims", "application/vnd.ms-ims"],
      ["inf", "application/inf"],
      ["ins", ["application/x-internet-signup", "application/x-internett-signup"]],
      ["ip", "application/x-ip2"],
      ["ipfix", "application/ipfix"],
      ["ipk", "application/vnd.shana.informed.package"],
      ["irm", "application/vnd.ibm.rights-management"],
      ["irp", "application/vnd.irepository.package+xml"],
      ["isp", "application/x-internet-signup"],
      ["isu", "video/x-isvideo"],
      ["it", "audio/it"],
      ["itp", "application/vnd.shana.informed.formtemplate"],
      ["iv", "application/x-inventor"],
      ["ivp", "application/vnd.immervision-ivp"],
      ["ivr", "i-world/i-vrml"],
      ["ivu", "application/vnd.immervision-ivu"],
      ["ivy", "application/x-livescreen"],
      ["jad", "text/vnd.sun.j2me.app-descriptor"],
      ["jam", ["application/vnd.jam", "audio/x-jam"]],
      ["jar", "application/java-archive"],
      ["jav", ["text/plain", "text/x-java-source"]],
      ["java", ["text/plain", "text/x-java-source,java", "text/x-java-source"]],
      ["jcm", "application/x-java-commerce"],
      ["jfif", ["image/pipeg", "image/jpeg", "image/pjpeg"]],
      ["jfif-tbnl", "image/jpeg"],
      ["jisp", "application/vnd.jisp"],
      ["jlt", "application/vnd.hp-jlyt"],
      ["jnlp", "application/x-java-jnlp-file"],
      ["joda", "application/vnd.joost.joda-archive"],
      ["jpe", ["image/jpeg", "image/pjpeg"]],
      ["jpeg", ["image/jpeg", "image/pjpeg"]],
      ["jpg", ["image/jpeg", "image/pjpeg"]],
      ["jpgv", "video/jpeg"],
      ["jpm", "video/jpm"],
      ["jps", "image/x-jps"],
      ["js", ["application/javascript", "application/ecmascript", "text/javascript", "text/ecmascript", "application/x-javascript"]],
      ["json", "application/json"],
      ["jut", "image/jutvision"],
      ["kar", ["audio/midi", "music/x-karaoke"]],
      ["karbon", "application/vnd.kde.karbon"],
      ["kfo", "application/vnd.kde.kformula"],
      ["kia", "application/vnd.kidspiration"],
      ["kml", "application/vnd.google-earth.kml+xml"],
      ["kmz", "application/vnd.google-earth.kmz"],
      ["kne", "application/vnd.kinar"],
      ["kon", "application/vnd.kde.kontour"],
      ["kpr", "application/vnd.kde.kpresenter"],
      ["ksh", ["application/x-ksh", "text/x-script.ksh"]],
      ["ksp", "application/vnd.kde.kspread"],
      ["ktx", "image/ktx"],
      ["ktz", "application/vnd.kahootz"],
      ["kwd", "application/vnd.kde.kword"],
      ["la", ["audio/nspaudio", "audio/x-nspaudio"]],
      ["lam", "audio/x-liveaudio"],
      ["lasxml", "application/vnd.las.las+xml"],
      ["latex", "application/x-latex"],
      ["lbd", "application/vnd.llamagraphics.life-balance.desktop"],
      ["lbe", "application/vnd.llamagraphics.life-balance.exchange+xml"],
      ["les", "application/vnd.hhe.lesson-player"],
      ["lha", ["application/octet-stream", "application/lha", "application/x-lha"]],
      ["lhx", "application/octet-stream"],
      ["link66", "application/vnd.route66.link66+xml"],
      ["list", "text/plain"],
      ["lma", ["audio/nspaudio", "audio/x-nspaudio"]],
      ["log", "text/plain"],
      ["lrm", "application/vnd.ms-lrm"],
      ["lsf", "video/x-la-asf"],
      ["lsp", ["application/x-lisp", "text/x-script.lisp"]],
      ["lst", "text/plain"],
      ["lsx", ["video/x-la-asf", "text/x-la-asf"]],
      ["ltf", "application/vnd.frogans.ltf"],
      ["ltx", "application/x-latex"],
      ["lvp", "audio/vnd.lucent.voice"],
      ["lwp", "application/vnd.lotus-wordpro"],
      ["lzh", ["application/octet-stream", "application/x-lzh"]],
      ["lzx", ["application/lzx", "application/octet-stream", "application/x-lzx"]],
      ["m", ["text/plain", "text/x-m"]],
      ["m13", "application/x-msmediaview"],
      ["m14", "application/x-msmediaview"],
      ["m1v", "video/mpeg"],
      ["m21", "application/mp21"],
      ["m2a", "audio/mpeg"],
      ["m2v", "video/mpeg"],
      ["m3u", ["audio/x-mpegurl", "audio/x-mpequrl"]],
      ["m3u8", "application/vnd.apple.mpegurl"],
      ["m4v", "video/x-m4v"],
      ["ma", "application/mathematica"],
      ["mads", "application/mads+xml"],
      ["mag", "application/vnd.ecowin.chart"],
      ["man", "application/x-troff-man"],
      ["map", "application/x-navimap"],
      ["mar", "text/plain"],
      ["mathml", "application/mathml+xml"],
      ["mbd", "application/mbedlet"],
      ["mbk", "application/vnd.mobius.mbk"],
      ["mbox", "application/mbox"],
      ["mc$", "application/x-magic-cap-package-1.0"],
      ["mc1", "application/vnd.medcalcdata"],
      ["mcd", ["application/mcad", "application/vnd.mcd", "application/x-mathcad"]],
      ["mcf", ["image/vasa", "text/mcf"]],
      ["mcp", "application/netmc"],
      ["mcurl", "text/vnd.curl.mcurl"],
      ["mdb", "application/x-msaccess"],
      ["mdi", "image/vnd.ms-modi"],
      ["me", "application/x-troff-me"],
      ["meta4", "application/metalink4+xml"],
      ["mets", "application/mets+xml"],
      ["mfm", "application/vnd.mfmp"],
      ["mgp", "application/vnd.osgeo.mapguide.package"],
      ["mgz", "application/vnd.proteus.magazine"],
      ["mht", "message/rfc822"],
      ["mhtml", "message/rfc822"],
      ["mid", ["audio/mid", "audio/midi", "music/crescendo", "x-music/x-midi", "audio/x-midi", "application/x-midi", "audio/x-mid"]],
      ["midi", ["audio/midi", "music/crescendo", "x-music/x-midi", "audio/x-midi", "application/x-midi", "audio/x-mid"]],
      ["mif", ["application/vnd.mif", "application/x-mif", "application/x-frame"]],
      ["mime", ["message/rfc822", "www/mime"]],
      ["mj2", "video/mj2"],
      ["mjf", "audio/x-vnd.audioexplosion.mjuicemediafile"],
      ["mjpg", "video/x-motion-jpeg"],
      ["mlp", "application/vnd.dolby.mlp"],
      ["mm", ["application/base64", "application/x-meme"]],
      ["mmd", "application/vnd.chipnuts.karaoke-mmd"],
      ["mme", "application/base64"],
      ["mmf", "application/vnd.smaf"],
      ["mmr", "image/vnd.fujixerox.edmics-mmr"],
      ["mny", "application/x-msmoney"],
      ["mod", ["audio/mod", "audio/x-mod"]],
      ["mods", "application/mods+xml"],
      ["moov", "video/quicktime"],
      ["mov", "video/quicktime"],
      ["movie", "video/x-sgi-movie"],
      ["mp2", ["video/mpeg", "audio/mpeg", "video/x-mpeg", "audio/x-mpeg", "video/x-mpeq2a"]],
      ["mp3", ["audio/mpeg", "audio/mpeg3", "video/mpeg", "audio/x-mpeg-3", "video/x-mpeg"]],
      ["mp4", ["video/mp4", "application/mp4"]],
      ["mp4a", "audio/mp4"],
      ["mpa", ["video/mpeg", "audio/mpeg"]],
      ["mpc", ["application/vnd.mophun.certificate", "application/x-project"]],
      ["mpe", "video/mpeg"],
      ["mpeg", "video/mpeg"],
      ["mpg", ["video/mpeg", "audio/mpeg"]],
      ["mpga", "audio/mpeg"],
      ["mpkg", "application/vnd.apple.installer+xml"],
      ["mpm", "application/vnd.blueice.multipass"],
      ["mpn", "application/vnd.mophun.application"],
      ["mpp", "application/vnd.ms-project"],
      ["mpt", "application/x-project"],
      ["mpv", "application/x-project"],
      ["mpv2", "video/mpeg"],
      ["mpx", "application/x-project"],
      ["mpy", "application/vnd.ibm.minipay"],
      ["mqy", "application/vnd.mobius.mqy"],
      ["mrc", "application/marc"],
      ["mrcx", "application/marcxml+xml"],
      ["ms", "application/x-troff-ms"],
      ["mscml", "application/mediaservercontrol+xml"],
      ["mseq", "application/vnd.mseq"],
      ["msf", "application/vnd.epson.msf"],
      ["msg", "application/vnd.ms-outlook"],
      ["msh", "model/mesh"],
      ["msl", "application/vnd.mobius.msl"],
      ["msty", "application/vnd.muvee.style"],
      ["mts", "model/vnd.mts"],
      ["mus", "application/vnd.musician"],
      ["musicxml", "application/vnd.recordare.musicxml+xml"],
      ["mv", "video/x-sgi-movie"],
      ["mvb", "application/x-msmediaview"],
      ["mwf", "application/vnd.mfer"],
      ["mxf", "application/mxf"],
      ["mxl", "application/vnd.recordare.musicxml"],
      ["mxml", "application/xv+xml"],
      ["mxs", "application/vnd.triscape.mxs"],
      ["mxu", "video/vnd.mpegurl"],
      ["my", "audio/make"],
      ["mzz", "application/x-vnd.audioexplosion.mzz"],
      ["n-gage", "application/vnd.nokia.n-gage.symbian.install"],
      ["n3", "text/n3"],
      ["nap", "image/naplps"],
      ["naplps", "image/naplps"],
      ["nbp", "application/vnd.wolfram.player"],
      ["nc", "application/x-netcdf"],
      ["ncm", "application/vnd.nokia.configuration-message"],
      ["ncx", "application/x-dtbncx+xml"],
      ["ngdat", "application/vnd.nokia.n-gage.data"],
      ["nif", "image/x-niff"],
      ["niff", "image/x-niff"],
      ["nix", "application/x-mix-transfer"],
      ["nlu", "application/vnd.neurolanguage.nlu"],
      ["nml", "application/vnd.enliven"],
      ["nnd", "application/vnd.noblenet-directory"],
      ["nns", "application/vnd.noblenet-sealer"],
      ["nnw", "application/vnd.noblenet-web"],
      ["npx", "image/vnd.net-fpx"],
      ["nsc", "application/x-conference"],
      ["nsf", "application/vnd.lotus-notes"],
      ["nvd", "application/x-navidoc"],
      ["nws", "message/rfc822"],
      ["o", "application/octet-stream"],
      ["oa2", "application/vnd.fujitsu.oasys2"],
      ["oa3", "application/vnd.fujitsu.oasys3"],
      ["oas", "application/vnd.fujitsu.oasys"],
      ["obd", "application/x-msbinder"],
      ["oda", "application/oda"],
      ["odb", "application/vnd.oasis.opendocument.database"],
      ["odc", "application/vnd.oasis.opendocument.chart"],
      ["odf", "application/vnd.oasis.opendocument.formula"],
      ["odft", "application/vnd.oasis.opendocument.formula-template"],
      ["odg", "application/vnd.oasis.opendocument.graphics"],
      ["odi", "application/vnd.oasis.opendocument.image"],
      ["odm", "application/vnd.oasis.opendocument.text-master"],
      ["odp", "application/vnd.oasis.opendocument.presentation"],
      ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
      ["odt", "application/vnd.oasis.opendocument.text"],
      ["oga", "audio/ogg"],
      ["ogv", "video/ogg"],
      ["ogx", "application/ogg"],
      ["omc", "application/x-omc"],
      ["omcd", "application/x-omcdatamaker"],
      ["omcr", "application/x-omcregerator"],
      ["onetoc", "application/onenote"],
      ["opf", "application/oebps-package+xml"],
      ["org", "application/vnd.lotus-organizer"],
      ["osf", "application/vnd.yamaha.openscoreformat"],
      ["osfpvg", "application/vnd.yamaha.openscoreformat.osfpvg+xml"],
      ["otc", "application/vnd.oasis.opendocument.chart-template"],
      ["otf", "application/x-font-otf"],
      ["otg", "application/vnd.oasis.opendocument.graphics-template"],
      ["oth", "application/vnd.oasis.opendocument.text-web"],
      ["oti", "application/vnd.oasis.opendocument.image-template"],
      ["otp", "application/vnd.oasis.opendocument.presentation-template"],
      ["ots", "application/vnd.oasis.opendocument.spreadsheet-template"],
      ["ott", "application/vnd.oasis.opendocument.text-template"],
      ["oxt", "application/vnd.openofficeorg.extension"],
      ["p", "text/x-pascal"],
      ["p10", ["application/pkcs10", "application/x-pkcs10"]],
      ["p12", ["application/pkcs-12", "application/x-pkcs12"]],
      ["p7a", "application/x-pkcs7-signature"],
      ["p7b", "application/x-pkcs7-certificates"],
      ["p7c", ["application/pkcs7-mime", "application/x-pkcs7-mime"]],
      ["p7m", ["application/pkcs7-mime", "application/x-pkcs7-mime"]],
      ["p7r", "application/x-pkcs7-certreqresp"],
      ["p7s", ["application/pkcs7-signature", "application/x-pkcs7-signature"]],
      ["p8", "application/pkcs8"],
      ["par", "text/plain-bas"],
      ["part", "application/pro_eng"],
      ["pas", "text/pascal"],
      ["paw", "application/vnd.pawaafile"],
      ["pbd", "application/vnd.powerbuilder6"],
      ["pbm", "image/x-portable-bitmap"],
      ["pcf", "application/x-font-pcf"],
      ["pcl", ["application/vnd.hp-pcl", "application/x-pcl"]],
      ["pclxl", "application/vnd.hp-pclxl"],
      ["pct", "image/x-pict"],
      ["pcurl", "application/vnd.curl.pcurl"],
      ["pcx", "image/x-pcx"],
      ["pdb", ["application/vnd.palm", "chemical/x-pdb"]],
      ["pdf", "application/pdf"],
      ["pfa", "application/x-font-type1"],
      ["pfr", "application/font-tdpfr"],
      ["pfunk", ["audio/make", "audio/make.my.funk"]],
      ["pfx", "application/x-pkcs12"],
      ["pgm", ["image/x-portable-graymap", "image/x-portable-greymap"]],
      ["pgn", "application/x-chess-pgn"],
      ["pgp", "application/pgp-signature"],
      ["pic", ["image/pict", "image/x-pict"]],
      ["pict", "image/pict"],
      ["pkg", "application/x-newton-compatible-pkg"],
      ["pki", "application/pkixcmp"],
      ["pkipath", "application/pkix-pkipath"],
      ["pko", ["application/ynd.ms-pkipko", "application/vnd.ms-pki.pko"]],
      ["pl", ["text/plain", "text/x-script.perl"]],
      ["plb", "application/vnd.3gpp.pic-bw-large"],
      ["plc", "application/vnd.mobius.plc"],
      ["plf", "application/vnd.pocketlearn"],
      ["pls", "application/pls+xml"],
      ["plx", "application/x-pixclscript"],
      ["pm", ["text/x-script.perl-module", "image/x-xpixmap"]],
      ["pm4", "application/x-pagemaker"],
      ["pm5", "application/x-pagemaker"],
      ["pma", "application/x-perfmon"],
      ["pmc", "application/x-perfmon"],
      ["pml", ["application/vnd.ctc-posml", "application/x-perfmon"]],
      ["pmr", "application/x-perfmon"],
      ["pmw", "application/x-perfmon"],
      ["png", "image/png"],
      ["pnm", ["application/x-portable-anymap", "image/x-portable-anymap"]],
      ["portpkg", "application/vnd.macports.portpkg"],
      ["pot", ["application/vnd.ms-powerpoint", "application/mspowerpoint"]],
      ["potm", "application/vnd.ms-powerpoint.template.macroenabled.12"],
      ["potx", "application/vnd.openxmlformats-officedocument.presentationml.template"],
      ["pov", "model/x-pov"],
      ["ppa", "application/vnd.ms-powerpoint"],
      ["ppam", "application/vnd.ms-powerpoint.addin.macroenabled.12"],
      ["ppd", "application/vnd.cups-ppd"],
      ["ppm", "image/x-portable-pixmap"],
      ["pps", ["application/vnd.ms-powerpoint", "application/mspowerpoint"]],
      ["ppsm", "application/vnd.ms-powerpoint.slideshow.macroenabled.12"],
      ["ppsx", "application/vnd.openxmlformats-officedocument.presentationml.slideshow"],
      ["ppt", ["application/vnd.ms-powerpoint", "application/mspowerpoint", "application/powerpoint", "application/x-mspowerpoint"]],
      ["pptm", "application/vnd.ms-powerpoint.presentation.macroenabled.12"],
      ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
      ["ppz", "application/mspowerpoint"],
      ["prc", "application/x-mobipocket-ebook"],
      ["pre", ["application/vnd.lotus-freelance", "application/x-freelance"]],
      ["prf", "application/pics-rules"],
      ["prt", "application/pro_eng"],
      ["ps", "application/postscript"],
      ["psb", "application/vnd.3gpp.pic-bw-small"],
      ["psd", ["application/octet-stream", "image/vnd.adobe.photoshop"]],
      ["psf", "application/x-font-linux-psf"],
      ["pskcxml", "application/pskc+xml"],
      ["ptid", "application/vnd.pvi.ptid1"],
      ["pub", "application/x-mspublisher"],
      ["pvb", "application/vnd.3gpp.pic-bw-var"],
      ["pvu", "paleovu/x-pv"],
      ["pwn", "application/vnd.3m.post-it-notes"],
      ["pwz", "application/vnd.ms-powerpoint"],
      ["py", "text/x-script.phyton"],
      ["pya", "audio/vnd.ms-playready.media.pya"],
      ["pyc", "application/x-bytecode.python"],
      ["pyv", "video/vnd.ms-playready.media.pyv"],
      ["qam", "application/vnd.epson.quickanime"],
      ["qbo", "application/vnd.intu.qbo"],
      ["qcp", "audio/vnd.qcelp"],
      ["qd3", "x-world/x-3dmf"],
      ["qd3d", "x-world/x-3dmf"],
      ["qfx", "application/vnd.intu.qfx"],
      ["qif", "image/x-quicktime"],
      ["qps", "application/vnd.publishare-delta-tree"],
      ["qt", "video/quicktime"],
      ["qtc", "video/x-qtc"],
      ["qti", "image/x-quicktime"],
      ["qtif", "image/x-quicktime"],
      ["qxd", "application/vnd.quark.quarkxpress"],
      ["ra", ["audio/x-realaudio", "audio/x-pn-realaudio", "audio/x-pn-realaudio-plugin"]],
      ["ram", "audio/x-pn-realaudio"],
      ["rar", "application/x-rar-compressed"],
      ["ras", ["image/cmu-raster", "application/x-cmu-raster", "image/x-cmu-raster"]],
      ["rast", "image/cmu-raster"],
      ["rcprofile", "application/vnd.ipunplugged.rcprofile"],
      ["rdf", "application/rdf+xml"],
      ["rdz", "application/vnd.data-vision.rdz"],
      ["rep", "application/vnd.businessobjects"],
      ["res", "application/x-dtbresource+xml"],
      ["rexx", "text/x-script.rexx"],
      ["rf", "image/vnd.rn-realflash"],
      ["rgb", "image/x-rgb"],
      ["rif", "application/reginfo+xml"],
      ["rip", "audio/vnd.rip"],
      ["rl", "application/resource-lists+xml"],
      ["rlc", "image/vnd.fujixerox.edmics-rlc"],
      ["rld", "application/resource-lists-diff+xml"],
      ["rm", ["application/vnd.rn-realmedia", "audio/x-pn-realaudio"]],
      ["rmi", "audio/mid"],
      ["rmm", "audio/x-pn-realaudio"],
      ["rmp", ["audio/x-pn-realaudio-plugin", "audio/x-pn-realaudio"]],
      ["rms", "application/vnd.jcp.javame.midlet-rms"],
      ["rnc", "application/relax-ng-compact-syntax"],
      ["rng", ["application/ringing-tones", "application/vnd.nokia.ringing-tone"]],
      ["rnx", "application/vnd.rn-realplayer"],
      ["roff", "application/x-troff"],
      ["rp", "image/vnd.rn-realpix"],
      ["rp9", "application/vnd.cloanto.rp9"],
      ["rpm", "audio/x-pn-realaudio-plugin"],
      ["rpss", "application/vnd.nokia.radio-presets"],
      ["rpst", "application/vnd.nokia.radio-preset"],
      ["rq", "application/sparql-query"],
      ["rs", "application/rls-services+xml"],
      ["rsd", "application/rsd+xml"],
      ["rt", ["text/richtext", "text/vnd.rn-realtext"]],
      ["rtf", ["application/rtf", "text/richtext", "application/x-rtf"]],
      ["rtx", ["text/richtext", "application/rtf"]],
      ["rv", "video/vnd.rn-realvideo"],
      ["s", "text/x-asm"],
      ["s3m", "audio/s3m"],
      ["saf", "application/vnd.yamaha.smaf-audio"],
      ["saveme", "application/octet-stream"],
      ["sbk", "application/x-tbook"],
      ["sbml", "application/sbml+xml"],
      ["sc", "application/vnd.ibm.secure-container"],
      ["scd", "application/x-msschedule"],
      ["scm", ["application/vnd.lotus-screencam", "video/x-scm", "text/x-script.guile", "application/x-lotusscreencam", "text/x-script.scheme"]],
      ["scq", "application/scvp-cv-request"],
      ["scs", "application/scvp-cv-response"],
      ["sct", "text/scriptlet"],
      ["scurl", "text/vnd.curl.scurl"],
      ["sda", "application/vnd.stardivision.draw"],
      ["sdc", "application/vnd.stardivision.calc"],
      ["sdd", "application/vnd.stardivision.impress"],
      ["sdkm", "application/vnd.solent.sdkm+xml"],
      ["sdml", "text/plain"],
      ["sdp", ["application/sdp", "application/x-sdp"]],
      ["sdr", "application/sounder"],
      ["sdw", "application/vnd.stardivision.writer"],
      ["sea", ["application/sea", "application/x-sea"]],
      ["see", "application/vnd.seemail"],
      ["seed", "application/vnd.fdsn.seed"],
      ["sema", "application/vnd.sema"],
      ["semd", "application/vnd.semd"],
      ["semf", "application/vnd.semf"],
      ["ser", "application/java-serialized-object"],
      ["set", "application/set"],
      ["setpay", "application/set-payment-initiation"],
      ["setreg", "application/set-registration-initiation"],
      ["sfd-hdstx", "application/vnd.hydrostatix.sof-data"],
      ["sfs", "application/vnd.spotfire.sfs"],
      ["sgl", "application/vnd.stardivision.writer-global"],
      ["sgm", ["text/sgml", "text/x-sgml"]],
      ["sgml", ["text/sgml", "text/x-sgml"]],
      ["sh", ["application/x-shar", "application/x-bsh", "application/x-sh", "text/x-script.sh"]],
      ["shar", ["application/x-bsh", "application/x-shar"]],
      ["shf", "application/shf+xml"],
      ["shtml", ["text/html", "text/x-server-parsed-html"]],
      ["sid", "audio/x-psid"],
      ["sis", "application/vnd.symbian.install"],
      ["sit", ["application/x-stuffit", "application/x-sit"]],
      ["sitx", "application/x-stuffitx"],
      ["skd", "application/x-koan"],
      ["skm", "application/x-koan"],
      ["skp", ["application/vnd.koan", "application/x-koan"]],
      ["skt", "application/x-koan"],
      ["sl", "application/x-seelogo"],
      ["sldm", "application/vnd.ms-powerpoint.slide.macroenabled.12"],
      ["sldx", "application/vnd.openxmlformats-officedocument.presentationml.slide"],
      ["slt", "application/vnd.epson.salt"],
      ["sm", "application/vnd.stepmania.stepchart"],
      ["smf", "application/vnd.stardivision.math"],
      ["smi", ["application/smil", "application/smil+xml"]],
      ["smil", "application/smil"],
      ["snd", ["audio/basic", "audio/x-adpcm"]],
      ["snf", "application/x-font-snf"],
      ["sol", "application/solids"],
      ["spc", ["text/x-speech", "application/x-pkcs7-certificates"]],
      ["spf", "application/vnd.yamaha.smaf-phrase"],
      ["spl", ["application/futuresplash", "application/x-futuresplash"]],
      ["spot", "text/vnd.in3d.spot"],
      ["spp", "application/scvp-vp-response"],
      ["spq", "application/scvp-vp-request"],
      ["spr", "application/x-sprite"],
      ["sprite", "application/x-sprite"],
      ["src", "application/x-wais-source"],
      ["sru", "application/sru+xml"],
      ["srx", "application/sparql-results+xml"],
      ["sse", "application/vnd.kodak-descriptor"],
      ["ssf", "application/vnd.epson.ssf"],
      ["ssi", "text/x-server-parsed-html"],
      ["ssm", "application/streamingmedia"],
      ["ssml", "application/ssml+xml"],
      ["sst", ["application/vnd.ms-pkicertstore", "application/vnd.ms-pki.certstore"]],
      ["st", "application/vnd.sailingtracker.track"],
      ["stc", "application/vnd.sun.xml.calc.template"],
      ["std", "application/vnd.sun.xml.draw.template"],
      ["step", "application/step"],
      ["stf", "application/vnd.wt.stf"],
      ["sti", "application/vnd.sun.xml.impress.template"],
      ["stk", "application/hyperstudio"],
      ["stl", ["application/vnd.ms-pkistl", "application/sla", "application/vnd.ms-pki.stl", "application/x-navistyle"]],
      ["stm", "text/html"],
      ["stp", "application/step"],
      ["str", "application/vnd.pg.format"],
      ["stw", "application/vnd.sun.xml.writer.template"],
      ["sub", "image/vnd.dvb.subtitle"],
      ["sus", "application/vnd.sus-calendar"],
      ["sv4cpio", "application/x-sv4cpio"],
      ["sv4crc", "application/x-sv4crc"],
      ["svc", "application/vnd.dvb.service"],
      ["svd", "application/vnd.svd"],
      ["svf", ["image/vnd.dwg", "image/x-dwg"]],
      ["svg", "image/svg+xml"],
      ["svr", ["x-world/x-svr", "application/x-world"]],
      ["swf", "application/x-shockwave-flash"],
      ["swi", "application/vnd.aristanetworks.swi"],
      ["sxc", "application/vnd.sun.xml.calc"],
      ["sxd", "application/vnd.sun.xml.draw"],
      ["sxg", "application/vnd.sun.xml.writer.global"],
      ["sxi", "application/vnd.sun.xml.impress"],
      ["sxm", "application/vnd.sun.xml.math"],
      ["sxw", "application/vnd.sun.xml.writer"],
      ["t", ["text/troff", "application/x-troff"]],
      ["talk", "text/x-speech"],
      ["tao", "application/vnd.tao.intent-module-archive"],
      ["tar", "application/x-tar"],
      ["tbk", ["application/toolbook", "application/x-tbook"]],
      ["tcap", "application/vnd.3gpp2.tcap"],
      ["tcl", ["text/x-script.tcl", "application/x-tcl"]],
      ["tcsh", "text/x-script.tcsh"],
      ["teacher", "application/vnd.smart.teacher"],
      ["tei", "application/tei+xml"],
      ["tex", "application/x-tex"],
      ["texi", "application/x-texinfo"],
      ["texinfo", "application/x-texinfo"],
      ["text", ["application/plain", "text/plain"]],
      ["tfi", "application/thraud+xml"],
      ["tfm", "application/x-tex-tfm"],
      ["tgz", ["application/gnutar", "application/x-compressed"]],
      ["thmx", "application/vnd.ms-officetheme"],
      ["tif", ["image/tiff", "image/x-tiff"]],
      ["tiff", ["image/tiff", "image/x-tiff"]],
      ["tmo", "application/vnd.tmobile-livetv"],
      ["torrent", "application/x-bittorrent"],
      ["tpl", "application/vnd.groove-tool-template"],
      ["tpt", "application/vnd.trid.tpt"],
      ["tr", "application/x-troff"],
      ["tra", "application/vnd.trueapp"],
      ["trm", "application/x-msterminal"],
      ["tsd", "application/timestamped-data"],
      ["tsi", "audio/tsp-audio"],
      ["tsp", ["application/dsptype", "audio/tsplayer"]],
      ["tsv", "text/tab-separated-values"],
      ["ttf", "application/x-font-ttf"],
      ["ttl", "text/turtle"],
      ["turbot", "image/florian"],
      ["twd", "application/vnd.simtech-mindmapper"],
      ["txd", "application/vnd.genomatix.tuxedo"],
      ["txf", "application/vnd.mobius.txf"],
      ["txt", "text/plain"],
      ["ufd", "application/vnd.ufdl"],
      ["uil", "text/x-uil"],
      ["uls", "text/iuls"],
      ["umj", "application/vnd.umajin"],
      ["uni", "text/uri-list"],
      ["unis", "text/uri-list"],
      ["unityweb", "application/vnd.unity"],
      ["unv", "application/i-deas"],
      ["uoml", "application/vnd.uoml+xml"],
      ["uri", "text/uri-list"],
      ["uris", "text/uri-list"],
      ["ustar", ["application/x-ustar", "multipart/x-ustar"]],
      ["utz", "application/vnd.uiq.theme"],
      ["uu", ["application/octet-stream", "text/x-uuencode"]],
      ["uue", "text/x-uuencode"],
      ["uva", "audio/vnd.dece.audio"],
      ["uvh", "video/vnd.dece.hd"],
      ["uvi", "image/vnd.dece.graphic"],
      ["uvm", "video/vnd.dece.mobile"],
      ["uvp", "video/vnd.dece.pd"],
      ["uvs", "video/vnd.dece.sd"],
      ["uvu", "video/vnd.uvvu.mp4"],
      ["uvv", "video/vnd.dece.video"],
      ["vcd", "application/x-cdlink"],
      ["vcf", "text/x-vcard"],
      ["vcg", "application/vnd.groove-vcard"],
      ["vcs", "text/x-vcalendar"],
      ["vcx", "application/vnd.vcx"],
      ["vda", "application/vda"],
      ["vdo", "video/vdo"],
      ["vew", "application/groupwise"],
      ["vis", "application/vnd.visionary"],
      ["viv", ["video/vivo", "video/vnd.vivo"]],
      ["vivo", ["video/vivo", "video/vnd.vivo"]],
      ["vmd", "application/vocaltec-media-desc"],
      ["vmf", "application/vocaltec-media-file"],
      ["voc", ["audio/voc", "audio/x-voc"]],
      ["vos", "video/vosaic"],
      ["vox", "audio/voxware"],
      ["vqe", "audio/x-twinvq-plugin"],
      ["vqf", "audio/x-twinvq"],
      ["vql", "audio/x-twinvq-plugin"],
      ["vrml", ["model/vrml", "x-world/x-vrml", "application/x-vrml"]],
      ["vrt", "x-world/x-vrt"],
      ["vsd", ["application/vnd.visio", "application/x-visio"]],
      ["vsf", "application/vnd.vsf"],
      ["vst", "application/x-visio"],
      ["vsw", "application/x-visio"],
      ["vtu", "model/vnd.vtu"],
      ["vxml", "application/voicexml+xml"],
      ["w60", "application/wordperfect6.0"],
      ["w61", "application/wordperfect6.1"],
      ["w6w", "application/msword"],
      ["wad", "application/x-doom"],
      ["wav", ["audio/wav", "audio/x-wav"]],
      ["wax", "audio/x-ms-wax"],
      ["wb1", "application/x-qpro"],
      ["wbmp", "image/vnd.wap.wbmp"],
      ["wbs", "application/vnd.criticaltools.wbs+xml"],
      ["wbxml", "application/vnd.wap.wbxml"],
      ["wcm", "application/vnd.ms-works"],
      ["wdb", "application/vnd.ms-works"],
      ["web", "application/vnd.xara"],
      ["weba", "audio/webm"],
      ["webm", "video/webm"],
      ["webp", "image/webp"],
      ["wg", "application/vnd.pmi.widget"],
      ["wgt", "application/widget"],
      ["wiz", "application/msword"],
      ["wk1", "application/x-123"],
      ["wks", "application/vnd.ms-works"],
      ["wm", "video/x-ms-wm"],
      ["wma", "audio/x-ms-wma"],
      ["wmd", "application/x-ms-wmd"],
      ["wmf", ["windows/metafile", "application/x-msmetafile"]],
      ["wml", "text/vnd.wap.wml"],
      ["wmlc", "application/vnd.wap.wmlc"],
      ["wmls", "text/vnd.wap.wmlscript"],
      ["wmlsc", "application/vnd.wap.wmlscriptc"],
      ["wmv", "video/x-ms-wmv"],
      ["wmx", "video/x-ms-wmx"],
      ["wmz", "application/x-ms-wmz"],
      ["woff", "application/x-font-woff"],
      ["word", "application/msword"],
      ["wp", "application/wordperfect"],
      ["wp5", ["application/wordperfect", "application/wordperfect6.0"]],
      ["wp6", "application/wordperfect"],
      ["wpd", ["application/wordperfect", "application/vnd.wordperfect", "application/x-wpwin"]],
      ["wpl", "application/vnd.ms-wpl"],
      ["wps", "application/vnd.ms-works"],
      ["wq1", "application/x-lotus"],
      ["wqd", "application/vnd.wqd"],
      ["wri", ["application/mswrite", "application/x-wri", "application/x-mswrite"]],
      ["wrl", ["model/vrml", "x-world/x-vrml", "application/x-world"]],
      ["wrz", ["model/vrml", "x-world/x-vrml"]],
      ["wsc", "text/scriplet"],
      ["wsdl", "application/wsdl+xml"],
      ["wspolicy", "application/wspolicy+xml"],
      ["wsrc", "application/x-wais-source"],
      ["wtb", "application/vnd.webturbo"],
      ["wtk", "application/x-wintalk"],
      ["wvx", "video/x-ms-wvx"],
      ["x-png", "image/png"],
      ["x3d", "application/vnd.hzn-3d-crossword"],
      ["xaf", "x-world/x-vrml"],
      ["xap", "application/x-silverlight-app"],
      ["xar", "application/vnd.xara"],
      ["xbap", "application/x-ms-xbap"],
      ["xbd", "application/vnd.fujixerox.docuworks.binder"],
      ["xbm", ["image/xbm", "image/x-xbm", "image/x-xbitmap"]],
      ["xdf", "application/xcap-diff+xml"],
      ["xdm", "application/vnd.syncml.dm+xml"],
      ["xdp", "application/vnd.adobe.xdp+xml"],
      ["xdr", "video/x-amt-demorun"],
      ["xdssc", "application/dssc+xml"],
      ["xdw", "application/vnd.fujixerox.docuworks"],
      ["xenc", "application/xenc+xml"],
      ["xer", "application/patch-ops-error+xml"],
      ["xfdf", "application/vnd.adobe.xfdf"],
      ["xfdl", "application/vnd.xfdl"],
      ["xgz", "xgl/drawing"],
      ["xhtml", "application/xhtml+xml"],
      ["xif", "image/vnd.xiff"],
      ["xl", "application/excel"],
      ["xla", ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"]],
      ["xlam", "application/vnd.ms-excel.addin.macroenabled.12"],
      ["xlb", ["application/excel", "application/vnd.ms-excel", "application/x-excel"]],
      ["xlc", ["application/vnd.ms-excel", "application/excel", "application/x-excel"]],
      ["xld", ["application/excel", "application/x-excel"]],
      ["xlk", ["application/excel", "application/x-excel"]],
      ["xll", ["application/excel", "application/vnd.ms-excel", "application/x-excel"]],
      ["xlm", ["application/vnd.ms-excel", "application/excel", "application/x-excel"]],
      ["xls", ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"]],
      ["xlsb", "application/vnd.ms-excel.sheet.binary.macroenabled.12"],
      ["xlsm", "application/vnd.ms-excel.sheet.macroenabled.12"],
      ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
      ["xlt", ["application/vnd.ms-excel", "application/excel", "application/x-excel"]],
      ["xltm", "application/vnd.ms-excel.template.macroenabled.12"],
      ["xltx", "application/vnd.openxmlformats-officedocument.spreadsheetml.template"],
      ["xlv", ["application/excel", "application/x-excel"]],
      ["xlw", ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"]],
      ["xm", "audio/xm"],
      ["xml", ["application/xml", "text/xml", "application/atom+xml", "application/rss+xml"]],
      ["xmz", "xgl/movie"],
      ["xo", "application/vnd.olpc-sugar"],
      ["xof", "x-world/x-vrml"],
      ["xop", "application/xop+xml"],
      ["xpi", "application/x-xpinstall"],
      ["xpix", "application/x-vnd.ls-xpix"],
      ["xpm", ["image/xpm", "image/x-xpixmap"]],
      ["xpr", "application/vnd.is-xpr"],
      ["xps", "application/vnd.ms-xpsdocument"],
      ["xpw", "application/vnd.intercon.formnet"],
      ["xslt", "application/xslt+xml"],
      ["xsm", "application/vnd.syncml+xml"],
      ["xspf", "application/xspf+xml"],
      ["xsr", "video/x-amt-showrun"],
      ["xul", "application/vnd.mozilla.xul+xml"],
      ["xwd", ["image/x-xwd", "image/x-xwindowdump"]],
      ["xyz", ["chemical/x-xyz", "chemical/x-pdb"]],
      ["yang", "application/yang"],
      ["yin", "application/yin+xml"],
      ["z", ["application/x-compressed", "application/x-compress"]],
      ["zaz", "application/vnd.zzazz.deck+xml"],
      ["zip", ["application/zip", "multipart/x-zip", "application/x-zip-compressed", "application/x-compressed"]],
      ["zir", "application/vnd.zul"],
      ["zmm", "application/vnd.handheld-entertainment+xml"],
      ["zoo", "application/octet-stream"],
      ["zsh", "text/x-script.zsh"]
    ]);
    module2.exports = {
      detectMimeType(filename) {
        if (!filename) {
          return defaultMimeType;
        }
        let parsed = path.parse(filename);
        let extension = (parsed.ext.substr(1) || parsed.name || "").split("?").shift().trim().toLowerCase();
        let value = defaultMimeType;
        if (extensions.has(extension)) {
          value = extensions.get(extension);
        }
        if (Array.isArray(value)) {
          return value[0];
        }
        return value;
      },
      detectExtension(mimeType) {
        if (!mimeType) {
          return defaultExtension;
        }
        let parts = (mimeType || "").toLowerCase().trim().split("/");
        let rootType = parts.shift().trim();
        let subType = parts.join("/").trim();
        if (mimeTypes.has(rootType + "/" + subType)) {
          let value = mimeTypes.get(rootType + "/" + subType);
          if (Array.isArray(value)) {
            return value[0];
          }
          return value;
        }
        switch (rootType) {
          case "text":
            return "txt";
          default:
            return "bin";
        }
      }
    };
  }
});

// node_modules/nodemailer/lib/punycode/index.js
var require_punycode = __commonJS({
  "node_modules/nodemailer/lib/punycode/index.js"(exports, module2) {
    "use strict";
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7F]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error(type) {
      throw new RangeError(errors[type]);
    }
    function map(array, callback2) {
      const result = [];
      let length = array.length;
      while (length--) {
        result[length] = callback2(array[length]);
      }
      return result;
    }
    function mapDomain(domain, callback2) {
      const parts = domain.split("@");
      let result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        domain = parts[1];
      }
      domain = domain.replace(regexSeparators, ".");
      const labels = domain.split(".");
      const encoded = map(labels, callback2).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      const output = [];
      let counter = 0;
      const length = string.length;
      while (counter < length) {
        const value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          const extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
    var basicToDigit = function(codePoint) {
      if (codePoint >= 48 && codePoint < 58) {
        return 26 + (codePoint - 48);
      }
      if (codePoint >= 65 && codePoint < 91) {
        return codePoint - 65;
      }
      if (codePoint >= 97 && codePoint < 123) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function(delta, numPoints, firstTime) {
      let k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (
        ;
        /* no initialization */
        delta > baseMinusTMin * tMax >> 1;
        k += base
      ) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function(input) {
      const output = [];
      const inputLength = input.length;
      let i = 0;
      let n = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (let j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (let index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
        const oldi = i;
        for (let w = 1, k = base; ; k += base) {
          if (index2 >= inputLength) {
            error("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index2++));
          if (digit >= base) {
            error("invalid-input");
          }
          if (digit > floor((maxInt - i) / w)) {
            error("overflow");
          }
          i += digit * w;
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          const baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint(...output);
    };
    var encode = function(input) {
      const output = [];
      input = ucs2decode(input);
      const inputLength = input.length;
      let n = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      const basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        let m = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue of input) {
          if (currentValue < n && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue === n) {
            let q = delta;
            for (let k = base; ; k += base) {
              const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              const qMinusT = q - t;
              const baseMinusT = base - t;
              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    var toUnicode = function(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "2.3.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: ucs2decode,
        encode: ucs2encode
      },
      decode,
      encode,
      toASCII,
      toUnicode
    };
    module2.exports = punycode;
  }
});

// node_modules/nodemailer/lib/base64/index.js
var require_base64 = __commonJS({
  "node_modules/nodemailer/lib/base64/index.js"(exports, module2) {
    "use strict";
    var Transform = require("stream").Transform;
    function encode(buffer) {
      if (typeof buffer === "string") {
        buffer = Buffer.from(buffer, "utf-8");
      }
      return buffer.toString("base64");
    }
    function wrap(str, lineLength) {
      str = (str || "").toString();
      lineLength = lineLength || 76;
      if (str.length <= lineLength) {
        return str;
      }
      let result = [];
      let pos = 0;
      let chunkLength = lineLength * 1024;
      while (pos < str.length) {
        let wrappedLines = str.substr(pos, chunkLength).replace(new RegExp(".{" + lineLength + "}", "g"), "$&\r\n").trim();
        result.push(wrappedLines);
        pos += chunkLength;
      }
      return result.join("\r\n").trim();
    }
    var Encoder = class extends Transform {
      constructor(options) {
        super();
        this.options = options || {};
        if (this.options.lineLength !== false) {
          this.options.lineLength = this.options.lineLength || 76;
        }
        this._curLine = "";
        this._remainingBytes = false;
        this.inputBytes = 0;
        this.outputBytes = 0;
      }
      _transform(chunk, encoding, done) {
        if (encoding !== "buffer") {
          chunk = Buffer.from(chunk, encoding);
        }
        if (!chunk || !chunk.length) {
          return setImmediate(done);
        }
        this.inputBytes += chunk.length;
        if (this._remainingBytes && this._remainingBytes.length) {
          chunk = Buffer.concat([this._remainingBytes, chunk], this._remainingBytes.length + chunk.length);
          this._remainingBytes = false;
        }
        if (chunk.length % 3) {
          this._remainingBytes = chunk.slice(chunk.length - chunk.length % 3);
          chunk = chunk.slice(0, chunk.length - chunk.length % 3);
        } else {
          this._remainingBytes = false;
        }
        let b64 = this._curLine + encode(chunk);
        if (this.options.lineLength) {
          b64 = wrap(b64, this.options.lineLength);
          let lastLF = b64.lastIndexOf("\n");
          if (lastLF < 0) {
            this._curLine = b64;
            b64 = "";
          } else if (lastLF === b64.length - 1) {
            this._curLine = "";
          } else {
            this._curLine = b64.substr(lastLF + 1);
            b64 = b64.substr(0, lastLF + 1);
          }
        }
        if (b64) {
          this.outputBytes += b64.length;
          this.push(Buffer.from(b64, "ascii"));
        }
        setImmediate(done);
      }
      _flush(done) {
        if (this._remainingBytes && this._remainingBytes.length) {
          this._curLine += encode(this._remainingBytes);
        }
        if (this._curLine) {
          this._curLine = wrap(this._curLine, this.options.lineLength);
          this.outputBytes += this._curLine.length;
          this.push(this._curLine, "ascii");
          this._curLine = "";
        }
        done();
      }
    };
    module2.exports = {
      encode,
      wrap,
      Encoder
    };
  }
});

// node_modules/nodemailer/lib/qp/index.js
var require_qp = __commonJS({
  "node_modules/nodemailer/lib/qp/index.js"(exports, module2) {
    "use strict";
    var Transform = require("stream").Transform;
    function encode(buffer) {
      if (typeof buffer === "string") {
        buffer = Buffer.from(buffer, "utf-8");
      }
      let ranges = [
        // https://tools.ietf.org/html/rfc2045#section-6.7
        [9],
        // <TAB>
        [10],
        // <LF>
        [13],
        // <CR>
        [32, 60],
        // <SP>!"#$%&'()*+,-./0123456789:;
        [62, 126]
        // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}
      ];
      let result = "";
      let ord;
      for (let i = 0, len = buffer.length; i < len; i++) {
        ord = buffer[i];
        if (checkRanges(ord, ranges) && !((ord === 32 || ord === 9) && (i === len - 1 || buffer[i + 1] === 10 || buffer[i + 1] === 13))) {
          result += String.fromCharCode(ord);
          continue;
        }
        result += "=" + (ord < 16 ? "0" : "") + ord.toString(16).toUpperCase();
      }
      return result;
    }
    function wrap(str, lineLength) {
      str = (str || "").toString();
      lineLength = lineLength || 76;
      if (str.length <= lineLength) {
        return str;
      }
      let pos = 0;
      let len = str.length;
      let match, code, line;
      let lineMargin = Math.floor(lineLength / 3);
      let result = "";
      while (pos < len) {
        line = str.substr(pos, lineLength);
        if (match = line.match(/\r\n/)) {
          line = line.substr(0, match.index + match[0].length);
          result += line;
          pos += line.length;
          continue;
        }
        if (line.substr(-1) === "\n") {
          result += line;
          pos += line.length;
          continue;
        } else if (match = line.substr(-lineMargin).match(/\n.*?$/)) {
          line = line.substr(0, line.length - (match[0].length - 1));
          result += line;
          pos += line.length;
          continue;
        } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \t.,!?][^ \t.,!?]*$/))) {
          line = line.substr(0, line.length - (match[0].length - 1));
        } else if (line.match(/[=][\da-f]{0,2}$/i)) {
          if (match = line.match(/[=][\da-f]{0,1}$/i)) {
            line = line.substr(0, line.length - match[0].length);
          }
          while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\da-f]{2}){1,4}$/i) && (match = line.match(/[=][\da-f]{2}$/gi))) {
            code = parseInt(match[0].substr(1, 2), 16);
            if (code < 128) {
              break;
            }
            line = line.substr(0, line.length - 3);
            if (code >= 192) {
              break;
            }
          }
        }
        if (pos + line.length < len && line.substr(-1) !== "\n") {
          if (line.length === lineLength && line.match(/[=][\da-f]{2}$/i)) {
            line = line.substr(0, line.length - 3);
          } else if (line.length === lineLength) {
            line = line.substr(0, line.length - 1);
          }
          pos += line.length;
          line += "=\r\n";
        } else {
          pos += line.length;
        }
        result += line;
      }
      return result;
    }
    function checkRanges(nr, ranges) {
      for (let i = ranges.length - 1; i >= 0; i--) {
        if (!ranges[i].length) {
          continue;
        }
        if (ranges[i].length === 1 && nr === ranges[i][0]) {
          return true;
        }
        if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {
          return true;
        }
      }
      return false;
    }
    var Encoder = class extends Transform {
      constructor(options) {
        super();
        this.options = options || {};
        if (this.options.lineLength !== false) {
          this.options.lineLength = this.options.lineLength || 76;
        }
        this._curLine = "";
        this.inputBytes = 0;
        this.outputBytes = 0;
      }
      _transform(chunk, encoding, done) {
        let qp;
        if (encoding !== "buffer") {
          chunk = Buffer.from(chunk, encoding);
        }
        if (!chunk || !chunk.length) {
          return done();
        }
        this.inputBytes += chunk.length;
        if (this.options.lineLength) {
          qp = this._curLine + encode(chunk);
          qp = wrap(qp, this.options.lineLength);
          qp = qp.replace(/(^|\n)([^\n]*)$/, (match, lineBreak, lastLine) => {
            this._curLine = lastLine;
            return lineBreak;
          });
          if (qp) {
            this.outputBytes += qp.length;
            this.push(qp);
          }
        } else {
          qp = encode(chunk);
          this.outputBytes += qp.length;
          this.push(qp, "ascii");
        }
        done();
      }
      _flush(done) {
        if (this._curLine) {
          this.outputBytes += this._curLine.length;
          this.push(this._curLine, "ascii");
        }
        done();
      }
    };
    module2.exports = {
      encode,
      wrap,
      Encoder
    };
  }
});

// node_modules/nodemailer/lib/mime-funcs/index.js
var require_mime_funcs = __commonJS({
  "node_modules/nodemailer/lib/mime-funcs/index.js"(exports, module2) {
    "use strict";
    var base64 = require_base64();
    var qp = require_qp();
    var mimeTypes = require_mime_types();
    module2.exports = {
      /**
       * Checks if a value is plaintext string (uses only printable 7bit chars)
       *
       * @param {String} value String to be tested
       * @returns {Boolean} true if it is a plaintext string
       */
      isPlainText(value, isParam) {
        const re = isParam ? /[\x00-\x08\x0b\x0c\x0e-\x1f"\u0080-\uFFFF]/ : /[\x00-\x08\x0b\x0c\x0e-\x1f\u0080-\uFFFF]/;
        if (typeof value !== "string" || re.test(value)) {
          return false;
        } else {
          return true;
        }
      },
      /**
       * Checks if a multi line string containes lines longer than the selected value.
       *
       * Useful when detecting if a mail message needs any processing at all 
       * if only plaintext characters are used and lines are short, then there is
       * no need to encode the values in any way. If the value is plaintext but has
       * longer lines then allowed, then use format=flowed
       *
       * @param {Number} lineLength Max line length to check for
       * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars
       */
      hasLongerLines(str, lineLength) {
        if (str.length > 128 * 1024) {
          return true;
        }
        return new RegExp("^.{" + (lineLength + 1) + ",}", "m").test(str);
      },
      /**
       * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)
       *
       * @param {String|Buffer} data String to be encoded
       * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B
       * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed
       * @return {String} Single or several mime words joined together
       */
      encodeWord(data, mimeWordEncoding, maxLength) {
        mimeWordEncoding = (mimeWordEncoding || "Q").toString().toUpperCase().trim().charAt(0);
        maxLength = maxLength || 0;
        let encodedStr;
        let toCharset = "UTF-8";
        if (maxLength && maxLength > 7 + toCharset.length) {
          maxLength -= 7 + toCharset.length;
        }
        if (mimeWordEncoding === "Q") {
          encodedStr = qp.encode(data).replace(/[^a-z0-9!*+\-/=]/gi, (chr) => {
            let ord = chr.charCodeAt(0).toString(16).toUpperCase();
            if (chr === " ") {
              return "_";
            } else {
              return "=" + (ord.length === 1 ? "0" + ord : ord);
            }
          });
        } else if (mimeWordEncoding === "B") {
          encodedStr = typeof data === "string" ? data : base64.encode(data);
          maxLength = maxLength ? Math.max(3, (maxLength - maxLength % 4) / 4 * 3) : 0;
        }
        if (maxLength && (mimeWordEncoding !== "B" ? encodedStr : base64.encode(data)).length > maxLength) {
          if (mimeWordEncoding === "Q") {
            encodedStr = this.splitMimeEncodedString(encodedStr, maxLength).join("?= =?" + toCharset + "?" + mimeWordEncoding + "?");
          } else {
            let parts = [];
            let lpart = "";
            for (let i = 0, len = encodedStr.length; i < len; i++) {
              let chr = encodedStr.charAt(i);
              if (/[\ud83c\ud83d\ud83e]/.test(chr) && i < len - 1) {
                chr += encodedStr.charAt(++i);
              }
              if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {
                lpart += chr;
              } else {
                parts.push(base64.encode(lpart));
                lpart = chr;
              }
            }
            if (lpart) {
              parts.push(base64.encode(lpart));
            }
            if (parts.length > 1) {
              encodedStr = parts.join("?= =?" + toCharset + "?" + mimeWordEncoding + "?");
            } else {
              encodedStr = parts.join("");
            }
          }
        } else if (mimeWordEncoding === "B") {
          encodedStr = base64.encode(data);
        }
        return "=?" + toCharset + "?" + mimeWordEncoding + "?" + encodedStr + (encodedStr.substr(-2) === "?=" ? "" : "?=");
      },
      /**
       * Finds word sequences with non ascii text and converts these to mime words
       *
       * @param {String} value String to be encoded
       * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B
       * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed
       * @param {Boolean} [encodeAll=false] If true and the value needs encoding then encodes entire string, not just the smallest match
       * @return {String} String with possible mime words
       */
      encodeWords(value, mimeWordEncoding, maxLength, encodeAll) {
        maxLength = maxLength || 0;
        let encodedValue;
        let firstMatch = value.match(/(?:^|\s)([^\s]*["\u0080-\uFFFF])/);
        if (!firstMatch) {
          return value;
        }
        if (encodeAll) {
          return this.encodeWord(value, mimeWordEncoding, maxLength);
        }
        let lastMatch = value.match(/(["\u0080-\uFFFF][^\s]*)[^"\u0080-\uFFFF]*$/);
        if (!lastMatch) {
          return value;
        }
        let startIndex = firstMatch.index + (firstMatch[0].match(/[^\s]/) || {
          index: 0
        }).index;
        let endIndex = lastMatch.index + (lastMatch[1] || "").length;
        encodedValue = (startIndex ? value.substr(0, startIndex) : "") + this.encodeWord(value.substring(startIndex, endIndex), mimeWordEncoding || "Q", maxLength) + (endIndex < value.length ? value.substr(endIndex) : "");
        return encodedValue;
      },
      /**
       * Joins parsed header value together as 'value; param1=value1; param2=value2'
       * PS: We are following RFC 822 for the list of special characters that we need to keep in quotes.
       *      Refer: https://www.w3.org/Protocols/rfc1341/4_Content-Type.html
       * @param {Object} structured Parsed header value
       * @return {String} joined header value
       */
      buildHeaderValue(structured) {
        let paramsArray = [];
        Object.keys(structured.params || {}).forEach((param) => {
          let value = structured.params[param];
          if (!this.isPlainText(value, true) || value.length >= 75) {
            this.buildHeaderParam(param, value, 50).forEach((encodedParam) => {
              if (!/[\s"\\;:/=(),<>@[\]?]|^[-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === "*") {
                paramsArray.push(encodedParam.key + "=" + encodedParam.value);
              } else {
                paramsArray.push(encodedParam.key + "=" + JSON.stringify(encodedParam.value));
              }
            });
          } else if (/[\s'"\\;:/=(),<>@[\]?]|^-/.test(value)) {
            paramsArray.push(param + "=" + JSON.stringify(value));
          } else {
            paramsArray.push(param + "=" + value);
          }
        });
        return structured.value + (paramsArray.length ? "; " + paramsArray.join("; ") : "");
      },
      /**
       * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)
       * Useful for splitting long parameter values.
       *
       * For example
       *      title="unicode string"
       * becomes
       *     title*0*=utf-8''unicode
       *     title*1*=%20string
       *
       * @param {String|Buffer} data String to be encoded
       * @param {Number} [maxLength=50] Max length for generated chunks
       * @param {String} [fromCharset='UTF-8'] Source sharacter set
       * @return {Array} A list of encoded keys and headers
       */
      buildHeaderParam(key, data, maxLength) {
        let list = [];
        let encodedStr = typeof data === "string" ? data : (data || "").toString();
        let encodedStrArr;
        let chr, ord;
        let line;
        let startPos = 0;
        let i, len;
        maxLength = maxLength || 50;
        if (this.isPlainText(data, true)) {
          if (encodedStr.length <= maxLength) {
            return [
              {
                key,
                value: encodedStr
              }
            ];
          }
          encodedStr = encodedStr.replace(new RegExp(".{" + maxLength + "}", "g"), (str) => {
            list.push({
              line: str
            });
            return "";
          });
          if (encodedStr) {
            list.push({
              line: encodedStr
            });
          }
        } else {
          if (/[\uD800-\uDBFF]/.test(encodedStr)) {
            encodedStrArr = [];
            for (i = 0, len = encodedStr.length; i < len; i++) {
              chr = encodedStr.charAt(i);
              ord = chr.charCodeAt(0);
              if (ord >= 55296 && ord <= 56319 && i < len - 1) {
                chr += encodedStr.charAt(i + 1);
                encodedStrArr.push(chr);
                i++;
              } else {
                encodedStrArr.push(chr);
              }
            }
            encodedStr = encodedStrArr;
          }
          line = "utf-8''";
          let encoded = true;
          startPos = 0;
          for (i = 0, len = encodedStr.length; i < len; i++) {
            chr = encodedStr[i];
            if (encoded) {
              chr = this.safeEncodeURIComponent(chr);
            } else {
              chr = chr === " " ? chr : this.safeEncodeURIComponent(chr);
              if (chr !== encodedStr[i]) {
                if ((this.safeEncodeURIComponent(line) + chr).length >= maxLength) {
                  list.push({
                    line,
                    encoded
                  });
                  line = "";
                  startPos = i - 1;
                } else {
                  encoded = true;
                  i = startPos;
                  line = "";
                  continue;
                }
              }
            }
            if ((line + chr).length >= maxLength) {
              list.push({
                line,
                encoded
              });
              line = chr = encodedStr[i] === " " ? " " : this.safeEncodeURIComponent(encodedStr[i]);
              if (chr === encodedStr[i]) {
                encoded = false;
                startPos = i - 1;
              } else {
                encoded = true;
              }
            } else {
              line += chr;
            }
          }
          if (line) {
            list.push({
              line,
              encoded
            });
          }
        }
        return list.map((item, i2) => ({
          // encoded lines: {name}*{part}*
          // unencoded lines: {name}*{part}
          // if any line needs to be encoded then the first line (part==0) is always encoded
          key: key + "*" + i2 + (item.encoded ? "*" : ""),
          value: item.line
        }));
      },
      /**
       * Parses a header value with key=value arguments into a structured
       * object.
       *
       *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->
       *   {
       *     'value': 'text/plain',
       *     'params': {
       *       'charset': 'UTF-8'
       *     }
       *   }
       *
       * @param {String} str Header value
       * @return {Object} Header value as a parsed structure
       */
      parseHeaderValue(str) {
        let response = {
          value: false,
          params: {}
        };
        let key = false;
        let value = "";
        let type = "value";
        let quote = false;
        let escaped = false;
        let chr;
        for (let i = 0, len = str.length; i < len; i++) {
          chr = str.charAt(i);
          if (type === "key") {
            if (chr === "=") {
              key = value.trim().toLowerCase();
              type = "value";
              value = "";
              continue;
            }
            value += chr;
          } else {
            if (escaped) {
              value += chr;
            } else if (chr === "\\") {
              escaped = true;
              continue;
            } else if (quote && chr === quote) {
              quote = false;
            } else if (!quote && chr === '"') {
              quote = chr;
            } else if (!quote && chr === ";") {
              if (key === false) {
                response.value = value.trim();
              } else {
                response.params[key] = value.trim();
              }
              type = "key";
              value = "";
            } else {
              value += chr;
            }
            escaped = false;
          }
        }
        if (type === "value") {
          if (key === false) {
            response.value = value.trim();
          } else {
            response.params[key] = value.trim();
          }
        } else if (value.trim()) {
          response.params[value.trim().toLowerCase()] = "";
        }
        Object.keys(response.params).forEach((key2) => {
          let actualKey, nr, match, value2;
          if (match = key2.match(/(\*(\d+)|\*(\d+)\*|\*)$/)) {
            actualKey = key2.substr(0, match.index);
            nr = Number(match[2] || match[3]) || 0;
            if (!response.params[actualKey] || typeof response.params[actualKey] !== "object") {
              response.params[actualKey] = {
                charset: false,
                values: []
              };
            }
            value2 = response.params[key2];
            if (nr === 0 && match[0].substr(-1) === "*" && (match = value2.match(/^([^']*)'[^']*'(.*)$/))) {
              response.params[actualKey].charset = match[1] || "iso-8859-1";
              value2 = match[2];
            }
            response.params[actualKey].values[nr] = value2;
            delete response.params[key2];
          }
        });
        Object.keys(response.params).forEach((key2) => {
          let value2;
          if (response.params[key2] && Array.isArray(response.params[key2].values)) {
            value2 = response.params[key2].values.map((val) => val || "").join("");
            if (response.params[key2].charset) {
              response.params[key2] = "=?" + response.params[key2].charset + "?Q?" + value2.replace(/[=?_\s]/g, (s) => {
                let c = s.charCodeAt(0).toString(16);
                if (s === " ") {
                  return "_";
                } else {
                  return "%" + (c.length < 2 ? "0" : "") + c;
                }
              }).replace(/%/g, "=") + "?=";
            } else {
              response.params[key2] = value2;
            }
          }
        });
        return response;
      },
      /**
       * Returns file extension for a content type string. If no suitable extensions
       * are found, 'bin' is used as the default extension
       *
       * @param {String} mimeType Content type to be checked for
       * @return {String} File extension
       */
      detectExtension: (mimeType) => mimeTypes.detectExtension(mimeType),
      /**
       * Returns content type for a file extension. If no suitable content types
       * are found, 'application/octet-stream' is used as the default content type
       *
       * @param {String} extension Extension to be checked for
       * @return {String} File extension
       */
      detectMimeType: (extension) => mimeTypes.detectMimeType(extension),
      /**
       * Folds long lines, useful for folding header lines (afterSpace=false) and
       * flowed text (afterSpace=true)
       *
       * @param {String} str String to be folded
       * @param {Number} [lineLength=76] Maximum length of a line
       * @param {Boolean} afterSpace If true, leave a space in th end of a line
       * @return {String} String with folded lines
       */
      foldLines(str, lineLength, afterSpace) {
        str = (str || "").toString();
        lineLength = lineLength || 76;
        let pos = 0, len = str.length, result = "", line, match;
        while (pos < len) {
          line = str.substr(pos, lineLength);
          if (line.length < lineLength) {
            result += line;
            break;
          }
          if (match = line.match(/^[^\n\r]*(\r?\n|\r)/)) {
            line = match[0];
            result += line;
            pos += line.length;
            continue;
          } else if ((match = line.match(/(\s+)[^\s]*$/)) && match[0].length - (afterSpace ? (match[1] || "").length : 0) < line.length) {
            line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || "").length : 0)));
          } else if (match = str.substr(pos + line.length).match(/^[^\s]+(\s*)/)) {
            line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || "").length : 0));
          }
          result += line;
          pos += line.length;
          if (pos < len) {
            result += "\r\n";
          }
        }
        return result;
      },
      /**
       * Splits a mime encoded string. Needed for dividing mime words into smaller chunks
       *
       * @param {String} str Mime encoded string to be split up
       * @param {Number} maxlen Maximum length of characters for one part (minimum 12)
       * @return {Array} Split string
       */
      splitMimeEncodedString: (str, maxlen) => {
        let curLine, match, chr, done, lines = [];
        maxlen = Math.max(maxlen || 0, 12);
        while (str.length) {
          curLine = str.substr(0, maxlen);
          if (match = curLine.match(/[=][0-9A-F]?$/i)) {
            curLine = curLine.substr(0, match.index);
          }
          done = false;
          while (!done) {
            done = true;
            if (match = str.substr(curLine.length).match(/^[=]([0-9A-F]{2})/i)) {
              chr = parseInt(match[1], 16);
              if (chr < 194 && chr > 127) {
                curLine = curLine.substr(0, curLine.length - 3);
                done = false;
              }
            }
          }
          if (curLine.length) {
            lines.push(curLine);
          }
          str = str.substr(curLine.length);
        }
        return lines;
      },
      encodeURICharComponent: (chr) => {
        let res = "";
        let ord = chr.charCodeAt(0).toString(16).toUpperCase();
        if (ord.length % 2) {
          ord = "0" + ord;
        }
        if (ord.length > 2) {
          for (let i = 0, len = ord.length / 2; i < len; i++) {
            res += "%" + ord.substr(i, 2);
          }
        } else {
          res += "%" + ord;
        }
        return res;
      },
      safeEncodeURIComponent(str) {
        str = (str || "").toString();
        try {
          str = encodeURIComponent(str);
        } catch (E) {
          return str.replace(/[^\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]+/g, "");
        }
        return str.replace(/[\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]/g, (chr) => this.encodeURICharComponent(chr));
      }
    };
  }
});

// node_modules/nodemailer/lib/addressparser/index.js
var require_addressparser = __commonJS({
  "node_modules/nodemailer/lib/addressparser/index.js"(exports, module2) {
    "use strict";
    function _handleAddress(tokens) {
      let token;
      let isGroup = false;
      let state = "text";
      let address;
      let addresses = [];
      let data = {
        address: [],
        comment: [],
        group: [],
        text: []
      };
      let i;
      let len;
      for (i = 0, len = tokens.length; i < len; i++) {
        token = tokens[i];
        if (token.type === "operator") {
          switch (token.value) {
            case "<":
              state = "address";
              break;
            case "(":
              state = "comment";
              break;
            case ":":
              state = "group";
              isGroup = true;
              break;
            default:
              state = "text";
          }
        } else if (token.value) {
          if (state === "address") {
            token.value = token.value.replace(/^[^<]*<\s*/, "");
          }
          data[state].push(token.value);
        }
      }
      if (!data.text.length && data.comment.length) {
        data.text = data.comment;
        data.comment = [];
      }
      if (isGroup) {
        data.text = data.text.join(" ");
        addresses.push({
          name: data.text || address && address.name,
          group: data.group.length ? addressparser(data.group.join(",")) : []
        });
      } else {
        if (!data.address.length && data.text.length) {
          for (i = data.text.length - 1; i >= 0; i--) {
            if (data.text[i].match(/^[^@\s]+@[^@\s]+$/)) {
              data.address = data.text.splice(i, 1);
              break;
            }
          }
          let _regexHandler = function(address2) {
            if (!data.address.length) {
              data.address = [address2.trim()];
              return " ";
            } else {
              return address2;
            }
          };
          if (!data.address.length) {
            for (i = data.text.length - 1; i >= 0; i--) {
              data.text[i] = data.text[i].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/, _regexHandler).trim();
              if (data.address.length) {
                break;
              }
            }
          }
        }
        if (!data.text.length && data.comment.length) {
          data.text = data.comment;
          data.comment = [];
        }
        if (data.address.length > 1) {
          data.text = data.text.concat(data.address.splice(1));
        }
        data.text = data.text.join(" ");
        data.address = data.address.join(" ");
        if (!data.address && isGroup) {
          return [];
        } else {
          address = {
            address: data.address || data.text || "",
            name: data.text || data.address || ""
          };
          if (address.address === address.name) {
            if ((address.address || "").match(/@/)) {
              address.name = "";
            } else {
              address.address = "";
            }
          }
          addresses.push(address);
        }
      }
      return addresses;
    }
    var Tokenizer2 = class {
      constructor(str) {
        this.str = (str || "").toString();
        this.operatorCurrent = "";
        this.operatorExpecting = "";
        this.node = null;
        this.escaped = false;
        this.list = [];
        this.operators = {
          '"': '"',
          "(": ")",
          "<": ">",
          ",": "",
          ":": ";",
          // Semicolons are not a legal delimiter per the RFC2822 grammar other
          // than for terminating a group, but they are also not valid for any
          // other use in this context.  Given that some mail clients have
          // historically allowed the semicolon as a delimiter equivalent to the
          // comma in their UI, it makes sense to treat them the same as a comma
          // when used outside of a group.
          ";": ""
        };
      }
      /**
       * Tokenizes the original input string
       *
       * @return {Array} An array of operator|text tokens
       */
      tokenize() {
        let chr, list = [];
        for (let i = 0, len = this.str.length; i < len; i++) {
          chr = this.str.charAt(i);
          this.checkChar(chr);
        }
        this.list.forEach((node) => {
          node.value = (node.value || "").toString().trim();
          if (node.value) {
            list.push(node);
          }
        });
        return list;
      }
      /**
       * Checks if a character is an operator or text and acts accordingly
       *
       * @param {String} chr Character from the address field
       */
      checkChar(chr) {
        if (this.escaped) {
        } else if (chr === this.operatorExpecting) {
          this.node = {
            type: "operator",
            value: chr
          };
          this.list.push(this.node);
          this.node = null;
          this.operatorExpecting = "";
          this.escaped = false;
          return;
        } else if (!this.operatorExpecting && chr in this.operators) {
          this.node = {
            type: "operator",
            value: chr
          };
          this.list.push(this.node);
          this.node = null;
          this.operatorExpecting = this.operators[chr];
          this.escaped = false;
          return;
        } else if (['"', "'"].includes(this.operatorExpecting) && chr === "\\") {
          this.escaped = true;
          return;
        }
        if (!this.node) {
          this.node = {
            type: "text",
            value: ""
          };
          this.list.push(this.node);
        }
        if (chr === "\n") {
          chr = " ";
        }
        if (chr.charCodeAt(0) >= 33 || [" ", "	"].includes(chr)) {
          this.node.value += chr;
        }
        this.escaped = false;
      }
    };
    function addressparser(str, options) {
      options = options || {};
      let tokenizer = new Tokenizer2(str);
      let tokens = tokenizer.tokenize();
      let addresses = [];
      let address = [];
      let parsedAddresses = [];
      tokens.forEach((token) => {
        if (token.type === "operator" && (token.value === "," || token.value === ";")) {
          if (address.length) {
            addresses.push(address);
          }
          address = [];
        } else {
          address.push(token);
        }
      });
      if (address.length) {
        addresses.push(address);
      }
      addresses.forEach((address2) => {
        address2 = _handleAddress(address2);
        if (address2.length) {
          parsedAddresses = parsedAddresses.concat(address2);
        }
      });
      if (options.flatten) {
        let addresses2 = [];
        let walkAddressList = (list) => {
          list.forEach((address2) => {
            if (address2.group) {
              return walkAddressList(address2.group);
            } else {
              addresses2.push(address2);
            }
          });
        };
        walkAddressList(parsedAddresses);
        return addresses2;
      }
      return parsedAddresses;
    }
    module2.exports = addressparser;
  }
});

// node_modules/nodemailer/lib/mime-node/last-newline.js
var require_last_newline = __commonJS({
  "node_modules/nodemailer/lib/mime-node/last-newline.js"(exports, module2) {
    "use strict";
    var Transform = require("stream").Transform;
    var LastNewline = class extends Transform {
      constructor() {
        super();
        this.lastByte = false;
      }
      _transform(chunk, encoding, done) {
        if (chunk.length) {
          this.lastByte = chunk[chunk.length - 1];
        }
        this.push(chunk);
        done();
      }
      _flush(done) {
        if (this.lastByte === 10) {
          return done();
        }
        if (this.lastByte === 13) {
          this.push(Buffer.from("\n"));
          return done();
        }
        this.push(Buffer.from("\r\n"));
        return done();
      }
    };
    module2.exports = LastNewline;
  }
});

// node_modules/nodemailer/lib/mime-node/le-windows.js
var require_le_windows = __commonJS({
  "node_modules/nodemailer/lib/mime-node/le-windows.js"(exports, module2) {
    "use strict";
    var stream = require("stream");
    var Transform = stream.Transform;
    var LeWindows = class extends Transform {
      constructor(options) {
        super(options);
        this.options = options || {};
        this.lastByte = false;
      }
      /**
       * Escapes dots
       */
      _transform(chunk, encoding, done) {
        let buf;
        let lastPos = 0;
        for (let i = 0, len = chunk.length; i < len; i++) {
          if (chunk[i] === 10) {
            if (i && chunk[i - 1] !== 13 || !i && this.lastByte !== 13) {
              if (i > lastPos) {
                buf = chunk.slice(lastPos, i);
                this.push(buf);
              }
              this.push(Buffer.from("\r\n"));
              lastPos = i + 1;
            }
          }
        }
        if (lastPos && lastPos < chunk.length) {
          buf = chunk.slice(lastPos);
          this.push(buf);
        } else if (!lastPos) {
          this.push(chunk);
        }
        this.lastByte = chunk[chunk.length - 1];
        done();
      }
    };
    module2.exports = LeWindows;
  }
});

// node_modules/nodemailer/lib/mime-node/le-unix.js
var require_le_unix = __commonJS({
  "node_modules/nodemailer/lib/mime-node/le-unix.js"(exports, module2) {
    "use strict";
    var stream = require("stream");
    var Transform = stream.Transform;
    var LeWindows = class extends Transform {
      constructor(options) {
        super(options);
        this.options = options || {};
      }
      /**
       * Escapes dots
       */
      _transform(chunk, encoding, done) {
        let buf;
        let lastPos = 0;
        for (let i = 0, len = chunk.length; i < len; i++) {
          if (chunk[i] === 13) {
            buf = chunk.slice(lastPos, i);
            lastPos = i + 1;
            this.push(buf);
          }
        }
        if (lastPos && lastPos < chunk.length) {
          buf = chunk.slice(lastPos);
          this.push(buf);
        } else if (!lastPos) {
          this.push(chunk);
        }
        done();
      }
    };
    module2.exports = LeWindows;
  }
});

// node_modules/nodemailer/lib/mime-node/index.js
var require_mime_node = __commonJS({
  "node_modules/nodemailer/lib/mime-node/index.js"(exports, module2) {
    "use strict";
    var crypto3 = require("crypto");
    var fs = require("fs");
    var punycode = require_punycode();
    var PassThrough2 = require("stream").PassThrough;
    var shared = require_shared2();
    var mimeFuncs = require_mime_funcs();
    var qp = require_qp();
    var base64 = require_base64();
    var addressparser = require_addressparser();
    var nmfetch = require_fetch();
    var LastNewline = require_last_newline();
    var LeWindows = require_le_windows();
    var LeUnix = require_le_unix();
    var MimeNode = class _MimeNode {
      constructor(contentType, options) {
        this.nodeCounter = 0;
        options = options || {};
        this.baseBoundary = options.baseBoundary || crypto3.randomBytes(8).toString("hex");
        this.boundaryPrefix = options.boundaryPrefix || "--_NmP";
        this.disableFileAccess = !!options.disableFileAccess;
        this.disableUrlAccess = !!options.disableUrlAccess;
        this.normalizeHeaderKey = options.normalizeHeaderKey;
        this.date = /* @__PURE__ */ new Date();
        this.rootNode = options.rootNode || this;
        this.keepBcc = !!options.keepBcc;
        if (options.filename) {
          this.filename = options.filename;
          if (!contentType) {
            contentType = mimeFuncs.detectMimeType(this.filename.split(".").pop());
          }
        }
        this.textEncoding = (options.textEncoding || "").toString().trim().charAt(0).toUpperCase();
        this.parentNode = options.parentNode;
        this.hostname = options.hostname;
        this.newline = options.newline;
        this.childNodes = [];
        this._nodeId = ++this.rootNode.nodeCounter;
        this._headers = [];
        this._isPlainText = false;
        this._hasLongLines = false;
        this._envelope = false;
        this._raw = false;
        this._transforms = [];
        this._processFuncs = [];
        if (contentType) {
          this.setHeader("Content-Type", contentType);
        }
      }
      /////// PUBLIC METHODS
      /**
       * Creates and appends a child node.Arguments provided are passed to MimeNode constructor
       *
       * @param {String} [contentType] Optional content type
       * @param {Object} [options] Optional options object
       * @return {Object} Created node object
       */
      createChild(contentType, options) {
        if (!options && typeof contentType === "object") {
          options = contentType;
          contentType = void 0;
        }
        let node = new _MimeNode(contentType, options);
        this.appendChild(node);
        return node;
      }
      /**
       * Appends an existing node to the mime tree. Removes the node from an existing
       * tree if needed
       *
       * @param {Object} childNode node to be appended
       * @return {Object} Appended node object
       */
      appendChild(childNode) {
        if (childNode.rootNode !== this.rootNode) {
          childNode.rootNode = this.rootNode;
          childNode._nodeId = ++this.rootNode.nodeCounter;
        }
        childNode.parentNode = this;
        this.childNodes.push(childNode);
        return childNode;
      }
      /**
       * Replaces current node with another node
       *
       * @param {Object} node Replacement node
       * @return {Object} Replacement node
       */
      replace(node) {
        if (node === this) {
          return this;
        }
        this.parentNode.childNodes.forEach((childNode, i) => {
          if (childNode === this) {
            node.rootNode = this.rootNode;
            node.parentNode = this.parentNode;
            node._nodeId = this._nodeId;
            this.rootNode = this;
            this.parentNode = void 0;
            node.parentNode.childNodes[i] = node;
          }
        });
        return node;
      }
      /**
       * Removes current node from the mime tree
       *
       * @return {Object} removed node
       */
      remove() {
        if (!this.parentNode) {
          return this;
        }
        for (let i = this.parentNode.childNodes.length - 1; i >= 0; i--) {
          if (this.parentNode.childNodes[i] === this) {
            this.parentNode.childNodes.splice(i, 1);
            this.parentNode = void 0;
            this.rootNode = this;
            return this;
          }
        }
      }
      /**
       * Sets a header value. If the value for selected key exists, it is overwritten.
       * You can set multiple values as well by using [{key:'', value:''}] or
       * {key: 'value'} as the first argument.
       *
       * @param {String|Array|Object} key Header key or a list of key value pairs
       * @param {String} value Header value
       * @return {Object} current node
       */
      setHeader(key, value) {
        let added = false, headerValue;
        if (!value && key && typeof key === "object") {
          if (key.key && "value" in key) {
            this.setHeader(key.key, key.value);
          } else if (Array.isArray(key)) {
            key.forEach((i) => {
              this.setHeader(i.key, i.value);
            });
          } else {
            Object.keys(key).forEach((i) => {
              this.setHeader(i, key[i]);
            });
          }
          return this;
        }
        key = this._normalizeHeaderKey(key);
        headerValue = {
          key,
          value
        };
        for (let i = 0, len = this._headers.length; i < len; i++) {
          if (this._headers[i].key === key) {
            if (!added) {
              this._headers[i] = headerValue;
              added = true;
            } else {
              this._headers.splice(i, 1);
              i--;
              len--;
            }
          }
        }
        if (!added) {
          this._headers.push(headerValue);
        }
        return this;
      }
      /**
       * Adds a header value. If the value for selected key exists, the value is appended
       * as a new field and old one is not touched.
       * You can set multiple values as well by using [{key:'', value:''}] or
       * {key: 'value'} as the first argument.
       *
       * @param {String|Array|Object} key Header key or a list of key value pairs
       * @param {String} value Header value
       * @return {Object} current node
       */
      addHeader(key, value) {
        if (!value && key && typeof key === "object") {
          if (key.key && key.value) {
            this.addHeader(key.key, key.value);
          } else if (Array.isArray(key)) {
            key.forEach((i) => {
              this.addHeader(i.key, i.value);
            });
          } else {
            Object.keys(key).forEach((i) => {
              this.addHeader(i, key[i]);
            });
          }
          return this;
        } else if (Array.isArray(value)) {
          value.forEach((val) => {
            this.addHeader(key, val);
          });
          return this;
        }
        this._headers.push({
          key: this._normalizeHeaderKey(key),
          value
        });
        return this;
      }
      /**
       * Retrieves the first mathcing value of a selected key
       *
       * @param {String} key Key to search for
       * @retun {String} Value for the key
       */
      getHeader(key) {
        key = this._normalizeHeaderKey(key);
        for (let i = 0, len = this._headers.length; i < len; i++) {
          if (this._headers[i].key === key) {
            return this._headers[i].value;
          }
        }
      }
      /**
       * Sets body content for current node. If the value is a string, charset is added automatically
       * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify
       * the charset yourself
       *
       * @param (String|Buffer) content Body content
       * @return {Object} current node
       */
      setContent(content) {
        this.content = content;
        if (typeof this.content.pipe === "function") {
          this._contentErrorHandler = (err) => {
            this.content.removeListener("error", this._contentErrorHandler);
            this.content = err;
          };
          this.content.once("error", this._contentErrorHandler);
        } else if (typeof this.content === "string") {
          this._isPlainText = mimeFuncs.isPlainText(this.content);
          if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {
            this._hasLongLines = true;
          }
        }
        return this;
      }
      build(callback2) {
        let promise;
        if (!callback2) {
          promise = new Promise((resolve2, reject) => {
            callback2 = shared.callbackPromise(resolve2, reject);
          });
        }
        let stream = this.createReadStream();
        let buf = [];
        let buflen = 0;
        let returned = false;
        stream.on("readable", () => {
          let chunk;
          while ((chunk = stream.read()) !== null) {
            buf.push(chunk);
            buflen += chunk.length;
          }
        });
        stream.once("error", (err) => {
          if (returned) {
            return;
          }
          returned = true;
          return callback2(err);
        });
        stream.once("end", (chunk) => {
          if (returned) {
            return;
          }
          returned = true;
          if (chunk && chunk.length) {
            buf.push(chunk);
            buflen += chunk.length;
          }
          return callback2(null, Buffer.concat(buf, buflen));
        });
        return promise;
      }
      getTransferEncoding() {
        let transferEncoding = false;
        let contentType = (this.getHeader("Content-Type") || "").toString().toLowerCase().trim();
        if (this.content) {
          transferEncoding = (this.getHeader("Content-Transfer-Encoding") || "").toString().toLowerCase().trim();
          if (!transferEncoding || !["base64", "quoted-printable"].includes(transferEncoding)) {
            if (/^text\//i.test(contentType)) {
              if (this._isPlainText && !this._hasLongLines) {
                transferEncoding = "7bit";
              } else if (typeof this.content === "string" || this.content instanceof Buffer) {
                transferEncoding = this._getTextEncoding(this.content) === "Q" ? "quoted-printable" : "base64";
              } else {
                transferEncoding = this.textEncoding === "B" ? "base64" : "quoted-printable";
              }
            } else if (!/^(multipart|message)\//i.test(contentType)) {
              transferEncoding = transferEncoding || "base64";
            }
          }
        }
        return transferEncoding;
      }
      /**
       * Builds the header block for the mime node. Append \r\n\r\n before writing the content
       *
       * @returns {String} Headers
       */
      buildHeaders() {
        let transferEncoding = this.getTransferEncoding();
        let headers = [];
        if (transferEncoding) {
          this.setHeader("Content-Transfer-Encoding", transferEncoding);
        }
        if (this.filename && !this.getHeader("Content-Disposition")) {
          this.setHeader("Content-Disposition", "attachment");
        }
        if (this.rootNode === this) {
          if (!this.getHeader("Date")) {
            this.setHeader("Date", this.date.toUTCString().replace(/GMT/, "+0000"));
          }
          this.messageId();
          if (!this.getHeader("MIME-Version")) {
            this.setHeader("MIME-Version", "1.0");
          }
        }
        this._headers.forEach((header) => {
          let key = header.key;
          let value = header.value;
          let structured;
          let param;
          let options = {};
          let formattedHeaders = ["From", "Sender", "To", "Cc", "Bcc", "Reply-To", "Date", "References"];
          if (value && typeof value === "object" && !formattedHeaders.includes(key)) {
            Object.keys(value).forEach((key2) => {
              if (key2 !== "value") {
                options[key2] = value[key2];
              }
            });
            value = (value.value || "").toString();
            if (!value.trim()) {
              return;
            }
          }
          if (options.prepared) {
            if (options.foldLines) {
              headers.push(mimeFuncs.foldLines(key + ": " + value));
            } else {
              headers.push(key + ": " + value);
            }
            return;
          }
          switch (header.key) {
            case "Content-Disposition":
              structured = mimeFuncs.parseHeaderValue(value);
              if (this.filename) {
                structured.params.filename = this.filename;
              }
              value = mimeFuncs.buildHeaderValue(structured);
              break;
            case "Content-Type":
              structured = mimeFuncs.parseHeaderValue(value);
              this._handleContentType(structured);
              if (structured.value.match(/^text\/plain\b/) && typeof this.content === "string" && /[\u0080-\uFFFF]/.test(this.content)) {
                structured.params.charset = "utf-8";
              }
              value = mimeFuncs.buildHeaderValue(structured);
              if (this.filename) {
                param = this._encodeWords(this.filename);
                if (param !== this.filename || /[\s'"\\;:/=(),<>@[\]?]|^-/.test(param)) {
                  param = '"' + param + '"';
                }
                value += "; name=" + param;
              }
              break;
            case "Bcc":
              if (!this.keepBcc) {
                return;
              }
              break;
          }
          value = this._encodeHeaderValue(key, value);
          if (!(value || "").toString().trim()) {
            return;
          }
          if (typeof this.normalizeHeaderKey === "function") {
            let normalized = this.normalizeHeaderKey(key, value);
            if (normalized && typeof normalized === "string" && normalized.length) {
              key = normalized;
            }
          }
          headers.push(mimeFuncs.foldLines(key + ": " + value, 76));
        });
        return headers.join("\r\n");
      }
      /**
       * Streams the rfc2822 message from the current node. If this is a root node,
       * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)
       *
       * @return {String} Compiled message
       */
      createReadStream(options) {
        options = options || {};
        let stream = new PassThrough2(options);
        let outputStream = stream;
        let transform;
        this.stream(stream, options, (err) => {
          if (err) {
            outputStream.emit("error", err);
            return;
          }
          stream.end();
        });
        for (let i = 0, len = this._transforms.length; i < len; i++) {
          transform = typeof this._transforms[i] === "function" ? this._transforms[i]() : this._transforms[i];
          outputStream.once("error", (err) => {
            transform.emit("error", err);
          });
          outputStream = outputStream.pipe(transform);
        }
        transform = new LastNewline();
        outputStream.once("error", (err) => {
          transform.emit("error", err);
        });
        outputStream = outputStream.pipe(transform);
        for (let i = 0, len = this._processFuncs.length; i < len; i++) {
          transform = this._processFuncs[i];
          outputStream = transform(outputStream);
        }
        if (this.newline) {
          const winbreak = ["win", "windows", "dos", "\r\n"].includes(this.newline.toString().toLowerCase());
          const newlineTransform = winbreak ? new LeWindows() : new LeUnix();
          const stream2 = outputStream.pipe(newlineTransform);
          outputStream.on("error", (err) => stream2.emit("error", err));
          return stream2;
        }
        return outputStream;
      }
      /**
       * Appends a transform stream object to the transforms list. Final output
       * is passed through this stream before exposing
       *
       * @param {Object} transform Read-Write stream
       */
      transform(transform) {
        this._transforms.push(transform);
      }
      /**
       * Appends a post process function. The functon is run after transforms and
       * uses the following syntax
       *
       *   processFunc(input) -> outputStream
       *
       * @param {Object} processFunc Read-Write stream
       */
      processFunc(processFunc) {
        this._processFuncs.push(processFunc);
      }
      stream(outputStream, options, done) {
        let transferEncoding = this.getTransferEncoding();
        let contentStream;
        let localStream;
        let returned = false;
        let callback2 = (err) => {
          if (returned) {
            return;
          }
          returned = true;
          done(err);
        };
        let finalize = () => {
          let childId = 0;
          let processChildNode = () => {
            if (childId >= this.childNodes.length) {
              outputStream.write("\r\n--" + this.boundary + "--\r\n");
              return callback2();
            }
            let child = this.childNodes[childId++];
            outputStream.write((childId > 1 ? "\r\n" : "") + "--" + this.boundary + "\r\n");
            child.stream(outputStream, options, (err) => {
              if (err) {
                return callback2(err);
              }
              setImmediate(processChildNode);
            });
          };
          if (this.multipart) {
            setImmediate(processChildNode);
          } else {
            return callback2();
          }
        };
        let sendContent = () => {
          if (this.content) {
            if (Object.prototype.toString.call(this.content) === "[object Error]") {
              return callback2(this.content);
            }
            if (typeof this.content.pipe === "function") {
              this.content.removeListener("error", this._contentErrorHandler);
              this._contentErrorHandler = (err) => callback2(err);
              this.content.once("error", this._contentErrorHandler);
            }
            let createStream = () => {
              if (["quoted-printable", "base64"].includes(transferEncoding)) {
                contentStream = new (transferEncoding === "base64" ? base64 : qp).Encoder(options);
                contentStream.pipe(outputStream, {
                  end: false
                });
                contentStream.once("end", finalize);
                contentStream.once("error", (err) => callback2(err));
                localStream = this._getStream(this.content);
                localStream.pipe(contentStream);
              } else {
                localStream = this._getStream(this.content);
                localStream.pipe(outputStream, {
                  end: false
                });
                localStream.once("end", finalize);
              }
              localStream.once("error", (err) => callback2(err));
            };
            if (this.content._resolve) {
              let chunks = [];
              let chunklen = 0;
              let returned2 = false;
              let sourceStream = this._getStream(this.content);
              sourceStream.on("error", (err) => {
                if (returned2) {
                  return;
                }
                returned2 = true;
                callback2(err);
              });
              sourceStream.on("readable", () => {
                let chunk;
                while ((chunk = sourceStream.read()) !== null) {
                  chunks.push(chunk);
                  chunklen += chunk.length;
                }
              });
              sourceStream.on("end", () => {
                if (returned2) {
                  return;
                }
                returned2 = true;
                this.content._resolve = false;
                this.content._resolvedValue = Buffer.concat(chunks, chunklen);
                setImmediate(createStream);
              });
            } else {
              setImmediate(createStream);
            }
            return;
          } else {
            return setImmediate(finalize);
          }
        };
        if (this._raw) {
          setImmediate(() => {
            if (Object.prototype.toString.call(this._raw) === "[object Error]") {
              return callback2(this._raw);
            }
            if (typeof this._raw.pipe === "function") {
              this._raw.removeListener("error", this._contentErrorHandler);
            }
            let raw = this._getStream(this._raw);
            raw.pipe(outputStream, {
              end: false
            });
            raw.on("error", (err) => outputStream.emit("error", err));
            raw.on("end", finalize);
          });
        } else {
          outputStream.write(this.buildHeaders() + "\r\n\r\n");
          setImmediate(sendContent);
        }
      }
      /**
       * Sets envelope to be used instead of the generated one
       *
       * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}
       */
      setEnvelope(envelope) {
        let list;
        this._envelope = {
          from: false,
          to: []
        };
        if (envelope.from) {
          list = [];
          this._convertAddresses(this._parseAddresses(envelope.from), list);
          list = list.filter((address) => address && address.address);
          if (list.length && list[0]) {
            this._envelope.from = list[0].address;
          }
        }
        ["to", "cc", "bcc"].forEach((key) => {
          if (envelope[key]) {
            this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);
          }
        });
        this._envelope.to = this._envelope.to.map((to) => to.address).filter((address) => address);
        let standardFields = ["to", "cc", "bcc", "from"];
        Object.keys(envelope).forEach((key) => {
          if (!standardFields.includes(key)) {
            this._envelope[key] = envelope[key];
          }
        });
        return this;
      }
      /**
       * Generates and returns an object with parsed address fields
       *
       * @return {Object} Address object
       */
      getAddresses() {
        let addresses = {};
        this._headers.forEach((header) => {
          let key = header.key.toLowerCase();
          if (["from", "sender", "reply-to", "to", "cc", "bcc"].includes(key)) {
            if (!Array.isArray(addresses[key])) {
              addresses[key] = [];
            }
            this._convertAddresses(this._parseAddresses(header.value), addresses[key]);
          }
        });
        return addresses;
      }
      /**
       * Generates and returns SMTP envelope with the sender address and a list of recipients addresses
       *
       * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}
       */
      getEnvelope() {
        if (this._envelope) {
          return this._envelope;
        }
        let envelope = {
          from: false,
          to: []
        };
        this._headers.forEach((header) => {
          let list = [];
          if (header.key === "From" || !envelope.from && ["Reply-To", "Sender"].includes(header.key)) {
            this._convertAddresses(this._parseAddresses(header.value), list);
            if (list.length && list[0]) {
              envelope.from = list[0].address;
            }
          } else if (["To", "Cc", "Bcc"].includes(header.key)) {
            this._convertAddresses(this._parseAddresses(header.value), envelope.to);
          }
        });
        envelope.to = envelope.to.map((to) => to.address);
        return envelope;
      }
      /**
       * Returns Message-Id value. If it does not exist, then creates one
       *
       * @return {String} Message-Id value
       */
      messageId() {
        let messageId = this.getHeader("Message-ID");
        if (!messageId) {
          messageId = this._generateMessageId();
          this.setHeader("Message-ID", messageId);
        }
        return messageId;
      }
      /**
       * Sets pregenerated content that will be used as the output of this node
       *
       * @param {String|Buffer|Stream} Raw MIME contents
       */
      setRaw(raw) {
        this._raw = raw;
        if (this._raw && typeof this._raw.pipe === "function") {
          this._contentErrorHandler = (err) => {
            this._raw.removeListener("error", this._contentErrorHandler);
            this._raw = err;
          };
          this._raw.once("error", this._contentErrorHandler);
        }
        return this;
      }
      /////// PRIVATE METHODS
      /**
       * Detects and returns handle to a stream related with the content.
       *
       * @param {Mixed} content Node content
       * @returns {Object} Stream object
       */
      _getStream(content) {
        let contentStream;
        if (content._resolvedValue) {
          contentStream = new PassThrough2();
          setImmediate(() => {
            try {
              contentStream.end(content._resolvedValue);
            } catch (err) {
              contentStream.emit("error", err);
            }
          });
          return contentStream;
        } else if (typeof content.pipe === "function") {
          return content;
        } else if (content && typeof content.path === "string" && !content.href) {
          if (this.disableFileAccess) {
            contentStream = new PassThrough2();
            setImmediate(() => contentStream.emit("error", new Error("File access rejected for " + content.path)));
            return contentStream;
          }
          return fs.createReadStream(content.path);
        } else if (content && typeof content.href === "string") {
          if (this.disableUrlAccess) {
            contentStream = new PassThrough2();
            setImmediate(() => contentStream.emit("error", new Error("Url access rejected for " + content.href)));
            return contentStream;
          }
          return nmfetch(content.href, { headers: content.httpHeaders });
        } else {
          contentStream = new PassThrough2();
          setImmediate(() => {
            try {
              contentStream.end(content || "");
            } catch (err) {
              contentStream.emit("error", err);
            }
          });
          return contentStream;
        }
      }
      /**
       * Parses addresses. Takes in a single address or an array or an
       * array of address arrays (eg. To: [[first group], [second group],...])
       *
       * @param {Mixed} addresses Addresses to be parsed
       * @return {Array} An array of address objects
       */
      _parseAddresses(addresses) {
        return [].concat.apply(
          [],
          [].concat(addresses).map((address) => {
            if (address && address.address) {
              address.address = this._normalizeAddress(address.address);
              address.name = address.name || "";
              return [address];
            }
            return addressparser(address);
          })
        );
      }
      /**
       * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-
       *
       * @param {String} key Key to be normalized
       * @return {String} key in Camel-Case form
       */
      _normalizeHeaderKey(key) {
        key = (key || "").toString().replace(/\r?\n|\r/g, " ").trim().toLowerCase().replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, (c) => c.toUpperCase()).replace(/^Content-Features$/i, "Content-features");
        return key;
      }
      /**
       * Checks if the content type is multipart and defines boundary if needed.
       * Doesn't return anything, modifies object argument instead.
       *
       * @param {Object} structured Parsed header value for 'Content-Type' key
       */
      _handleContentType(structured) {
        this.contentType = structured.value.trim().toLowerCase();
        this.multipart = /^multipart\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf("/") + 1) : false;
        if (this.multipart) {
          this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();
        } else {
          this.boundary = false;
        }
      }
      /**
       * Generates a multipart boundary value
       *
       * @return {String} boundary value
       */
      _generateBoundary() {
        return this.rootNode.boundaryPrefix + "-" + this.rootNode.baseBoundary + "-Part_" + this._nodeId;
      }
      /**
       * Encodes a header value for use in the generated rfc2822 email.
       *
       * @param {String} key Header key
       * @param {String} value Header value
       */
      _encodeHeaderValue(key, value) {
        key = this._normalizeHeaderKey(key);
        switch (key) {
          case "From":
          case "Sender":
          case "To":
          case "Cc":
          case "Bcc":
          case "Reply-To":
            return this._convertAddresses(this._parseAddresses(value));
          case "Message-ID":
          case "In-Reply-To":
          case "Content-Id":
            value = (value || "").toString().replace(/\r?\n|\r/g, " ");
            if (value.charAt(0) !== "<") {
              value = "<" + value;
            }
            if (value.charAt(value.length - 1) !== ">") {
              value = value + ">";
            }
            return value;
          case "References":
            value = [].concat.apply(
              [],
              [].concat(value || "").map((elm) => {
                elm = (elm || "").toString().replace(/\r?\n|\r/g, " ").trim();
                return elm.replace(/<[^>]*>/g, (str) => str.replace(/\s/g, "")).split(/\s+/);
              })
            ).map((elm) => {
              if (elm.charAt(0) !== "<") {
                elm = "<" + elm;
              }
              if (elm.charAt(elm.length - 1) !== ">") {
                elm = elm + ">";
              }
              return elm;
            });
            return value.join(" ").trim();
          case "Date":
            if (Object.prototype.toString.call(value) === "[object Date]") {
              return value.toUTCString().replace(/GMT/, "+0000");
            }
            value = (value || "").toString().replace(/\r?\n|\r/g, " ");
            return this._encodeWords(value);
          case "Content-Type":
          case "Content-Disposition":
            return (value || "").toString().replace(/\r?\n|\r/g, " ");
          default:
            value = (value || "").toString().replace(/\r?\n|\r/g, " ");
            return this._encodeWords(value);
        }
      }
      /**
       * Rebuilds address object using punycode and other adjustments
       *
       * @param {Array} addresses An array of address objects
       * @param {Array} [uniqueList] An array to be populated with addresses
       * @return {String} address string
       */
      _convertAddresses(addresses, uniqueList) {
        let values = [];
        uniqueList = uniqueList || [];
        [].concat(addresses || []).forEach((address) => {
          if (address.address) {
            address.address = this._normalizeAddress(address.address);
            if (!address.name) {
              values.push(address.address.indexOf(" ") >= 0 ? `<${address.address}>` : `${address.address}`);
            } else if (address.name) {
              values.push(`${this._encodeAddressName(address.name)} <${address.address}>`);
            }
            if (address.address) {
              if (!uniqueList.filter((a) => a.address === address.address).length) {
                uniqueList.push(address);
              }
            }
          } else if (address.group) {
            let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : "").trim();
            values.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);
          }
        });
        return values.join(", ");
      }
      /**
       * Normalizes an email address
       *
       * @param {Array} address An array of address objects
       * @return {String} address string
       */
      _normalizeAddress(address) {
        address = (address || "").toString().replace(/[\x00-\x1F<>]+/g, " ").trim();
        let lastAt = address.lastIndexOf("@");
        if (lastAt < 0) {
          return address;
        }
        let user = address.substr(0, lastAt);
        let domain = address.substr(lastAt + 1);
        let encodedDomain;
        try {
          encodedDomain = punycode.toASCII(domain.toLowerCase());
        } catch (err) {
        }
        if (user.indexOf(" ") >= 0) {
          if (user.charAt(0) !== '"') {
            user = '"' + user;
          }
          if (user.substr(-1) !== '"') {
            user = user + '"';
          }
        }
        return `${user}@${encodedDomain}`;
      }
      /**
       * If needed, mime encodes the name part
       *
       * @param {String} name Name part of an address
       * @returns {String} Mime word encoded string if needed
       */
      _encodeAddressName(name) {
        if (!/^[\w ']*$/.test(name)) {
          if (/^[\x20-\x7e]*$/.test(name)) {
            return '"' + name.replace(/([\\"])/g, "\\$1") + '"';
          } else {
            return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);
          }
        }
        return name;
      }
      /**
       * If needed, mime encodes the name part
       *
       * @param {String} name Name part of an address
       * @returns {String} Mime word encoded string if needed
       */
      _encodeWords(value) {
        return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);
      }
      /**
       * Detects best mime encoding for a text value
       *
       * @param {String} value Value to check for
       * @return {String} either 'Q' or 'B'
       */
      _getTextEncoding(value) {
        value = (value || "").toString();
        let encoding = this.textEncoding;
        let latinLen;
        let nonLatinLen;
        if (!encoding) {
          nonLatinLen = (value.match(/[\x00-\x08\x0B\x0C\x0E-\x1F\u0080-\uFFFF]/g) || []).length;
          latinLen = (value.match(/[a-z]/gi) || []).length;
          encoding = nonLatinLen < latinLen ? "Q" : "B";
        }
        return encoding;
      }
      /**
       * Generates a message id
       *
       * @return {String} Random Message-ID value
       */
      _generateMessageId() {
        return "<" + [2, 2, 2, 6].reduce(
          // crux to generate UUID-like random strings
          (prev, len) => prev + "-" + crypto3.randomBytes(len).toString("hex"),
          crypto3.randomBytes(4).toString("hex")
        ) + "@" + // try to use the domain of the FROM address or fallback to server hostname
        (this.getEnvelope().from || this.hostname || "localhost").split("@").pop() + ">";
      }
    };
    module2.exports = MimeNode;
  }
});

// node_modules/nodemailer/lib/mail-composer/index.js
var require_mail_composer = __commonJS({
  "node_modules/nodemailer/lib/mail-composer/index.js"(exports, module2) {
    "use strict";
    var MimeNode = require_mime_node();
    var mimeFuncs = require_mime_funcs();
    var parseDataURI = require_shared2().parseDataURI;
    var MailComposer = class {
      constructor(mail) {
        this.mail = mail || {};
        this.message = false;
      }
      /**
       * Builds MimeNode instance
       */
      compile() {
        this._alternatives = this.getAlternatives();
        this._htmlNode = this._alternatives.filter((alternative) => /^text\/html\b/i.test(alternative.contentType)).pop();
        this._attachments = this.getAttachments(!!this._htmlNode);
        this._useRelated = !!(this._htmlNode && this._attachments.related.length);
        this._useAlternative = this._alternatives.length > 1;
        this._useMixed = this._attachments.attached.length > 1 || this._alternatives.length && this._attachments.attached.length === 1;
        if (this.mail.raw) {
          this.message = new MimeNode("message/rfc822", { newline: this.mail.newline }).setRaw(this.mail.raw);
        } else if (this._useMixed) {
          this.message = this._createMixed();
        } else if (this._useAlternative) {
          this.message = this._createAlternative();
        } else if (this._useRelated) {
          this.message = this._createRelated();
        } else {
          this.message = this._createContentNode(
            false,
            [].concat(this._alternatives || []).concat(this._attachments.attached || []).shift() || {
              contentType: "text/plain",
              content: ""
            }
          );
        }
        if (this.mail.headers) {
          this.message.addHeader(this.mail.headers);
        }
        ["from", "sender", "to", "cc", "bcc", "reply-to", "in-reply-to", "references", "subject", "message-id", "date"].forEach((header) => {
          let key = header.replace(/-(\w)/g, (o, c) => c.toUpperCase());
          if (this.mail[key]) {
            this.message.setHeader(header, this.mail[key]);
          }
        });
        if (this.mail.envelope) {
          this.message.setEnvelope(this.mail.envelope);
        }
        this.message.messageId();
        return this.message;
      }
      /**
       * List all attachments. Resulting attachment objects can be used as input for MimeNode nodes
       *
       * @param {Boolean} findRelated If true separate related attachments from attached ones
       * @returns {Object} An object of arrays (`related` and `attached`)
       */
      getAttachments(findRelated) {
        let icalEvent, eventObject;
        let attachments = [].concat(this.mail.attachments || []).map((attachment, i) => {
          let data;
          let isMessageNode = /^message\//i.test(attachment.contentType);
          if (/^data:/i.test(attachment.path || attachment.href)) {
            attachment = this._processDataUrl(attachment);
          }
          let contentType = attachment.contentType || mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || "bin");
          let isImage = /^image\//i.test(contentType);
          let contentDisposition = attachment.contentDisposition || (isMessageNode || isImage && attachment.cid ? "inline" : "attachment");
          data = {
            contentType,
            contentDisposition,
            contentTransferEncoding: "contentTransferEncoding" in attachment ? attachment.contentTransferEncoding : "base64"
          };
          if (attachment.filename) {
            data.filename = attachment.filename;
          } else if (!isMessageNode && attachment.filename !== false) {
            data.filename = (attachment.path || attachment.href || "").split("/").pop().split("?").shift() || "attachment-" + (i + 1);
            if (data.filename.indexOf(".") < 0) {
              data.filename += "." + mimeFuncs.detectExtension(data.contentType);
            }
          }
          if (/^https?:\/\//i.test(attachment.path)) {
            attachment.href = attachment.path;
            attachment.path = void 0;
          }
          if (attachment.cid) {
            data.cid = attachment.cid;
          }
          if (attachment.raw) {
            data.raw = attachment.raw;
          } else if (attachment.path) {
            data.content = {
              path: attachment.path
            };
          } else if (attachment.href) {
            data.content = {
              href: attachment.href,
              httpHeaders: attachment.httpHeaders
            };
          } else {
            data.content = attachment.content || "";
          }
          if (attachment.encoding) {
            data.encoding = attachment.encoding;
          }
          if (attachment.headers) {
            data.headers = attachment.headers;
          }
          return data;
        });
        if (this.mail.icalEvent) {
          if (typeof this.mail.icalEvent === "object" && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {
            icalEvent = this.mail.icalEvent;
          } else {
            icalEvent = {
              content: this.mail.icalEvent
            };
          }
          eventObject = {};
          Object.keys(icalEvent).forEach((key) => {
            eventObject[key] = icalEvent[key];
          });
          eventObject.contentType = "application/ics";
          if (!eventObject.headers) {
            eventObject.headers = {};
          }
          eventObject.filename = eventObject.filename || "invite.ics";
          eventObject.headers["Content-Disposition"] = "attachment";
          eventObject.headers["Content-Transfer-Encoding"] = "base64";
        }
        if (!findRelated) {
          return {
            attached: attachments.concat(eventObject || []),
            related: []
          };
        } else {
          return {
            attached: attachments.filter((attachment) => !attachment.cid).concat(eventObject || []),
            related: attachments.filter((attachment) => !!attachment.cid)
          };
        }
      }
      /**
       * List alternatives. Resulting objects can be used as input for MimeNode nodes
       *
       * @returns {Array} An array of alternative elements. Includes the `text` and `html` values as well
       */
      getAlternatives() {
        let alternatives = [], text, html, watchHtml, amp, icalEvent, eventObject;
        if (this.mail.text) {
          if (typeof this.mail.text === "object" && (this.mail.text.content || this.mail.text.path || this.mail.text.href || this.mail.text.raw)) {
            text = this.mail.text;
          } else {
            text = {
              content: this.mail.text
            };
          }
          text.contentType = "text/plain; charset=utf-8";
        }
        if (this.mail.watchHtml) {
          if (typeof this.mail.watchHtml === "object" && (this.mail.watchHtml.content || this.mail.watchHtml.path || this.mail.watchHtml.href || this.mail.watchHtml.raw)) {
            watchHtml = this.mail.watchHtml;
          } else {
            watchHtml = {
              content: this.mail.watchHtml
            };
          }
          watchHtml.contentType = "text/watch-html; charset=utf-8";
        }
        if (this.mail.amp) {
          if (typeof this.mail.amp === "object" && (this.mail.amp.content || this.mail.amp.path || this.mail.amp.href || this.mail.amp.raw)) {
            amp = this.mail.amp;
          } else {
            amp = {
              content: this.mail.amp
            };
          }
          amp.contentType = "text/x-amp-html; charset=utf-8";
        }
        if (this.mail.icalEvent) {
          if (typeof this.mail.icalEvent === "object" && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {
            icalEvent = this.mail.icalEvent;
          } else {
            icalEvent = {
              content: this.mail.icalEvent
            };
          }
          eventObject = {};
          Object.keys(icalEvent).forEach((key) => {
            eventObject[key] = icalEvent[key];
          });
          if (eventObject.content && typeof eventObject.content === "object") {
            eventObject.content._resolve = true;
          }
          eventObject.filename = false;
          eventObject.contentType = "text/calendar; charset=utf-8; method=" + (eventObject.method || "PUBLISH").toString().trim().toUpperCase();
          if (!eventObject.headers) {
            eventObject.headers = {};
          }
        }
        if (this.mail.html) {
          if (typeof this.mail.html === "object" && (this.mail.html.content || this.mail.html.path || this.mail.html.href || this.mail.html.raw)) {
            html = this.mail.html;
          } else {
            html = {
              content: this.mail.html
            };
          }
          html.contentType = "text/html; charset=utf-8";
        }
        [].concat(text || []).concat(watchHtml || []).concat(amp || []).concat(html || []).concat(eventObject || []).concat(this.mail.alternatives || []).forEach((alternative) => {
          let data;
          if (/^data:/i.test(alternative.path || alternative.href)) {
            alternative = this._processDataUrl(alternative);
          }
          data = {
            contentType: alternative.contentType || mimeFuncs.detectMimeType(alternative.filename || alternative.path || alternative.href || "txt"),
            contentTransferEncoding: alternative.contentTransferEncoding
          };
          if (alternative.filename) {
            data.filename = alternative.filename;
          }
          if (/^https?:\/\//i.test(alternative.path)) {
            alternative.href = alternative.path;
            alternative.path = void 0;
          }
          if (alternative.raw) {
            data.raw = alternative.raw;
          } else if (alternative.path) {
            data.content = {
              path: alternative.path
            };
          } else if (alternative.href) {
            data.content = {
              href: alternative.href
            };
          } else {
            data.content = alternative.content || "";
          }
          if (alternative.encoding) {
            data.encoding = alternative.encoding;
          }
          if (alternative.headers) {
            data.headers = alternative.headers;
          }
          alternatives.push(data);
        });
        return alternatives;
      }
      /**
       * Builds multipart/mixed node. It should always contain different type of elements on the same level
       * eg. text + attachments
       *
       * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
       * @returns {Object} MimeNode node element
       */
      _createMixed(parentNode) {
        let node;
        if (!parentNode) {
          node = new MimeNode("multipart/mixed", {
            baseBoundary: this.mail.baseBoundary,
            textEncoding: this.mail.textEncoding,
            boundaryPrefix: this.mail.boundaryPrefix,
            disableUrlAccess: this.mail.disableUrlAccess,
            disableFileAccess: this.mail.disableFileAccess,
            normalizeHeaderKey: this.mail.normalizeHeaderKey,
            newline: this.mail.newline
          });
        } else {
          node = parentNode.createChild("multipart/mixed", {
            disableUrlAccess: this.mail.disableUrlAccess,
            disableFileAccess: this.mail.disableFileAccess,
            normalizeHeaderKey: this.mail.normalizeHeaderKey,
            newline: this.mail.newline
          });
        }
        if (this._useAlternative) {
          this._createAlternative(node);
        } else if (this._useRelated) {
          this._createRelated(node);
        }
        [].concat(!this._useAlternative && this._alternatives || []).concat(this._attachments.attached || []).forEach((element) => {
          if (!this._useRelated || element !== this._htmlNode) {
            this._createContentNode(node, element);
          }
        });
        return node;
      }
      /**
       * Builds multipart/alternative node. It should always contain same type of elements on the same level
       * eg. text + html view of the same data
       *
       * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
       * @returns {Object} MimeNode node element
       */
      _createAlternative(parentNode) {
        let node;
        if (!parentNode) {
          node = new MimeNode("multipart/alternative", {
            baseBoundary: this.mail.baseBoundary,
            textEncoding: this.mail.textEncoding,
            boundaryPrefix: this.mail.boundaryPrefix,
            disableUrlAccess: this.mail.disableUrlAccess,
            disableFileAccess: this.mail.disableFileAccess,
            normalizeHeaderKey: this.mail.normalizeHeaderKey,
            newline: this.mail.newline
          });
        } else {
          node = parentNode.createChild("multipart/alternative", {
            disableUrlAccess: this.mail.disableUrlAccess,
            disableFileAccess: this.mail.disableFileAccess,
            normalizeHeaderKey: this.mail.normalizeHeaderKey,
            newline: this.mail.newline
          });
        }
        this._alternatives.forEach((alternative) => {
          if (this._useRelated && this._htmlNode === alternative) {
            this._createRelated(node);
          } else {
            this._createContentNode(node, alternative);
          }
        });
        return node;
      }
      /**
       * Builds multipart/related node. It should always contain html node with related attachments
       *
       * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
       * @returns {Object} MimeNode node element
       */
      _createRelated(parentNode) {
        let node;
        if (!parentNode) {
          node = new MimeNode('multipart/related; type="text/html"', {
            baseBoundary: this.mail.baseBoundary,
            textEncoding: this.mail.textEncoding,
            boundaryPrefix: this.mail.boundaryPrefix,
            disableUrlAccess: this.mail.disableUrlAccess,
            disableFileAccess: this.mail.disableFileAccess,
            normalizeHeaderKey: this.mail.normalizeHeaderKey,
            newline: this.mail.newline
          });
        } else {
          node = parentNode.createChild('multipart/related; type="text/html"', {
            disableUrlAccess: this.mail.disableUrlAccess,
            disableFileAccess: this.mail.disableFileAccess,
            normalizeHeaderKey: this.mail.normalizeHeaderKey,
            newline: this.mail.newline
          });
        }
        this._createContentNode(node, this._htmlNode);
        this._attachments.related.forEach((alternative) => this._createContentNode(node, alternative));
        return node;
      }
      /**
       * Creates a regular node with contents
       *
       * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
       * @param {Object} element Node data
       * @returns {Object} MimeNode node element
       */
      _createContentNode(parentNode, element) {
        element = element || {};
        element.content = element.content || "";
        let node;
        let encoding = (element.encoding || "utf8").toString().toLowerCase().replace(/[-_\s]/g, "");
        if (!parentNode) {
          node = new MimeNode(element.contentType, {
            filename: element.filename,
            baseBoundary: this.mail.baseBoundary,
            textEncoding: this.mail.textEncoding,
            boundaryPrefix: this.mail.boundaryPrefix,
            disableUrlAccess: this.mail.disableUrlAccess,
            disableFileAccess: this.mail.disableFileAccess,
            normalizeHeaderKey: this.mail.normalizeHeaderKey,
            newline: this.mail.newline
          });
        } else {
          node = parentNode.createChild(element.contentType, {
            filename: element.filename,
            textEncoding: this.mail.textEncoding,
            disableUrlAccess: this.mail.disableUrlAccess,
            disableFileAccess: this.mail.disableFileAccess,
            normalizeHeaderKey: this.mail.normalizeHeaderKey,
            newline: this.mail.newline
          });
        }
        if (element.headers) {
          node.addHeader(element.headers);
        }
        if (element.cid) {
          node.setHeader("Content-Id", "<" + element.cid.replace(/[<>]/g, "") + ">");
        }
        if (element.contentTransferEncoding) {
          node.setHeader("Content-Transfer-Encoding", element.contentTransferEncoding);
        } else if (this.mail.encoding && /^text\//i.test(element.contentType)) {
          node.setHeader("Content-Transfer-Encoding", this.mail.encoding);
        }
        if (!/^text\//i.test(element.contentType) || element.contentDisposition) {
          node.setHeader(
            "Content-Disposition",
            element.contentDisposition || (element.cid && /^image\//i.test(element.contentType) ? "inline" : "attachment")
          );
        }
        if (typeof element.content === "string" && !["utf8", "usascii", "ascii"].includes(encoding)) {
          element.content = Buffer.from(element.content, encoding);
        }
        if (element.raw) {
          node.setRaw(element.raw);
        } else {
          node.setContent(element.content);
        }
        return node;
      }
      /**
       * Parses data uri and converts it to a Buffer
       *
       * @param {Object} element Content element
       * @return {Object} Parsed element
       */
      _processDataUrl(element) {
        let parsedDataUri;
        if ((element.path || element.href).match(/^data:/)) {
          parsedDataUri = parseDataURI(element.path || element.href);
        }
        if (!parsedDataUri) {
          return element;
        }
        element.content = parsedDataUri.data;
        element.contentType = element.contentType || parsedDataUri.contentType;
        if ("path" in element) {
          element.path = false;
        }
        if ("href" in element) {
          element.href = false;
        }
        return element;
      }
    };
    module2.exports = MailComposer;
  }
});

// node_modules/nodemailer/lib/dkim/message-parser.js
var require_message_parser = __commonJS({
  "node_modules/nodemailer/lib/dkim/message-parser.js"(exports, module2) {
    "use strict";
    var Transform = require("stream").Transform;
    var MessageParser = class extends Transform {
      constructor(options) {
        super(options);
        this.lastBytes = Buffer.alloc(4);
        this.headersParsed = false;
        this.headerBytes = 0;
        this.headerChunks = [];
        this.rawHeaders = false;
        this.bodySize = 0;
      }
      /**
       * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries
       *
       * @param {Buffer} data Next data chunk from the stream
       */
      updateLastBytes(data) {
        let lblen = this.lastBytes.length;
        let nblen = Math.min(data.length, lblen);
        for (let i = 0, len = lblen - nblen; i < len; i++) {
          this.lastBytes[i] = this.lastBytes[i + nblen];
        }
        for (let i = 1; i <= nblen; i++) {
          this.lastBytes[lblen - i] = data[data.length - i];
        }
      }
      /**
       * Finds and removes message headers from the remaining body. We want to keep
       * headers separated until final delivery to be able to modify these
       *
       * @param {Buffer} data Next chunk of data
       * @return {Boolean} Returns true if headers are already found or false otherwise
       */
      checkHeaders(data) {
        if (this.headersParsed) {
          return true;
        }
        let lblen = this.lastBytes.length;
        let headerPos = 0;
        this.curLinePos = 0;
        for (let i = 0, len = this.lastBytes.length + data.length; i < len; i++) {
          let chr;
          if (i < lblen) {
            chr = this.lastBytes[i];
          } else {
            chr = data[i - lblen];
          }
          if (chr === 10 && i) {
            let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];
            let pr2 = i > 1 ? i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen] : false;
            if (pr1 === 10) {
              this.headersParsed = true;
              headerPos = i - lblen + 1;
              this.headerBytes += headerPos;
              break;
            } else if (pr1 === 13 && pr2 === 10) {
              this.headersParsed = true;
              headerPos = i - lblen + 1;
              this.headerBytes += headerPos;
              break;
            }
          }
        }
        if (this.headersParsed) {
          this.headerChunks.push(data.slice(0, headerPos));
          this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);
          this.headerChunks = null;
          this.emit("headers", this.parseHeaders());
          if (data.length - 1 > headerPos) {
            let chunk = data.slice(headerPos);
            this.bodySize += chunk.length;
            setImmediate(() => this.push(chunk));
          }
          return false;
        } else {
          this.headerBytes += data.length;
          this.headerChunks.push(data);
        }
        this.updateLastBytes(data);
        return false;
      }
      _transform(chunk, encoding, callback2) {
        if (!chunk || !chunk.length) {
          return callback2();
        }
        if (typeof chunk === "string") {
          chunk = Buffer.from(chunk, encoding);
        }
        let headersFound;
        try {
          headersFound = this.checkHeaders(chunk);
        } catch (E) {
          return callback2(E);
        }
        if (headersFound) {
          this.bodySize += chunk.length;
          this.push(chunk);
        }
        setImmediate(callback2);
      }
      _flush(callback2) {
        if (this.headerChunks) {
          let chunk = Buffer.concat(this.headerChunks, this.headerBytes);
          this.bodySize += chunk.length;
          this.push(chunk);
          this.headerChunks = null;
        }
        callback2();
      }
      parseHeaders() {
        let lines = (this.rawHeaders || "").toString().split(/\r?\n/);
        for (let i = lines.length - 1; i > 0; i--) {
          if (/^\s/.test(lines[i])) {
            lines[i - 1] += "\n" + lines[i];
            lines.splice(i, 1);
          }
        }
        return lines.filter((line) => line.trim()).map((line) => ({
          key: line.substr(0, line.indexOf(":")).trim().toLowerCase(),
          line
        }));
      }
    };
    module2.exports = MessageParser;
  }
});

// node_modules/nodemailer/lib/dkim/relaxed-body.js
var require_relaxed_body = __commonJS({
  "node_modules/nodemailer/lib/dkim/relaxed-body.js"(exports, module2) {
    "use strict";
    var Transform = require("stream").Transform;
    var crypto3 = require("crypto");
    var RelaxedBody = class extends Transform {
      constructor(options) {
        super();
        options = options || {};
        this.chunkBuffer = [];
        this.chunkBufferLen = 0;
        this.bodyHash = crypto3.createHash(options.hashAlgo || "sha1");
        this.remainder = "";
        this.byteLength = 0;
        this.debug = options.debug;
        this._debugBody = options.debug ? [] : false;
      }
      updateHash(chunk) {
        let bodyStr;
        let nextRemainder = "";
        let state = "file";
        for (let i = chunk.length - 1; i >= 0; i--) {
          let c = chunk[i];
          if (state === "file" && (c === 10 || c === 13)) {
          } else if (state === "file" && (c === 9 || c === 32)) {
            state = "line";
          } else if (state === "line" && (c === 9 || c === 32)) {
          } else if (state === "file" || state === "line") {
            state = "body";
            if (i === chunk.length - 1) {
              break;
            }
          }
          if (i === 0) {
            if (state === "file" && (!this.remainder || /[\r\n]$/.test(this.remainder)) || state === "line" && (!this.remainder || /[ \t]$/.test(this.remainder))) {
              this.remainder += chunk.toString("binary");
              return;
            } else if (state === "line" || state === "file") {
              nextRemainder = chunk.toString("binary");
              chunk = false;
              break;
            }
          }
          if (state !== "body") {
            continue;
          }
          nextRemainder = chunk.slice(i + 1).toString("binary");
          chunk = chunk.slice(0, i + 1);
          break;
        }
        let needsFixing = !!this.remainder;
        if (chunk && !needsFixing) {
          for (let i = 0, len = chunk.length; i < len; i++) {
            if (i && chunk[i] === 10 && chunk[i - 1] !== 13) {
              needsFixing = true;
              break;
            } else if (i && chunk[i] === 13 && chunk[i - 1] === 32) {
              needsFixing = true;
              break;
            } else if (i && chunk[i] === 32 && chunk[i - 1] === 32) {
              needsFixing = true;
              break;
            } else if (chunk[i] === 9) {
              needsFixing = true;
              break;
            }
          }
        }
        if (needsFixing) {
          bodyStr = this.remainder + (chunk ? chunk.toString("binary") : "");
          this.remainder = nextRemainder;
          bodyStr = bodyStr.replace(/\r?\n/g, "\n").replace(/[ \t]*$/gm, "").replace(/[ \t]+/gm, " ").replace(/\n/g, "\r\n");
          chunk = Buffer.from(bodyStr, "binary");
        } else if (nextRemainder) {
          this.remainder = nextRemainder;
        }
        if (this.debug) {
          this._debugBody.push(chunk);
        }
        this.bodyHash.update(chunk);
      }
      _transform(chunk, encoding, callback2) {
        if (!chunk || !chunk.length) {
          return callback2();
        }
        if (typeof chunk === "string") {
          chunk = Buffer.from(chunk, encoding);
        }
        this.updateHash(chunk);
        this.byteLength += chunk.length;
        this.push(chunk);
        callback2();
      }
      _flush(callback2) {
        if (/[\r\n]$/.test(this.remainder) && this.byteLength > 2) {
          this.bodyHash.update(Buffer.from("\r\n"));
        }
        if (!this.byteLength) {
          this.push(Buffer.from("\r\n"));
        }
        this.emit("hash", this.bodyHash.digest("base64"), this.debug ? Buffer.concat(this._debugBody) : false);
        callback2();
      }
    };
    module2.exports = RelaxedBody;
  }
});

// node_modules/nodemailer/lib/dkim/sign.js
var require_sign = __commonJS({
  "node_modules/nodemailer/lib/dkim/sign.js"(exports, module2) {
    "use strict";
    var punycode = require_punycode();
    var mimeFuncs = require_mime_funcs();
    var crypto3 = require("crypto");
    module2.exports = (headers, hashAlgo, bodyHash, options) => {
      options = options || {};
      let defaultFieldNames = "From:Sender:Reply-To:Subject:Date:Message-ID:To:Cc:MIME-Version:Content-Type:Content-Transfer-Encoding:Content-ID:Content-Description:Resent-Date:Resent-From:Resent-Sender:Resent-To:Resent-Cc:Resent-Message-ID:In-Reply-To:References:List-Id:List-Help:List-Unsubscribe:List-Subscribe:List-Post:List-Owner:List-Archive";
      let fieldNames = options.headerFieldNames || defaultFieldNames;
      let canonicalizedHeaderData = relaxedHeaders(headers, fieldNames, options.skipFields);
      let dkimHeader = generateDKIMHeader(options.domainName, options.keySelector, canonicalizedHeaderData.fieldNames, hashAlgo, bodyHash);
      let signer, signature;
      canonicalizedHeaderData.headers += "dkim-signature:" + relaxedHeaderLine(dkimHeader);
      signer = crypto3.createSign(("rsa-" + hashAlgo).toUpperCase());
      signer.update(canonicalizedHeaderData.headers);
      try {
        signature = signer.sign(options.privateKey, "base64");
      } catch (E) {
        return false;
      }
      return dkimHeader + signature.replace(/(^.{73}|.{75}(?!\r?\n|\r))/g, "$&\r\n ").trim();
    };
    module2.exports.relaxedHeaders = relaxedHeaders;
    function generateDKIMHeader(domainName, keySelector, fieldNames, hashAlgo, bodyHash) {
      let dkim = [
        "v=1",
        "a=rsa-" + hashAlgo,
        "c=relaxed/relaxed",
        "d=" + punycode.toASCII(domainName),
        "q=dns/txt",
        "s=" + keySelector,
        "bh=" + bodyHash,
        "h=" + fieldNames
      ].join("; ");
      return mimeFuncs.foldLines("DKIM-Signature: " + dkim, 76) + ";\r\n b=";
    }
    function relaxedHeaders(headers, fieldNames, skipFields) {
      let includedFields = /* @__PURE__ */ new Set();
      let skip = /* @__PURE__ */ new Set();
      let headerFields = /* @__PURE__ */ new Map();
      (skipFields || "").toLowerCase().split(":").forEach((field) => {
        skip.add(field.trim());
      });
      (fieldNames || "").toLowerCase().split(":").filter((field) => !skip.has(field.trim())).forEach((field) => {
        includedFields.add(field.trim());
      });
      for (let i = headers.length - 1; i >= 0; i--) {
        let line = headers[i];
        if (includedFields.has(line.key) && !headerFields.has(line.key)) {
          headerFields.set(line.key, relaxedHeaderLine(line.line));
        }
      }
      let headersList = [];
      let fields = [];
      includedFields.forEach((field) => {
        if (headerFields.has(field)) {
          fields.push(field);
          headersList.push(field + ":" + headerFields.get(field));
        }
      });
      return {
        headers: headersList.join("\r\n") + "\r\n",
        fieldNames: fields.join(":")
      };
    }
    function relaxedHeaderLine(line) {
      return line.substr(line.indexOf(":") + 1).replace(/\r?\n/g, "").replace(/\s+/g, " ").trim();
    }
  }
});

// node_modules/nodemailer/lib/dkim/index.js
var require_dkim = __commonJS({
  "node_modules/nodemailer/lib/dkim/index.js"(exports, module2) {
    "use strict";
    var MessageParser = require_message_parser();
    var RelaxedBody = require_relaxed_body();
    var sign = require_sign();
    var PassThrough2 = require("stream").PassThrough;
    var fs = require("fs");
    var path = require("path");
    var crypto3 = require("crypto");
    var DKIM_ALGO = "sha256";
    var MAX_MESSAGE_SIZE = 128 * 1024;
    var DKIMSigner = class {
      constructor(options, keys, input, output) {
        this.options = options || {};
        this.keys = keys;
        this.cacheTreshold = Number(this.options.cacheTreshold) || MAX_MESSAGE_SIZE;
        this.hashAlgo = this.options.hashAlgo || DKIM_ALGO;
        this.cacheDir = this.options.cacheDir || false;
        this.chunks = [];
        this.chunklen = 0;
        this.readPos = 0;
        this.cachePath = this.cacheDir ? path.join(this.cacheDir, "message." + Date.now() + "-" + crypto3.randomBytes(14).toString("hex")) : false;
        this.cache = false;
        this.headers = false;
        this.bodyHash = false;
        this.parser = false;
        this.relaxedBody = false;
        this.input = input;
        this.output = output;
        this.output.usingCache = false;
        this.hasErrored = false;
        this.input.on("error", (err) => {
          this.hasErrored = true;
          this.cleanup();
          output.emit("error", err);
        });
      }
      cleanup() {
        if (!this.cache || !this.cachePath) {
          return;
        }
        fs.unlink(this.cachePath, () => false);
      }
      createReadCache() {
        this.cache = fs.createReadStream(this.cachePath);
        this.cache.once("error", (err) => {
          this.cleanup();
          this.output.emit("error", err);
        });
        this.cache.once("close", () => {
          this.cleanup();
        });
        this.cache.pipe(this.output);
      }
      sendNextChunk() {
        if (this.hasErrored) {
          return;
        }
        if (this.readPos >= this.chunks.length) {
          if (!this.cache) {
            return this.output.end();
          }
          return this.createReadCache();
        }
        let chunk = this.chunks[this.readPos++];
        if (this.output.write(chunk) === false) {
          return this.output.once("drain", () => {
            this.sendNextChunk();
          });
        }
        setImmediate(() => this.sendNextChunk());
      }
      sendSignedOutput() {
        let keyPos = 0;
        let signNextKey = () => {
          if (keyPos >= this.keys.length) {
            this.output.write(this.parser.rawHeaders);
            return setImmediate(() => this.sendNextChunk());
          }
          let key = this.keys[keyPos++];
          let dkimField = sign(this.headers, this.hashAlgo, this.bodyHash, {
            domainName: key.domainName,
            keySelector: key.keySelector,
            privateKey: key.privateKey,
            headerFieldNames: this.options.headerFieldNames,
            skipFields: this.options.skipFields
          });
          if (dkimField) {
            this.output.write(Buffer.from(dkimField + "\r\n"));
          }
          return setImmediate(signNextKey);
        };
        if (this.bodyHash && this.headers) {
          return signNextKey();
        }
        this.output.write(this.parser.rawHeaders);
        this.sendNextChunk();
      }
      createWriteCache() {
        this.output.usingCache = true;
        this.cache = fs.createWriteStream(this.cachePath);
        this.cache.once("error", (err) => {
          this.cleanup();
          this.relaxedBody.unpipe(this.cache);
          this.relaxedBody.on("readable", () => {
            while (this.relaxedBody.read() !== null) {
            }
          });
          this.hasErrored = true;
          this.output.emit("error", err);
        });
        this.cache.once("close", () => {
          this.sendSignedOutput();
        });
        this.relaxedBody.removeAllListeners("readable");
        this.relaxedBody.pipe(this.cache);
      }
      signStream() {
        this.parser = new MessageParser();
        this.relaxedBody = new RelaxedBody({
          hashAlgo: this.hashAlgo
        });
        this.parser.on("headers", (value) => {
          this.headers = value;
        });
        this.relaxedBody.on("hash", (value) => {
          this.bodyHash = value;
        });
        this.relaxedBody.on("readable", () => {
          let chunk;
          if (this.cache) {
            return;
          }
          while ((chunk = this.relaxedBody.read()) !== null) {
            this.chunks.push(chunk);
            this.chunklen += chunk.length;
            if (this.chunklen >= this.cacheTreshold && this.cachePath) {
              return this.createWriteCache();
            }
          }
        });
        this.relaxedBody.on("end", () => {
          if (this.cache) {
            return;
          }
          this.sendSignedOutput();
        });
        this.parser.pipe(this.relaxedBody);
        setImmediate(() => this.input.pipe(this.parser));
      }
    };
    var DKIM = class {
      constructor(options) {
        this.options = options || {};
        this.keys = [].concat(
          this.options.keys || {
            domainName: options.domainName,
            keySelector: options.keySelector,
            privateKey: options.privateKey
          }
        );
      }
      sign(input, extraOptions) {
        let output = new PassThrough2();
        let inputStream = input;
        let writeValue = false;
        if (Buffer.isBuffer(input)) {
          writeValue = input;
          inputStream = new PassThrough2();
        } else if (typeof input === "string") {
          writeValue = Buffer.from(input);
          inputStream = new PassThrough2();
        }
        let options = this.options;
        if (extraOptions && Object.keys(extraOptions).length) {
          options = {};
          Object.keys(this.options || {}).forEach((key) => {
            options[key] = this.options[key];
          });
          Object.keys(extraOptions || {}).forEach((key) => {
            if (!(key in options)) {
              options[key] = extraOptions[key];
            }
          });
        }
        let signer = new DKIMSigner(options, this.keys, inputStream, output);
        setImmediate(() => {
          signer.signStream();
          if (writeValue) {
            setImmediate(() => {
              inputStream.end(writeValue);
            });
          }
        });
        return output;
      }
    };
    module2.exports = DKIM;
  }
});

// node_modules/nodemailer/lib/smtp-connection/http-proxy-client.js
var require_http_proxy_client = __commonJS({
  "node_modules/nodemailer/lib/smtp-connection/http-proxy-client.js"(exports, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var urllib = require("url");
    function httpProxyClient(proxyUrl, destinationPort, destinationHost, callback2) {
      let proxy = urllib.parse(proxyUrl);
      let options;
      let connect;
      let socket;
      options = {
        host: proxy.hostname,
        port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === "https:" ? 443 : 80
      };
      if (proxy.protocol === "https:") {
        options.rejectUnauthorized = false;
        connect = tls.connect.bind(tls);
      } else {
        connect = net.connect.bind(net);
      }
      let finished = false;
      let tempSocketErr = (err) => {
        if (finished) {
          return;
        }
        finished = true;
        try {
          socket.destroy();
        } catch (E) {
        }
        callback2(err);
      };
      let timeoutErr = () => {
        let err = new Error("Proxy socket timed out");
        err.code = "ETIMEDOUT";
        tempSocketErr(err);
      };
      socket = connect(options, () => {
        if (finished) {
          return;
        }
        let reqHeaders = {
          Host: destinationHost + ":" + destinationPort,
          Connection: "close"
        };
        if (proxy.auth) {
          reqHeaders["Proxy-Authorization"] = "Basic " + Buffer.from(proxy.auth).toString("base64");
        }
        socket.write(
          // HTTP method
          "CONNECT " + destinationHost + ":" + destinationPort + " HTTP/1.1\r\n" + // HTTP request headers
          Object.keys(reqHeaders).map((key) => key + ": " + reqHeaders[key]).join("\r\n") + // End request
          "\r\n\r\n"
        );
        let headers = "";
        let onSocketData = (chunk) => {
          let match;
          let remainder;
          if (finished) {
            return;
          }
          headers += chunk.toString("binary");
          if (match = headers.match(/\r\n\r\n/)) {
            socket.removeListener("data", onSocketData);
            remainder = headers.substr(match.index + match[0].length);
            headers = headers.substr(0, match.index);
            if (remainder) {
              socket.unshift(Buffer.from(remainder, "binary"));
            }
            finished = true;
            match = headers.match(/^HTTP\/\d+\.\d+ (\d+)/i);
            if (!match || (match[1] || "").charAt(0) !== "2") {
              try {
                socket.destroy();
              } catch (E) {
              }
              return callback2(new Error("Invalid response from proxy" + (match && ": " + match[1] || "")));
            }
            socket.removeListener("error", tempSocketErr);
            socket.removeListener("timeout", timeoutErr);
            socket.setTimeout(0);
            return callback2(null, socket);
          }
        };
        socket.on("data", onSocketData);
      });
      socket.setTimeout(httpProxyClient.timeout || 30 * 1e3);
      socket.on("timeout", timeoutErr);
      socket.once("error", tempSocketErr);
    }
    module2.exports = httpProxyClient;
  }
});

// node_modules/nodemailer/lib/mailer/mail-message.js
var require_mail_message = __commonJS({
  "node_modules/nodemailer/lib/mailer/mail-message.js"(exports, module2) {
    "use strict";
    var shared = require_shared2();
    var MimeNode = require_mime_node();
    var mimeFuncs = require_mime_funcs();
    var MailMessage = class {
      constructor(mailer, data) {
        this.mailer = mailer;
        this.data = {};
        this.message = null;
        data = data || {};
        let options = mailer.options || {};
        let defaults = mailer._defaults || {};
        Object.keys(data).forEach((key) => {
          this.data[key] = data[key];
        });
        this.data.headers = this.data.headers || {};
        Object.keys(defaults).forEach((key) => {
          if (!(key in this.data)) {
            this.data[key] = defaults[key];
          } else if (key === "headers") {
            Object.keys(defaults.headers).forEach((key2) => {
              if (!(key2 in this.data.headers)) {
                this.data.headers[key2] = defaults.headers[key2];
              }
            });
          }
        });
        ["disableFileAccess", "disableUrlAccess", "normalizeHeaderKey"].forEach((key) => {
          if (key in options) {
            this.data[key] = options[key];
          }
        });
      }
      resolveContent(...args) {
        return shared.resolveContent(...args);
      }
      resolveAll(callback2) {
        let keys = [
          [this.data, "html"],
          [this.data, "text"],
          [this.data, "watchHtml"],
          [this.data, "amp"],
          [this.data, "icalEvent"]
        ];
        if (this.data.alternatives && this.data.alternatives.length) {
          this.data.alternatives.forEach((alternative, i) => {
            keys.push([this.data.alternatives, i]);
          });
        }
        if (this.data.attachments && this.data.attachments.length) {
          this.data.attachments.forEach((attachment, i) => {
            if (!attachment.filename) {
              attachment.filename = (attachment.path || attachment.href || "").split("/").pop().split("?").shift() || "attachment-" + (i + 1);
              if (attachment.filename.indexOf(".") < 0) {
                attachment.filename += "." + mimeFuncs.detectExtension(attachment.contentType);
              }
            }
            if (!attachment.contentType) {
              attachment.contentType = mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || "bin");
            }
            keys.push([this.data.attachments, i]);
          });
        }
        let mimeNode = new MimeNode();
        let addressKeys = ["from", "to", "cc", "bcc", "sender", "replyTo"];
        addressKeys.forEach((address) => {
          let value;
          if (this.message) {
            value = [].concat(mimeNode._parseAddresses(this.message.getHeader(address === "replyTo" ? "reply-to" : address)) || []);
          } else if (this.data[address]) {
            value = [].concat(mimeNode._parseAddresses(this.data[address]) || []);
          }
          if (value && value.length) {
            this.data[address] = value;
          } else if (address in this.data) {
            this.data[address] = null;
          }
        });
        let singleKeys = ["from", "sender"];
        singleKeys.forEach((address) => {
          if (this.data[address]) {
            this.data[address] = this.data[address].shift();
          }
        });
        let pos = 0;
        let resolveNext = () => {
          if (pos >= keys.length) {
            return callback2(null, this.data);
          }
          let args = keys[pos++];
          if (!args[0] || !args[0][args[1]]) {
            return resolveNext();
          }
          shared.resolveContent(...args, (err, value) => {
            if (err) {
              return callback2(err);
            }
            let node = {
              content: value
            };
            if (args[0][args[1]] && typeof args[0][args[1]] === "object" && !Buffer.isBuffer(args[0][args[1]])) {
              Object.keys(args[0][args[1]]).forEach((key) => {
                if (!(key in node) && !["content", "path", "href", "raw"].includes(key)) {
                  node[key] = args[0][args[1]][key];
                }
              });
            }
            args[0][args[1]] = node;
            resolveNext();
          });
        };
        setImmediate(() => resolveNext());
      }
      normalize(callback2) {
        let envelope = this.data.envelope || this.message.getEnvelope();
        let messageId = this.message.messageId();
        this.resolveAll((err, data) => {
          if (err) {
            return callback2(err);
          }
          data.envelope = envelope;
          data.messageId = messageId;
          ["html", "text", "watchHtml", "amp"].forEach((key) => {
            if (data[key] && data[key].content) {
              if (typeof data[key].content === "string") {
                data[key] = data[key].content;
              } else if (Buffer.isBuffer(data[key].content)) {
                data[key] = data[key].content.toString();
              }
            }
          });
          if (data.icalEvent && Buffer.isBuffer(data.icalEvent.content)) {
            data.icalEvent.content = data.icalEvent.content.toString("base64");
            data.icalEvent.encoding = "base64";
          }
          if (data.alternatives && data.alternatives.length) {
            data.alternatives.forEach((alternative) => {
              if (alternative && alternative.content && Buffer.isBuffer(alternative.content)) {
                alternative.content = alternative.content.toString("base64");
                alternative.encoding = "base64";
              }
            });
          }
          if (data.attachments && data.attachments.length) {
            data.attachments.forEach((attachment) => {
              if (attachment && attachment.content && Buffer.isBuffer(attachment.content)) {
                attachment.content = attachment.content.toString("base64");
                attachment.encoding = "base64";
              }
            });
          }
          data.normalizedHeaders = {};
          Object.keys(data.headers || {}).forEach((key) => {
            let value = [].concat(data.headers[key] || []).shift();
            value = value && value.value || value;
            if (value) {
              if (["references", "in-reply-to", "message-id", "content-id"].includes(key)) {
                value = this.message._encodeHeaderValue(key, value);
              }
              data.normalizedHeaders[key] = value;
            }
          });
          if (data.list && typeof data.list === "object") {
            let listHeaders = this._getListHeaders(data.list);
            listHeaders.forEach((entry) => {
              data.normalizedHeaders[entry.key] = entry.value.map((val) => val && val.value || val).join(", ");
            });
          }
          if (data.references) {
            data.normalizedHeaders.references = this.message._encodeHeaderValue("references", data.references);
          }
          if (data.inReplyTo) {
            data.normalizedHeaders["in-reply-to"] = this.message._encodeHeaderValue("in-reply-to", data.inReplyTo);
          }
          return callback2(null, data);
        });
      }
      setMailerHeader() {
        if (!this.message || !this.data.xMailer) {
          return;
        }
        this.message.setHeader("X-Mailer", this.data.xMailer);
      }
      setPriorityHeaders() {
        if (!this.message || !this.data.priority) {
          return;
        }
        switch ((this.data.priority || "").toString().toLowerCase()) {
          case "high":
            this.message.setHeader("X-Priority", "1 (Highest)");
            this.message.setHeader("X-MSMail-Priority", "High");
            this.message.setHeader("Importance", "High");
            break;
          case "low":
            this.message.setHeader("X-Priority", "5 (Lowest)");
            this.message.setHeader("X-MSMail-Priority", "Low");
            this.message.setHeader("Importance", "Low");
            break;
          default:
        }
      }
      setListHeaders() {
        if (!this.message || !this.data.list || typeof this.data.list !== "object") {
          return;
        }
        if (this.data.list && typeof this.data.list === "object") {
          this._getListHeaders(this.data.list).forEach((listHeader) => {
            listHeader.value.forEach((value) => {
              this.message.addHeader(listHeader.key, value);
            });
          });
        }
      }
      _getListHeaders(listData) {
        return Object.keys(listData).map((key) => ({
          key: "list-" + key.toLowerCase().trim(),
          value: [].concat(listData[key] || []).map((value) => ({
            prepared: true,
            foldLines: true,
            value: [].concat(value || []).map((value2) => {
              if (typeof value2 === "string") {
                value2 = {
                  url: value2
                };
              }
              if (value2 && value2.url) {
                if (key.toLowerCase().trim() === "id") {
                  let comment2 = value2.comment || "";
                  if (mimeFuncs.isPlainText(comment2)) {
                    comment2 = '"' + comment2 + '"';
                  } else {
                    comment2 = mimeFuncs.encodeWord(comment2);
                  }
                  return (value2.comment ? comment2 + " " : "") + this._formatListUrl(value2.url).replace(/^<[^:]+\/{,2}/, "");
                }
                let comment = value2.comment || "";
                if (!mimeFuncs.isPlainText(comment)) {
                  comment = mimeFuncs.encodeWord(comment);
                }
                return this._formatListUrl(value2.url) + (value2.comment ? " (" + comment + ")" : "");
              }
              return "";
            }).filter((value2) => value2).join(", ")
          }))
        }));
      }
      _formatListUrl(url) {
        url = url.replace(/[\s<]+|[\s>]+/g, "");
        if (/^(https?|mailto|ftp):/.test(url)) {
          return "<" + url + ">";
        }
        if (/^[^@]+@[^@]+$/.test(url)) {
          return "<mailto:" + url + ">";
        }
        return "<http://" + url + ">";
      }
    };
    module2.exports = MailMessage;
  }
});

// node_modules/nodemailer/lib/mailer/index.js
var require_mailer = __commonJS({
  "node_modules/nodemailer/lib/mailer/index.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var shared = require_shared2();
    var mimeTypes = require_mime_types();
    var MailComposer = require_mail_composer();
    var DKIM = require_dkim();
    var httpProxyClient = require_http_proxy_client();
    var util = require("util");
    var urllib = require("url");
    var packageData = require_package2();
    var MailMessage = require_mail_message();
    var net = require("net");
    var dns = require("dns");
    var crypto3 = require("crypto");
    var Mail = class extends EventEmitter {
      constructor(transporter, options, defaults) {
        super();
        this.options = options || {};
        this._defaults = defaults || {};
        this._defaultPlugins = {
          compile: [(...args) => this._convertDataImages(...args)],
          stream: []
        };
        this._userPlugins = {
          compile: [],
          stream: []
        };
        this.meta = /* @__PURE__ */ new Map();
        this.dkim = this.options.dkim ? new DKIM(this.options.dkim) : false;
        this.transporter = transporter;
        this.transporter.mailer = this;
        this.logger = shared.getLogger(this.options, {
          component: this.options.component || "mail"
        });
        this.logger.debug(
          {
            tnx: "create"
          },
          "Creating transport: %s",
          this.getVersionString()
        );
        if (typeof this.transporter.on === "function") {
          this.transporter.on("log", (log) => {
            this.logger.debug(
              {
                tnx: "transport"
              },
              "%s: %s",
              log.type,
              log.message
            );
          });
          this.transporter.on("error", (err) => {
            this.logger.error(
              {
                err,
                tnx: "transport"
              },
              "Transport Error: %s",
              err.message
            );
            this.emit("error", err);
          });
          this.transporter.on("idle", (...args) => {
            this.emit("idle", ...args);
          });
        }
        ["close", "isIdle", "verify"].forEach((method) => {
          this[method] = (...args) => {
            if (typeof this.transporter[method] === "function") {
              if (method === "verify" && typeof this.getSocket === "function") {
                this.transporter.getSocket = this.getSocket;
                this.getSocket = false;
              }
              return this.transporter[method](...args);
            } else {
              this.logger.warn(
                {
                  tnx: "transport",
                  methodName: method
                },
                "Non existing method %s called for transport",
                method
              );
              return false;
            }
          };
        });
        if (this.options.proxy && typeof this.options.proxy === "string") {
          this.setupProxy(this.options.proxy);
        }
      }
      use(step, plugin) {
        step = (step || "").toString();
        if (!this._userPlugins.hasOwnProperty(step)) {
          this._userPlugins[step] = [plugin];
        } else {
          this._userPlugins[step].push(plugin);
        }
        return this;
      }
      /**
       * Sends an email using the preselected transport object
       *
       * @param {Object} data E-data description
       * @param {Function?} callback Callback to run once the sending succeeded or failed
       */
      sendMail(data, callback2 = null) {
        let promise;
        if (!callback2) {
          promise = new Promise((resolve2, reject) => {
            callback2 = shared.callbackPromise(resolve2, reject);
          });
        }
        if (typeof this.getSocket === "function") {
          this.transporter.getSocket = this.getSocket;
          this.getSocket = false;
        }
        let mail = new MailMessage(this, data);
        this.logger.debug(
          {
            tnx: "transport",
            name: this.transporter.name,
            version: this.transporter.version,
            action: "send"
          },
          "Sending mail using %s/%s",
          this.transporter.name,
          this.transporter.version
        );
        this._processPlugins("compile", mail, (err) => {
          if (err) {
            this.logger.error(
              {
                err,
                tnx: "plugin",
                action: "compile"
              },
              "PluginCompile Error: %s",
              err.message
            );
            return callback2(err);
          }
          mail.message = new MailComposer(mail.data).compile();
          mail.setMailerHeader();
          mail.setPriorityHeaders();
          mail.setListHeaders();
          this._processPlugins("stream", mail, (err2) => {
            if (err2) {
              this.logger.error(
                {
                  err: err2,
                  tnx: "plugin",
                  action: "stream"
                },
                "PluginStream Error: %s",
                err2.message
              );
              return callback2(err2);
            }
            if (mail.data.dkim || this.dkim) {
              mail.message.processFunc((input) => {
                let dkim = mail.data.dkim ? new DKIM(mail.data.dkim) : this.dkim;
                this.logger.debug(
                  {
                    tnx: "DKIM",
                    messageId: mail.message.messageId(),
                    dkimDomains: dkim.keys.map((key) => key.keySelector + "." + key.domainName).join(", ")
                  },
                  "Signing outgoing message with %s keys",
                  dkim.keys.length
                );
                return dkim.sign(input, mail.data._dkim);
              });
            }
            this.transporter.send(mail, (...args) => {
              if (args[0]) {
                this.logger.error(
                  {
                    err: args[0],
                    tnx: "transport",
                    action: "send"
                  },
                  "Send Error: %s",
                  args[0].message
                );
              }
              callback2(...args);
            });
          });
        });
        return promise;
      }
      getVersionString() {
        return util.format("%s (%s; +%s; %s/%s)", packageData.name, packageData.version, packageData.homepage, this.transporter.name, this.transporter.version);
      }
      _processPlugins(step, mail, callback2) {
        step = (step || "").toString();
        if (!this._userPlugins.hasOwnProperty(step)) {
          return callback2();
        }
        let userPlugins = this._userPlugins[step] || [];
        let defaultPlugins = this._defaultPlugins[step] || [];
        if (userPlugins.length) {
          this.logger.debug(
            {
              tnx: "transaction",
              pluginCount: userPlugins.length,
              step
            },
            "Using %s plugins for %s",
            userPlugins.length,
            step
          );
        }
        if (userPlugins.length + defaultPlugins.length === 0) {
          return callback2();
        }
        let pos = 0;
        let block = "default";
        let processPlugins = () => {
          let curplugins = block === "default" ? defaultPlugins : userPlugins;
          if (pos >= curplugins.length) {
            if (block === "default" && userPlugins.length) {
              block = "user";
              pos = 0;
              curplugins = userPlugins;
            } else {
              return callback2();
            }
          }
          let plugin = curplugins[pos++];
          plugin(mail, (err) => {
            if (err) {
              return callback2(err);
            }
            processPlugins();
          });
        };
        processPlugins();
      }
      /**
       * Sets up proxy handler for a Nodemailer object
       *
       * @param {String} proxyUrl Proxy configuration url
       */
      setupProxy(proxyUrl) {
        let proxy = urllib.parse(proxyUrl);
        this.getSocket = (options, callback2) => {
          let protocol = proxy.protocol.replace(/:$/, "").toLowerCase();
          if (this.meta.has("proxy_handler_" + protocol)) {
            return this.meta.get("proxy_handler_" + protocol)(proxy, options, callback2);
          }
          switch (protocol) {
            case "http":
            case "https":
              httpProxyClient(proxy.href, options.port, options.host, (err, socket) => {
                if (err) {
                  return callback2(err);
                }
                return callback2(null, {
                  connection: socket
                });
              });
              return;
            case "socks":
            case "socks5":
            case "socks4":
            case "socks4a": {
              if (!this.meta.has("proxy_socks_module")) {
                return callback2(new Error("Socks module not loaded"));
              }
              let connect = (ipaddress) => {
                let proxyV2 = !!this.meta.get("proxy_socks_module").SocksClient;
                let socksClient = proxyV2 ? this.meta.get("proxy_socks_module").SocksClient : this.meta.get("proxy_socks_module");
                let proxyType = Number(proxy.protocol.replace(/\D/g, "")) || 5;
                let connectionOpts = {
                  proxy: {
                    ipaddress,
                    port: Number(proxy.port),
                    type: proxyType
                  },
                  [proxyV2 ? "destination" : "target"]: {
                    host: options.host,
                    port: options.port
                  },
                  command: "connect"
                };
                if (proxy.auth) {
                  let username = decodeURIComponent(proxy.auth.split(":").shift());
                  let password2 = decodeURIComponent(proxy.auth.split(":").pop());
                  if (proxyV2) {
                    connectionOpts.proxy.userId = username;
                    connectionOpts.proxy.password = password2;
                  } else if (proxyType === 4) {
                    connectionOpts.userid = username;
                  } else {
                    connectionOpts.authentication = {
                      username,
                      password: password2
                    };
                  }
                }
                socksClient.createConnection(connectionOpts, (err, info) => {
                  if (err) {
                    return callback2(err);
                  }
                  return callback2(null, {
                    connection: info.socket || info
                  });
                });
              };
              if (net.isIP(proxy.hostname)) {
                return connect(proxy.hostname);
              }
              return dns.resolve(proxy.hostname, (err, address) => {
                if (err) {
                  return callback2(err);
                }
                connect(Array.isArray(address) ? address[0] : address);
              });
            }
          }
          callback2(new Error("Unknown proxy configuration"));
        };
      }
      _convertDataImages(mail, callback2) {
        if (!this.options.attachDataUrls && !mail.data.attachDataUrls || !mail.data.html) {
          return callback2();
        }
        mail.resolveContent(mail.data, "html", (err, html) => {
          if (err) {
            return callback2(err);
          }
          let cidCounter = 0;
          html = (html || "").toString().replace(/(<img\b[^<>]{0,1024} src\s{0,20}=[\s"']{0,20})(data:([^;]+);[^"'>\s]+)/gi, (match, prefix, dataUri, mimeType) => {
            let cid = crypto3.randomBytes(10).toString("hex") + "@localhost";
            if (!mail.data.attachments) {
              mail.data.attachments = [];
            }
            if (!Array.isArray(mail.data.attachments)) {
              mail.data.attachments = [].concat(mail.data.attachments || []);
            }
            mail.data.attachments.push({
              path: dataUri,
              cid,
              filename: "image-" + ++cidCounter + "." + mimeTypes.detectExtension(mimeType)
            });
            return prefix + "cid:" + cid;
          });
          mail.data.html = html;
          callback2();
        });
      }
      set(key, value) {
        return this.meta.set(key, value);
      }
      get(key) {
        return this.meta.get(key);
      }
    };
    module2.exports = Mail;
  }
});

// node_modules/nodemailer/lib/smtp-connection/data-stream.js
var require_data_stream = __commonJS({
  "node_modules/nodemailer/lib/smtp-connection/data-stream.js"(exports, module2) {
    "use strict";
    var stream = require("stream");
    var Transform = stream.Transform;
    var DataStream = class extends Transform {
      constructor(options) {
        super(options);
        this.options = options || {};
        this._curLine = "";
        this.inByteCount = 0;
        this.outByteCount = 0;
        this.lastByte = false;
      }
      /**
       * Escapes dots
       */
      _transform(chunk, encoding, done) {
        let chunks = [];
        let chunklen = 0;
        let i, len, lastPos = 0;
        let buf;
        if (!chunk || !chunk.length) {
          return done();
        }
        if (typeof chunk === "string") {
          chunk = Buffer.from(chunk);
        }
        this.inByteCount += chunk.length;
        for (i = 0, len = chunk.length; i < len; i++) {
          if (chunk[i] === 46) {
            if (i && chunk[i - 1] === 10 || !i && (!this.lastByte || this.lastByte === 10)) {
              buf = chunk.slice(lastPos, i + 1);
              chunks.push(buf);
              chunks.push(Buffer.from("."));
              chunklen += buf.length + 1;
              lastPos = i + 1;
            }
          } else if (chunk[i] === 10) {
            if (i && chunk[i - 1] !== 13 || !i && this.lastByte !== 13) {
              if (i > lastPos) {
                buf = chunk.slice(lastPos, i);
                chunks.push(buf);
                chunklen += buf.length + 2;
              } else {
                chunklen += 2;
              }
              chunks.push(Buffer.from("\r\n"));
              lastPos = i + 1;
            }
          }
        }
        if (chunklen) {
          if (lastPos < chunk.length) {
            buf = chunk.slice(lastPos);
            chunks.push(buf);
            chunklen += buf.length;
          }
          this.outByteCount += chunklen;
          this.push(Buffer.concat(chunks, chunklen));
        } else {
          this.outByteCount += chunk.length;
          this.push(chunk);
        }
        this.lastByte = chunk[chunk.length - 1];
        done();
      }
      /**
       * Finalizes the stream with a dot on a single line
       */
      _flush(done) {
        let buf;
        if (this.lastByte === 10) {
          buf = Buffer.from(".\r\n");
        } else if (this.lastByte === 13) {
          buf = Buffer.from("\n.\r\n");
        } else {
          buf = Buffer.from("\r\n.\r\n");
        }
        this.outByteCount += buf.length;
        this.push(buf);
        done();
      }
    };
    module2.exports = DataStream;
  }
});

// node_modules/nodemailer/lib/smtp-connection/index.js
var require_smtp_connection = __commonJS({
  "node_modules/nodemailer/lib/smtp-connection/index.js"(exports, module2) {
    "use strict";
    var packageInfo = require_package2();
    var EventEmitter = require("events").EventEmitter;
    var net = require("net");
    var tls = require("tls");
    var os = require("os");
    var crypto3 = require("crypto");
    var DataStream = require_data_stream();
    var PassThrough2 = require("stream").PassThrough;
    var shared = require_shared2();
    var CONNECTION_TIMEOUT = 2 * 60 * 1e3;
    var SOCKET_TIMEOUT = 10 * 60 * 1e3;
    var GREETING_TIMEOUT = 30 * 1e3;
    var DNS_TIMEOUT = 30 * 1e3;
    var SMTPConnection = class extends EventEmitter {
      constructor(options) {
        super(options);
        this.id = crypto3.randomBytes(8).toString("base64").replace(/\W/g, "");
        this.stage = "init";
        this.options = options || {};
        this.secureConnection = !!this.options.secure;
        this.alreadySecured = !!this.options.secured;
        this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);
        this.host = this.options.host || "localhost";
        this.allowInternalNetworkInterfaces = this.options.allowInternalNetworkInterfaces || false;
        if (typeof this.options.secure === "undefined" && this.port === 465) {
          this.secureConnection = true;
        }
        this.name = this.options.name || this._getHostname();
        this.logger = shared.getLogger(this.options, {
          component: this.options.component || "smtp-connection",
          sid: this.id
        });
        this.customAuth = /* @__PURE__ */ new Map();
        Object.keys(this.options.customAuth || {}).forEach((key) => {
          let mapKey = (key || "").toString().trim().toUpperCase();
          if (!mapKey) {
            return;
          }
          this.customAuth.set(mapKey, this.options.customAuth[key]);
        });
        this.version = packageInfo.version;
        this.authenticated = false;
        this.destroyed = false;
        this.secure = !!this.secureConnection;
        this._remainder = "";
        this._responseQueue = [];
        this.lastServerResponse = false;
        this._socket = false;
        this._supportedAuth = [];
        this.allowsAuth = false;
        this._envelope = false;
        this._supportedExtensions = [];
        this._maxAllowedSize = 0;
        this._responseActions = [];
        this._recipientQueue = [];
        this._greetingTimeout = false;
        this._connectionTimeout = false;
        this._destroyed = false;
        this._closing = false;
        this._onSocketData = (chunk) => this._onData(chunk);
        this._onSocketError = (error) => this._onError(error, "ESOCKET", false, "CONN");
        this._onSocketClose = () => this._onClose();
        this._onSocketEnd = () => this._onEnd();
        this._onSocketTimeout = () => this._onTimeout();
      }
      /**
       * Creates a connection to a SMTP server and sets up connection
       * listener
       */
      connect(connectCallback) {
        if (typeof connectCallback === "function") {
          this.once("connect", () => {
            this.logger.debug(
              {
                tnx: "smtp"
              },
              "SMTP handshake finished"
            );
            connectCallback();
          });
          const isDestroyedMessage = this._isDestroyedMessage("connect");
          if (isDestroyedMessage) {
            return connectCallback(this._formatError(isDestroyedMessage, "ECONNECTION", false, "CONN"));
          }
        }
        let opts = {
          port: this.port,
          host: this.host,
          allowInternalNetworkInterfaces: this.allowInternalNetworkInterfaces,
          timeout: this.options.dnsTimeout || DNS_TIMEOUT
        };
        if (this.options.localAddress) {
          opts.localAddress = this.options.localAddress;
        }
        let setupConnectionHandlers = () => {
          this._connectionTimeout = setTimeout(() => {
            this._onError("Connection timeout", "ETIMEDOUT", false, "CONN");
          }, this.options.connectionTimeout || CONNECTION_TIMEOUT);
          this._socket.on("error", this._onSocketError);
        };
        if (this.options.connection) {
          this._socket = this.options.connection;
          if (this.secureConnection && !this.alreadySecured) {
            setImmediate(
              () => this._upgradeConnection((err) => {
                if (err) {
                  this._onError(new Error("Error initiating TLS - " + (err.message || err)), "ETLS", false, "CONN");
                  return;
                }
                this._onConnect();
              })
            );
          } else {
            setImmediate(() => this._onConnect());
          }
          return;
        } else if (this.options.socket) {
          this._socket = this.options.socket;
          return shared.resolveHostname(opts, (err, resolved) => {
            if (err) {
              return setImmediate(() => this._onError(err, "EDNS", false, "CONN"));
            }
            this.logger.debug(
              {
                tnx: "dns",
                source: opts.host,
                resolved: resolved.host,
                cached: !!resolved.cached
              },
              "Resolved %s as %s [cache %s]",
              opts.host,
              resolved.host,
              resolved.cached ? "hit" : "miss"
            );
            Object.keys(resolved).forEach((key) => {
              if (key.charAt(0) !== "_" && resolved[key]) {
                opts[key] = resolved[key];
              }
            });
            try {
              this._socket.connect(this.port, this.host, () => {
                this._socket.setKeepAlive(true);
                this._onConnect();
              });
              setupConnectionHandlers();
            } catch (E) {
              return setImmediate(() => this._onError(E, "ECONNECTION", false, "CONN"));
            }
          });
        } else if (this.secureConnection) {
          if (this.options.tls) {
            Object.keys(this.options.tls).forEach((key) => {
              opts[key] = this.options.tls[key];
            });
          }
          return shared.resolveHostname(opts, (err, resolved) => {
            if (err) {
              return setImmediate(() => this._onError(err, "EDNS", false, "CONN"));
            }
            this.logger.debug(
              {
                tnx: "dns",
                source: opts.host,
                resolved: resolved.host,
                cached: !!resolved.cached
              },
              "Resolved %s as %s [cache %s]",
              opts.host,
              resolved.host,
              resolved.cached ? "hit" : "miss"
            );
            Object.keys(resolved).forEach((key) => {
              if (key.charAt(0) !== "_" && resolved[key]) {
                opts[key] = resolved[key];
              }
            });
            try {
              this._socket = tls.connect(opts, () => {
                this._socket.setKeepAlive(true);
                this._onConnect();
              });
              setupConnectionHandlers();
            } catch (E) {
              return setImmediate(() => this._onError(E, "ECONNECTION", false, "CONN"));
            }
          });
        } else {
          return shared.resolveHostname(opts, (err, resolved) => {
            if (err) {
              return setImmediate(() => this._onError(err, "EDNS", false, "CONN"));
            }
            this.logger.debug(
              {
                tnx: "dns",
                source: opts.host,
                resolved: resolved.host,
                cached: !!resolved.cached
              },
              "Resolved %s as %s [cache %s]",
              opts.host,
              resolved.host,
              resolved.cached ? "hit" : "miss"
            );
            Object.keys(resolved).forEach((key) => {
              if (key.charAt(0) !== "_" && resolved[key]) {
                opts[key] = resolved[key];
              }
            });
            try {
              this._socket = net.connect(opts, () => {
                this._socket.setKeepAlive(true);
                this._onConnect();
              });
              setupConnectionHandlers();
            } catch (E) {
              return setImmediate(() => this._onError(E, "ECONNECTION", false, "CONN"));
            }
          });
        }
      }
      /**
       * Sends QUIT
       */
      quit() {
        this._sendCommand("QUIT");
        this._responseActions.push(this.close);
      }
      /**
       * Closes the connection to the server
       */
      close() {
        clearTimeout(this._connectionTimeout);
        clearTimeout(this._greetingTimeout);
        this._responseActions = [];
        if (this._closing) {
          return;
        }
        this._closing = true;
        let closeMethod = "end";
        if (this.stage === "init") {
          closeMethod = "destroy";
        }
        this.logger.debug(
          {
            tnx: "smtp"
          },
          'Closing connection to the server using "%s"',
          closeMethod
        );
        let socket = this._socket && this._socket.socket || this._socket;
        if (socket && !socket.destroyed) {
          try {
            this._socket[closeMethod]();
          } catch (E) {
          }
        }
        this._destroy();
      }
      /**
       * Authenticate user
       */
      login(authData, callback2) {
        const isDestroyedMessage = this._isDestroyedMessage("login");
        if (isDestroyedMessage) {
          return callback2(this._formatError(isDestroyedMessage, "ECONNECTION", false, "API"));
        }
        this._auth = authData || {};
        this._authMethod = (this._auth.method || "").toString().trim().toUpperCase() || false;
        if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {
          this._authMethod = "XOAUTH2";
        } else if (!this._authMethod || this._authMethod === "XOAUTH2" && !this._auth.oauth2) {
          this._authMethod = (this._supportedAuth[0] || "PLAIN").toUpperCase().trim();
        }
        if (this._authMethod !== "XOAUTH2" && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {
          if (this._auth.user && this._auth.pass || this.customAuth.has(this._authMethod)) {
            this._auth.credentials = {
              user: this._auth.user,
              pass: this._auth.pass,
              options: this._auth.options
            };
          } else {
            return callback2(this._formatError('Missing credentials for "' + this._authMethod + '"', "EAUTH", false, "API"));
          }
        }
        if (this.customAuth.has(this._authMethod)) {
          let handler = this.customAuth.get(this._authMethod);
          let lastResponse;
          let returned = false;
          let resolve2 = () => {
            if (returned) {
              return;
            }
            returned = true;
            this.logger.info(
              {
                tnx: "smtp",
                username: this._auth.user,
                action: "authenticated",
                method: this._authMethod
              },
              "User %s authenticated",
              JSON.stringify(this._auth.user)
            );
            this.authenticated = true;
            callback2(null, true);
          };
          let reject = (err) => {
            if (returned) {
              return;
            }
            returned = true;
            callback2(this._formatError(err, "EAUTH", lastResponse, "AUTH " + this._authMethod));
          };
          let handlerResponse = handler({
            auth: this._auth,
            method: this._authMethod,
            extensions: [].concat(this._supportedExtensions),
            authMethods: [].concat(this._supportedAuth),
            maxAllowedSize: this._maxAllowedSize || false,
            sendCommand: (cmd, done) => {
              let promise;
              if (!done) {
                promise = new Promise((resolve3, reject2) => {
                  done = shared.callbackPromise(resolve3, reject2);
                });
              }
              this._responseActions.push((str) => {
                lastResponse = str;
                let codes = str.match(/^(\d+)(?:\s(\d+\.\d+\.\d+))?\s/);
                let data = {
                  command: cmd,
                  response: str
                };
                if (codes) {
                  data.status = Number(codes[1]) || 0;
                  if (codes[2]) {
                    data.code = codes[2];
                  }
                  data.text = str.substr(codes[0].length);
                } else {
                  data.text = str;
                  data.status = 0;
                }
                done(null, data);
              });
              setImmediate(() => this._sendCommand(cmd));
              return promise;
            },
            resolve: resolve2,
            reject
          });
          if (handlerResponse && typeof handlerResponse.catch === "function") {
            handlerResponse.then(resolve2).catch(reject);
          }
          return;
        }
        switch (this._authMethod) {
          case "XOAUTH2":
            this._handleXOauth2Token(false, callback2);
            return;
          case "LOGIN":
            this._responseActions.push((str) => {
              this._actionAUTH_LOGIN_USER(str, callback2);
            });
            this._sendCommand("AUTH LOGIN");
            return;
          case "PLAIN":
            this._responseActions.push((str) => {
              this._actionAUTHComplete(str, callback2);
            });
            this._sendCommand(
              "AUTH PLAIN " + Buffer.from(
                //this._auth.user+'\u0000'+
                "\0" + // skip authorization identity as it causes problems with some servers
                this._auth.credentials.user + "\0" + this._auth.credentials.pass,
                "utf-8"
              ).toString("base64"),
              // log entry without passwords
              "AUTH PLAIN " + Buffer.from(
                //this._auth.user+'\u0000'+
                "\0" + // skip authorization identity as it causes problems with some servers
                this._auth.credentials.user + "\0/* secret */",
                "utf-8"
              ).toString("base64")
            );
            return;
          case "CRAM-MD5":
            this._responseActions.push((str) => {
              this._actionAUTH_CRAM_MD5(str, callback2);
            });
            this._sendCommand("AUTH CRAM-MD5");
            return;
        }
        return callback2(this._formatError('Unknown authentication method "' + this._authMethod + '"', "EAUTH", false, "API"));
      }
      /**
       * Sends a message
       *
       * @param {Object} envelope Envelope object, {from: addr, to: [addr]}
       * @param {Object} message String, Buffer or a Stream
       * @param {Function} callback Callback to return once sending is completed
       */
      send(envelope, message, done) {
        if (!message) {
          return done(this._formatError("Empty message", "EMESSAGE", false, "API"));
        }
        const isDestroyedMessage = this._isDestroyedMessage("send message");
        if (isDestroyedMessage) {
          return done(this._formatError(isDestroyedMessage, "ECONNECTION", false, "API"));
        }
        if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {
          return setImmediate(() => {
            done(this._formatError("Message size larger than allowed " + this._maxAllowedSize, "EMESSAGE", false, "MAIL FROM"));
          });
        }
        let returned = false;
        let callback2 = function() {
          if (returned) {
            return;
          }
          returned = true;
          done(...arguments);
        };
        if (typeof message.on === "function") {
          message.on("error", (err) => callback2(this._formatError(err, "ESTREAM", false, "API")));
        }
        let startTime = Date.now();
        this._setEnvelope(envelope, (err, info) => {
          if (err) {
            return callback2(err);
          }
          let envelopeTime = Date.now();
          let stream = this._createSendStream((err2, str) => {
            if (err2) {
              return callback2(err2);
            }
            info.envelopeTime = envelopeTime - startTime;
            info.messageTime = Date.now() - envelopeTime;
            info.messageSize = stream.outByteCount;
            info.response = str;
            return callback2(null, info);
          });
          if (typeof message.pipe === "function") {
            message.pipe(stream);
          } else {
            stream.write(message);
            stream.end();
          }
        });
      }
      /**
       * Resets connection state
       *
       * @param {Function} callback Callback to return once connection is reset
       */
      reset(callback2) {
        this._sendCommand("RSET");
        this._responseActions.push((str) => {
          if (str.charAt(0) !== "2") {
            return callback2(this._formatError("Could not reset session state. response=" + str, "EPROTOCOL", str, "RSET"));
          }
          this._envelope = false;
          return callback2(null, true);
        });
      }
      /**
       * Connection listener that is run when the connection to
       * the server is opened
       *
       * @event
       */
      _onConnect() {
        clearTimeout(this._connectionTimeout);
        this.logger.info(
          {
            tnx: "network",
            localAddress: this._socket.localAddress,
            localPort: this._socket.localPort,
            remoteAddress: this._socket.remoteAddress,
            remotePort: this._socket.remotePort
          },
          "%s established to %s:%s",
          this.secure ? "Secure connection" : "Connection",
          this._socket.remoteAddress,
          this._socket.remotePort
        );
        if (this._destroyed) {
          this.close();
          return;
        }
        this.stage = "connected";
        this._socket.removeListener("data", this._onSocketData);
        this._socket.removeListener("timeout", this._onSocketTimeout);
        this._socket.removeListener("close", this._onSocketClose);
        this._socket.removeListener("end", this._onSocketEnd);
        this._socket.on("data", this._onSocketData);
        this._socket.once("close", this._onSocketClose);
        this._socket.once("end", this._onSocketEnd);
        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);
        this._socket.on("timeout", this._onSocketTimeout);
        this._greetingTimeout = setTimeout(() => {
          if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {
            this._onError("Greeting never received", "ETIMEDOUT", false, "CONN");
          }
        }, this.options.greetingTimeout || GREETING_TIMEOUT);
        this._responseActions.push(this._actionGreeting);
        this._socket.resume();
      }
      /**
       * 'data' listener for data coming from the server
       *
       * @event
       * @param {Buffer} chunk Data chunk coming from the server
       */
      _onData(chunk) {
        if (this._destroyed || !chunk || !chunk.length) {
          return;
        }
        let data = (chunk || "").toString("binary");
        let lines = (this._remainder + data).split(/\r?\n/);
        let lastline;
        this._remainder = lines.pop();
        for (let i = 0, len = lines.length; i < len; i++) {
          if (this._responseQueue.length) {
            lastline = this._responseQueue[this._responseQueue.length - 1];
            if (/^\d+-/.test(lastline.split("\n").pop())) {
              this._responseQueue[this._responseQueue.length - 1] += "\n" + lines[i];
              continue;
            }
          }
          this._responseQueue.push(lines[i]);
        }
        if (this._responseQueue.length) {
          lastline = this._responseQueue[this._responseQueue.length - 1];
          if (/^\d+-/.test(lastline.split("\n").pop())) {
            return;
          }
        }
        this._processResponse();
      }
      /**
       * 'error' listener for the socket
       *
       * @event
       * @param {Error} err Error object
       * @param {String} type Error name
       */
      _onError(err, type, data, command) {
        clearTimeout(this._connectionTimeout);
        clearTimeout(this._greetingTimeout);
        if (this._destroyed) {
          return;
        }
        err = this._formatError(err, type, data, command);
        this.logger.error(data, err.message);
        this.emit("error", err);
        this.close();
      }
      _formatError(message, type, response, command) {
        let err;
        if (/Error\]$/i.test(Object.prototype.toString.call(message))) {
          err = message;
        } else {
          err = new Error(message);
        }
        if (type && type !== "Error") {
          err.code = type;
        }
        if (response) {
          err.response = response;
          err.message += ": " + response;
        }
        let responseCode = typeof response === "string" && Number((response.match(/^\d+/) || [])[0]) || false;
        if (responseCode) {
          err.responseCode = responseCode;
        }
        if (command) {
          err.command = command;
        }
        return err;
      }
      /**
       * 'close' listener for the socket
       *
       * @event
       */
      _onClose() {
        let serverResponse = false;
        if (this._remainder && this._remainder.trim()) {
          if (this.options.debug || this.options.transactionLog) {
            this.logger.debug(
              {
                tnx: "server"
              },
              this._remainder.replace(/\r?\n$/, "")
            );
          }
          this.lastServerResponse = serverResponse = this._remainder.trim();
        }
        this.logger.info(
          {
            tnx: "network"
          },
          "Connection closed"
        );
        if (this.upgrading && !this._destroyed) {
          return this._onError(new Error("Connection closed unexpectedly"), "ETLS", serverResponse, "CONN");
        } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {
          return this._onError(new Error("Connection closed unexpectedly"), "ECONNECTION", serverResponse, "CONN");
        } else if (/^[45]\d{2}\b/.test(serverResponse)) {
          return this._onError(new Error("Connection closed unexpectedly"), "ECONNECTION", serverResponse, "CONN");
        }
        this._destroy();
      }
      /**
       * 'end' listener for the socket
       *
       * @event
       */
      _onEnd() {
        if (this._socket && !this._socket.destroyed) {
          this._socket.destroy();
        }
      }
      /**
       * 'timeout' listener for the socket
       *
       * @event
       */
      _onTimeout() {
        return this._onError(new Error("Timeout"), "ETIMEDOUT", false, "CONN");
      }
      /**
       * Destroys the client, emits 'end'
       */
      _destroy() {
        if (this._destroyed) {
          return;
        }
        this._destroyed = true;
        this.emit("end");
      }
      /**
       * Upgrades the connection to TLS
       *
       * @param {Function} callback Callback function to run when the connection
       *        has been secured
       */
      _upgradeConnection(callback2) {
        this._socket.removeListener("data", this._onSocketData);
        this._socket.removeListener("timeout", this._onSocketTimeout);
        let socketPlain = this._socket;
        let opts = {
          socket: this._socket,
          host: this.host
        };
        Object.keys(this.options.tls || {}).forEach((key) => {
          opts[key] = this.options.tls[key];
        });
        this.upgrading = true;
        try {
          this._socket = tls.connect(opts, () => {
            this.secure = true;
            this.upgrading = false;
            this._socket.on("data", this._onSocketData);
            socketPlain.removeListener("close", this._onSocketClose);
            socketPlain.removeListener("end", this._onSocketEnd);
            return callback2(null, true);
          });
        } catch (err) {
          return callback2(err);
        }
        this._socket.on("error", this._onSocketError);
        this._socket.once("close", this._onSocketClose);
        this._socket.once("end", this._onSocketEnd);
        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);
        this._socket.on("timeout", this._onSocketTimeout);
        socketPlain.resume();
      }
      /**
       * Processes queued responses from the server
       *
       * @param {Boolean} force If true, ignores _processing flag
       */
      _processResponse() {
        if (!this._responseQueue.length) {
          return false;
        }
        let str = this.lastServerResponse = (this._responseQueue.shift() || "").toString();
        if (/^\d+-/.test(str.split("\n").pop())) {
          return;
        }
        if (this.options.debug || this.options.transactionLog) {
          this.logger.debug(
            {
              tnx: "server"
            },
            str.replace(/\r?\n$/, "")
          );
        }
        if (!str.trim()) {
          setImmediate(() => this._processResponse());
        }
        let action = this._responseActions.shift();
        if (typeof action === "function") {
          action.call(this, str);
          setImmediate(() => this._processResponse());
        } else {
          return this._onError(new Error("Unexpected Response"), "EPROTOCOL", str, "CONN");
        }
      }
      /**
       * Send a command to the server, append \r\n
       *
       * @param {String} str String to be sent to the server
       * @param {String} logStr Optional string to be used for logging instead of the actual string
       */
      _sendCommand(str, logStr) {
        if (this._destroyed) {
          return;
        }
        if (this._socket.destroyed) {
          return this.close();
        }
        if (this.options.debug || this.options.transactionLog) {
          this.logger.debug(
            {
              tnx: "client"
            },
            (logStr || str || "").toString().replace(/\r?\n$/, "")
          );
        }
        this._socket.write(Buffer.from(str + "\r\n", "utf-8"));
      }
      /**
       * Initiates a new message by submitting envelope data, starting with
       * MAIL FROM: command
       *
       * @param {Object} envelope Envelope object in the form of
       *        {from:'...', to:['...']}
       *        or
       *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}
       */
      _setEnvelope(envelope, callback2) {
        let args = [];
        let useSmtpUtf8 = false;
        this._envelope = envelope || {};
        this._envelope.from = (this._envelope.from && this._envelope.from.address || this._envelope.from || "").toString().trim();
        this._envelope.to = [].concat(this._envelope.to || []).map((to) => (to && to.address || to || "").toString().trim());
        if (!this._envelope.to.length) {
          return callback2(this._formatError("No recipients defined", "EENVELOPE", false, "API"));
        }
        if (this._envelope.from && /[\r\n<>]/.test(this._envelope.from)) {
          return callback2(this._formatError("Invalid sender " + JSON.stringify(this._envelope.from), "EENVELOPE", false, "API"));
        }
        if (/[\x80-\uFFFF]/.test(this._envelope.from)) {
          useSmtpUtf8 = true;
        }
        for (let i = 0, len = this._envelope.to.length; i < len; i++) {
          if (!this._envelope.to[i] || /[\r\n<>]/.test(this._envelope.to[i])) {
            return callback2(this._formatError("Invalid recipient " + JSON.stringify(this._envelope.to[i]), "EENVELOPE", false, "API"));
          }
          if (/[\x80-\uFFFF]/.test(this._envelope.to[i])) {
            useSmtpUtf8 = true;
          }
        }
        this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));
        this._envelope.rejected = [];
        this._envelope.rejectedErrors = [];
        this._envelope.accepted = [];
        if (this._envelope.dsn) {
          try {
            this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);
          } catch (err) {
            return callback2(this._formatError("Invalid DSN " + err.message, "EENVELOPE", false, "API"));
          }
        }
        this._responseActions.push((str) => {
          this._actionMAIL(str, callback2);
        });
        if (useSmtpUtf8 && this._supportedExtensions.includes("SMTPUTF8")) {
          args.push("SMTPUTF8");
          this._usingSmtpUtf8 = true;
        }
        if (this._envelope.use8BitMime && this._supportedExtensions.includes("8BITMIME")) {
          args.push("BODY=8BITMIME");
          this._using8BitMime = true;
        }
        if (this._envelope.size && this._supportedExtensions.includes("SIZE")) {
          args.push("SIZE=" + this._envelope.size);
        }
        if (this._envelope.dsn && this._supportedExtensions.includes("DSN")) {
          if (this._envelope.dsn.ret) {
            args.push("RET=" + shared.encodeXText(this._envelope.dsn.ret));
          }
          if (this._envelope.dsn.envid) {
            args.push("ENVID=" + shared.encodeXText(this._envelope.dsn.envid));
          }
        }
        this._sendCommand("MAIL FROM:<" + this._envelope.from + ">" + (args.length ? " " + args.join(" ") : ""));
      }
      _setDsnEnvelope(params) {
        let ret = (params.ret || params.return || "").toString().toUpperCase() || null;
        if (ret) {
          switch (ret) {
            case "HDRS":
            case "HEADERS":
              ret = "HDRS";
              break;
            case "FULL":
            case "BODY":
              ret = "FULL";
              break;
          }
        }
        if (ret && !["FULL", "HDRS"].includes(ret)) {
          throw new Error("ret: " + JSON.stringify(ret));
        }
        let envid = (params.envid || params.id || "").toString() || null;
        let notify = params.notify || null;
        if (notify) {
          if (typeof notify === "string") {
            notify = notify.split(",");
          }
          notify = notify.map((n) => n.trim().toUpperCase());
          let validNotify = ["NEVER", "SUCCESS", "FAILURE", "DELAY"];
          let invaliNotify = notify.filter((n) => !validNotify.includes(n));
          if (invaliNotify.length || notify.length > 1 && notify.includes("NEVER")) {
            throw new Error("notify: " + JSON.stringify(notify.join(",")));
          }
          notify = notify.join(",");
        }
        let orcpt = (params.recipient || params.orcpt || "").toString() || null;
        if (orcpt && orcpt.indexOf(";") < 0) {
          orcpt = "rfc822;" + orcpt;
        }
        return {
          ret,
          envid,
          notify,
          orcpt
        };
      }
      _getDsnRcptToArgs() {
        let args = [];
        if (this._envelope.dsn && this._supportedExtensions.includes("DSN")) {
          if (this._envelope.dsn.notify) {
            args.push("NOTIFY=" + shared.encodeXText(this._envelope.dsn.notify));
          }
          if (this._envelope.dsn.orcpt) {
            args.push("ORCPT=" + shared.encodeXText(this._envelope.dsn.orcpt));
          }
        }
        return args.length ? " " + args.join(" ") : "";
      }
      _createSendStream(callback2) {
        let dataStream = new DataStream();
        let logStream;
        if (this.options.lmtp) {
          this._envelope.accepted.forEach((recipient, i) => {
            let final = i === this._envelope.accepted.length - 1;
            this._responseActions.push((str) => {
              this._actionLMTPStream(recipient, final, str, callback2);
            });
          });
        } else {
          this._responseActions.push((str) => {
            this._actionSMTPStream(str, callback2);
          });
        }
        dataStream.pipe(this._socket, {
          end: false
        });
        if (this.options.debug) {
          logStream = new PassThrough2();
          logStream.on("readable", () => {
            let chunk;
            while (chunk = logStream.read()) {
              this.logger.debug(
                {
                  tnx: "message"
                },
                chunk.toString("binary").replace(/\r?\n$/, "")
              );
            }
          });
          dataStream.pipe(logStream);
        }
        dataStream.once("end", () => {
          this.logger.info(
            {
              tnx: "message",
              inByteCount: dataStream.inByteCount,
              outByteCount: dataStream.outByteCount
            },
            "<%s bytes encoded mime message (source size %s bytes)>",
            dataStream.outByteCount,
            dataStream.inByteCount
          );
        });
        return dataStream;
      }
      /** ACTIONS **/
      /**
       * Will be run after the connection is created and the server sends
       * a greeting. If the incoming message starts with 220 initiate
       * SMTP session by sending EHLO command
       *
       * @param {String} str Message from the server
       */
      _actionGreeting(str) {
        clearTimeout(this._greetingTimeout);
        if (str.substr(0, 3) !== "220") {
          this._onError(new Error("Invalid greeting. response=" + str), "EPROTOCOL", str, "CONN");
          return;
        }
        if (this.options.lmtp) {
          this._responseActions.push(this._actionLHLO);
          this._sendCommand("LHLO " + this.name);
        } else {
          this._responseActions.push(this._actionEHLO);
          this._sendCommand("EHLO " + this.name);
        }
      }
      /**
       * Handles server response for LHLO command. If it yielded in
       * error, emit 'error', otherwise treat this as an EHLO response
       *
       * @param {String} str Message from the server
       */
      _actionLHLO(str) {
        if (str.charAt(0) !== "2") {
          this._onError(new Error("Invalid LHLO. response=" + str), "EPROTOCOL", str, "LHLO");
          return;
        }
        this._actionEHLO(str);
      }
      /**
       * Handles server response for EHLO command. If it yielded in
       * error, try HELO instead, otherwise initiate TLS negotiation
       * if STARTTLS is supported by the server or move into the
       * authentication phase.
       *
       * @param {String} str Message from the server
       */
      _actionEHLO(str) {
        let match;
        if (str.substr(0, 3) === "421") {
          this._onError(new Error("Server terminates connection. response=" + str), "ECONNECTION", str, "EHLO");
          return;
        }
        if (str.charAt(0) !== "2") {
          if (this.options.requireTLS) {
            this._onError(new Error("EHLO failed but HELO does not support required STARTTLS. response=" + str), "ECONNECTION", str, "EHLO");
            return;
          }
          this._responseActions.push(this._actionHELO);
          this._sendCommand("HELO " + this.name);
          return;
        }
        this._ehloLines = str.split(/\r?\n/).map((line) => line.replace(/^\d+[ -]/, "").trim()).filter((line) => line).slice(1);
        if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\b/im.test(str) || this.options.requireTLS)) {
          this._sendCommand("STARTTLS");
          this._responseActions.push(this._actionSTARTTLS);
          return;
        }
        if (/[ -]SMTPUTF8\b/im.test(str)) {
          this._supportedExtensions.push("SMTPUTF8");
        }
        if (/[ -]DSN\b/im.test(str)) {
          this._supportedExtensions.push("DSN");
        }
        if (/[ -]8BITMIME\b/im.test(str)) {
          this._supportedExtensions.push("8BITMIME");
        }
        if (/[ -]PIPELINING\b/im.test(str)) {
          this._supportedExtensions.push("PIPELINING");
        }
        if (/[ -]AUTH\b/i.test(str)) {
          this.allowsAuth = true;
        }
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)PLAIN/i.test(str)) {
          this._supportedAuth.push("PLAIN");
        }
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)LOGIN/i.test(str)) {
          this._supportedAuth.push("LOGIN");
        }
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)CRAM-MD5/i.test(str)) {
          this._supportedAuth.push("CRAM-MD5");
        }
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)XOAUTH2/i.test(str)) {
          this._supportedAuth.push("XOAUTH2");
        }
        if (match = str.match(/[ -]SIZE(?:[ \t]+(\d+))?/im)) {
          this._supportedExtensions.push("SIZE");
          this._maxAllowedSize = Number(match[1]) || 0;
        }
        this.emit("connect");
      }
      /**
       * Handles server response for HELO command. If it yielded in
       * error, emit 'error', otherwise move into the authentication phase.
       *
       * @param {String} str Message from the server
       */
      _actionHELO(str) {
        if (str.charAt(0) !== "2") {
          this._onError(new Error("Invalid HELO. response=" + str), "EPROTOCOL", str, "HELO");
          return;
        }
        this.allowsAuth = true;
        this.emit("connect");
      }
      /**
       * Handles server response for STARTTLS command. If there's an error
       * try HELO instead, otherwise initiate TLS upgrade. If the upgrade
       * succeedes restart the EHLO
       *
       * @param {String} str Message from the server
       */
      _actionSTARTTLS(str) {
        if (str.charAt(0) !== "2") {
          if (this.options.opportunisticTLS) {
            this.logger.info(
              {
                tnx: "smtp"
              },
              "Failed STARTTLS upgrade, continuing unencrypted"
            );
            return this.emit("connect");
          }
          this._onError(new Error("Error upgrading connection with STARTTLS"), "ETLS", str, "STARTTLS");
          return;
        }
        this._upgradeConnection((err, secured) => {
          if (err) {
            this._onError(new Error("Error initiating TLS - " + (err.message || err)), "ETLS", false, "STARTTLS");
            return;
          }
          this.logger.info(
            {
              tnx: "smtp"
            },
            "Connection upgraded with STARTTLS"
          );
          if (secured) {
            if (this.options.lmtp) {
              this._responseActions.push(this._actionLHLO);
              this._sendCommand("LHLO " + this.name);
            } else {
              this._responseActions.push(this._actionEHLO);
              this._sendCommand("EHLO " + this.name);
            }
          } else {
            this.emit("connect");
          }
        });
      }
      /**
       * Handle the response for AUTH LOGIN command. We are expecting
       * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as
       * response needs to be base64 encoded username. We do not need
       * exact match but settle with 334 response in general as some
       * hosts invalidly use a longer message than VXNlcm5hbWU6
       *
       * @param {String} str Message from the server
       */
      _actionAUTH_LOGIN_USER(str, callback2) {
        if (!/^334[ -]/.test(str)) {
          callback2(this._formatError('Invalid login sequence while waiting for "334 VXNlcm5hbWU6"', "EAUTH", str, "AUTH LOGIN"));
          return;
        }
        this._responseActions.push((str2) => {
          this._actionAUTH_LOGIN_PASS(str2, callback2);
        });
        this._sendCommand(Buffer.from(this._auth.credentials.user + "", "utf-8").toString("base64"));
      }
      /**
       * Handle the response for AUTH CRAM-MD5 command. We are expecting
       * '334 <challenge string>'. Data to be sent as response needs to be
       * base64 decoded challenge string, MD5 hashed using the password as
       * a HMAC key, prefixed by the username and a space, and finally all
       * base64 encoded again.
       *
       * @param {String} str Message from the server
       */
      _actionAUTH_CRAM_MD5(str, callback2) {
        let challengeMatch = str.match(/^334\s+(.+)$/);
        let challengeString = "";
        if (!challengeMatch) {
          return callback2(this._formatError("Invalid login sequence while waiting for server challenge string", "EAUTH", str, "AUTH CRAM-MD5"));
        } else {
          challengeString = challengeMatch[1];
        }
        let base64decoded = Buffer.from(challengeString, "base64").toString("ascii"), hmacMD5 = crypto3.createHmac("md5", this._auth.credentials.pass);
        hmacMD5.update(base64decoded);
        let prepended = this._auth.credentials.user + " " + hmacMD5.digest("hex");
        this._responseActions.push((str2) => {
          this._actionAUTH_CRAM_MD5_PASS(str2, callback2);
        });
        this._sendCommand(
          Buffer.from(prepended).toString("base64"),
          // hidden hash for logs
          Buffer.from(this._auth.credentials.user + " /* secret */").toString("base64")
        );
      }
      /**
       * Handles the response to CRAM-MD5 authentication, if there's no error,
       * the user can be considered logged in. Start waiting for a message to send
       *
       * @param {String} str Message from the server
       */
      _actionAUTH_CRAM_MD5_PASS(str, callback2) {
        if (!str.match(/^235\s+/)) {
          return callback2(this._formatError('Invalid login sequence while waiting for "235"', "EAUTH", str, "AUTH CRAM-MD5"));
        }
        this.logger.info(
          {
            tnx: "smtp",
            username: this._auth.user,
            action: "authenticated",
            method: this._authMethod
          },
          "User %s authenticated",
          JSON.stringify(this._auth.user)
        );
        this.authenticated = true;
        callback2(null, true);
      }
      /**
       * Handle the response for AUTH LOGIN command. We are expecting
       * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as
       * response needs to be base64 encoded password.
       *
       * @param {String} str Message from the server
       */
      _actionAUTH_LOGIN_PASS(str, callback2) {
        if (!/^334[ -]/.test(str)) {
          return callback2(this._formatError('Invalid login sequence while waiting for "334 UGFzc3dvcmQ6"', "EAUTH", str, "AUTH LOGIN"));
        }
        this._responseActions.push((str2) => {
          this._actionAUTHComplete(str2, callback2);
        });
        this._sendCommand(
          Buffer.from((this._auth.credentials.pass || "").toString(), "utf-8").toString("base64"),
          // Hidden pass for logs
          Buffer.from("/* secret */", "utf-8").toString("base64")
        );
      }
      /**
       * Handles the response for authentication, if there's no error,
       * the user can be considered logged in. Start waiting for a message to send
       *
       * @param {String} str Message from the server
       */
      _actionAUTHComplete(str, isRetry, callback2) {
        if (!callback2 && typeof isRetry === "function") {
          callback2 = isRetry;
          isRetry = false;
        }
        if (str.substr(0, 3) === "334") {
          this._responseActions.push((str2) => {
            if (isRetry || this._authMethod !== "XOAUTH2") {
              this._actionAUTHComplete(str2, true, callback2);
            } else {
              setImmediate(() => this._handleXOauth2Token(true, callback2));
            }
          });
          this._sendCommand("");
          return;
        }
        if (str.charAt(0) !== "2") {
          this.logger.info(
            {
              tnx: "smtp",
              username: this._auth.user,
              action: "authfail",
              method: this._authMethod
            },
            "User %s failed to authenticate",
            JSON.stringify(this._auth.user)
          );
          return callback2(this._formatError("Invalid login", "EAUTH", str, "AUTH " + this._authMethod));
        }
        this.logger.info(
          {
            tnx: "smtp",
            username: this._auth.user,
            action: "authenticated",
            method: this._authMethod
          },
          "User %s authenticated",
          JSON.stringify(this._auth.user)
        );
        this.authenticated = true;
        callback2(null, true);
      }
      /**
       * Handle response for a MAIL FROM: command
       *
       * @param {String} str Message from the server
       */
      _actionMAIL(str, callback2) {
        let message, curRecipient;
        if (Number(str.charAt(0)) !== 2) {
          if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\x80-\uFFFF]/.test(this._envelope.from)) {
            message = "Internationalized mailbox name not allowed";
          } else {
            message = "Mail command failed";
          }
          return callback2(this._formatError(message, "EENVELOPE", str, "MAIL FROM"));
        }
        if (!this._envelope.rcptQueue.length) {
          return callback2(this._formatError("Can't send mail - no recipients defined", "EENVELOPE", false, "API"));
        } else {
          this._recipientQueue = [];
          if (this._supportedExtensions.includes("PIPELINING")) {
            while (this._envelope.rcptQueue.length) {
              curRecipient = this._envelope.rcptQueue.shift();
              this._recipientQueue.push(curRecipient);
              this._responseActions.push((str2) => {
                this._actionRCPT(str2, callback2);
              });
              this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
            }
          } else {
            curRecipient = this._envelope.rcptQueue.shift();
            this._recipientQueue.push(curRecipient);
            this._responseActions.push((str2) => {
              this._actionRCPT(str2, callback2);
            });
            this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
          }
        }
      }
      /**
       * Handle response for a RCPT TO: command
       *
       * @param {String} str Message from the server
       */
      _actionRCPT(str, callback2) {
        let message, err, curRecipient = this._recipientQueue.shift();
        if (Number(str.charAt(0)) !== 2) {
          if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\x80-\uFFFF]/.test(curRecipient)) {
            message = "Internationalized mailbox name not allowed";
          } else {
            message = "Recipient command failed";
          }
          this._envelope.rejected.push(curRecipient);
          err = this._formatError(message, "EENVELOPE", str, "RCPT TO");
          err.recipient = curRecipient;
          this._envelope.rejectedErrors.push(err);
        } else {
          this._envelope.accepted.push(curRecipient);
        }
        if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {
          if (this._envelope.rejected.length < this._envelope.to.length) {
            this._responseActions.push((str2) => {
              this._actionDATA(str2, callback2);
            });
            this._sendCommand("DATA");
          } else {
            err = this._formatError("Can't send mail - all recipients were rejected", "EENVELOPE", str, "RCPT TO");
            err.rejected = this._envelope.rejected;
            err.rejectedErrors = this._envelope.rejectedErrors;
            return callback2(err);
          }
        } else if (this._envelope.rcptQueue.length) {
          curRecipient = this._envelope.rcptQueue.shift();
          this._recipientQueue.push(curRecipient);
          this._responseActions.push((str2) => {
            this._actionRCPT(str2, callback2);
          });
          this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
        }
      }
      /**
       * Handle response for a DATA command
       *
       * @param {String} str Message from the server
       */
      _actionDATA(str, callback2) {
        if (!/^[23]/.test(str)) {
          return callback2(this._formatError("Data command failed", "EENVELOPE", str, "DATA"));
        }
        let response = {
          accepted: this._envelope.accepted,
          rejected: this._envelope.rejected
        };
        if (this._ehloLines && this._ehloLines.length) {
          response.ehlo = this._ehloLines;
        }
        if (this._envelope.rejectedErrors.length) {
          response.rejectedErrors = this._envelope.rejectedErrors;
        }
        callback2(null, response);
      }
      /**
       * Handle response for a DATA stream when using SMTP
       * We expect a single response that defines if the sending succeeded or failed
       *
       * @param {String} str Message from the server
       */
      _actionSMTPStream(str, callback2) {
        if (Number(str.charAt(0)) !== 2) {
          return callback2(this._formatError("Message failed", "EMESSAGE", str, "DATA"));
        } else {
          return callback2(null, str);
        }
      }
      /**
       * Handle response for a DATA stream
       * We expect a separate response for every recipient. All recipients can either
       * succeed or fail separately
       *
       * @param {String} recipient The recipient this response applies to
       * @param {Boolean} final Is this the final recipient?
       * @param {String} str Message from the server
       */
      _actionLMTPStream(recipient, final, str, callback2) {
        let err;
        if (Number(str.charAt(0)) !== 2) {
          err = this._formatError("Message failed for recipient " + recipient, "EMESSAGE", str, "DATA");
          err.recipient = recipient;
          this._envelope.rejected.push(recipient);
          this._envelope.rejectedErrors.push(err);
          for (let i = 0, len = this._envelope.accepted.length; i < len; i++) {
            if (this._envelope.accepted[i] === recipient) {
              this._envelope.accepted.splice(i, 1);
            }
          }
        }
        if (final) {
          return callback2(null, str);
        }
      }
      _handleXOauth2Token(isRetry, callback2) {
        this._auth.oauth2.getToken(isRetry, (err, accessToken) => {
          if (err) {
            this.logger.info(
              {
                tnx: "smtp",
                username: this._auth.user,
                action: "authfail",
                method: this._authMethod
              },
              "User %s failed to authenticate",
              JSON.stringify(this._auth.user)
            );
            return callback2(this._formatError(err, "EAUTH", false, "AUTH XOAUTH2"));
          }
          this._responseActions.push((str) => {
            this._actionAUTHComplete(str, isRetry, callback2);
          });
          this._sendCommand(
            "AUTH XOAUTH2 " + this._auth.oauth2.buildXOAuth2Token(accessToken),
            //  Hidden for logs
            "AUTH XOAUTH2 " + this._auth.oauth2.buildXOAuth2Token("/* secret */")
          );
        });
      }
      /**
       *
       * @param {string} command
       * @private
       */
      _isDestroyedMessage(command) {
        if (this._destroyed) {
          return "Cannot " + command + " - smtp connection is already destroyed.";
        }
        if (this._socket) {
          if (this._socket.destroyed) {
            return "Cannot " + command + " - smtp connection socket is already destroyed.";
          }
          if (!this._socket.writable) {
            return "Cannot " + command + " - smtp connection socket is already half-closed.";
          }
        }
      }
      _getHostname() {
        let defaultHostname;
        try {
          defaultHostname = os.hostname() || "";
        } catch (err) {
          defaultHostname = "localhost";
        }
        if (!defaultHostname || defaultHostname.indexOf(".") < 0) {
          defaultHostname = "[127.0.0.1]";
        }
        if (defaultHostname.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)) {
          defaultHostname = "[" + defaultHostname + "]";
        }
        return defaultHostname;
      }
    };
    module2.exports = SMTPConnection;
  }
});

// node_modules/nodemailer/lib/xoauth2/index.js
var require_xoauth2 = __commonJS({
  "node_modules/nodemailer/lib/xoauth2/index.js"(exports, module2) {
    "use strict";
    var Stream2 = require("stream").Stream;
    var nmfetch = require_fetch();
    var crypto3 = require("crypto");
    var shared = require_shared2();
    var XOAuth2 = class extends Stream2 {
      constructor(options, logger) {
        super();
        this.options = options || {};
        if (options && options.serviceClient) {
          if (!options.privateKey || !options.user) {
            setImmediate(() => this.emit("error", new Error('Options "privateKey" and "user" are required for service account!')));
            return;
          }
          let serviceRequestTimeout = Math.min(Math.max(Number(this.options.serviceRequestTimeout) || 0, 0), 3600);
          this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;
        }
        this.logger = shared.getLogger(
          {
            logger
          },
          {
            component: this.options.component || "OAuth2"
          }
        );
        this.provisionCallback = typeof this.options.provisionCallback === "function" ? this.options.provisionCallback : false;
        this.options.accessUrl = this.options.accessUrl || "https://accounts.google.com/o/oauth2/token";
        this.options.customHeaders = this.options.customHeaders || {};
        this.options.customParams = this.options.customParams || {};
        this.accessToken = this.options.accessToken || false;
        if (this.options.expires && Number(this.options.expires)) {
          this.expires = this.options.expires;
        } else {
          let timeout = Math.max(Number(this.options.timeout) || 0, 0);
          this.expires = timeout && Date.now() + timeout * 1e3 || 0;
        }
      }
      /**
       * Returns or generates (if previous has expired) a XOAuth2 token
       *
       * @param {Boolean} renew If false then use cached access token (if available)
       * @param {Function} callback Callback function with error object and token string
       */
      getToken(renew, callback2) {
        if (!renew && this.accessToken && (!this.expires || this.expires > Date.now())) {
          return callback2(null, this.accessToken);
        }
        let generateCallback = (...args) => {
          if (args[0]) {
            this.logger.error(
              {
                err: args[0],
                tnx: "OAUTH2",
                user: this.options.user,
                action: "renew"
              },
              "Failed generating new Access Token for %s",
              this.options.user
            );
          } else {
            this.logger.info(
              {
                tnx: "OAUTH2",
                user: this.options.user,
                action: "renew"
              },
              "Generated new Access Token for %s",
              this.options.user
            );
          }
          callback2(...args);
        };
        if (this.provisionCallback) {
          this.provisionCallback(this.options.user, !!renew, (err, accessToken, expires) => {
            if (!err && accessToken) {
              this.accessToken = accessToken;
              this.expires = expires || 0;
            }
            generateCallback(err, accessToken);
          });
        } else {
          this.generateToken(generateCallback);
        }
      }
      /**
       * Updates token values
       *
       * @param {String} accessToken New access token
       * @param {Number} timeout Access token lifetime in seconds
       *
       * Emits 'token': { user: User email-address, accessToken: the new accessToken, timeout: TTL in seconds}
       */
      updateToken(accessToken, timeout) {
        this.accessToken = accessToken;
        timeout = Math.max(Number(timeout) || 0, 0);
        this.expires = timeout && Date.now() + timeout * 1e3 || 0;
        this.emit("token", {
          user: this.options.user,
          accessToken: accessToken || "",
          expires: this.expires
        });
      }
      /**
       * Generates a new XOAuth2 token with the credentials provided at initialization
       *
       * @param {Function} callback Callback function with error object and token string
       */
      generateToken(callback2) {
        let urlOptions;
        let loggedUrlOptions;
        if (this.options.serviceClient) {
          let iat = Math.floor(Date.now() / 1e3);
          let tokenData = {
            iss: this.options.serviceClient,
            scope: this.options.scope || "https://mail.google.com/",
            sub: this.options.user,
            aud: this.options.accessUrl,
            iat,
            exp: iat + this.options.serviceRequestTimeout
          };
          let token;
          try {
            token = this.jwtSignRS256(tokenData);
          } catch (err) {
            return callback2(new Error("Can't generate token. Check your auth options"));
          }
          urlOptions = {
            grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
            assertion: token
          };
          loggedUrlOptions = {
            grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
            assertion: tokenData
          };
        } else {
          if (!this.options.refreshToken) {
            return callback2(new Error("Can't create new access token for user"));
          }
          urlOptions = {
            client_id: this.options.clientId || "",
            client_secret: this.options.clientSecret || "",
            refresh_token: this.options.refreshToken,
            grant_type: "refresh_token"
          };
          loggedUrlOptions = {
            client_id: this.options.clientId || "",
            client_secret: (this.options.clientSecret || "").substr(0, 6) + "...",
            refresh_token: (this.options.refreshToken || "").substr(0, 6) + "...",
            grant_type: "refresh_token"
          };
        }
        Object.keys(this.options.customParams).forEach((key) => {
          urlOptions[key] = this.options.customParams[key];
          loggedUrlOptions[key] = this.options.customParams[key];
        });
        this.logger.debug(
          {
            tnx: "OAUTH2",
            user: this.options.user,
            action: "generate"
          },
          "Requesting token using: %s",
          JSON.stringify(loggedUrlOptions)
        );
        this.postRequest(this.options.accessUrl, urlOptions, this.options, (error, body) => {
          let data;
          if (error) {
            return callback2(error);
          }
          try {
            data = JSON.parse(body.toString());
          } catch (E) {
            return callback2(E);
          }
          if (!data || typeof data !== "object") {
            this.logger.debug(
              {
                tnx: "OAUTH2",
                user: this.options.user,
                action: "post"
              },
              "Response: %s",
              (body || "").toString()
            );
            return callback2(new Error("Invalid authentication response"));
          }
          let logData = {};
          Object.keys(data).forEach((key) => {
            if (key !== "access_token") {
              logData[key] = data[key];
            } else {
              logData[key] = (data[key] || "").toString().substr(0, 6) + "...";
            }
          });
          this.logger.debug(
            {
              tnx: "OAUTH2",
              user: this.options.user,
              action: "post"
            },
            "Response: %s",
            JSON.stringify(logData)
          );
          if (data.error) {
            let errorMessage = data.error;
            if (data.error_description) {
              errorMessage += ": " + data.error_description;
            }
            if (data.error_uri) {
              errorMessage += " (" + data.error_uri + ")";
            }
            return callback2(new Error(errorMessage));
          }
          if (data.access_token) {
            this.updateToken(data.access_token, data.expires_in);
            return callback2(null, this.accessToken);
          }
          return callback2(new Error("No access token"));
        });
      }
      /**
       * Converts an access_token and user id into a base64 encoded XOAuth2 token
       *
       * @param {String} [accessToken] Access token string
       * @return {String} Base64 encoded token for IMAP or SMTP login
       */
      buildXOAuth2Token(accessToken) {
        let authData = ["user=" + (this.options.user || ""), "auth=Bearer " + (accessToken || this.accessToken), "", ""];
        return Buffer.from(authData.join(""), "utf-8").toString("base64");
      }
      /**
       * Custom POST request handler.
       * This is only needed to keep paths short in Windows  usually this module
       * is a dependency of a dependency and if it tries to require something
       * like the request module the paths get way too long to handle for Windows.
       * As we do only a simple POST request we do not actually require complicated
       * logic support (no redirects, no nothing) anyway.
       *
       * @param {String} url Url to POST to
       * @param {String|Buffer} payload Payload to POST
       * @param {Function} callback Callback function with (err, buff)
       */
      postRequest(url, payload, params, callback2) {
        let returned = false;
        let chunks = [];
        let chunklen = 0;
        let req = nmfetch(url, {
          method: "post",
          headers: params.customHeaders,
          body: payload,
          allowErrorResponse: true
        });
        req.on("readable", () => {
          let chunk;
          while ((chunk = req.read()) !== null) {
            chunks.push(chunk);
            chunklen += chunk.length;
          }
        });
        req.once("error", (err) => {
          if (returned) {
            return;
          }
          returned = true;
          return callback2(err);
        });
        req.once("end", () => {
          if (returned) {
            return;
          }
          returned = true;
          return callback2(null, Buffer.concat(chunks, chunklen));
        });
      }
      /**
       * Encodes a buffer or a string into Base64url format
       *
       * @param {Buffer|String} data The data to convert
       * @return {String} The encoded string
       */
      toBase64URL(data) {
        if (typeof data === "string") {
          data = Buffer.from(data);
        }
        return data.toString("base64").replace(/[=]+/g, "").replace(/\+/g, "-").replace(/\//g, "_");
      }
      /**
       * Creates a JSON Web Token signed with RS256 (SHA256 + RSA)
       *
       * @param {Object} payload The payload to include in the generated token
       * @return {String} The generated and signed token
       */
      jwtSignRS256(payload) {
        payload = ['{"alg":"RS256","typ":"JWT"}', JSON.stringify(payload)].map((val) => this.toBase64URL(val)).join(".");
        let signature = crypto3.createSign("RSA-SHA256").update(payload).sign(this.options.privateKey);
        return payload + "." + this.toBase64URL(signature);
      }
    };
    module2.exports = XOAuth2;
  }
});

// node_modules/nodemailer/lib/smtp-pool/pool-resource.js
var require_pool_resource = __commonJS({
  "node_modules/nodemailer/lib/smtp-pool/pool-resource.js"(exports, module2) {
    "use strict";
    var SMTPConnection = require_smtp_connection();
    var assign2 = require_shared2().assign;
    var XOAuth2 = require_xoauth2();
    var EventEmitter = require("events");
    var PoolResource = class extends EventEmitter {
      constructor(pool) {
        super();
        this.pool = pool;
        this.options = pool.options;
        this.logger = this.pool.logger;
        if (this.options.auth) {
          switch ((this.options.auth.type || "").toString().toUpperCase()) {
            case "OAUTH2": {
              let oauth2 = new XOAuth2(this.options.auth, this.logger);
              oauth2.provisionCallback = this.pool.mailer && this.pool.mailer.get("oauth2_provision_cb") || oauth2.provisionCallback;
              this.auth = {
                type: "OAUTH2",
                user: this.options.auth.user,
                oauth2,
                method: "XOAUTH2"
              };
              oauth2.on("token", (token) => this.pool.mailer.emit("token", token));
              oauth2.on("error", (err) => this.emit("error", err));
              break;
            }
            default:
              if (!this.options.auth.user && !this.options.auth.pass) {
                break;
              }
              this.auth = {
                type: (this.options.auth.type || "").toString().toUpperCase() || "LOGIN",
                user: this.options.auth.user,
                credentials: {
                  user: this.options.auth.user || "",
                  pass: this.options.auth.pass,
                  options: this.options.auth.options
                },
                method: (this.options.auth.method || "").trim().toUpperCase() || this.options.authMethod || false
              };
          }
        }
        this._connection = false;
        this._connected = false;
        this.messages = 0;
        this.available = true;
      }
      /**
       * Initiates a connection to the SMTP server
       *
       * @param {Function} callback Callback function to run once the connection is established or failed
       */
      connect(callback2) {
        this.pool.getSocket(this.options, (err, socketOptions) => {
          if (err) {
            return callback2(err);
          }
          let returned = false;
          let options = this.options;
          if (socketOptions && socketOptions.connection) {
            this.logger.info(
              {
                tnx: "proxy",
                remoteAddress: socketOptions.connection.remoteAddress,
                remotePort: socketOptions.connection.remotePort,
                destHost: options.host || "",
                destPort: options.port || "",
                action: "connected"
              },
              "Using proxied socket from %s:%s to %s:%s",
              socketOptions.connection.remoteAddress,
              socketOptions.connection.remotePort,
              options.host || "",
              options.port || ""
            );
            options = assign2(false, options);
            Object.keys(socketOptions).forEach((key) => {
              options[key] = socketOptions[key];
            });
          }
          this.connection = new SMTPConnection(options);
          this.connection.once("error", (err2) => {
            this.emit("error", err2);
            if (returned) {
              return;
            }
            returned = true;
            return callback2(err2);
          });
          this.connection.once("end", () => {
            this.close();
            if (returned) {
              return;
            }
            returned = true;
            let timer = setTimeout(() => {
              if (returned) {
                return;
              }
              let err2 = new Error("Unexpected socket close");
              if (this.connection && this.connection._socket && this.connection._socket.upgrading) {
                err2.code = "ETLS";
              }
              callback2(err2);
            }, 1e3);
            try {
              timer.unref();
            } catch (E) {
            }
          });
          this.connection.connect(() => {
            if (returned) {
              return;
            }
            if (this.auth && (this.connection.allowsAuth || options.forceAuth)) {
              this.connection.login(this.auth, (err2) => {
                if (returned) {
                  return;
                }
                returned = true;
                if (err2) {
                  this.connection.close();
                  this.emit("error", err2);
                  return callback2(err2);
                }
                this._connected = true;
                callback2(null, true);
              });
            } else {
              returned = true;
              this._connected = true;
              return callback2(null, true);
            }
          });
        });
      }
      /**
       * Sends an e-mail to be sent using the selected settings
       *
       * @param {Object} mail Mail object
       * @param {Function} callback Callback function
       */
      send(mail, callback2) {
        if (!this._connected) {
          return this.connect((err) => {
            if (err) {
              return callback2(err);
            }
            return this.send(mail, callback2);
          });
        }
        let envelope = mail.message.getEnvelope();
        let messageId = mail.message.messageId();
        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
          recipients.push("...and " + recipients.splice(2).length + " more");
        }
        this.logger.info(
          {
            tnx: "send",
            messageId,
            cid: this.id
          },
          "Sending message %s using #%s to <%s>",
          messageId,
          this.id,
          recipients.join(", ")
        );
        if (mail.data.dsn) {
          envelope.dsn = mail.data.dsn;
        }
        this.connection.send(envelope, mail.message.createReadStream(), (err, info) => {
          this.messages++;
          if (err) {
            this.connection.close();
            this.emit("error", err);
            return callback2(err);
          }
          info.envelope = {
            from: envelope.from,
            to: envelope.to
          };
          info.messageId = messageId;
          setImmediate(() => {
            let err2;
            if (this.messages >= this.options.maxMessages) {
              err2 = new Error("Resource exhausted");
              err2.code = "EMAXLIMIT";
              this.connection.close();
              this.emit("error", err2);
            } else {
              this.pool._checkRateLimit(() => {
                this.available = true;
                this.emit("available");
              });
            }
          });
          callback2(null, info);
        });
      }
      /**
       * Closes the connection
       */
      close() {
        this._connected = false;
        if (this.auth && this.auth.oauth2) {
          this.auth.oauth2.removeAllListeners();
        }
        if (this.connection) {
          this.connection.close();
        }
        this.emit("close");
      }
    };
    module2.exports = PoolResource;
  }
});

// node_modules/nodemailer/lib/well-known/services.json
var require_services = __commonJS({
  "node_modules/nodemailer/lib/well-known/services.json"(exports, module2) {
    module2.exports = {
      "1und1": {
        host: "smtp.1und1.de",
        port: 465,
        secure: true,
        authMethod: "LOGIN"
      },
      Aliyun: {
        domains: ["aliyun.com"],
        host: "smtp.aliyun.com",
        port: 465,
        secure: true
      },
      AOL: {
        domains: ["aol.com"],
        host: "smtp.aol.com",
        port: 587
      },
      Bluewin: {
        host: "smtpauths.bluewin.ch",
        domains: ["bluewin.ch"],
        port: 465
      },
      DebugMail: {
        host: "debugmail.io",
        port: 25
      },
      DynectEmail: {
        aliases: ["Dynect"],
        host: "smtp.dynect.net",
        port: 25
      },
      Ethereal: {
        aliases: ["ethereal.email"],
        host: "smtp.ethereal.email",
        port: 587
      },
      FastMail: {
        domains: ["fastmail.fm"],
        host: "smtp.fastmail.com",
        port: 465,
        secure: true
      },
      "Forward Email": {
        aliases: ["FE", "ForwardEmail"],
        domains: ["forwardemail.net"],
        host: "smtp.forwardemail.net",
        port: 465,
        secure: true
      },
      GandiMail: {
        aliases: ["Gandi", "Gandi Mail"],
        host: "mail.gandi.net",
        port: 587
      },
      Gmail: {
        aliases: ["Google Mail"],
        domains: ["gmail.com", "googlemail.com"],
        host: "smtp.gmail.com",
        port: 465,
        secure: true
      },
      Godaddy: {
        host: "smtpout.secureserver.net",
        port: 25
      },
      GodaddyAsia: {
        host: "smtp.asia.secureserver.net",
        port: 25
      },
      GodaddyEurope: {
        host: "smtp.europe.secureserver.net",
        port: 25
      },
      "hot.ee": {
        host: "mail.hot.ee"
      },
      Hotmail: {
        aliases: ["Outlook", "Outlook.com", "Hotmail.com"],
        domains: ["hotmail.com", "outlook.com"],
        host: "smtp-mail.outlook.com",
        port: 587
      },
      iCloud: {
        aliases: ["Me", "Mac"],
        domains: ["me.com", "mac.com"],
        host: "smtp.mail.me.com",
        port: 587
      },
      Infomaniak: {
        host: "mail.infomaniak.com",
        domains: ["ik.me", "ikmail.com", "etik.com"],
        port: 587
      },
      "mail.ee": {
        host: "smtp.mail.ee"
      },
      "Mail.ru": {
        host: "smtp.mail.ru",
        port: 465,
        secure: true
      },
      "Mailcatch.app": {
        host: "sandbox-smtp.mailcatch.app",
        port: 2525
      },
      Maildev: {
        port: 1025,
        ignoreTLS: true
      },
      Mailgun: {
        host: "smtp.mailgun.org",
        port: 465,
        secure: true
      },
      Mailjet: {
        host: "in.mailjet.com",
        port: 587
      },
      Mailosaur: {
        host: "mailosaur.io",
        port: 25
      },
      Mailtrap: {
        host: "smtp.mailtrap.io",
        port: 2525
      },
      Mandrill: {
        host: "smtp.mandrillapp.com",
        port: 587
      },
      Naver: {
        host: "smtp.naver.com",
        port: 587
      },
      One: {
        host: "send.one.com",
        port: 465,
        secure: true
      },
      OpenMailBox: {
        aliases: ["OMB", "openmailbox.org"],
        host: "smtp.openmailbox.org",
        port: 465,
        secure: true
      },
      Outlook365: {
        host: "smtp.office365.com",
        port: 587,
        secure: false
      },
      OhMySMTP: {
        host: "smtp.ohmysmtp.com",
        port: 587,
        secure: false
      },
      Postmark: {
        aliases: ["PostmarkApp"],
        host: "smtp.postmarkapp.com",
        port: 2525
      },
      "qiye.aliyun": {
        host: "smtp.mxhichina.com",
        port: "465",
        secure: true
      },
      QQ: {
        domains: ["qq.com"],
        host: "smtp.qq.com",
        port: 465,
        secure: true
      },
      QQex: {
        aliases: ["QQ Enterprise"],
        domains: ["exmail.qq.com"],
        host: "smtp.exmail.qq.com",
        port: 465,
        secure: true
      },
      SendCloud: {
        host: "smtp.sendcloud.net",
        port: 2525
      },
      SendGrid: {
        host: "smtp.sendgrid.net",
        port: 587
      },
      SendinBlue: {
        aliases: ["Brevo"],
        host: "smtp-relay.brevo.com",
        port: 587
      },
      SendPulse: {
        host: "smtp-pulse.com",
        port: 465,
        secure: true
      },
      SES: {
        host: "email-smtp.us-east-1.amazonaws.com",
        port: 465,
        secure: true
      },
      "SES-US-EAST-1": {
        host: "email-smtp.us-east-1.amazonaws.com",
        port: 465,
        secure: true
      },
      "SES-US-WEST-2": {
        host: "email-smtp.us-west-2.amazonaws.com",
        port: 465,
        secure: true
      },
      "SES-EU-WEST-1": {
        host: "email-smtp.eu-west-1.amazonaws.com",
        port: 465,
        secure: true
      },
      "SES-AP-SOUTH-1": {
        host: "email-smtp.ap-south-1.amazonaws.com",
        port: 465,
        secure: true
      },
      "SES-AP-NORTHEAST-1": {
        host: "email-smtp.ap-northeast-1.amazonaws.com",
        port: 465,
        secure: true
      },
      "SES-AP-NORTHEAST-2": {
        host: "email-smtp.ap-northeast-2.amazonaws.com",
        port: 465,
        secure: true
      },
      "SES-AP-NORTHEAST-3": {
        host: "email-smtp.ap-northeast-3.amazonaws.com",
        port: 465,
        secure: true
      },
      "SES-AP-SOUTHEAST-1": {
        host: "email-smtp.ap-southeast-1.amazonaws.com",
        port: 465,
        secure: true
      },
      "SES-AP-SOUTHEAST-2": {
        host: "email-smtp.ap-southeast-2.amazonaws.com",
        port: 465,
        secure: true
      },
      Sparkpost: {
        aliases: ["SparkPost", "SparkPost Mail"],
        domains: ["sparkpost.com"],
        host: "smtp.sparkpostmail.com",
        port: 587,
        secure: false
      },
      Tipimail: {
        host: "smtp.tipimail.com",
        port: 587
      },
      Yahoo: {
        domains: ["yahoo.com"],
        host: "smtp.mail.yahoo.com",
        port: 465,
        secure: true
      },
      Yandex: {
        domains: ["yandex.ru"],
        host: "smtp.yandex.ru",
        port: 465,
        secure: true
      },
      Zoho: {
        host: "smtp.zoho.com",
        port: 465,
        secure: true,
        authMethod: "LOGIN"
      },
      "126": {
        host: "smtp.126.com",
        port: 465,
        secure: true
      },
      "163": {
        host: "smtp.163.com",
        port: 465,
        secure: true
      }
    };
  }
});

// node_modules/nodemailer/lib/well-known/index.js
var require_well_known = __commonJS({
  "node_modules/nodemailer/lib/well-known/index.js"(exports, module2) {
    "use strict";
    var services = require_services();
    var normalized = {};
    Object.keys(services).forEach((key) => {
      let service = services[key];
      normalized[normalizeKey(key)] = normalizeService(service);
      [].concat(service.aliases || []).forEach((alias) => {
        normalized[normalizeKey(alias)] = normalizeService(service);
      });
      [].concat(service.domains || []).forEach((domain) => {
        normalized[normalizeKey(domain)] = normalizeService(service);
      });
    });
    function normalizeKey(key) {
      return key.replace(/[^a-zA-Z0-9.-]/g, "").toLowerCase();
    }
    function normalizeService(service) {
      let filter3 = ["domains", "aliases"];
      let response = {};
      Object.keys(service).forEach((key) => {
        if (filter3.indexOf(key) < 0) {
          response[key] = service[key];
        }
      });
      return response;
    }
    module2.exports = function(key) {
      key = normalizeKey(key.split("@").pop());
      return normalized[key] || false;
    };
  }
});

// node_modules/nodemailer/lib/smtp-pool/index.js
var require_smtp_pool = __commonJS({
  "node_modules/nodemailer/lib/smtp-pool/index.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var PoolResource = require_pool_resource();
    var SMTPConnection = require_smtp_connection();
    var wellKnown = require_well_known();
    var shared = require_shared2();
    var packageData = require_package2();
    var SMTPPool = class extends EventEmitter {
      constructor(options) {
        super();
        options = options || {};
        if (typeof options === "string") {
          options = {
            url: options
          };
        }
        let urlData;
        let service = options.service;
        if (typeof options.getSocket === "function") {
          this.getSocket = options.getSocket;
        }
        if (options.url) {
          urlData = shared.parseConnectionUrl(options.url);
          service = service || urlData.service;
        }
        this.options = shared.assign(
          false,
          // create new object
          options,
          // regular options
          urlData,
          // url options
          service && wellKnown(service)
          // wellknown options
        );
        this.options.maxConnections = this.options.maxConnections || 5;
        this.options.maxMessages = this.options.maxMessages || 100;
        this.logger = shared.getLogger(this.options, {
          component: this.options.component || "smtp-pool"
        });
        let connection = new SMTPConnection(this.options);
        this.name = "SMTP (pool)";
        this.version = packageData.version + "[client:" + connection.version + "]";
        this._rateLimit = {
          counter: 0,
          timeout: null,
          waiting: [],
          checkpoint: false,
          delta: Number(this.options.rateDelta) || 1e3,
          limit: Number(this.options.rateLimit) || 0
        };
        this._closed = false;
        this._queue = [];
        this._connections = [];
        this._connectionCounter = 0;
        this.idling = true;
        setImmediate(() => {
          if (this.idling) {
            this.emit("idle");
          }
        });
      }
      /**
       * Placeholder function for creating proxy sockets. This method immediatelly returns
       * without a socket
       *
       * @param {Object} options Connection options
       * @param {Function} callback Callback function to run with the socket keys
       */
      getSocket(options, callback2) {
        return setImmediate(() => callback2(null, false));
      }
      /**
       * Queues an e-mail to be sent using the selected settings
       *
       * @param {Object} mail Mail object
       * @param {Function} callback Callback function
       */
      send(mail, callback2) {
        if (this._closed) {
          return false;
        }
        this._queue.push({
          mail,
          requeueAttempts: 0,
          callback: callback2
        });
        if (this.idling && this._queue.length >= this.options.maxConnections) {
          this.idling = false;
        }
        setImmediate(() => this._processMessages());
        return true;
      }
      /**
       * Closes all connections in the pool. If there is a message being sent, the connection
       * is closed later
       */
      close() {
        let connection;
        let len = this._connections.length;
        this._closed = true;
        clearTimeout(this._rateLimit.timeout);
        if (!len && !this._queue.length) {
          return;
        }
        for (let i = len - 1; i >= 0; i--) {
          if (this._connections[i] && this._connections[i].available) {
            connection = this._connections[i];
            connection.close();
            this.logger.info(
              {
                tnx: "connection",
                cid: connection.id,
                action: "removed"
              },
              "Connection #%s removed",
              connection.id
            );
          }
        }
        if (len && !this._connections.length) {
          this.logger.debug(
            {
              tnx: "connection"
            },
            "All connections removed"
          );
        }
        if (!this._queue.length) {
          return;
        }
        let invokeCallbacks = () => {
          if (!this._queue.length) {
            this.logger.debug(
              {
                tnx: "connection"
              },
              "Pending queue entries cleared"
            );
            return;
          }
          let entry = this._queue.shift();
          if (entry && typeof entry.callback === "function") {
            try {
              entry.callback(new Error("Connection pool was closed"));
            } catch (E) {
              this.logger.error(
                {
                  err: E,
                  tnx: "callback",
                  cid: connection.id
                },
                "Callback error for #%s: %s",
                connection.id,
                E.message
              );
            }
          }
          setImmediate(invokeCallbacks);
        };
        setImmediate(invokeCallbacks);
      }
      /**
       * Check the queue and available connections. If there is a message to be sent and there is
       * an available connection, then use this connection to send the mail
       */
      _processMessages() {
        let connection;
        let i, len;
        if (this._closed) {
          return;
        }
        if (!this._queue.length) {
          if (!this.idling) {
            this.idling = true;
            this.emit("idle");
          }
          return;
        }
        for (i = 0, len = this._connections.length; i < len; i++) {
          if (this._connections[i].available) {
            connection = this._connections[i];
            break;
          }
        }
        if (!connection && this._connections.length < this.options.maxConnections) {
          connection = this._createConnection();
        }
        if (!connection) {
          this.idling = false;
          return;
        }
        if (!this.idling && this._queue.length < this.options.maxConnections) {
          this.idling = true;
          this.emit("idle");
        }
        let entry = connection.queueEntry = this._queue.shift();
        entry.messageId = (connection.queueEntry.mail.message.getHeader("message-id") || "").replace(/[<>\s]/g, "");
        connection.available = false;
        this.logger.debug(
          {
            tnx: "pool",
            cid: connection.id,
            messageId: entry.messageId,
            action: "assign"
          },
          "Assigned message <%s> to #%s (%s)",
          entry.messageId,
          connection.id,
          connection.messages + 1
        );
        if (this._rateLimit.limit) {
          this._rateLimit.counter++;
          if (!this._rateLimit.checkpoint) {
            this._rateLimit.checkpoint = Date.now();
          }
        }
        connection.send(entry.mail, (err, info) => {
          if (entry === connection.queueEntry) {
            try {
              entry.callback(err, info);
            } catch (E) {
              this.logger.error(
                {
                  err: E,
                  tnx: "callback",
                  cid: connection.id
                },
                "Callback error for #%s: %s",
                connection.id,
                E.message
              );
            }
            connection.queueEntry = false;
          }
        });
      }
      /**
       * Creates a new pool resource
       */
      _createConnection() {
        let connection = new PoolResource(this);
        connection.id = ++this._connectionCounter;
        this.logger.info(
          {
            tnx: "pool",
            cid: connection.id,
            action: "conection"
          },
          "Created new pool resource #%s",
          connection.id
        );
        connection.on("available", () => {
          this.logger.debug(
            {
              tnx: "connection",
              cid: connection.id,
              action: "available"
            },
            "Connection #%s became available",
            connection.id
          );
          if (this._closed) {
            this.close();
          } else {
            this._processMessages();
          }
        });
        connection.once("error", (err) => {
          if (err.code !== "EMAXLIMIT") {
            this.logger.error(
              {
                err,
                tnx: "pool",
                cid: connection.id
              },
              "Pool Error for #%s: %s",
              connection.id,
              err.message
            );
          } else {
            this.logger.debug(
              {
                tnx: "pool",
                cid: connection.id,
                action: "maxlimit"
              },
              "Max messages limit exchausted for #%s",
              connection.id
            );
          }
          if (connection.queueEntry) {
            try {
              connection.queueEntry.callback(err);
            } catch (E) {
              this.logger.error(
                {
                  err: E,
                  tnx: "callback",
                  cid: connection.id
                },
                "Callback error for #%s: %s",
                connection.id,
                E.message
              );
            }
            connection.queueEntry = false;
          }
          this._removeConnection(connection);
          this._continueProcessing();
        });
        connection.once("close", () => {
          this.logger.info(
            {
              tnx: "connection",
              cid: connection.id,
              action: "closed"
            },
            "Connection #%s was closed",
            connection.id
          );
          this._removeConnection(connection);
          if (connection.queueEntry) {
            setTimeout(() => {
              if (connection.queueEntry) {
                if (this._shouldRequeuOnConnectionClose(connection.queueEntry)) {
                  this._requeueEntryOnConnectionClose(connection);
                } else {
                  this._failDeliveryOnConnectionClose(connection);
                }
              }
              this._continueProcessing();
            }, 50);
          } else {
            this._continueProcessing();
          }
        });
        this._connections.push(connection);
        return connection;
      }
      _shouldRequeuOnConnectionClose(queueEntry) {
        if (this.options.maxRequeues === void 0 || this.options.maxRequeues < 0) {
          return true;
        }
        return queueEntry.requeueAttempts < this.options.maxRequeues;
      }
      _failDeliveryOnConnectionClose(connection) {
        if (connection.queueEntry && connection.queueEntry.callback) {
          try {
            connection.queueEntry.callback(new Error("Reached maximum number of retries after connection was closed"));
          } catch (E) {
            this.logger.error(
              {
                err: E,
                tnx: "callback",
                messageId: connection.queueEntry.messageId,
                cid: connection.id
              },
              "Callback error for #%s: %s",
              connection.id,
              E.message
            );
          }
          connection.queueEntry = false;
        }
      }
      _requeueEntryOnConnectionClose(connection) {
        connection.queueEntry.requeueAttempts = connection.queueEntry.requeueAttempts + 1;
        this.logger.debug(
          {
            tnx: "pool",
            cid: connection.id,
            messageId: connection.queueEntry.messageId,
            action: "requeue"
          },
          "Re-queued message <%s> for #%s. Attempt: #%s",
          connection.queueEntry.messageId,
          connection.id,
          connection.queueEntry.requeueAttempts
        );
        this._queue.unshift(connection.queueEntry);
        connection.queueEntry = false;
      }
      /**
       * Continue to process message if the pool hasn't closed
       */
      _continueProcessing() {
        if (this._closed) {
          this.close();
        } else {
          setTimeout(() => this._processMessages(), 100);
        }
      }
      /**
       * Remove resource from pool
       *
       * @param {Object} connection The PoolResource to remove
       */
      _removeConnection(connection) {
        let index2 = this._connections.indexOf(connection);
        if (index2 !== -1) {
          this._connections.splice(index2, 1);
        }
      }
      /**
       * Checks if connections have hit current rate limit and if so, queues the availability callback
       *
       * @param {Function} callback Callback function to run once rate limiter has been cleared
       */
      _checkRateLimit(callback2) {
        if (!this._rateLimit.limit) {
          return callback2();
        }
        let now2 = Date.now();
        if (this._rateLimit.counter < this._rateLimit.limit) {
          return callback2();
        }
        this._rateLimit.waiting.push(callback2);
        if (this._rateLimit.checkpoint <= now2 - this._rateLimit.delta) {
          return this._clearRateLimit();
        } else if (!this._rateLimit.timeout) {
          this._rateLimit.timeout = setTimeout(() => this._clearRateLimit(), this._rateLimit.delta - (now2 - this._rateLimit.checkpoint));
          this._rateLimit.checkpoint = now2;
        }
      }
      /**
       * Clears current rate limit limitation and runs paused callback
       */
      _clearRateLimit() {
        clearTimeout(this._rateLimit.timeout);
        this._rateLimit.timeout = null;
        this._rateLimit.counter = 0;
        this._rateLimit.checkpoint = false;
        while (this._rateLimit.waiting.length) {
          let cb = this._rateLimit.waiting.shift();
          setImmediate(cb);
        }
      }
      /**
       * Returns true if there are free slots in the queue
       */
      isIdle() {
        return this.idling;
      }
      /**
       * Verifies SMTP configuration
       *
       * @param {Function} callback Callback function
       */
      verify(callback2) {
        let promise;
        if (!callback2) {
          promise = new Promise((resolve2, reject) => {
            callback2 = shared.callbackPromise(resolve2, reject);
          });
        }
        let auth = new PoolResource(this).auth;
        this.getSocket(this.options, (err, socketOptions) => {
          if (err) {
            return callback2(err);
          }
          let options = this.options;
          if (socketOptions && socketOptions.connection) {
            this.logger.info(
              {
                tnx: "proxy",
                remoteAddress: socketOptions.connection.remoteAddress,
                remotePort: socketOptions.connection.remotePort,
                destHost: options.host || "",
                destPort: options.port || "",
                action: "connected"
              },
              "Using proxied socket from %s:%s to %s:%s",
              socketOptions.connection.remoteAddress,
              socketOptions.connection.remotePort,
              options.host || "",
              options.port || ""
            );
            options = shared.assign(false, options);
            Object.keys(socketOptions).forEach((key) => {
              options[key] = socketOptions[key];
            });
          }
          let connection = new SMTPConnection(options);
          let returned = false;
          connection.once("error", (err2) => {
            if (returned) {
              return;
            }
            returned = true;
            connection.close();
            return callback2(err2);
          });
          connection.once("end", () => {
            if (returned) {
              return;
            }
            returned = true;
            return callback2(new Error("Connection closed"));
          });
          let finalize = () => {
            if (returned) {
              return;
            }
            returned = true;
            connection.quit();
            return callback2(null, true);
          };
          connection.connect(() => {
            if (returned) {
              return;
            }
            if (auth && (connection.allowsAuth || options.forceAuth)) {
              connection.login(auth, (err2) => {
                if (returned) {
                  return;
                }
                if (err2) {
                  returned = true;
                  connection.close();
                  return callback2(err2);
                }
                finalize();
              });
            } else if (!auth && connection.allowsAuth && options.forceAuth) {
              let err2 = new Error("Authentication info was not provided");
              err2.code = "NoAuth";
              returned = true;
              connection.close();
              return callback2(err2);
            } else {
              finalize();
            }
          });
        });
        return promise;
      }
    };
    module2.exports = SMTPPool;
  }
});

// node_modules/nodemailer/lib/smtp-transport/index.js
var require_smtp_transport = __commonJS({
  "node_modules/nodemailer/lib/smtp-transport/index.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var SMTPConnection = require_smtp_connection();
    var wellKnown = require_well_known();
    var shared = require_shared2();
    var XOAuth2 = require_xoauth2();
    var packageData = require_package2();
    var SMTPTransport = class extends EventEmitter {
      constructor(options) {
        super();
        options = options || {};
        if (typeof options === "string") {
          options = {
            url: options
          };
        }
        let urlData;
        let service = options.service;
        if (typeof options.getSocket === "function") {
          this.getSocket = options.getSocket;
        }
        if (options.url) {
          urlData = shared.parseConnectionUrl(options.url);
          service = service || urlData.service;
        }
        this.options = shared.assign(
          false,
          // create new object
          options,
          // regular options
          urlData,
          // url options
          service && wellKnown(service)
          // wellknown options
        );
        this.logger = shared.getLogger(this.options, {
          component: this.options.component || "smtp-transport"
        });
        let connection = new SMTPConnection(this.options);
        this.name = "SMTP";
        this.version = packageData.version + "[client:" + connection.version + "]";
        if (this.options.auth) {
          this.auth = this.getAuth({});
        }
      }
      /**
       * Placeholder function for creating proxy sockets. This method immediatelly returns
       * without a socket
       *
       * @param {Object} options Connection options
       * @param {Function} callback Callback function to run with the socket keys
       */
      getSocket(options, callback2) {
        return setImmediate(() => callback2(null, false));
      }
      getAuth(authOpts) {
        if (!authOpts) {
          return this.auth;
        }
        let hasAuth = false;
        let authData = {};
        if (this.options.auth && typeof this.options.auth === "object") {
          Object.keys(this.options.auth).forEach((key) => {
            hasAuth = true;
            authData[key] = this.options.auth[key];
          });
        }
        if (authOpts && typeof authOpts === "object") {
          Object.keys(authOpts).forEach((key) => {
            hasAuth = true;
            authData[key] = authOpts[key];
          });
        }
        if (!hasAuth) {
          return false;
        }
        switch ((authData.type || "").toString().toUpperCase()) {
          case "OAUTH2": {
            if (!authData.service && !authData.user) {
              return false;
            }
            let oauth2 = new XOAuth2(authData, this.logger);
            oauth2.provisionCallback = this.mailer && this.mailer.get("oauth2_provision_cb") || oauth2.provisionCallback;
            oauth2.on("token", (token) => this.mailer.emit("token", token));
            oauth2.on("error", (err) => this.emit("error", err));
            return {
              type: "OAUTH2",
              user: authData.user,
              oauth2,
              method: "XOAUTH2"
            };
          }
          default:
            return {
              type: (authData.type || "").toString().toUpperCase() || "LOGIN",
              user: authData.user,
              credentials: {
                user: authData.user || "",
                pass: authData.pass,
                options: authData.options
              },
              method: (authData.method || "").trim().toUpperCase() || this.options.authMethod || false
            };
        }
      }
      /**
       * Sends an e-mail using the selected settings
       *
       * @param {Object} mail Mail object
       * @param {Function} callback Callback function
       */
      send(mail, callback2) {
        this.getSocket(this.options, (err, socketOptions) => {
          if (err) {
            return callback2(err);
          }
          let returned = false;
          let options = this.options;
          if (socketOptions && socketOptions.connection) {
            this.logger.info(
              {
                tnx: "proxy",
                remoteAddress: socketOptions.connection.remoteAddress,
                remotePort: socketOptions.connection.remotePort,
                destHost: options.host || "",
                destPort: options.port || "",
                action: "connected"
              },
              "Using proxied socket from %s:%s to %s:%s",
              socketOptions.connection.remoteAddress,
              socketOptions.connection.remotePort,
              options.host || "",
              options.port || ""
            );
            options = shared.assign(false, options);
            Object.keys(socketOptions).forEach((key) => {
              options[key] = socketOptions[key];
            });
          }
          let connection = new SMTPConnection(options);
          connection.once("error", (err2) => {
            if (returned) {
              return;
            }
            returned = true;
            connection.close();
            return callback2(err2);
          });
          connection.once("end", () => {
            if (returned) {
              return;
            }
            let timer = setTimeout(() => {
              if (returned) {
                return;
              }
              returned = true;
              let err2 = new Error("Unexpected socket close");
              if (connection && connection._socket && connection._socket.upgrading) {
                err2.code = "ETLS";
              }
              callback2(err2);
            }, 1e3);
            try {
              timer.unref();
            } catch (E) {
            }
          });
          let sendMessage = () => {
            let envelope = mail.message.getEnvelope();
            let messageId = mail.message.messageId();
            let recipients = [].concat(envelope.to || []);
            if (recipients.length > 3) {
              recipients.push("...and " + recipients.splice(2).length + " more");
            }
            if (mail.data.dsn) {
              envelope.dsn = mail.data.dsn;
            }
            this.logger.info(
              {
                tnx: "send",
                messageId
              },
              "Sending message %s to <%s>",
              messageId,
              recipients.join(", ")
            );
            connection.send(envelope, mail.message.createReadStream(), (err2, info) => {
              returned = true;
              connection.close();
              if (err2) {
                this.logger.error(
                  {
                    err: err2,
                    tnx: "send"
                  },
                  "Send error for %s: %s",
                  messageId,
                  err2.message
                );
                return callback2(err2);
              }
              info.envelope = {
                from: envelope.from,
                to: envelope.to
              };
              info.messageId = messageId;
              try {
                return callback2(null, info);
              } catch (E) {
                this.logger.error(
                  {
                    err: E,
                    tnx: "callback"
                  },
                  "Callback error for %s: %s",
                  messageId,
                  E.message
                );
              }
            });
          };
          connection.connect(() => {
            if (returned) {
              return;
            }
            let auth = this.getAuth(mail.data.auth);
            if (auth && (connection.allowsAuth || options.forceAuth)) {
              connection.login(auth, (err2) => {
                if (auth && auth !== this.auth && auth.oauth2) {
                  auth.oauth2.removeAllListeners();
                }
                if (returned) {
                  return;
                }
                if (err2) {
                  returned = true;
                  connection.close();
                  return callback2(err2);
                }
                sendMessage();
              });
            } else {
              sendMessage();
            }
          });
        });
      }
      /**
       * Verifies SMTP configuration
       *
       * @param {Function} callback Callback function
       */
      verify(callback2) {
        let promise;
        if (!callback2) {
          promise = new Promise((resolve2, reject) => {
            callback2 = shared.callbackPromise(resolve2, reject);
          });
        }
        this.getSocket(this.options, (err, socketOptions) => {
          if (err) {
            return callback2(err);
          }
          let options = this.options;
          if (socketOptions && socketOptions.connection) {
            this.logger.info(
              {
                tnx: "proxy",
                remoteAddress: socketOptions.connection.remoteAddress,
                remotePort: socketOptions.connection.remotePort,
                destHost: options.host || "",
                destPort: options.port || "",
                action: "connected"
              },
              "Using proxied socket from %s:%s to %s:%s",
              socketOptions.connection.remoteAddress,
              socketOptions.connection.remotePort,
              options.host || "",
              options.port || ""
            );
            options = shared.assign(false, options);
            Object.keys(socketOptions).forEach((key) => {
              options[key] = socketOptions[key];
            });
          }
          let connection = new SMTPConnection(options);
          let returned = false;
          connection.once("error", (err2) => {
            if (returned) {
              return;
            }
            returned = true;
            connection.close();
            return callback2(err2);
          });
          connection.once("end", () => {
            if (returned) {
              return;
            }
            returned = true;
            return callback2(new Error("Connection closed"));
          });
          let finalize = () => {
            if (returned) {
              return;
            }
            returned = true;
            connection.quit();
            return callback2(null, true);
          };
          connection.connect(() => {
            if (returned) {
              return;
            }
            let authData = this.getAuth({});
            if (authData && (connection.allowsAuth || options.forceAuth)) {
              connection.login(authData, (err2) => {
                if (returned) {
                  return;
                }
                if (err2) {
                  returned = true;
                  connection.close();
                  return callback2(err2);
                }
                finalize();
              });
            } else if (!authData && connection.allowsAuth && options.forceAuth) {
              let err2 = new Error("Authentication info was not provided");
              err2.code = "NoAuth";
              returned = true;
              connection.close();
              return callback2(err2);
            } else {
              finalize();
            }
          });
        });
        return promise;
      }
      /**
       * Releases resources
       */
      close() {
        if (this.auth && this.auth.oauth2) {
          this.auth.oauth2.removeAllListeners();
        }
        this.emit("close");
      }
    };
    module2.exports = SMTPTransport;
  }
});

// node_modules/nodemailer/lib/sendmail-transport/index.js
var require_sendmail_transport = __commonJS({
  "node_modules/nodemailer/lib/sendmail-transport/index.js"(exports, module2) {
    "use strict";
    var spawn = require("child_process").spawn;
    var packageData = require_package2();
    var shared = require_shared2();
    var SendmailTransport = class {
      constructor(options) {
        options = options || {};
        this._spawn = spawn;
        this.options = options || {};
        this.name = "Sendmail";
        this.version = packageData.version;
        this.path = "sendmail";
        this.args = false;
        this.winbreak = false;
        this.logger = shared.getLogger(this.options, {
          component: this.options.component || "sendmail"
        });
        if (options) {
          if (typeof options === "string") {
            this.path = options;
          } else if (typeof options === "object") {
            if (options.path) {
              this.path = options.path;
            }
            if (Array.isArray(options.args)) {
              this.args = options.args;
            }
            this.winbreak = ["win", "windows", "dos", "\r\n"].includes((options.newline || "").toString().toLowerCase());
          }
        }
      }
      /**
       * <p>Compiles a mailcomposer message and forwards it to handler that sends it.</p>
       *
       * @param {Object} emailMessage MailComposer object
       * @param {Function} callback Callback function to run when the sending is completed
       */
      send(mail, done) {
        mail.message.keepBcc = true;
        let envelope = mail.data.envelope || mail.message.getEnvelope();
        let messageId = mail.message.messageId();
        let args;
        let sendmail;
        let returned;
        const hasInvalidAddresses = [].concat(envelope.from || []).concat(envelope.to || []).some((addr) => /^-/.test(addr));
        if (hasInvalidAddresses) {
          return done(new Error("Can not send mail. Invalid envelope addresses."));
        }
        if (this.args) {
          args = ["-i"].concat(this.args).concat(envelope.to);
        } else {
          args = ["-i"].concat(envelope.from ? ["-f", envelope.from] : []).concat(envelope.to);
        }
        let callback2 = (err) => {
          if (returned) {
            return;
          }
          returned = true;
          if (typeof done === "function") {
            if (err) {
              return done(err);
            } else {
              return done(null, {
                envelope: mail.data.envelope || mail.message.getEnvelope(),
                messageId,
                response: "Messages queued for delivery"
              });
            }
          }
        };
        try {
          sendmail = this._spawn(this.path, args);
        } catch (E) {
          this.logger.error(
            {
              err: E,
              tnx: "spawn",
              messageId
            },
            "Error occurred while spawning sendmail. %s",
            E.message
          );
          return callback2(E);
        }
        if (sendmail) {
          sendmail.on("error", (err) => {
            this.logger.error(
              {
                err,
                tnx: "spawn",
                messageId
              },
              "Error occurred when sending message %s. %s",
              messageId,
              err.message
            );
            callback2(err);
          });
          sendmail.once("exit", (code) => {
            if (!code) {
              return callback2();
            }
            let err;
            if (code === 127) {
              err = new Error("Sendmail command not found, process exited with code " + code);
            } else {
              err = new Error("Sendmail exited with code " + code);
            }
            this.logger.error(
              {
                err,
                tnx: "stdin",
                messageId
              },
              "Error sending message %s to sendmail. %s",
              messageId,
              err.message
            );
            callback2(err);
          });
          sendmail.once("close", callback2);
          sendmail.stdin.on("error", (err) => {
            this.logger.error(
              {
                err,
                tnx: "stdin",
                messageId
              },
              "Error occurred when piping message %s to sendmail. %s",
              messageId,
              err.message
            );
            callback2(err);
          });
          let recipients = [].concat(envelope.to || []);
          if (recipients.length > 3) {
            recipients.push("...and " + recipients.splice(2).length + " more");
          }
          this.logger.info(
            {
              tnx: "send",
              messageId
            },
            "Sending message %s to <%s>",
            messageId,
            recipients.join(", ")
          );
          let sourceStream = mail.message.createReadStream();
          sourceStream.once("error", (err) => {
            this.logger.error(
              {
                err,
                tnx: "stdin",
                messageId
              },
              "Error occurred when generating message %s. %s",
              messageId,
              err.message
            );
            sendmail.kill("SIGINT");
            callback2(err);
          });
          sourceStream.pipe(sendmail.stdin);
        } else {
          return callback2(new Error("sendmail was not found"));
        }
      }
    };
    module2.exports = SendmailTransport;
  }
});

// node_modules/nodemailer/lib/stream-transport/index.js
var require_stream_transport = __commonJS({
  "node_modules/nodemailer/lib/stream-transport/index.js"(exports, module2) {
    "use strict";
    var packageData = require_package2();
    var shared = require_shared2();
    var StreamTransport = class {
      constructor(options) {
        options = options || {};
        this.options = options || {};
        this.name = "StreamTransport";
        this.version = packageData.version;
        this.logger = shared.getLogger(this.options, {
          component: this.options.component || "stream-transport"
        });
        this.winbreak = ["win", "windows", "dos", "\r\n"].includes((options.newline || "").toString().toLowerCase());
      }
      /**
       * Compiles a mailcomposer message and forwards it to handler that sends it
       *
       * @param {Object} emailMessage MailComposer object
       * @param {Function} callback Callback function to run when the sending is completed
       */
      send(mail, done) {
        mail.message.keepBcc = true;
        let envelope = mail.data.envelope || mail.message.getEnvelope();
        let messageId = mail.message.messageId();
        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
          recipients.push("...and " + recipients.splice(2).length + " more");
        }
        this.logger.info(
          {
            tnx: "send",
            messageId
          },
          "Sending message %s to <%s> using %s line breaks",
          messageId,
          recipients.join(", "),
          this.winbreak ? "<CR><LF>" : "<LF>"
        );
        setImmediate(() => {
          let stream;
          try {
            stream = mail.message.createReadStream();
          } catch (E) {
            this.logger.error(
              {
                err: E,
                tnx: "send",
                messageId
              },
              "Creating send stream failed for %s. %s",
              messageId,
              E.message
            );
            return done(E);
          }
          if (!this.options.buffer) {
            stream.once("error", (err) => {
              this.logger.error(
                {
                  err,
                  tnx: "send",
                  messageId
                },
                "Failed creating message for %s. %s",
                messageId,
                err.message
              );
            });
            return done(null, {
              envelope: mail.data.envelope || mail.message.getEnvelope(),
              messageId,
              message: stream
            });
          }
          let chunks = [];
          let chunklen = 0;
          stream.on("readable", () => {
            let chunk;
            while ((chunk = stream.read()) !== null) {
              chunks.push(chunk);
              chunklen += chunk.length;
            }
          });
          stream.once("error", (err) => {
            this.logger.error(
              {
                err,
                tnx: "send",
                messageId
              },
              "Failed creating message for %s. %s",
              messageId,
              err.message
            );
            return done(err);
          });
          stream.on(
            "end",
            () => done(null, {
              envelope: mail.data.envelope || mail.message.getEnvelope(),
              messageId,
              message: Buffer.concat(chunks, chunklen)
            })
          );
        });
      }
    };
    module2.exports = StreamTransport;
  }
});

// node_modules/nodemailer/lib/json-transport/index.js
var require_json_transport = __commonJS({
  "node_modules/nodemailer/lib/json-transport/index.js"(exports, module2) {
    "use strict";
    var packageData = require_package2();
    var shared = require_shared2();
    var JSONTransport = class {
      constructor(options) {
        options = options || {};
        this.options = options || {};
        this.name = "JSONTransport";
        this.version = packageData.version;
        this.logger = shared.getLogger(this.options, {
          component: this.options.component || "json-transport"
        });
      }
      /**
       * <p>Compiles a mailcomposer message and forwards it to handler that sends it.</p>
       *
       * @param {Object} emailMessage MailComposer object
       * @param {Function} callback Callback function to run when the sending is completed
       */
      send(mail, done) {
        mail.message.keepBcc = true;
        let envelope = mail.data.envelope || mail.message.getEnvelope();
        let messageId = mail.message.messageId();
        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
          recipients.push("...and " + recipients.splice(2).length + " more");
        }
        this.logger.info(
          {
            tnx: "send",
            messageId
          },
          "Composing JSON structure of %s to <%s>",
          messageId,
          recipients.join(", ")
        );
        setImmediate(() => {
          mail.normalize((err, data) => {
            if (err) {
              this.logger.error(
                {
                  err,
                  tnx: "send",
                  messageId
                },
                "Failed building JSON structure for %s. %s",
                messageId,
                err.message
              );
              return done(err);
            }
            delete data.envelope;
            delete data.normalizedHeaders;
            return done(null, {
              envelope,
              messageId,
              message: this.options.skipEncoding ? data : JSON.stringify(data)
            });
          });
        });
      }
    };
    module2.exports = JSONTransport;
  }
});

// node_modules/nodemailer/lib/ses-transport/index.js
var require_ses_transport = __commonJS({
  "node_modules/nodemailer/lib/ses-transport/index.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var packageData = require_package2();
    var shared = require_shared2();
    var LeWindows = require_le_windows();
    var SESTransport = class extends EventEmitter {
      constructor(options) {
        super();
        options = options || {};
        this.options = options || {};
        this.ses = this.options.SES;
        this.name = "SESTransport";
        this.version = packageData.version;
        this.logger = shared.getLogger(this.options, {
          component: this.options.component || "ses-transport"
        });
        this.maxConnections = Number(this.options.maxConnections) || Infinity;
        this.connections = 0;
        this.sendingRate = Number(this.options.sendingRate) || Infinity;
        this.sendingRateTTL = null;
        this.rateInterval = 1e3;
        this.rateMessages = [];
        this.pending = [];
        this.idling = true;
        setImmediate(() => {
          if (this.idling) {
            this.emit("idle");
          }
        });
      }
      /**
       * Schedules a sending of a message
       *
       * @param {Object} emailMessage MailComposer object
       * @param {Function} callback Callback function to run when the sending is completed
       */
      send(mail, callback2) {
        if (this.connections >= this.maxConnections) {
          this.idling = false;
          return this.pending.push({
            mail,
            callback: callback2
          });
        }
        if (!this._checkSendingRate()) {
          this.idling = false;
          return this.pending.push({
            mail,
            callback: callback2
          });
        }
        this._send(mail, (...args) => {
          setImmediate(() => callback2(...args));
          this._sent();
        });
      }
      _checkRatedQueue() {
        if (this.connections >= this.maxConnections || !this._checkSendingRate()) {
          return;
        }
        if (!this.pending.length) {
          if (!this.idling) {
            this.idling = true;
            this.emit("idle");
          }
          return;
        }
        let next = this.pending.shift();
        this._send(next.mail, (...args) => {
          setImmediate(() => next.callback(...args));
          this._sent();
        });
      }
      _checkSendingRate() {
        clearTimeout(this.sendingRateTTL);
        let now2 = Date.now();
        let oldest = false;
        for (let i = this.rateMessages.length - 1; i >= 0; i--) {
          if (this.rateMessages[i].ts >= now2 - this.rateInterval && (!oldest || this.rateMessages[i].ts < oldest)) {
            oldest = this.rateMessages[i].ts;
          }
          if (this.rateMessages[i].ts < now2 - this.rateInterval && !this.rateMessages[i].pending) {
            this.rateMessages.splice(i, 1);
          }
        }
        if (this.rateMessages.length < this.sendingRate) {
          return true;
        }
        let delay3 = Math.max(oldest + 1001, now2 + 20);
        this.sendingRateTTL = setTimeout(() => this._checkRatedQueue(), now2 - delay3);
        try {
          this.sendingRateTTL.unref();
        } catch (E) {
        }
        return false;
      }
      _sent() {
        this.connections--;
        this._checkRatedQueue();
      }
      /**
       * Returns true if there are free slots in the queue
       */
      isIdle() {
        return this.idling;
      }
      /**
       * Compiles a mailcomposer message and forwards it to SES
       *
       * @param {Object} emailMessage MailComposer object
       * @param {Function} callback Callback function to run when the sending is completed
       */
      _send(mail, callback2) {
        let statObject = {
          ts: Date.now(),
          pending: true
        };
        this.connections++;
        this.rateMessages.push(statObject);
        let envelope = mail.data.envelope || mail.message.getEnvelope();
        let messageId = mail.message.messageId();
        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
          recipients.push("...and " + recipients.splice(2).length + " more");
        }
        this.logger.info(
          {
            tnx: "send",
            messageId
          },
          "Sending message %s to <%s>",
          messageId,
          recipients.join(", ")
        );
        let getRawMessage = (next) => {
          if (!mail.data._dkim) {
            mail.data._dkim = {};
          }
          if (mail.data._dkim.skipFields && typeof mail.data._dkim.skipFields === "string") {
            mail.data._dkim.skipFields += ":date:message-id";
          } else {
            mail.data._dkim.skipFields = "date:message-id";
          }
          let sourceStream = mail.message.createReadStream();
          let stream = sourceStream.pipe(new LeWindows());
          let chunks = [];
          let chunklen = 0;
          stream.on("readable", () => {
            let chunk;
            while ((chunk = stream.read()) !== null) {
              chunks.push(chunk);
              chunklen += chunk.length;
            }
          });
          sourceStream.once("error", (err) => stream.emit("error", err));
          stream.once("error", (err) => {
            next(err);
          });
          stream.once("end", () => next(null, Buffer.concat(chunks, chunklen)));
        };
        setImmediate(
          () => getRawMessage((err, raw) => {
            if (err) {
              this.logger.error(
                {
                  err,
                  tnx: "send",
                  messageId
                },
                "Failed creating message for %s. %s",
                messageId,
                err.message
              );
              statObject.pending = false;
              return callback2(err);
            }
            let sesMessage = {
              RawMessage: {
                // required
                Data: raw
                // required
              },
              Source: envelope.from,
              Destinations: envelope.to
            };
            Object.keys(mail.data.ses || {}).forEach((key) => {
              sesMessage[key] = mail.data.ses[key];
            });
            let ses = (this.ses.aws ? this.ses.ses : this.ses) || {};
            let aws = this.ses.aws || {};
            let getRegion = (cb) => {
              if (ses.config && typeof ses.config.region === "function") {
                return ses.config.region().then((region) => cb(null, region)).catch((err2) => cb(err2));
              }
              return cb(null, ses.config && ses.config.region || "us-east-1");
            };
            getRegion((err2, region) => {
              if (err2 || !region) {
                region = "us-east-1";
              }
              let sendPromise;
              if (typeof ses.send === "function" && aws.SendRawEmailCommand) {
                sendPromise = ses.send(new aws.SendRawEmailCommand(sesMessage));
              } else {
                sendPromise = ses.sendRawEmail(sesMessage).promise();
              }
              sendPromise.then((data) => {
                if (region === "us-east-1") {
                  region = "email";
                }
                statObject.pending = false;
                callback2(null, {
                  envelope: {
                    from: envelope.from,
                    to: envelope.to
                  },
                  messageId: "<" + data.MessageId + (!/@/.test(data.MessageId) ? "@" + region + ".amazonses.com" : "") + ">",
                  response: data.MessageId,
                  raw
                });
              }).catch((err3) => {
                this.logger.error(
                  {
                    err: err3,
                    tnx: "send"
                  },
                  "Send error for %s: %s",
                  messageId,
                  err3.message
                );
                statObject.pending = false;
                callback2(err3);
              });
            });
          })
        );
      }
      /**
       * Verifies SES configuration
       *
       * @param {Function} callback Callback function
       */
      verify(callback2) {
        let promise;
        let ses = (this.ses.aws ? this.ses.ses : this.ses) || {};
        let aws = this.ses.aws || {};
        const sesMessage = {
          RawMessage: {
            // required
            Data: "From: invalid@invalid\r\nTo: invalid@invalid\r\n Subject: Invalid\r\n\r\nInvalid"
          },
          Source: "invalid@invalid",
          Destinations: ["invalid@invalid"]
        };
        if (!callback2) {
          promise = new Promise((resolve2, reject) => {
            callback2 = shared.callbackPromise(resolve2, reject);
          });
        }
        const cb = (err) => {
          if (err && (err.code || err.Code) !== "InvalidParameterValue") {
            return callback2(err);
          }
          return callback2(null, true);
        };
        if (typeof ses.send === "function" && aws.SendRawEmailCommand) {
          sesMessage.RawMessage.Data = Buffer.from(sesMessage.RawMessage.Data);
          ses.send(new aws.SendRawEmailCommand(sesMessage), cb);
        } else {
          ses.sendRawEmail(sesMessage, cb);
        }
        return promise;
      }
    };
    module2.exports = SESTransport;
  }
});

// node_modules/nodemailer/lib/nodemailer.js
var require_nodemailer = __commonJS({
  "node_modules/nodemailer/lib/nodemailer.js"(exports, module2) {
    "use strict";
    var Mailer = require_mailer();
    var shared = require_shared2();
    var SMTPPool = require_smtp_pool();
    var SMTPTransport = require_smtp_transport();
    var SendmailTransport = require_sendmail_transport();
    var StreamTransport = require_stream_transport();
    var JSONTransport = require_json_transport();
    var SESTransport = require_ses_transport();
    var nmfetch = require_fetch();
    var packageData = require_package2();
    var ETHEREAL_API = (process.env.ETHEREAL_API || "https://api.nodemailer.com").replace(/\/+$/, "");
    var ETHEREAL_WEB = (process.env.ETHEREAL_WEB || "https://ethereal.email").replace(/\/+$/, "");
    var ETHEREAL_CACHE = ["true", "yes", "y", "1"].includes((process.env.ETHEREAL_CACHE || "yes").toString().trim().toLowerCase());
    var testAccount = false;
    module2.exports.createTransport = function(transporter, defaults) {
      let urlConfig;
      let options;
      let mailer;
      if (
        // provided transporter is a configuration object, not transporter plugin
        typeof transporter === "object" && typeof transporter.send !== "function" || // provided transporter looks like a connection url
        typeof transporter === "string" && /^(smtps?|direct):/i.test(transporter)
      ) {
        if (urlConfig = typeof transporter === "string" ? transporter : transporter.url) {
          options = shared.parseConnectionUrl(urlConfig);
        } else {
          options = transporter;
        }
        if (options.pool) {
          transporter = new SMTPPool(options);
        } else if (options.sendmail) {
          transporter = new SendmailTransport(options);
        } else if (options.streamTransport) {
          transporter = new StreamTransport(options);
        } else if (options.jsonTransport) {
          transporter = new JSONTransport(options);
        } else if (options.SES) {
          transporter = new SESTransport(options);
        } else {
          transporter = new SMTPTransport(options);
        }
      }
      mailer = new Mailer(transporter, options, defaults);
      return mailer;
    };
    module2.exports.createTestAccount = function(apiUrl, callback2) {
      let promise;
      if (!callback2 && typeof apiUrl === "function") {
        callback2 = apiUrl;
        apiUrl = false;
      }
      if (!callback2) {
        promise = new Promise((resolve2, reject) => {
          callback2 = shared.callbackPromise(resolve2, reject);
        });
      }
      if (ETHEREAL_CACHE && testAccount) {
        setImmediate(() => callback2(null, testAccount));
        return promise;
      }
      apiUrl = apiUrl || ETHEREAL_API;
      let chunks = [];
      let chunklen = 0;
      let req = nmfetch(apiUrl + "/user", {
        contentType: "application/json",
        method: "POST",
        body: Buffer.from(
          JSON.stringify({
            requestor: packageData.name,
            version: packageData.version
          })
        )
      });
      req.on("readable", () => {
        let chunk;
        while ((chunk = req.read()) !== null) {
          chunks.push(chunk);
          chunklen += chunk.length;
        }
      });
      req.once("error", (err) => callback2(err));
      req.once("end", () => {
        let res = Buffer.concat(chunks, chunklen);
        let data;
        let err;
        try {
          data = JSON.parse(res.toString());
        } catch (E) {
          err = E;
        }
        if (err) {
          return callback2(err);
        }
        if (data.status !== "success" || data.error) {
          return callback2(new Error(data.error || "Request failed"));
        }
        delete data.status;
        testAccount = data;
        callback2(null, testAccount);
      });
      return promise;
    };
    module2.exports.getTestMessageUrl = function(info) {
      if (!info || !info.response) {
        return false;
      }
      let infoProps = /* @__PURE__ */ new Map();
      info.response.replace(/\[([^\]]+)\]$/, (m, props) => {
        props.replace(/\b([A-Z0-9]+)=([^\s]+)/g, (m2, key, value) => {
          infoProps.set(key, value);
        });
      });
      if (infoProps.has("STATUS") && infoProps.has("MSGID")) {
        return (testAccount.web || ETHEREAL_WEB) + "/message/" + infoProps.get("MSGID");
      }
      return false;
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/helpers/bind.js
var require_bind2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/helpers/bind.js"(exports, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/utils.js"(exports, module2) {
    "use strict";
    var bind = require_bind2();
    var toString = Object.prototype.toString;
    var kindOf = function(cache) {
      return function(thing) {
        var str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
      };
    }(/* @__PURE__ */ Object.create(null));
    function kindOfTest(type) {
      type = type.toLowerCase();
      return function isKindOf(thing) {
        return kindOf(thing) === type;
      };
    }
    function isArray3(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer2(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString2(val) {
      return typeof val === "string";
    }
    function isNumber3(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject2(val) {
      if (kindOf(val) !== "object") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob2 = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isFormData(thing) {
      var pattern = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
    }
    var isURLSearchParams2 = kindOfTest("URLSearchParams");
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray3(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject2(result[key]) && isPlainObject2(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject2(val)) {
          result[key] = merge({}, val);
        } else if (isArray3(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function inherits(constructor, superConstructor, props, descriptors) {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors);
      constructor.prototype.constructor = constructor;
      props && Object.assign(constructor.prototype, props);
    }
    function toFlatObject(sourceObj, destObj, filter3) {
      var props;
      var i;
      var prop;
      var merged = {};
      destObj = destObj || {};
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if (!merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = Object.getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    }
    function endsWith(str, searchString, position) {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      var lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    }
    function toArray(thing) {
      if (!thing)
        return null;
      var i = thing.length;
      if (isUndefined(i))
        return null;
      var arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    }
    var isTypedArray = function(TypedArray) {
      return function(thing) {
        return TypedArray && thing instanceof TypedArray;
      };
    }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
    module2.exports = {
      isArray: isArray3,
      isArrayBuffer,
      isBuffer: isBuffer2,
      isFormData,
      isArrayBufferView,
      isString: isString2,
      isNumber: isNumber3,
      isObject,
      isPlainObject: isPlainObject2,
      isUndefined,
      isDate,
      isFile,
      isBlob: isBlob2,
      isFunction,
      isStream,
      isURLSearchParams: isURLSearchParams2,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      isTypedArray,
      isFileList
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/helpers/buildURL.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/core/InterceptorManager.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// node_modules/contentful/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/core/AxiosError.js
var require_AxiosError = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/core/AxiosError.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED"
      // eslint-disable-next-line func-names
    ].forEach(function(code) {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype, "isAxiosError", { value: true });
    AxiosError.from = function(error, code, config, request, response, customProps) {
      var axiosError = Object.create(prototype);
      utils.toFlatObject(error, axiosError, function filter3(obj) {
        return obj !== Error.prototype;
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    module2.exports = AxiosError;
  }
});

// node_modules/contentful/node_modules/axios/lib/defaults/transitional.js
var require_transitional2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/defaults/transitional.js"(exports, module2) {
    "use strict";
    module2.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/helpers/toFormData.js
var require_toFormData = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/helpers/toFormData.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    function toFormData(obj, formData) {
      formData = formData || new FormData();
      var stack = [];
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils.isDate(value)) {
          return value.toISOString();
        }
        if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
          return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function build(data, parentKey) {
        if (utils.isPlainObject(data) || utils.isArray(data)) {
          if (stack.indexOf(data) !== -1) {
            throw Error("Circular reference detected in " + parentKey);
          }
          stack.push(data);
          utils.forEach(data, function each(value, key) {
            if (utils.isUndefined(value))
              return;
            var fullKey = parentKey ? parentKey + "." + key : key;
            var arr;
            if (value && !parentKey && typeof value === "object") {
              if (utils.endsWith(key, "{}")) {
                value = JSON.stringify(value);
              } else if (utils.endsWith(key, "[]") && (arr = utils.toArray(value))) {
                arr.forEach(function(el) {
                  !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
                });
                return;
              }
            }
            build(value, fullKey);
          });
          stack.pop();
        } else {
          formData.append(parentKey, convertValue(data));
        }
      }
      build(obj);
      return formData;
    }
    module2.exports = toFormData;
  }
});

// node_modules/contentful/node_modules/axios/lib/core/settle.js
var require_settle2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/core/settle.js"(exports, module2) {
    "use strict";
    var AxiosError = require_AxiosError();
    module2.exports = function settle(resolve2, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve2(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/helpers/cookies.js
var require_cookies3 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/helpers/cookies.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie2 = [];
            cookie2.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie2.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie2.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie2.push("domain=" + domain);
            }
            if (secure === true) {
              cookie2.push("secure");
            }
            document.cookie = cookie2.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/contentful/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/helpers/combineURLs.js"(exports, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/core/buildFullPath.js"(exports, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL2();
    var combineURLs = require_combineURLs2();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/helpers/parseHeaders.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders2(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/contentful/node_modules/axios/lib/cancel/CanceledError.js
var require_CanceledError = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/cancel/CanceledError.js"(exports, module2) {
    "use strict";
    var AxiosError = require_AxiosError();
    var utils = require_utils3();
    function CanceledError(message) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED);
      this.name = "CanceledError";
    }
    utils.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    module2.exports = CanceledError;
  }
});

// node_modules/contentful/node_modules/axios/lib/helpers/parseProtocol.js
var require_parseProtocol = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/helpers/parseProtocol.js"(exports, module2) {
    "use strict";
    module2.exports = function parseProtocol(url) {
      var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/adapters/xhr.js
var require_xhr2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/adapters/xhr.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var settle = require_settle2();
    var cookies = require_cookies3();
    var buildURL = require_buildURL2();
    var buildFullPath = require_buildFullPath2();
    var parseHeaders2 = require_parseHeaders2();
    var isURLSameOrigin = require_isURLSameOrigin2();
    var transitionalDefaults = require_transitional2();
    var AxiosError = require_AxiosError();
    var CanceledError = require_CanceledError();
    var parseProtocol = require_parseProtocol();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve2, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password2 = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password2);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders2(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve2(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError2() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        var protocol = parseProtocol(fullPath);
        if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/env/data.js
var require_data2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/env/data.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "version": "0.27.2"
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/adapters/http.js
var require_http2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/adapters/http.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var settle = require_settle2();
    var buildFullPath = require_buildFullPath2();
    var buildURL = require_buildURL2();
    var http2 = require("http");
    var https2 = require("https");
    var httpFollow = require_follow_redirects().http;
    var httpsFollow = require_follow_redirects().https;
    var url = require("url");
    var zlib2 = require("zlib");
    var VERSION = require_data2().version;
    var transitionalDefaults = require_transitional2();
    var AxiosError = require_AxiosError();
    var CanceledError = require_CanceledError();
    var isHttps = /https:?/;
    var supportedProtocols = ["http:", "https:", "file:"];
    function setProxy(options, proxy, location) {
      options.hostname = proxy.host;
      options.host = proxy.host;
      options.port = proxy.port;
      options.path = location;
      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
      };
    }
    module2.exports = function httpAdapter(config) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        var resolve2 = function resolve3(value) {
          done();
          resolvePromise(value);
        };
        var rejected = false;
        var reject = function reject2(value) {
          done();
          rejected = true;
          rejectPromise(value);
        };
        var data = config.data;
        var headers = config.headers;
        var headerNames = {};
        Object.keys(headers).forEach(function storeLowerName(name) {
          headerNames[name.toLowerCase()] = name;
        });
        if ("user-agent" in headerNames) {
          if (!headers[headerNames["user-agent"]]) {
            delete headers[headerNames["user-agent"]];
          }
        } else {
          headers["User-Agent"] = "axios/" + VERSION;
        }
        if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {
          Object.assign(headers, data.getHeaders());
        } else if (data && !utils.isStream(data)) {
          if (Buffer.isBuffer(data)) {
          } else if (utils.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(new AxiosError(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              AxiosError.ERR_BAD_REQUEST,
              config
            ));
          }
          if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
            return reject(new AxiosError(
              "Request body larger than maxBodyLength limit",
              AxiosError.ERR_BAD_REQUEST,
              config
            ));
          }
          if (!headerNames["content-length"]) {
            headers["Content-Length"] = data.length;
          }
        }
        var auth = void 0;
        if (config.auth) {
          var username = config.auth.username || "";
          var password2 = config.auth.password || "";
          auth = username + ":" + password2;
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || supportedProtocols[0];
        if (supportedProtocols.indexOf(protocol) === -1) {
          return reject(new AxiosError(
            "Unsupported protocol " + protocol,
            AxiosError.ERR_BAD_REQUEST,
            config
          ));
        }
        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(":");
          var urlUsername = urlAuth[0] || "";
          var urlPassword = urlAuth[1] || "";
          auth = urlUsername + ":" + urlPassword;
        }
        if (auth && headerNames.authorization) {
          delete headers[headerNames.authorization];
        }
        var isHttpsRequest = isHttps.test(protocol);
        var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        try {
          buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, "");
        } catch (err) {
          var customErr = new Error(err.message);
          customErr.config = config;
          customErr.url = config.url;
          customErr.exists = true;
          reject(customErr);
        }
        var options = {
          path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
          method: config.method.toUpperCase(),
          headers,
          agent,
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth
        };
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname;
          options.port = parsed.port;
        }
        var proxy = config.proxy;
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol.slice(0, -1) + "_proxy";
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl);
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
            var shouldProxy = true;
            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(",").map(function trim(s) {
                return s.trim();
              });
              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false;
                }
                if (proxyElement === "*") {
                  return true;
                }
                if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true;
                }
                return parsed.hostname === proxyElement;
              });
            }
            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              };
              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                };
              }
            }
          }
        }
        if (proxy) {
          options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
          setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsProxy ? https2 : http2;
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          if (config.beforeRedirect) {
            options.beforeRedirect = config.beforeRedirect;
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        }
        if (config.insecureHTTPParser) {
          options.insecureHTTPParser = config.insecureHTTPParser;
        }
        var req = transport.request(options, function handleResponse(res) {
          if (req.aborted)
            return;
          var stream = res;
          var lastRequest = res.req || req;
          if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
            switch (res.headers["content-encoding"]) {
              case "gzip":
              case "compress":
              case "deflate":
                stream = stream.pipe(zlib2.createUnzip());
                delete res.headers["content-encoding"];
                break;
            }
          }
          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config,
            request: lastRequest
          };
          if (config.responseType === "stream") {
            response.data = stream;
            settle(resolve2, reject, response);
          } else {
            var responseBuffer = [];
            var totalResponseBytes = 0;
            stream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                rejected = true;
                stream.destroy();
                reject(new AxiosError(
                  "maxContentLength size of " + config.maxContentLength + " exceeded",
                  AxiosError.ERR_BAD_RESPONSE,
                  config,
                  lastRequest
                ));
              }
            });
            stream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              stream.destroy();
              reject(new AxiosError(
                "maxContentLength size of " + config.maxContentLength + " exceeded",
                AxiosError.ERR_BAD_RESPONSE,
                config,
                lastRequest
              ));
            });
            stream.on("error", function handleStreamError(err) {
              if (req.aborted)
                return;
              reject(AxiosError.from(err, null, config, lastRequest));
            });
            stream.on("end", function handleStreamEnd() {
              try {
                var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (config.responseType !== "arraybuffer") {
                  responseData = responseData.toString(config.responseEncoding);
                  if (!config.responseEncoding || config.responseEncoding === "utf8") {
                    responseData = utils.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                reject(AxiosError.from(err, null, config, response.request, response));
              }
              settle(resolve2, reject, response);
            });
          }
        });
        req.on("error", function handleRequestError(err) {
          reject(AxiosError.from(err, null, config, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config.timeout) {
          var timeout = parseInt(config.timeout, 10);
          if (isNaN(timeout)) {
            reject(new AxiosError(
              "error trying to parse `config.timeout` to int",
              AxiosError.ERR_BAD_OPTION_VALUE,
              config,
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            req.abort();
            var transitional = config.transitional || transitionalDefaults;
            reject(new AxiosError(
              "timeout of " + timeout + "ms exceeded",
              transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
              config,
              req
            ));
          });
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (req.aborted)
              return;
            req.abort();
            reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (utils.isStream(data)) {
          data.on("error", function handleStreamError(err) {
            reject(AxiosError.from(err, config, null, req));
          }).pipe(req);
        } else {
          req.end(data);
        }
      });
    };
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports, module2) {
    "use strict";
    var Stream2 = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream2);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream2.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var Stream2 = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream2);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream2.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types2 = __commonJS({
  "node_modules/mime-types/index.js"(exports) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports, module2) {
    "use strict";
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports, module2) {
    "use strict";
    var defer = require_defer();
    module2.exports = async;
    function async(callback2) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback2(err, result);
        } else {
          defer(function nextTick_callback() {
            callback2(err, result);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports, module2) {
    "use strict";
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate2 = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports, module2) {
    "use strict";
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback2) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback2(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback2) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback2));
      } else {
        aborter = iterator(item, key, async(callback2));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports, module2) {
    "use strict";
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports, module2) {
    "use strict";
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback2) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback2)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports, module2) {
    "use strict";
    var iterate = require_iterate2();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback2) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback2(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback2(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback2);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports, module2) {
    "use strict";
    var iterate = require_iterate2();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback2) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback2(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback2(null, state.results);
      });
      return terminator.bind(state, callback2);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports, module2) {
    "use strict";
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback2) {
      return serialOrdered(list, iterator, null, callback2);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports, module2) {
    "use strict";
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports, module2) {
    "use strict";
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path = require("path");
    var http2 = require("http");
    var https2 = require("https");
    var parseUrl2 = require("url").parse;
    var fs = require("fs");
    var Stream2 = require("stream").Stream;
    var mime = require_mime_types2();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData2;
    util.inherits(FormData2, CombinedStream);
    function FormData2(options) {
      if (!(this instanceof FormData2)) {
        return new FormData2(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData2.LINE_BREAK = "\r\n";
    FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData2.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append2 = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (util.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append2(header);
      append2(value);
      append2(footer);
      this._trackLength(header, value, options);
    };
    FormData2.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream2)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData2.prototype._lengthRetriever = function(value, callback2) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback2(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback2(err);
              return;
            }
            fileSize = stat.size - (value.start ? value.start : 0);
            callback2(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback2(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback2(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback2("Unknown stream");
      }
    };
    FormData2.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
    };
    FormData2.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData2.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData2.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData2.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData2.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData2.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
    };
    FormData2.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData2.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData2.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData2.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData2.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData2.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData2.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData2.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData2.prototype.submit = function(params, cb) {
      var request, options, defaults = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl2(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request = https2.request(options);
      } else {
        request = http2.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback2 = function(error, responce) {
            request.removeListener("error", callback2);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback2.bind(this, null);
          request.on("error", callback2);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData2.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData2.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/defaults/env/FormData.js
var require_FormData = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/defaults/env/FormData.js"(exports, module2) {
    "use strict";
    module2.exports = require_form_data();
  }
});

// node_modules/contentful/node_modules/axios/lib/defaults/index.js
var require_defaults2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/defaults/index.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var normalizeHeaderName = require_normalizeHeaderName2();
    var AxiosError = require_AxiosError();
    var transitionalDefaults = require_transitional2();
    var toFormData = require_toFormData();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr2();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_http2();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        var isObjectPayload = utils.isObject(data);
        var contentType = headers && headers["Content-Type"];
        var isFileList;
        if ((isFileList = utils.isFileList(data)) || isObjectPayload && contentType === "multipart/form-data") {
          var _FormData = this.env && this.env.FormData;
          return toFormData(isFileList ? { "files[]": data } : data, _FormData && new _FormData());
        } else if (isObjectPayload || contentType === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: require_FormData()
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// node_modules/contentful/node_modules/axios/lib/core/transformData.js
var require_transformData2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/core/transformData.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var defaults = require_defaults2();
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/cancel/isCancel.js"(exports, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/core/dispatchRequest.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var transformData = require_transformData2();
    var isCancel = require_isCancel2();
    var defaults = require_defaults2();
    var CanceledError = require_CanceledError();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError();
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/core/mergeConfig.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "beforeRedirect": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/helpers/validator.js
var require_validator2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/helpers/validator.js"(exports, module2) {
    "use strict";
    var VERSION = require_data2().version;
    var AxiosError = require_AxiosError();
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    module2.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/core/Axios.js
var require_Axios2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/core/Axios.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var buildURL = require_buildURL2();
    var InterceptorManager = require_InterceptorManager2();
    var dispatchRequest = require_dispatchRequest2();
    var mergeConfig = require_mergeConfig2();
    var buildFullPath = require_buildFullPath2();
    var validator = require_validator2();
    var validators = validator.validators;
    function Axios3(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios3.prototype.request = function request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios3.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      var fullPath = buildFullPath(config.baseURL, config.url);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios3.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios3.prototype[method] = generateHTTPMethod();
      Axios3.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    module2.exports = Axios3;
  }
});

// node_modules/contentful/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/cancel/CancelToken.js"(exports, module2) {
    "use strict";
    var CanceledError = require_CanceledError();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve2) {
        resolvePromise = resolve2;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve2) {
          token.subscribe(resolve2);
          _resolve = resolve2;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index2 = this._listeners.indexOf(listener);
      if (index2 !== -1) {
        this._listeners.splice(index2, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// node_modules/contentful/node_modules/axios/lib/helpers/spread.js
var require_spread2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/helpers/spread.js"(exports, module2) {
    "use strict";
    module2.exports = function spread(callback2) {
      return function wrap(arr) {
        return callback2.apply(null, arr);
      };
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError2 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/helpers/isAxiosError.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    module2.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/contentful/node_modules/axios/lib/axios.js
var require_axios3 = __commonJS({
  "node_modules/contentful/node_modules/axios/lib/axios.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var bind = require_bind2();
    var Axios3 = require_Axios2();
    var mergeConfig = require_mergeConfig2();
    var defaults = require_defaults2();
    function createInstance(defaultConfig) {
      var context = new Axios3(defaultConfig);
      var instance = bind(Axios3.prototype.request, context);
      utils.extend(instance, Axios3.prototype, context);
      utils.extend(instance, context);
      instance.create = function create3(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios2 = createInstance(defaults);
    axios2.Axios = Axios3;
    axios2.CanceledError = require_CanceledError();
    axios2.CancelToken = require_CancelToken2();
    axios2.isCancel = require_isCancel2();
    axios2.VERSION = require_data2().version;
    axios2.toFormData = require_toFormData();
    axios2.AxiosError = require_AxiosError();
    axios2.Cancel = axios2.CanceledError;
    axios2.all = function all(promises) {
      return Promise.all(promises);
    };
    axios2.spread = require_spread2();
    axios2.isAxiosError = require_isAxiosError2();
    module2.exports = axios2;
    module2.exports.default = axios2;
  }
});

// node_modules/contentful/node_modules/axios/index.js
var require_axios4 = __commonJS({
  "node_modules/contentful/node_modules/axios/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_axios3();
  }
});

// node_modules/fast-copy/dist/esm/index.mjs
function createCacheLegacy() {
  return new LegacyCache();
}
function createCacheModern() {
  return /* @__PURE__ */ new WeakMap();
}
function getCleanClone(prototype) {
  if (!prototype) {
    return create(null);
  }
  var Constructor = prototype.constructor;
  if (Constructor === Object) {
    return prototype === Object.prototype ? {} : create(prototype);
  }
  if (~toStringFunction.call(Constructor).indexOf("[native code]")) {
    try {
      return new Constructor();
    } catch (_a4) {
    }
  }
  return create(prototype);
}
function getRegExpFlagsLegacy(regExp) {
  var flags = "";
  if (regExp.global) {
    flags += "g";
  }
  if (regExp.ignoreCase) {
    flags += "i";
  }
  if (regExp.multiline) {
    flags += "m";
  }
  if (regExp.unicode) {
    flags += "u";
  }
  if (regExp.sticky) {
    flags += "y";
  }
  return flags;
}
function getRegExpFlagsModern(regExp) {
  return regExp.flags;
}
function getTagLegacy(value) {
  var type = toStringObject.call(value);
  return type.substring(8, type.length - 1);
}
function getTagModern(value) {
  return value[Symbol.toStringTag] || getTagLegacy(value);
}
function getStrictPropertiesModern(object) {
  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
}
function copyOwnPropertiesStrict(value, clone2, state) {
  var properties = getStrictProperties(value);
  for (var index2 = 0, length_1 = properties.length, property = void 0, descriptor = void 0; index2 < length_1; ++index2) {
    property = properties[index2];
    if (property === "callee" || property === "caller") {
      continue;
    }
    descriptor = getOwnPropertyDescriptor(value, property);
    if (!descriptor) {
      clone2[property] = state.copier(value[property], state);
      continue;
    }
    if (!descriptor.get && !descriptor.set) {
      descriptor.value = state.copier(descriptor.value, state);
    }
    try {
      defineProperty(clone2, property, descriptor);
    } catch (error) {
      clone2[property] = descriptor.value;
    }
  }
  return clone2;
}
function copyArrayLoose(array, state) {
  var clone2 = new state.Constructor();
  state.cache.set(array, clone2);
  for (var index2 = 0, length_2 = array.length; index2 < length_2; ++index2) {
    clone2[index2] = state.copier(array[index2], state);
  }
  return clone2;
}
function copyArrayStrict(array, state) {
  var clone2 = new state.Constructor();
  state.cache.set(array, clone2);
  return copyOwnPropertiesStrict(array, clone2, state);
}
function copyArrayBuffer(arrayBuffer, _state) {
  return arrayBuffer.slice(0);
}
function copyBlob(blob, _state) {
  return blob.slice(0, blob.size, blob.type);
}
function copyDataView(dataView, state) {
  return new state.Constructor(copyArrayBuffer(dataView.buffer));
}
function copyDate(date, state) {
  return new state.Constructor(date.getTime());
}
function copyMapLoose(map, state) {
  var clone2 = new state.Constructor();
  state.cache.set(map, clone2);
  map.forEach(function(value, key) {
    clone2.set(key, state.copier(value, state));
  });
  return clone2;
}
function copyMapStrict(map, state) {
  return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);
}
function copyObjectLooseLegacy(object, state) {
  var clone2 = getCleanClone(state.prototype);
  state.cache.set(object, clone2);
  for (var key in object) {
    if (hasOwnProperty.call(object, key)) {
      clone2[key] = state.copier(object[key], state);
    }
  }
  return clone2;
}
function copyObjectLooseModern(object, state) {
  var clone2 = getCleanClone(state.prototype);
  state.cache.set(object, clone2);
  for (var key in object) {
    if (hasOwnProperty.call(object, key)) {
      clone2[key] = state.copier(object[key], state);
    }
  }
  var symbols = getOwnPropertySymbols(object);
  for (var index2 = 0, length_3 = symbols.length, symbol = void 0; index2 < length_3; ++index2) {
    symbol = symbols[index2];
    if (propertyIsEnumerable.call(object, symbol)) {
      clone2[symbol] = state.copier(object[symbol], state);
    }
  }
  return clone2;
}
function copyObjectStrict(object, state) {
  var clone2 = getCleanClone(state.prototype);
  state.cache.set(object, clone2);
  return copyOwnPropertiesStrict(object, clone2, state);
}
function copyPrimitiveWrapper(primitiveObject, state) {
  return new state.Constructor(primitiveObject.valueOf());
}
function copyRegExp(regExp, state) {
  var clone2 = new state.Constructor(regExp.source, getRegExpFlags(regExp));
  clone2.lastIndex = regExp.lastIndex;
  return clone2;
}
function copySelf(value, _state) {
  return value;
}
function copySetLoose(set, state) {
  var clone2 = new state.Constructor();
  state.cache.set(set, clone2);
  set.forEach(function(value) {
    clone2.add(state.copier(value, state));
  });
  return clone2;
}
function copySetStrict(set, state) {
  return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);
}
function getTagSpecificCopiers(options) {
  return {
    Arguments: options.object,
    Array: options.array,
    ArrayBuffer: options.arrayBuffer,
    Blob: options.blob,
    Boolean: copyPrimitiveWrapper,
    DataView: options.dataView,
    Date: options.date,
    Error: options.error,
    Float32Array: options.arrayBuffer,
    Float64Array: options.arrayBuffer,
    Int8Array: options.arrayBuffer,
    Int16Array: options.arrayBuffer,
    Int32Array: options.arrayBuffer,
    Map: options.map,
    Number: copyPrimitiveWrapper,
    Object: options.object,
    Promise: copySelf,
    RegExp: options.regExp,
    Set: options.set,
    String: copyPrimitiveWrapper,
    WeakMap: copySelf,
    WeakSet: copySelf,
    Uint8Array: options.arrayBuffer,
    Uint8ClampedArray: options.arrayBuffer,
    Uint16Array: options.arrayBuffer,
    Uint32Array: options.arrayBuffer,
    Uint64Array: options.arrayBuffer
  };
}
function createCopier(options) {
  var normalizedOptions = assign({}, DEFAULT_LOOSE_OPTIONS, options);
  var tagSpecificCopiers = getTagSpecificCopiers(normalizedOptions);
  var array = tagSpecificCopiers.Array, object = tagSpecificCopiers.Object;
  function copier(value, state) {
    state.prototype = state.Constructor = void 0;
    if (!value || typeof value !== "object") {
      return value;
    }
    if (state.cache.has(value)) {
      return state.cache.get(value);
    }
    state.prototype = value.__proto__ || getPrototypeOf(value);
    state.Constructor = state.prototype && state.prototype.constructor;
    if (!state.Constructor || state.Constructor === Object) {
      return object(value, state);
    }
    if (isArray(value)) {
      return array(value, state);
    }
    var tagSpecificCopier = tagSpecificCopiers[getTag(value)];
    if (tagSpecificCopier) {
      return tagSpecificCopier(value, state);
    }
    return typeof value.then === "function" ? value : object(value, state);
  }
  return function copy2(value) {
    return copier(value, {
      Constructor: void 0,
      cache: createCache(),
      copier,
      prototype: void 0
    });
  };
}
function createStrictCopier(options) {
  return createCopier(assign({}, DEFAULT_STRICT_OPTIONS, options));
}
var toStringFunction, create, toStringObject, LegacyCache, createCache, getRegExpFlags, getTag, defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, _a, hasOwnProperty, propertyIsEnumerable, SUPPORTS_SYMBOL, getStrictProperties, copyObjectLoose, isArray, assign, getPrototypeOf, DEFAULT_LOOSE_OPTIONS, DEFAULT_STRICT_OPTIONS, copyStrict, index;
var init_esm = __esm({
  "node_modules/fast-copy/dist/esm/index.mjs"() {
    "use strict";
    toStringFunction = Function.prototype.toString;
    create = Object.create;
    toStringObject = Object.prototype.toString;
    LegacyCache = /** @class */
    function() {
      function LegacyCache2() {
        this._keys = [];
        this._values = [];
      }
      LegacyCache2.prototype.has = function(key) {
        return !!~this._keys.indexOf(key);
      };
      LegacyCache2.prototype.get = function(key) {
        return this._values[this._keys.indexOf(key)];
      };
      LegacyCache2.prototype.set = function(key, value) {
        this._keys.push(key);
        this._values.push(value);
      };
      return LegacyCache2;
    }();
    createCache = typeof WeakMap !== "undefined" ? createCacheModern : createCacheLegacy;
    getRegExpFlags = /test/g.flags === "g" ? getRegExpFlagsModern : getRegExpFlagsLegacy;
    getTag = typeof Symbol !== "undefined" ? getTagModern : getTagLegacy;
    defineProperty = Object.defineProperty;
    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    getOwnPropertyNames = Object.getOwnPropertyNames;
    getOwnPropertySymbols = Object.getOwnPropertySymbols;
    _a = Object.prototype;
    hasOwnProperty = _a.hasOwnProperty;
    propertyIsEnumerable = _a.propertyIsEnumerable;
    SUPPORTS_SYMBOL = typeof getOwnPropertySymbols === "function";
    getStrictProperties = SUPPORTS_SYMBOL ? getStrictPropertiesModern : getOwnPropertyNames;
    copyObjectLoose = SUPPORTS_SYMBOL ? copyObjectLooseModern : copyObjectLooseLegacy;
    isArray = Array.isArray;
    assign = Object.assign;
    getPrototypeOf = Object.getPrototypeOf;
    DEFAULT_LOOSE_OPTIONS = {
      array: copyArrayLoose,
      arrayBuffer: copyArrayBuffer,
      blob: copyBlob,
      dataView: copyDataView,
      date: copyDate,
      error: copySelf,
      map: copyMapLoose,
      object: copyObjectLoose,
      regExp: copyRegExp,
      set: copySetLoose
    };
    DEFAULT_STRICT_OPTIONS = assign({}, DEFAULT_LOOSE_OPTIONS, {
      array: copyArrayStrict,
      map: copyMapStrict,
      object: copyObjectStrict,
      set: copySetStrict
    });
    copyStrict = createStrictCopier({});
    index = createCopier({});
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/side-channel/node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/side-channel/node_modules/function-bind/implementation.js"(exports, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/side-channel/node_modules/function-bind/index.js
var require_function_bind2 = __commonJS({
  "node_modules/side-channel/node_modules/function-bind/index.js"(exports, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/has/node_modules/function-bind/implementation.js"(exports, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/has/node_modules/function-bind/index.js
var require_function_bind3 = __commonJS({
  "node_modules/has/node_modules/function-bind/index.js"(exports, module2) {
    "use strict";
    var implementation = require_implementation2();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src2 = __commonJS({
  "node_modules/has/src/index.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind3();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/side-channel/node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/side-channel/node_modules/get-intrinsic/index.js"(exports, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x) {
      return x.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind2();
    var hasOwn = require_src2();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/side-channel/node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/side-channel/node_modules/call-bind/index.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind2();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/side-channel/node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/side-channel/node_modules/call-bind/callBound.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/object-inspect/util.inspect.js
var require_util_inspect = __commonJS({
  "node_modules/object-inspect/util.inspect.js"(exports, module2) {
    "use strict";
    module2.exports = require("util").inspect;
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports, module2) {
    "use strict";
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util_inspect();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray3(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray3(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
        });
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber3(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString2(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray3(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString2(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber3(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray3(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module2.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/contentful-sdk-core/node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/contentful-sdk-core/node_modules/qs/lib/formats.js"(exports, module2) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module2.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/contentful-sdk-core/node_modules/qs/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/contentful-sdk-core/node_modules/qs/lib/utils.js"(exports, module2) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray3 = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray3(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray3(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray3(target) && !isArray3(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray3(target) && isArray3(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign2 = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
          out += string.charAt(i);
          continue;
        }
        if (c < 128) {
          out = out + hexTable[c];
          continue;
        }
        if (c < 2048) {
          out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
          continue;
        }
        if (c < 55296 || c >= 57344) {
          out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer2 = function isBuffer3(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray3(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module2.exports = {
      arrayToObject,
      assign: assign2,
      combine,
      compact,
      decode,
      encode,
      isBuffer: isBuffer2,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// node_modules/contentful-sdk-core/node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/contentful-sdk-core/node_modules/qs/lib/stringify.js"(exports, module2) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils4();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray3 = Array.isArray;
    var split = String.prototype.split;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray3(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify2 = function stringify3(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter3, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter3 === "function") {
        obj = filter3(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray3(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          if (generateArrayPrefix === "comma" && encodeValuesOnly) {
            var valuesArray = split.call(String(obj), ",");
            var valuesJoined = "";
            for (var i = 0; i < valuesArray.length; ++i) {
              valuesJoined += (i === 0 ? "" : ",") + formatter(encoder(valuesArray[i], defaults.encoder, charset, "value", format));
            }
            return [formatter(keyValue) + (commaRoundTrip && isArray3(obj) && valuesArray.length === 1 ? "[]" : "") + "=" + valuesJoined];
          }
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray3(obj)) {
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray3(filter3)) {
        objKeys = filter3;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var adjustedPrefix = commaRoundTrip && isArray3(obj) && obj.length === 1 ? prefix + "[]" : prefix;
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray3(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify3(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          strictNullHandling,
          skipNulls,
          encoder,
          filter3,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter3 = defaults.filter;
      if (typeof opts.filter === "function" || isArray3(opts.filter)) {
        filter3 = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter3,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter3;
      if (typeof options.filter === "function") {
        filter3 = options.filter;
        obj = filter3("", obj);
      } else if (isArray3(options.filter)) {
        filter3 = options.filter;
        objKeys = filter3;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify2(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/contentful-sdk-core/node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/contentful-sdk-core/node_modules/qs/lib/parse.js"(exports, module2) {
    "use strict";
    var utils = require_utils4();
    var has = Object.prototype.hasOwnProperty;
    var isArray3 = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray3(val) ? [val] : val;
        }
        if (has.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index2 = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index2) && root !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
            obj = [];
            obj[index2] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/contentful-sdk-core/node_modules/qs/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/contentful-sdk-core/node_modules/qs/lib/index.js"(exports, module2) {
    "use strict";
    var stringify2 = require_stringify();
    var parse = require_parse();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse,
      stringify: stringify2
    };
  }
});

// node_modules/lodash.isstring/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isstring/index.js"(exports, module2) {
    "use strict";
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray3 = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString2(value) {
      return typeof value == "string" || !isArray3(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    module2.exports = isString2;
  }
});

// node_modules/p-throttle/index.js
var require_p_throttle = __commonJS({
  "node_modules/p-throttle/index.js"(exports, module2) {
    "use strict";
    var AbortError2 = class extends Error {
      constructor() {
        super("Throttled function aborted");
        this.name = "AbortError";
      }
    };
    var pThrottle2 = ({ limit, interval, strict }) => {
      if (!Number.isFinite(limit)) {
        throw new TypeError("Expected `limit` to be a finite number");
      }
      if (!Number.isFinite(interval)) {
        throw new TypeError("Expected `interval` to be a finite number");
      }
      const queue = /* @__PURE__ */ new Map();
      let currentTick = 0;
      let activeCount = 0;
      function windowedDelay() {
        const now2 = Date.now();
        if (now2 - currentTick > interval) {
          activeCount = 1;
          currentTick = now2;
          return 0;
        }
        if (activeCount < limit) {
          activeCount++;
        } else {
          currentTick += interval;
          activeCount = 1;
        }
        return currentTick - now2;
      }
      const strictTicks = [];
      function strictDelay() {
        const now2 = Date.now();
        if (strictTicks.length < limit) {
          strictTicks.push(now2);
          return 0;
        }
        const earliestTime = strictTicks.shift() + interval;
        if (now2 >= earliestTime) {
          strictTicks.push(now2);
          return 0;
        }
        strictTicks.push(earliestTime);
        return earliestTime - now2;
      }
      const getDelay = strict ? strictDelay : windowedDelay;
      return (function_) => {
        const throttled = function(...args) {
          if (!throttled.isEnabled) {
            return (async () => function_.apply(this, args))();
          }
          let timeout;
          return new Promise((resolve2, reject) => {
            const execute = () => {
              resolve2(function_.apply(this, args));
              queue.delete(timeout);
            };
            timeout = setTimeout(execute, getDelay());
            queue.set(timeout, reject);
          });
        };
        throttled.abort = () => {
          for (const timeout of queue.keys()) {
            clearTimeout(timeout);
            queue.get(timeout)(new AbortError2());
          }
          queue.clear();
          strictTicks.splice(0, strictTicks.length);
        };
        throttled.isEnabled = true;
        return throttled;
      };
    };
    module2.exports = pThrottle2;
    module2.exports.AbortError = AbortError2;
  }
});

// node_modules/lodash.isplainobject/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.isplainobject/index.js"(exports, module2) {
    "use strict";
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject2(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty3.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject2;
  }
});

// node_modules/contentful-sdk-core/dist/index.es-modules.js
var index_es_modules_exports = {};
__export(index_es_modules_exports, {
  createHttpClient: () => createHttpClient,
  createRequestConfig: () => createRequestConfig,
  enforceObjPath: () => enforceObjPath,
  errorHandler: () => errorHandler,
  freezeSys: () => freezeSys,
  getUserAgentHeader: () => getUserAgentHeader,
  toPlainObject: () => toPlainObject
});
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty3(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _wrapRegExp() {
  _wrapRegExp = function(re, groups) {
    return new BabelRegExp(re, void 0, groups);
  };
  var _super = RegExp.prototype, _groups = /* @__PURE__ */ new WeakMap();
  function BabelRegExp(re, flags, groups) {
    var _this = new RegExp(re, flags);
    return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype);
  }
  function buildGroups(result, re) {
    var g = _groups.get(re);
    return Object.keys(g).reduce(function(groups, name) {
      var i = g[name];
      if ("number" == typeof i)
        groups[name] = result[i];
      else {
        for (var k = 0; void 0 === result[i[k]] && k + 1 < i.length; )
          k++;
        groups[name] = result[i[k]];
      }
      return groups;
    }, /* @__PURE__ */ Object.create(null));
  }
  return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function(str) {
    var result = _super.exec.call(this, str);
    return result && (result.groups = buildGroups(result, this)), result;
  }, BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {
    if ("string" == typeof substitution) {
      var groups = _groups.get(this);
      return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function(_, name) {
        return "$" + groups[name];
      }));
    }
    if ("function" == typeof substitution) {
      var _this = this;
      return _super[Symbol.replace].call(this, str, function() {
        var args = arguments;
        return "object" != typeof args[args.length - 1] && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args);
      });
    }
    return _super[Symbol.replace].call(this, str, substitution);
  }, _wrapRegExp.apply(this, arguments);
}
function _defineProperty3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function() {
      };
      return {
        s: F,
        n: function() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function(e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = it.call(o);
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(e) {
      didErr = true;
      err = e;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
function isNode() {
  return typeof process !== "undefined" && !process.browser;
}
function isReactNative() {
  return typeof window !== "undefined" && "navigator" in window && "product" in window.navigator && window.navigator.product === "ReactNative";
}
function getNodeVersion() {
  return process.versions && process.versions.node ? "v".concat(process.versions.node) : process.version;
}
function getWindow() {
  return window;
}
function noop() {
  return void 0;
}
function calculateLimit(type) {
  var max = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 7;
  var limit = max;
  if (PERCENTAGE_REGEX.test(type)) {
    var _type$match;
    var groups = (_type$match = type.match(PERCENTAGE_REGEX)) === null || _type$match === void 0 ? void 0 : _type$match.groups;
    if (groups && groups.value) {
      var percentage = parseInt(groups.value) / 100;
      limit = Math.round(max * percentage);
    }
  }
  return Math.min(30, Math.max(1, limit));
}
function createThrottle(limit, logger) {
  logger("info", "Throttle request to ".concat(limit, "/s"));
  return (0, import_p_throttle.default)({
    limit,
    interval: 1e3,
    strict: false
  });
}
function rateLimit(instance) {
  var maxRetry = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  var _instance$defaults = instance.defaults, _instance$defaults$re = _instance$defaults.responseLogger, responseLogger = _instance$defaults$re === void 0 ? noop : _instance$defaults$re, _instance$defaults$re2 = _instance$defaults.requestLogger, requestLogger = _instance$defaults$re2 === void 0 ? noop : _instance$defaults$re2;
  instance.interceptors.request.use(function(config) {
    requestLogger(config);
    return config;
  }, function(error) {
    requestLogger(error);
    return Promise.reject(error);
  });
  instance.interceptors.response.use(function(response) {
    responseLogger(response);
    return response;
  }, function(error) {
    var response = error.response;
    var config = error.config;
    responseLogger(error);
    if (!config || !instance.defaults.retryOnError) {
      return Promise.reject(error);
    }
    var doneAttempts = config.attempts || 1;
    if (doneAttempts > maxRetry) {
      error.attempts = config.attempts;
      return Promise.reject(error);
    }
    var retryErrorType = null;
    var wait = defaultWait(doneAttempts);
    if (!response) {
      retryErrorType = "Connection";
    } else if (response.status >= 500 && response.status < 600) {
      retryErrorType = "Server ".concat(response.status);
    } else if (response.status === 429) {
      retryErrorType = "Rate limit";
      if (response.headers && error.response.headers["x-contentful-ratelimit-reset"]) {
        wait = response.headers["x-contentful-ratelimit-reset"];
      }
    }
    if (retryErrorType) {
      wait = Math.floor(wait * 1e3 + Math.random() * 200 + 500);
      instance.defaults.logHandler("warning", "".concat(retryErrorType, " error occurred. Waiting for ").concat(wait, " ms before retrying..."));
      config.attempts = doneAttempts + 1;
      delete config.httpAgent;
      delete config.httpsAgent;
      return delay(wait).then(function() {
        return instance(config);
      });
    }
    return Promise.reject(error);
  });
}
function asyncToken(instance, getToken) {
  instance.interceptors.request.use(function(config) {
    return getToken().then(function(accessToken) {
      config.headers = _objectSpread2(_objectSpread2({}, config.headers), {}, {
        Authorization: "Bearer ".concat(accessToken)
      });
      return config;
    });
  });
}
function createHttpClient(axios2, options) {
  var defaultConfig = {
    insecure: false,
    retryOnError: true,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    logHandler: function logHandler(level, data) {
      if (level === "error" && data) {
        var title = [data.name, data.message].filter(function(a) {
          return a;
        }).join(" - ");
        console.error("[error] ".concat(title));
        console.error(data);
        return;
      }
      console.log("[".concat(level, "] ").concat(data));
    },
    // Passed to axios
    headers: {},
    httpAgent: false,
    httpsAgent: false,
    timeout: 3e4,
    throttle: 0,
    proxy: false,
    basePath: "",
    adapter: void 0,
    maxContentLength: 1073741824,
    // 1GB
    maxBodyLength: 1073741824
    // 1GB
  };
  var config = _objectSpread2(_objectSpread2({}, defaultConfig), options);
  if (!config.accessToken) {
    var missingAccessTokenError = new TypeError("Expected parameter accessToken");
    config.logHandler("error", missingAccessTokenError);
    throw missingAccessTokenError;
  }
  var protocol = config.insecure ? "http" : "https";
  var space = config.space ? "".concat(config.space, "/") : "";
  var hostname = config.defaultHostname;
  var port = config.insecure ? 80 : 443;
  if (config.host && HOST_REGEX.test(config.host)) {
    var parsed = config.host.split(":");
    if (parsed.length === 2) {
      var _parsed = _slicedToArray(parsed, 2);
      hostname = _parsed[0];
      port = _parsed[1];
    } else {
      hostname = parsed[0];
    }
  }
  if (config.basePath) {
    config.basePath = "/".concat(config.basePath.split("/").filter(Boolean).join("/"));
  }
  var baseURL = options.baseURL || "".concat(protocol, "://").concat(hostname, ":").concat(port).concat(config.basePath, "/spaces/").concat(space);
  if (!config.headers.Authorization && typeof config.accessToken !== "function") {
    config.headers.Authorization = "Bearer " + config.accessToken;
  }
  if (isNode()) {
    config.headers["user-agent"] = "node.js/" + getNodeVersion();
    config.headers["Accept-Encoding"] = "gzip";
  }
  var axiosOptions = {
    // Axios
    baseURL,
    headers: config.headers,
    httpAgent: config.httpAgent,
    httpsAgent: config.httpsAgent,
    paramsSerializer: import_qs.default.stringify,
    proxy: config.proxy,
    timeout: config.timeout,
    adapter: config.adapter,
    maxContentLength: config.maxContentLength,
    maxBodyLength: config.maxBodyLength,
    // Contentful
    logHandler: config.logHandler,
    responseLogger: config.responseLogger,
    requestLogger: config.requestLogger,
    retryOnError: config.retryOnError
  };
  var instance = axios2.create(axiosOptions);
  instance.httpClientParams = options;
  instance.cloneWithNewParams = function(newParams) {
    return createHttpClient(axios2, _objectSpread2(_objectSpread2({}, index(options)), newParams));
  };
  if (config.onBeforeRequest) {
    instance.interceptors.request.use(config.onBeforeRequest);
  }
  if (typeof config.accessToken === "function") {
    asyncToken(instance, config.accessToken);
  }
  if (config.throttle) {
    rateLimitThrottle(instance, config.throttle);
  }
  rateLimit(instance, config.retryLimit);
  if (config.onError) {
    instance.interceptors.response.use(function(response) {
      return response;
    }, config.onError);
  }
  return instance;
}
function createRequestConfig(_ref) {
  var query2 = _ref.query;
  var config = {};
  delete query2.resolveLinks;
  config.params = index(query2);
  return config;
}
function enforceObjPath(obj, path) {
  if (!(path in obj)) {
    var err = new Error();
    err.name = "PropertyMissing";
    err.message = "Required property ".concat(path, " missing from:\n\n").concat(JSON.stringify(obj), "\n\n");
    throw err;
  }
  return true;
}
function deepFreeze(object) {
  var propNames = Object.getOwnPropertyNames(object);
  var _iterator = _createForOfIteratorHelper(propNames), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var name = _step.value;
      var value = object[name];
      if (value && _typeof(value) === "object") {
        deepFreeze(value);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return Object.freeze(object);
}
function freezeSys(obj) {
  deepFreeze(obj.sys || {});
  return obj;
}
function getBrowserOS() {
  var win = getWindow();
  if (!win) {
    return null;
  }
  var userAgent = win.navigator.userAgent;
  var platform = win.navigator.platform;
  var macosPlatforms = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"];
  var windowsPlatforms = ["Win32", "Win64", "Windows", "WinCE"];
  var iosPlatforms = ["iPhone", "iPad", "iPod"];
  if (macosPlatforms.indexOf(platform) !== -1) {
    return "macOS";
  } else if (iosPlatforms.indexOf(platform) !== -1) {
    return "iOS";
  } else if (windowsPlatforms.indexOf(platform) !== -1) {
    return "Windows";
  } else if (/Android/.test(userAgent)) {
    return "Android";
  } else if (/Linux/.test(platform)) {
    return "Linux";
  }
  return null;
}
function getNodeOS() {
  var platform = process.platform || "linux";
  var version = process.version || "0.0.0";
  var platformMap = {
    android: "Android",
    aix: "Linux",
    darwin: "macOS",
    freebsd: "Linux",
    linux: "Linux",
    openbsd: "Linux",
    sunos: "Linux",
    win32: "Windows"
  };
  if (platform in platformMap) {
    return "".concat(platformMap[platform] || "Linux", "/").concat(version);
  }
  return null;
}
function getUserAgentHeader(sdk, application, integration, feature) {
  var headerParts = [];
  if (application) {
    headerParts.push("app ".concat(application));
  }
  if (integration) {
    headerParts.push("integration ".concat(integration));
  }
  if (feature) {
    headerParts.push("feature " + feature);
  }
  headerParts.push("sdk ".concat(sdk));
  var platform = null;
  try {
    if (isReactNative()) {
      platform = getBrowserOS();
      headerParts.push("platform ReactNative");
    } else if (isNode()) {
      platform = getNodeOS();
      headerParts.push("platform node.js/".concat(getNodeVersion()));
    } else {
      platform = getBrowserOS();
      headerParts.push("platform browser");
    }
  } catch (e) {
    platform = null;
  }
  if (platform) {
    headerParts.push("os ".concat(platform));
  }
  return "".concat(headerParts.filter(function(item) {
    return item !== "";
  }).join("; "), ";");
}
function toPlainObject(data) {
  return Object.defineProperty(data, "toPlainObject", {
    enumerable: false,
    configurable: false,
    writable: false,
    value: function value() {
      return index(this);
    }
  });
}
function errorHandler(errorResponse) {
  var config = errorResponse.config, response = errorResponse.response;
  var errorName;
  if (config && config.headers && config.headers["Authorization"]) {
    var token = "...".concat(config.headers["Authorization"].toString().substr(-5));
    config.headers["Authorization"] = "Bearer ".concat(token);
  }
  if (!(0, import_lodash2.default)(response) || !(0, import_lodash2.default)(config)) {
    throw errorResponse;
  }
  var data = response === null || response === void 0 ? void 0 : response.data;
  var errorData = {
    status: response === null || response === void 0 ? void 0 : response.status,
    statusText: response === null || response === void 0 ? void 0 : response.statusText,
    message: "",
    details: {}
  };
  if ((0, import_lodash2.default)(config)) {
    errorData.request = {
      url: config.url,
      headers: config.headers,
      method: config.method,
      payloadData: config.data
    };
  }
  if (data && (0, import_lodash2.default)(data)) {
    if ("requestId" in data) {
      errorData.requestId = data.requestId || "UNKNOWN";
    }
    if ("message" in data) {
      errorData.message = data.message || "";
    }
    if ("details" in data) {
      errorData.details = data.details || {};
    }
    if ("sys" in data) {
      if ("id" in data.sys) {
        errorName = data.sys.id;
      }
    }
  }
  var error = new Error();
  error.name = errorName && errorName !== "Unknown" ? errorName : "".concat(response === null || response === void 0 ? void 0 : response.status, " ").concat(response === null || response === void 0 ? void 0 : response.statusText);
  try {
    error.message = JSON.stringify(errorData, null, "  ");
  } catch (_unused) {
    var _errorData$message;
    error.message = (_errorData$message = errorData === null || errorData === void 0 ? void 0 : errorData.message) !== null && _errorData$message !== void 0 ? _errorData$message : "";
  }
  throw error;
}
var import_qs, import_lodash, import_p_throttle, import_lodash2, PERCENTAGE_REGEX, rateLimitThrottle, delay, defaultWait, HOST_REGEX;
var init_index_es_modules = __esm({
  "node_modules/contentful-sdk-core/dist/index.es-modules.js"() {
    "use strict";
    init_esm();
    import_qs = __toESM(require_lib2());
    import_lodash = __toESM(require_lodash());
    import_p_throttle = __toESM(require_p_throttle());
    import_lodash2 = __toESM(require_lodash2());
    PERCENTAGE_REGEX = /* @__PURE__ */ _wrapRegExp(/(\d+)(%)/, {
      value: 1
    });
    rateLimitThrottle = function(axiosInstance) {
      var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "auto";
      var _axiosInstance$defaul = axiosInstance.defaults.logHandler, logHandler = _axiosInstance$defaul === void 0 ? noop : _axiosInstance$defaul;
      var limit = (0, import_lodash.default)(type) ? calculateLimit(type) : calculateLimit("auto", type);
      var throttle = createThrottle(limit, logHandler);
      var isCalculated = false;
      var requestInterceptorId = axiosInstance.interceptors.request.use(function(config) {
        return throttle(function() {
          return config;
        })();
      }, function(error) {
        return Promise.reject(error);
      });
      var responseInterceptorId = axiosInstance.interceptors.response.use(function(response) {
        if (!isCalculated && (0, import_lodash.default)(type) && (type === "auto" || PERCENTAGE_REGEX.test(type)) && response.headers && response.headers["x-contentful-ratelimit-second-limit"]) {
          var rawLimit = parseInt(response.headers["x-contentful-ratelimit-second-limit"]);
          var nextLimit = calculateLimit(type, rawLimit);
          if (nextLimit !== limit) {
            if (requestInterceptorId) {
              axiosInstance.interceptors.request.eject(requestInterceptorId);
            }
            limit = nextLimit;
            throttle = createThrottle(nextLimit, logHandler);
            requestInterceptorId = axiosInstance.interceptors.request.use(function(config) {
              return throttle(function() {
                return config;
              })();
            }, function(error) {
              return Promise.reject(error);
            });
          }
          isCalculated = true;
        }
        return response;
      }, function(error) {
        return Promise.reject(error);
      });
      return function() {
        axiosInstance.interceptors.request.eject(requestInterceptorId);
        axiosInstance.interceptors.response.eject(responseInterceptorId);
      };
    };
    delay = function delay2(ms) {
      return new Promise(function(resolve2) {
        setTimeout(resolve2, ms);
      });
    };
    defaultWait = function defaultWait2(attempts) {
      return Math.pow(Math.SQRT2, attempts);
    };
    HOST_REGEX = /^(?!\w+:\/\/)([^\s:]+\.?[^\s:]+)(?::(\d+))?(?!:)$/;
  }
});

// node_modules/contentful/dist/es-modules/entities/space.js
var require_space = __commonJS({
  "node_modules/contentful/dist/es-modules/entities/space.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.wrapSpace = wrapSpace;
    var _contentfulSdkCore = (init_index_es_modules(), __toCommonJS(index_es_modules_exports));
    function wrapSpace(data) {
      return (0, _contentfulSdkCore.freezeSys)((0, _contentfulSdkCore.toPlainObject)(data));
    }
  }
});

// node_modules/contentful/node_modules/fast-copy/dist/fast-copy.esm.js
var fast_copy_esm_exports = {};
__export(fast_copy_esm_exports, {
  default: () => copy
});
function copy(value, options) {
  var isStrict = !!(options && options.isStrict);
  var realm = options && options.realm || GLOBAL_THIS;
  var getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose;
  var handleCopy = function(value2, cache) {
    if (!value2 || typeof value2 !== "object") {
      return value2;
    }
    if (cache.has(value2)) {
      return cache.get(value2);
    }
    var prototype = value2.__proto__ || getPrototypeOf2(value2);
    var Constructor = prototype && prototype.constructor;
    if (!Constructor || Constructor === realm.Object) {
      return getObjectClone(value2, realm, handleCopy, cache);
    }
    var clone2;
    if (isArray2(value2)) {
      if (isStrict) {
        return getObjectCloneStrict(value2, realm, handleCopy, cache);
      }
      clone2 = new Constructor();
      cache.set(value2, clone2);
      for (var index2 = 0, length_1 = value2.length; index2 < length_1; ++index2) {
        clone2[index2] = handleCopy(value2[index2], cache);
      }
      return clone2;
    }
    if (value2 instanceof realm.Date) {
      return new Constructor(value2.getTime());
    }
    if (value2 instanceof realm.RegExp) {
      clone2 = new Constructor(value2.source, value2.flags || getRegExpFlags2(value2));
      clone2.lastIndex = value2.lastIndex;
      return clone2;
    }
    if (realm.Map && value2 instanceof realm.Map) {
      clone2 = new Constructor();
      cache.set(value2, clone2);
      value2.forEach(function(value3, key) {
        clone2.set(key, handleCopy(value3, cache));
      });
      return clone2;
    }
    if (realm.Set && value2 instanceof realm.Set) {
      clone2 = new Constructor();
      cache.set(value2, clone2);
      value2.forEach(function(value3) {
        clone2.add(handleCopy(value3, cache));
      });
      return clone2;
    }
    if (realm.Blob && value2 instanceof realm.Blob) {
      return value2.slice(0, value2.size, value2.type);
    }
    if (realm.Buffer && realm.Buffer.isBuffer(value2)) {
      clone2 = realm.Buffer.allocUnsafe ? realm.Buffer.allocUnsafe(value2.length) : new Constructor(value2.length);
      cache.set(value2, clone2);
      value2.copy(clone2);
      return clone2;
    }
    if (realm.ArrayBuffer) {
      if (realm.ArrayBuffer.isView(value2)) {
        clone2 = new Constructor(value2.buffer.slice(0));
        cache.set(value2, clone2);
        return clone2;
      }
      if (value2 instanceof realm.ArrayBuffer) {
        clone2 = value2.slice(0);
        cache.set(value2, clone2);
        return clone2;
      }
    }
    if (
      // promise-like
      typeof value2.then === "function" || // errors
      value2 instanceof Error || // weakmaps
      realm.WeakMap && value2 instanceof realm.WeakMap || // weaksets
      realm.WeakSet && value2 instanceof realm.WeakSet
    ) {
      return value2;
    }
    return getObjectClone(value2, realm, handleCopy, cache);
  };
  return handleCopy(value, createCache2());
}
var toStringFunction2, create2, defineProperty2, getOwnPropertyDescriptor2, getOwnPropertyNames2, getOwnPropertySymbols2, getPrototypeOf$1, _a2, hasOwnProperty2, propertyIsEnumerable2, SYMBOL_PROPERTIES, WEAK_MAP, createCache2, getCleanClone2, getObjectCloneLoose, getObjectCloneStrict, getRegExpFlags2, isArray2, getPrototypeOf2, GLOBAL_THIS;
var init_fast_copy_esm = __esm({
  "node_modules/contentful/node_modules/fast-copy/dist/fast-copy.esm.js"() {
    "use strict";
    toStringFunction2 = Function.prototype.toString;
    create2 = Object.create;
    defineProperty2 = Object.defineProperty;
    getOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
    getOwnPropertyNames2 = Object.getOwnPropertyNames;
    getOwnPropertySymbols2 = Object.getOwnPropertySymbols;
    getPrototypeOf$1 = Object.getPrototypeOf;
    _a2 = Object.prototype;
    hasOwnProperty2 = _a2.hasOwnProperty;
    propertyIsEnumerable2 = _a2.propertyIsEnumerable;
    SYMBOL_PROPERTIES = typeof getOwnPropertySymbols2 === "function";
    WEAK_MAP = typeof WeakMap === "function";
    createCache2 = function() {
      if (WEAK_MAP) {
        return function() {
          return /* @__PURE__ */ new WeakMap();
        };
      }
      var Cache = (
        /** @class */
        function() {
          function Cache2() {
            this._keys = [];
            this._values = [];
          }
          Cache2.prototype.has = function(key) {
            return !!~this._keys.indexOf(key);
          };
          Cache2.prototype.get = function(key) {
            return this._values[this._keys.indexOf(key)];
          };
          Cache2.prototype.set = function(key, value) {
            this._keys.push(key);
            this._values.push(value);
          };
          return Cache2;
        }()
      );
      return function() {
        return new Cache();
      };
    }();
    getCleanClone2 = function(object, realm) {
      var prototype = object.__proto__ || getPrototypeOf$1(object);
      if (!prototype) {
        return create2(null);
      }
      var Constructor = prototype.constructor;
      if (Constructor === realm.Object) {
        return prototype === realm.Object.prototype ? {} : create2(prototype);
      }
      if (~toStringFunction2.call(Constructor).indexOf("[native code]")) {
        try {
          return new Constructor();
        } catch (_a4) {
        }
      }
      return create2(prototype);
    };
    getObjectCloneLoose = function(object, realm, handleCopy, cache) {
      var clone2 = getCleanClone2(object, realm);
      cache.set(object, clone2);
      for (var key in object) {
        if (hasOwnProperty2.call(object, key)) {
          clone2[key] = handleCopy(object[key], cache);
        }
      }
      if (SYMBOL_PROPERTIES) {
        var symbols = getOwnPropertySymbols2(object);
        for (var index2 = 0, length_1 = symbols.length, symbol = void 0; index2 < length_1; ++index2) {
          symbol = symbols[index2];
          if (propertyIsEnumerable2.call(object, symbol)) {
            clone2[symbol] = handleCopy(object[symbol], cache);
          }
        }
      }
      return clone2;
    };
    getObjectCloneStrict = function(object, realm, handleCopy, cache) {
      var clone2 = getCleanClone2(object, realm);
      cache.set(object, clone2);
      var properties = SYMBOL_PROPERTIES ? getOwnPropertyNames2(object).concat(getOwnPropertySymbols2(object)) : getOwnPropertyNames2(object);
      for (var index2 = 0, length_2 = properties.length, property = void 0, descriptor = void 0; index2 < length_2; ++index2) {
        property = properties[index2];
        if (property !== "callee" && property !== "caller") {
          descriptor = getOwnPropertyDescriptor2(object, property);
          if (descriptor) {
            if (!descriptor.get && !descriptor.set) {
              descriptor.value = handleCopy(object[property], cache);
            }
            try {
              defineProperty2(clone2, property, descriptor);
            } catch (error) {
              clone2[property] = descriptor.value;
            }
          } else {
            clone2[property] = handleCopy(object[property], cache);
          }
        }
      }
      return clone2;
    };
    getRegExpFlags2 = function(regExp) {
      var flags = "";
      if (regExp.global) {
        flags += "g";
      }
      if (regExp.ignoreCase) {
        flags += "i";
      }
      if (regExp.multiline) {
        flags += "m";
      }
      if (regExp.unicode) {
        flags += "u";
      }
      if (regExp.sticky) {
        flags += "y";
      }
      return flags;
    };
    isArray2 = Array.isArray;
    getPrototypeOf2 = Object.getPrototypeOf;
    GLOBAL_THIS = function() {
      if (typeof globalThis !== "undefined") {
        return globalThis;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      if (console && console.error) {
        console.error('Unable to locate global object, returning "this".');
      }
      return this;
    }();
    copy.default = copy;
    copy.strict = function strictCopy(value, options) {
      return copy(value, {
        isStrict: true,
        realm: options ? options.realm : void 0
      });
    };
  }
});

// node_modules/json-stringify-safe/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/json-stringify-safe/stringify.js"(exports, module2) {
    "use strict";
    exports = module2.exports = stringify2;
    exports.getSerialize = serializer;
    function stringify2(obj, replacer, spaces, cycleReplacer) {
      return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
    }
    function serializer(replacer, cycleReplacer) {
      var stack = [], keys = [];
      if (cycleReplacer == null)
        cycleReplacer = function(key, value) {
          if (stack[0] === value)
            return "[Circular ~]";
          return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
        };
      return function(key, value) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this);
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
          if (~stack.indexOf(value))
            value = cycleReplacer.call(this, key, value);
        } else
          stack.push(value);
        return replacer == null ? value : replacer.call(this, key, value);
      };
    }
  }
});

// node_modules/contentful/dist/es-modules/mixins/stringify-safe.js
var require_stringify_safe = __commonJS({
  "node_modules/contentful/dist/es-modules/mixins/stringify-safe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = mixinStringifySafe;
    var _jsonStringifySafe = _interopRequireDefault(require_stringify2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function mixinStringifySafe(data) {
      return Object.defineProperty(data, "stringifySafe", {
        enumerable: false,
        configurable: false,
        writable: false,
        value: function() {
          let serializer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          let indent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          return (0, _jsonStringifySafe.default)(this, serializer, indent, (key, value) => {
            return {
              sys: {
                type: "Link",
                linkType: "Entry",
                id: value.sys.id,
                circular: true
              }
            };
          });
        }
      });
    }
  }
});

// node_modules/contentful-resolve-response/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  default: () => esm_default
});
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var _typeof2, UNRESOLVED_LINK, isLink, makeLookupKey, getLink, cleanUpLinks, walkMutate, normalizeLink, makeEntryObject, resolveResponse, esm_default;
var init_esm2 = __esm({
  "node_modules/contentful-resolve-response/dist/esm/index.js"() {
    "use strict";
    init_esm();
    _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    UNRESOLVED_LINK = {};
    isLink = function isLink2(object) {
      return object && object.sys && object.sys.type === "Link";
    };
    makeLookupKey = function makeLookupKey2(sys) {
      return sys.type + "!" + sys.id;
    };
    getLink = function getLink2(entityMap, link) {
      var _link$sys = link.sys, type = _link$sys.linkType, id = _link$sys.id;
      var lookupKey = makeLookupKey({ type, id });
      return entityMap.get(lookupKey) || UNRESOLVED_LINK;
    };
    cleanUpLinks = function cleanUpLinks2(input) {
      if (Array.isArray(input)) {
        return input.filter(function(val) {
          return val !== UNRESOLVED_LINK;
        });
      }
      for (var key in input) {
        if (input[key] === UNRESOLVED_LINK) {
          delete input[key];
        }
      }
      return input;
    };
    walkMutate = function walkMutate2(input, predicate, mutator, removeUnresolved) {
      if (predicate(input)) {
        return mutator(input);
      }
      if (input && (typeof input === "undefined" ? "undefined" : _typeof2(input)) === "object") {
        for (var key in input) {
          if (input.hasOwnProperty(key)) {
            input[key] = walkMutate2(input[key], predicate, mutator, removeUnresolved);
          }
        }
        if (removeUnresolved) {
          input = cleanUpLinks(input);
        }
      }
      return input;
    };
    normalizeLink = function normalizeLink2(entityMap, link, removeUnresolved) {
      var resolvedLink = getLink(entityMap, link);
      if (resolvedLink === UNRESOLVED_LINK) {
        return removeUnresolved ? resolvedLink : link;
      }
      return resolvedLink;
    };
    makeEntryObject = function makeEntryObject2(item, itemEntryPoints) {
      if (!Array.isArray(itemEntryPoints)) {
        return item;
      }
      var entryPoints = Object.keys(item).filter(function(ownKey) {
        return itemEntryPoints.indexOf(ownKey) !== -1;
      });
      return entryPoints.reduce(function(entryObj, entryPoint) {
        entryObj[entryPoint] = item[entryPoint];
        return entryObj;
      }, {});
    };
    resolveResponse = function resolveResponse2(response, options) {
      options = options || {};
      if (!response.items) {
        return [];
      }
      var responseClone = index(response);
      var allIncludes = Object.keys(responseClone.includes || {}).reduce(function(all, type) {
        return [].concat(_toConsumableArray(all), _toConsumableArray(response.includes[type]));
      }, []);
      var allEntries = [].concat(_toConsumableArray(responseClone.items), _toConsumableArray(allIncludes));
      var entityMap = new Map(allEntries.map(function(entity) {
        return [makeLookupKey(entity.sys), entity];
      }));
      allEntries.forEach(function(item) {
        var entryObject = makeEntryObject(item, options.itemEntryPoints);
        Object.assign(item, walkMutate(entryObject, isLink, function(link) {
          return normalizeLink(entityMap, link, options.removeUnresolved);
        }, options.removeUnresolved));
      });
      return responseClone.items;
    };
    esm_default = resolveResponse;
  }
});

// node_modules/contentful/dist/es-modules/entities/entry.js
var require_entry = __commonJS({
  "node_modules/contentful/dist/es-modules/entities/entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.wrapEntry = wrapEntry;
    exports.wrapEntryCollection = wrapEntryCollection;
    var _fastCopy = _interopRequireDefault((init_fast_copy_esm(), __toCommonJS(fast_copy_esm_exports)));
    var _contentfulSdkCore = (init_index_es_modules(), __toCommonJS(index_es_modules_exports));
    var _stringifySafe = _interopRequireDefault(require_stringify_safe());
    var _contentfulResolveResponse = _interopRequireDefault((init_esm2(), __toCommonJS(esm_exports)));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function wrapEntry(data) {
      return (0, _contentfulSdkCore.freezeSys)((0, _contentfulSdkCore.toPlainObject)((0, _fastCopy.default)(data)));
    }
    function wrapEntryCollection(data, _ref) {
      let {
        resolveLinks,
        removeUnresolved
      } = _ref;
      const wrappedData = (0, _stringifySafe.default)((0, _contentfulSdkCore.toPlainObject)((0, _fastCopy.default)(data)));
      if (resolveLinks) {
        wrappedData.items = (0, _contentfulResolveResponse.default)(wrappedData, {
          removeUnresolved,
          itemEntryPoints: ["fields"]
        });
      }
      return (0, _contentfulSdkCore.freezeSys)(wrappedData);
    }
  }
});

// node_modules/contentful/dist/es-modules/entities/asset.js
var require_asset = __commonJS({
  "node_modules/contentful/dist/es-modules/entities/asset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.wrapAsset = wrapAsset;
    exports.wrapAssetCollection = wrapAssetCollection;
    var _fastCopy = _interopRequireDefault((init_fast_copy_esm(), __toCommonJS(fast_copy_esm_exports)));
    var _contentfulSdkCore = (init_index_es_modules(), __toCommonJS(index_es_modules_exports));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function wrapAsset(data) {
      return (0, _contentfulSdkCore.freezeSys)((0, _contentfulSdkCore.toPlainObject)((0, _fastCopy.default)(data)));
    }
    function wrapAssetCollection(data) {
      return (0, _contentfulSdkCore.freezeSys)((0, _contentfulSdkCore.toPlainObject)((0, _fastCopy.default)(data)));
    }
  }
});

// node_modules/contentful/dist/es-modules/entities/asset-key.js
var require_asset_key = __commonJS({
  "node_modules/contentful/dist/es-modules/entities/asset-key.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.wrapAssetKey = wrapAssetKey;
    var _fastCopy = _interopRequireDefault((init_fast_copy_esm(), __toCommonJS(fast_copy_esm_exports)));
    var _contentfulSdkCore = (init_index_es_modules(), __toCommonJS(index_es_modules_exports));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function wrapAssetKey(data) {
      return (0, _contentfulSdkCore.freezeSys)((0, _contentfulSdkCore.toPlainObject)((0, _fastCopy.default)(data)));
    }
  }
});

// node_modules/contentful/dist/es-modules/entities/content-type.js
var require_content_type = __commonJS({
  "node_modules/contentful/dist/es-modules/entities/content-type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.wrapContentType = wrapContentType;
    exports.wrapContentTypeCollection = wrapContentTypeCollection;
    var _fastCopy = _interopRequireDefault((init_fast_copy_esm(), __toCommonJS(fast_copy_esm_exports)));
    var _contentfulSdkCore = (init_index_es_modules(), __toCommonJS(index_es_modules_exports));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function wrapContentType(data) {
      return (0, _contentfulSdkCore.freezeSys)((0, _contentfulSdkCore.toPlainObject)((0, _fastCopy.default)(data)));
    }
    function wrapContentTypeCollection(data) {
      return (0, _contentfulSdkCore.freezeSys)((0, _contentfulSdkCore.toPlainObject)((0, _fastCopy.default)(data)));
    }
  }
});

// node_modules/contentful/dist/es-modules/entities/locale.js
var require_locale = __commonJS({
  "node_modules/contentful/dist/es-modules/entities/locale.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.wrapLocale = wrapLocale;
    exports.wrapLocaleCollection = wrapLocaleCollection;
    var _fastCopy = _interopRequireDefault((init_fast_copy_esm(), __toCommonJS(fast_copy_esm_exports)));
    var _contentfulSdkCore = (init_index_es_modules(), __toCommonJS(index_es_modules_exports));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function wrapLocale(data) {
      return (0, _contentfulSdkCore.freezeSys)((0, _contentfulSdkCore.toPlainObject)((0, _fastCopy.default)(data)));
    }
    function wrapLocaleCollection(data) {
      return (0, _contentfulSdkCore.freezeSys)((0, _contentfulSdkCore.toPlainObject)((0, _fastCopy.default)(data)));
    }
  }
});

// node_modules/contentful/dist/es-modules/entities/tag.js
var require_tag = __commonJS({
  "node_modules/contentful/dist/es-modules/entities/tag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.wrapTag = wrapTag;
    exports.wrapTagCollection = wrapTagCollection;
    var _fastCopy = _interopRequireDefault((init_fast_copy_esm(), __toCommonJS(fast_copy_esm_exports)));
    var _contentfulSdkCore = (init_index_es_modules(), __toCommonJS(index_es_modules_exports));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function wrapTag(data) {
      return (0, _contentfulSdkCore.freezeSys)((0, _contentfulSdkCore.toPlainObject)((0, _fastCopy.default)(data)));
    }
    function wrapTagCollection(data) {
      return (0, _contentfulSdkCore.freezeSys)((0, _contentfulSdkCore.toPlainObject)((0, _fastCopy.default)(data)));
    }
  }
});

// node_modules/contentful/dist/es-modules/entities/index.js
var require_entities = __commonJS({
  "node_modules/contentful/dist/es-modules/entities/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var space = _interopRequireWildcard(require_space());
    var entry = _interopRequireWildcard(require_entry());
    var asset = _interopRequireWildcard(require_asset());
    var assetKey = _interopRequireWildcard(require_asset_key());
    var contentType = _interopRequireWildcard(require_content_type());
    var locale = _interopRequireWildcard(require_locale());
    var tag = _interopRequireWildcard(require_tag());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var _default = {
      space,
      entry,
      asset,
      assetKey,
      contentType,
      locale,
      tag
    };
    exports.default = _default;
  }
});

// node_modules/contentful/dist/es-modules/paged-sync.js
var require_paged_sync = __commonJS({
  "node_modules/contentful/dist/es-modules/paged-sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = pagedSync;
    var _contentfulSdkCore = (init_index_es_modules(), __toCommonJS(index_es_modules_exports));
    var _contentfulResolveResponse = _interopRequireDefault((init_esm2(), __toCommonJS(esm_exports)));
    var _stringifySafe = _interopRequireDefault(require_stringify_safe());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
          _defineProperty5(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty5(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    async function pagedSync(http2, query2) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (!query2 || !query2.initial && !query2.nextSyncToken && !query2.nextPageToken) {
        throw new Error("Please provide one of `initial`, `nextSyncToken` or `nextPageToken` parameters for syncing");
      }
      if (query2 && query2.content_type && !query2.type) {
        query2.type = "Entry";
      } else if (query2 && query2.content_type && query2.type && query2.type !== "Entry") {
        throw new Error("When using the `content_type` filter your `type` parameter cannot be different from `Entry`.");
      }
      const defaultOptions = {
        resolveLinks: true,
        removeUnresolved: false,
        paginate: true
      };
      const {
        resolveLinks,
        removeUnresolved,
        paginate
      } = _objectSpread3(_objectSpread3({}, defaultOptions), options);
      const syncOptions = {
        paginate
      };
      const response = await getSyncPage(http2, [], query2, syncOptions);
      if (resolveLinks) {
        response.items = (0, _contentfulResolveResponse.default)(response, {
          removeUnresolved,
          itemEntryPoints: ["fields"]
        });
      }
      const mappedResponseItems = mapResponseItems(response.items);
      if (response.nextSyncToken) {
        mappedResponseItems.nextSyncToken = response.nextSyncToken;
      }
      if (response.nextPageToken) {
        mappedResponseItems.nextPageToken = response.nextPageToken;
      }
      return (0, _contentfulSdkCore.freezeSys)((0, _stringifySafe.default)((0, _contentfulSdkCore.toPlainObject)(mappedResponseItems)));
    }
    function mapResponseItems(items) {
      const reducer = (type) => {
        return (accumulated, item) => {
          if (item.sys.type === type) {
            accumulated.push((0, _contentfulSdkCore.toPlainObject)(item));
          }
          return accumulated;
        };
      };
      return {
        entries: items.reduce(reducer("Entry"), []),
        assets: items.reduce(reducer("Asset"), []),
        deletedEntries: items.reduce(reducer("DeletedEntry"), []),
        deletedAssets: items.reduce(reducer("DeletedAsset"), [])
      };
    }
    async function getSyncPage(http2, items, query2, _ref) {
      let {
        paginate
      } = _ref;
      if (query2.nextSyncToken) {
        query2.sync_token = query2.nextSyncToken;
        delete query2.nextSyncToken;
      }
      if (query2.nextPageToken) {
        query2.sync_token = query2.nextPageToken;
        delete query2.nextPageToken;
      }
      if (query2.sync_token) {
        delete query2.initial;
        delete query2.type;
        delete query2.content_type;
        delete query2.limit;
      }
      const response = await http2.get("sync", (0, _contentfulSdkCore.createRequestConfig)({
        query: query2
      }));
      const data = response.data || {};
      items = items.concat(data.items || []);
      if (data.nextPageUrl) {
        if (paginate) {
          delete query2.initial;
          query2.sync_token = getToken(data.nextPageUrl);
          return getSyncPage(http2, items, query2, {
            paginate
          });
        }
        return {
          items,
          nextPageToken: getToken(data.nextPageUrl)
        };
      } else if (data.nextSyncUrl) {
        return {
          items,
          nextSyncToken: getToken(data.nextSyncUrl)
        };
      } else {
        return {
          items: []
        };
      }
    }
    function getToken(url) {
      const urlParts = url.split("?");
      return urlParts.length > 0 ? urlParts[1].replace("sync_token=", "") : "";
    }
  }
});

// node_modules/contentful/dist/es-modules/utils/normalize-select.js
var require_normalize_select = __commonJS({
  "node_modules/contentful/dist/es-modules/utils/normalize-select.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = normalizeSelect;
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
          _defineProperty5(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty5(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function normalizeSelect(query2) {
      if (!query2.select) {
        return query2;
      }
      const allSelects = Array.isArray(query2.select) ? query2.select : query2.select.split(",");
      const selectedSet = new Set(allSelects);
      if (selectedSet.has("sys")) {
        return query2;
      }
      selectedSet.add("sys.id");
      selectedSet.add("sys.type");
      return _objectSpread3(_objectSpread3({}, query2), {}, {
        select: [...selectedSet].join(",")
      });
    }
  }
});

// node_modules/contentful/dist/es-modules/utils/validate-timestamp.js
var require_validate_timestamp = __commonJS({
  "node_modules/contentful/dist/es-modules/utils/validate-timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ValidationError = void 0;
    exports.default = validateTimestamp;
    var ValidationError4 = class extends Error {
      constructor(name, message) {
        super(`Invalid "${name}" provided, ` + message);
        this.name = "ValidationError";
      }
    };
    exports.ValidationError = ValidationError4;
    function validateTimestamp(name, timestamp, options) {
      options = options || {};
      if (typeof timestamp !== "number") {
        throw new ValidationError4(name, `only numeric values are allowed for timestamps, provided type was "${typeof timestamp}"`);
      }
      if (options.maximum && timestamp > options.maximum) {
        throw new ValidationError4(name, `value (${timestamp}) cannot be further in the future than expected maximum (${options.maximum})`);
      }
      if (options.now && timestamp < options.now) {
        throw new ValidationError4(name, `value (${timestamp}) cannot be in the past, current time was ${options.now}`);
      }
    }
  }
});

// node_modules/contentful/dist/es-modules/create-contentful-api.js
var require_create_contentful_api = __commonJS({
  "node_modules/contentful/dist/es-modules/create-contentful-api.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createContentfulApi;
    var _contentfulSdkCore = (init_index_es_modules(), __toCommonJS(index_es_modules_exports));
    var _entities = _interopRequireDefault(require_entities());
    var _pagedSync = _interopRequireDefault(require_paged_sync());
    var _normalizeSelect = _interopRequireDefault(require_normalize_select());
    var _validateTimestamp = _interopRequireDefault(require_validate_timestamp());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
          _defineProperty5(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty5(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ASSET_KEY_MAX_LIFETIME = 48 * 60 * 60;
    function createContentfulApi(_ref) {
      let {
        http: http2,
        getGlobalOptions
      } = _ref;
      const {
        wrapSpace
      } = _entities.default.space;
      const {
        wrapContentType,
        wrapContentTypeCollection
      } = _entities.default.contentType;
      const {
        wrapEntry,
        wrapEntryCollection
      } = _entities.default.entry;
      const {
        wrapAsset,
        wrapAssetCollection
      } = _entities.default.asset;
      const {
        wrapTag,
        wrapTagCollection
      } = _entities.default.tag;
      const {
        wrapAssetKey
      } = _entities.default.assetKey;
      const {
        wrapLocaleCollection
      } = _entities.default.locale;
      const notFoundError = (id) => {
        const error = new Error("The resource could not be found.");
        error.sys = {
          type: "Error",
          id: "NotFound"
        };
        error.details = {
          type: "Entry",
          id,
          environment: getGlobalOptions().environment,
          space: getGlobalOptions().space
        };
        return error;
      };
      async function getSpace() {
        switchToSpace(http2);
        try {
          const response = await http2.get("/");
          return wrapSpace(response.data);
        } catch (error) {
          (0, _contentfulSdkCore.errorHandler)(error);
        }
      }
      async function getContentType(id) {
        switchToEnvironment(http2);
        try {
          const response = await http2.get(`content_types/${id}`);
          return wrapContentType(response.data);
        } catch (error) {
          (0, _contentfulSdkCore.errorHandler)(error);
        }
      }
      async function getContentTypes() {
        let query2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        switchToEnvironment(http2);
        try {
          const response = await http2.get("content_types", (0, _contentfulSdkCore.createRequestConfig)({
            query: query2
          }));
          return wrapContentTypeCollection(response.data);
        } catch (error) {
          (0, _contentfulSdkCore.errorHandler)(error);
        }
      }
      async function getEntry(id) {
        let query2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (!id) {
          throw notFoundError(id);
        }
        try {
          const response = await this.getEntries(_objectSpread3({
            "sys.id": id
          }, query2));
          if (response.items.length > 0) {
            return wrapEntry(response.items[0]);
          } else {
            throw notFoundError(id);
          }
        } catch (error) {
          (0, _contentfulSdkCore.errorHandler)(error);
        }
      }
      async function getEntries() {
        let query2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        switchToEnvironment(http2);
        const {
          resolveLinks,
          removeUnresolved
        } = getGlobalOptions(query2);
        query2 = (0, _normalizeSelect.default)(query2);
        try {
          const response = await http2.get("entries", (0, _contentfulSdkCore.createRequestConfig)({
            query: query2
          }));
          return wrapEntryCollection(response.data, {
            resolveLinks,
            removeUnresolved
          });
        } catch (error) {
          (0, _contentfulSdkCore.errorHandler)(error);
        }
      }
      async function getAsset(id) {
        let query2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        switchToEnvironment(http2);
        query2 = (0, _normalizeSelect.default)(query2);
        try {
          const response = await http2.get(`assets/${id}`, (0, _contentfulSdkCore.createRequestConfig)({
            query: query2
          }));
          return wrapAsset(response.data);
        } catch (error) {
          (0, _contentfulSdkCore.errorHandler)(error);
        }
      }
      async function getAssets() {
        let query2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        switchToEnvironment(http2);
        query2 = (0, _normalizeSelect.default)(query2);
        try {
          const response = await http2.get("assets", (0, _contentfulSdkCore.createRequestConfig)({
            query: query2
          }));
          return wrapAssetCollection(response.data);
        } catch (error) {
          (0, _contentfulSdkCore.errorHandler)(error);
        }
      }
      async function getTag2(id) {
        switchToEnvironment(http2);
        try {
          const response = await http2.get(`tags/${id}`);
          return wrapTag(response.data);
        } catch (error) {
          (0, _contentfulSdkCore.errorHandler)(error);
        }
      }
      async function getTags() {
        let query2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        switchToEnvironment(http2);
        query2 = (0, _normalizeSelect.default)(query2);
        try {
          const response = await http2.get("tags", (0, _contentfulSdkCore.createRequestConfig)({
            query: query2
          }));
          return wrapTagCollection(response.data);
        } catch (error) {
          (0, _contentfulSdkCore.errorHandler)(error);
        }
      }
      async function createAssetKey(expiresAt) {
        switchToEnvironment(http2);
        try {
          const now2 = Math.floor(Date.now() / 1e3);
          const currentMaxLifetime = now2 + ASSET_KEY_MAX_LIFETIME;
          (0, _validateTimestamp.default)("expiresAt", expiresAt, {
            maximum: currentMaxLifetime,
            now: now2
          });
          const params = {
            expiresAt
          };
          const response = await http2.post("asset_keys", params);
          return wrapAssetKey(response.data);
        } catch (error) {
          (0, _contentfulSdkCore.errorHandler)(error);
        }
      }
      async function getLocales() {
        let query2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        switchToEnvironment(http2);
        try {
          const response = await http2.get("locales", (0, _contentfulSdkCore.createRequestConfig)({
            query: query2
          }));
          return wrapLocaleCollection(response.data);
        } catch (error) {
          (0, _contentfulSdkCore.errorHandler)(error);
        }
      }
      async function sync() {
        let query2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          paginate: true
        };
        const {
          resolveLinks,
          removeUnresolved
        } = getGlobalOptions(query2);
        switchToEnvironment(http2);
        return (0, _pagedSync.default)(http2, query2, _objectSpread3({
          resolveLinks,
          removeUnresolved
        }, options));
      }
      function parseEntries(data) {
        const {
          resolveLinks,
          removeUnresolved
        } = getGlobalOptions({});
        return wrapEntryCollection(data, {
          resolveLinks,
          removeUnresolved
        });
      }
      function switchToEnvironment(http3) {
        http3.defaults.baseURL = getGlobalOptions().environmentBaseUrl;
      }
      function switchToSpace(http3) {
        http3.defaults.baseURL = getGlobalOptions().spaceBaseUrl;
      }
      return {
        getSpace,
        getContentType,
        getContentTypes,
        getEntry,
        getEntries,
        getAsset,
        getAssets,
        getTag: getTag2,
        getTags,
        createAssetKey,
        getLocales,
        parseEntries,
        sync
      };
    }
  }
});

// node_modules/contentful/dist/es-modules/create-global-options.js
var require_create_global_options = __commonJS({
  "node_modules/contentful/dist/es-modules/create-global-options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createGlobalOptions;
    function createGlobalOptions(globalSettings) {
      return function getGlobalOptions(query2) {
        return Object.assign({}, globalSettings, query2);
      };
    }
  }
});

// node_modules/contentful/dist/es-modules/contentful.js
var require_contentful = __commonJS({
  "node_modules/contentful/dist/es-modules/contentful.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createClient = createClient3;
    var _axios = _interopRequireDefault(require_axios4());
    var _contentfulSdkCore = (init_index_es_modules(), __toCommonJS(index_es_modules_exports));
    var _createContentfulApi = _interopRequireDefault(require_create_contentful_api());
    var _createGlobalOptions = _interopRequireDefault(require_create_global_options());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
          _defineProperty5(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty5(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function createClient3(params) {
      if (!params.accessToken) {
        throw new TypeError("Expected parameter accessToken");
      }
      if (!params.space) {
        throw new TypeError("Expected parameter space");
      }
      const defaultConfig = {
        resolveLinks: true,
        removeUnresolved: false,
        defaultHostname: "cdn.contentful.com",
        environment: "master"
      };
      const config = _objectSpread3(_objectSpread3({}, defaultConfig), params);
      const userAgentHeader = (0, _contentfulSdkCore.getUserAgentHeader)(`contentful.js/${"9.2.5"}`, config.application, config.integration);
      config.headers = _objectSpread3(_objectSpread3({}, config.headers), {}, {
        "Content-Type": "application/vnd.contentful.delivery.v1+json",
        "X-Contentful-User-Agent": userAgentHeader
      });
      const http2 = (0, _contentfulSdkCore.createHttpClient)(_axios.default, config);
      const getGlobalOptions = (0, _createGlobalOptions.default)({
        resolveLinks: config.resolveLinks,
        environment: config.environment,
        removeUnresolved: config.removeUnresolved,
        spaceBaseUrl: http2.defaults.baseURL,
        environmentBaseUrl: `${http2.defaults.baseURL}environments/${config.environment}`
      });
      http2.defaults.baseURL = getGlobalOptions().environmentBaseUrl;
      return (0, _createContentfulApi.default)({
        http: http2,
        getGlobalOptions
      });
    }
  }
});

// node_modules/is-retry-allowed/index.js
var require_is_retry_allowed = __commonJS({
  "node_modules/is-retry-allowed/index.js"(exports, module2) {
    "use strict";
    var denyList = /* @__PURE__ */ new Set([
      "ENOTFOUND",
      "ENETUNREACH",
      // SSL errors from https://github.com/nodejs/node/blob/fc8e3e2cdc521978351de257030db0076d79e0ab/src/crypto/crypto_common.cc#L301-L328
      "UNABLE_TO_GET_ISSUER_CERT",
      "UNABLE_TO_GET_CRL",
      "UNABLE_TO_DECRYPT_CERT_SIGNATURE",
      "UNABLE_TO_DECRYPT_CRL_SIGNATURE",
      "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY",
      "CERT_SIGNATURE_FAILURE",
      "CRL_SIGNATURE_FAILURE",
      "CERT_NOT_YET_VALID",
      "CERT_HAS_EXPIRED",
      "CRL_NOT_YET_VALID",
      "CRL_HAS_EXPIRED",
      "ERROR_IN_CERT_NOT_BEFORE_FIELD",
      "ERROR_IN_CERT_NOT_AFTER_FIELD",
      "ERROR_IN_CRL_LAST_UPDATE_FIELD",
      "ERROR_IN_CRL_NEXT_UPDATE_FIELD",
      "OUT_OF_MEM",
      "DEPTH_ZERO_SELF_SIGNED_CERT",
      "SELF_SIGNED_CERT_IN_CHAIN",
      "UNABLE_TO_GET_ISSUER_CERT_LOCALLY",
      "UNABLE_TO_VERIFY_LEAF_SIGNATURE",
      "CERT_CHAIN_TOO_LONG",
      "CERT_REVOKED",
      "INVALID_CA",
      "PATH_LENGTH_EXCEEDED",
      "INVALID_PURPOSE",
      "CERT_UNTRUSTED",
      "CERT_REJECTED",
      "HOSTNAME_MISMATCH"
    ]);
    module2.exports = (error) => !denyList.has(error && error.code);
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/bind.js
var require_bind3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/bind.js"(exports, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/utils.js"(exports, module2) {
    "use strict";
    var bind = require_bind3();
    var toString = Object.prototype.toString;
    function isArray3(val) {
      return toString.call(val) === "[object Array]";
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer2(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return typeof FormData !== "undefined" && val instanceof FormData;
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }
      return result;
    }
    function isString2(val) {
      return typeof val === "string";
    }
    function isNumber3(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject2(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob2(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams2(val) {
      return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray3(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject2(result[key]) && isPlainObject2(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject2(val)) {
          result[key] = merge({}, val);
        } else if (isArray3(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module2.exports = {
      isArray: isArray3,
      isArrayBuffer,
      isBuffer: isBuffer2,
      isFormData,
      isArrayBufferView,
      isString: isString2,
      isNumber: isNumber3,
      isObject,
      isPlainObject: isPlainObject2,
      isUndefined,
      isDate,
      isFile,
      isBlob: isBlob2,
      isFunction,
      isStream,
      isURLSearchParams: isURLSearchParams2,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/buildURL.js"(exports, module2) {
    "use strict";
    var utils = require_utils5();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/InterceptorManager.js"(exports, module2) {
    "use strict";
    var utils = require_utils5();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module2) {
    "use strict";
    var utils = require_utils5();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/enhanceError.js
var require_enhanceError2 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/enhanceError.js"(exports, module2) {
    "use strict";
    module2.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };
      return error;
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/createError.js
var require_createError2 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/createError.js"(exports, module2) {
    "use strict";
    var enhanceError = require_enhanceError2();
    module2.exports = function createError2(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/settle.js
var require_settle3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/settle.js"(exports, module2) {
    "use strict";
    var createError2 = require_createError2();
    module2.exports = function settle(resolve2, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve2(response);
      } else {
        reject(createError2(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/cookies.js
var require_cookies4 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/cookies.js"(exports, module2) {
    "use strict";
    var utils = require_utils5();
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie2 = [];
            cookie2.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie2.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie2.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie2.push("domain=" + domain);
            }
            if (secure === true) {
              cookie2.push("secure");
            }
            document.cookie = cookie2.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/combineURLs.js"(exports, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/buildFullPath.js"(exports, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL3();
    var combineURLs = require_combineURLs3();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/parseHeaders.js"(exports, module2) {
    "use strict";
    var utils = require_utils5();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders2(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module2) {
    "use strict";
    var utils = require_utils5();
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/adapters/xhr.js
var require_xhr3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/adapters/xhr.js"(exports, module2) {
    "use strict";
    var utils = require_utils5();
    var settle = require_settle3();
    var cookies = require_cookies4();
    var buildURL = require_buildURL3();
    var buildFullPath = require_buildFullPath3();
    var parseHeaders2 = require_parseHeaders3();
    var isURLSameOrigin = require_isURLSameOrigin3();
    var createError2 = require_createError2();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve2, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password2 = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password2);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders2(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(resolve2, reject, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError2("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError2() {
          reject(createError2("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError2(
            timeoutErrorMessage,
            config,
            config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken) {
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }
            request.abort();
            reject(cancel);
            request = null;
          });
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/package.json
var require_package3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/package.json"(exports, module2) {
    module2.exports = {
      name: "axios",
      version: "0.21.4",
      description: "Promise based HTTP client for the browser and node.js",
      main: "index.js",
      scripts: {
        test: "grunt test",
        start: "node ./sandbox/server.js",
        build: "NODE_ENV=production grunt build",
        preversion: "npm test",
        version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
        postversion: "git push && git push --tags",
        examples: "node ./examples/server.js",
        coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
        fix: "eslint --fix lib/**/*.js"
      },
      repository: {
        type: "git",
        url: "https://github.com/axios/axios.git"
      },
      keywords: [
        "xhr",
        "http",
        "ajax",
        "promise",
        "node"
      ],
      author: "Matt Zabriskie",
      license: "MIT",
      bugs: {
        url: "https://github.com/axios/axios/issues"
      },
      homepage: "https://axios-http.com",
      devDependencies: {
        coveralls: "^3.0.0",
        "es6-promise": "^4.2.4",
        grunt: "^1.3.0",
        "grunt-banner": "^0.6.0",
        "grunt-cli": "^1.2.0",
        "grunt-contrib-clean": "^1.1.0",
        "grunt-contrib-watch": "^1.0.0",
        "grunt-eslint": "^23.0.0",
        "grunt-karma": "^4.0.0",
        "grunt-mocha-test": "^0.13.3",
        "grunt-ts": "^6.0.0-beta.19",
        "grunt-webpack": "^4.0.2",
        "istanbul-instrumenter-loader": "^1.0.0",
        "jasmine-core": "^2.4.1",
        karma: "^6.3.2",
        "karma-chrome-launcher": "^3.1.0",
        "karma-firefox-launcher": "^2.1.0",
        "karma-jasmine": "^1.1.1",
        "karma-jasmine-ajax": "^0.1.13",
        "karma-safari-launcher": "^1.0.0",
        "karma-sauce-launcher": "^4.3.6",
        "karma-sinon": "^1.0.5",
        "karma-sourcemap-loader": "^0.3.8",
        "karma-webpack": "^4.0.2",
        "load-grunt-tasks": "^3.5.2",
        minimist: "^1.2.0",
        mocha: "^8.2.1",
        sinon: "^4.5.0",
        "terser-webpack-plugin": "^4.2.3",
        typescript: "^4.0.5",
        "url-search-params": "^0.10.0",
        webpack: "^4.44.2",
        "webpack-dev-server": "^3.11.0"
      },
      browser: {
        "./lib/adapters/http.js": "./lib/adapters/xhr.js"
      },
      jsdelivr: "dist/axios.min.js",
      unpkg: "dist/axios.min.js",
      typings: "./index.d.ts",
      dependencies: {
        "follow-redirects": "^1.14.0"
      },
      bundlesize: [
        {
          path: "./dist/axios.min.js",
          threshold: "5kB"
        }
      ]
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/adapters/http.js
var require_http3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/adapters/http.js"(exports, module2) {
    "use strict";
    var utils = require_utils5();
    var settle = require_settle3();
    var buildFullPath = require_buildFullPath3();
    var buildURL = require_buildURL3();
    var http2 = require("http");
    var https2 = require("https");
    var httpFollow = require_follow_redirects().http;
    var httpsFollow = require_follow_redirects().https;
    var url = require("url");
    var zlib2 = require("zlib");
    var pkg = require_package3();
    var createError2 = require_createError2();
    var enhanceError = require_enhanceError2();
    var isHttps = /https:?/;
    function setProxy(options, proxy, location) {
      options.hostname = proxy.host;
      options.host = proxy.host;
      options.port = proxy.port;
      options.path = location;
      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
      };
    }
    module2.exports = function httpAdapter(config) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var resolve2 = function resolve3(value) {
          resolvePromise(value);
        };
        var reject = function reject2(value) {
          rejectPromise(value);
        };
        var data = config.data;
        var headers = config.headers;
        if ("User-Agent" in headers || "user-agent" in headers) {
          if (!headers["User-Agent"] && !headers["user-agent"]) {
            delete headers["User-Agent"];
            delete headers["user-agent"];
          }
        } else {
          headers["User-Agent"] = "axios/" + pkg.version;
        }
        if (data && !utils.isStream(data)) {
          if (Buffer.isBuffer(data)) {
          } else if (utils.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(createError2(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              config
            ));
          }
          headers["Content-Length"] = data.length;
        }
        var auth = void 0;
        if (config.auth) {
          var username = config.auth.username || "";
          var password2 = config.auth.password || "";
          auth = username + ":" + password2;
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || "http:";
        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(":");
          var urlUsername = urlAuth[0] || "";
          var urlPassword = urlAuth[1] || "";
          auth = urlUsername + ":" + urlPassword;
        }
        if (auth) {
          delete headers.Authorization;
        }
        var isHttpsRequest = isHttps.test(protocol);
        var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        var options = {
          path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
          method: config.method.toUpperCase(),
          headers,
          agent,
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth
        };
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname;
          options.port = parsed.port;
        }
        var proxy = config.proxy;
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol.slice(0, -1) + "_proxy";
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl);
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
            var shouldProxy = true;
            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(",").map(function trim(s) {
                return s.trim();
              });
              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false;
                }
                if (proxyElement === "*") {
                  return true;
                }
                if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true;
                }
                return parsed.hostname === proxyElement;
              });
            }
            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              };
              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                };
              }
            }
          }
        }
        if (proxy) {
          options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
          setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsProxy ? https2 : http2;
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        }
        var req = transport.request(options, function handleResponse(res) {
          if (req.aborted)
            return;
          var stream = res;
          var lastRequest = res.req || req;
          if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
            switch (res.headers["content-encoding"]) {
              case "gzip":
              case "compress":
              case "deflate":
                stream = stream.pipe(zlib2.createUnzip());
                delete res.headers["content-encoding"];
                break;
            }
          }
          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config,
            request: lastRequest
          };
          if (config.responseType === "stream") {
            response.data = stream;
            settle(resolve2, reject, response);
          } else {
            var responseBuffer = [];
            var totalResponseBytes = 0;
            stream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                stream.destroy();
                reject(createError2(
                  "maxContentLength size of " + config.maxContentLength + " exceeded",
                  config,
                  null,
                  lastRequest
                ));
              }
            });
            stream.on("error", function handleStreamError(err) {
              if (req.aborted)
                return;
              reject(enhanceError(err, config, null, lastRequest));
            });
            stream.on("end", function handleStreamEnd() {
              var responseData = Buffer.concat(responseBuffer);
              if (config.responseType !== "arraybuffer") {
                responseData = responseData.toString(config.responseEncoding);
                if (!config.responseEncoding || config.responseEncoding === "utf8") {
                  responseData = utils.stripBOM(responseData);
                }
              }
              response.data = responseData;
              settle(resolve2, reject, response);
            });
          }
        });
        req.on("error", function handleRequestError(err) {
          if (req.aborted && err.code !== "ERR_FR_TOO_MANY_REDIRECTS")
            return;
          reject(enhanceError(err, config, null, req));
        });
        if (config.timeout) {
          var timeout = parseInt(config.timeout, 10);
          if (isNaN(timeout)) {
            reject(createError2(
              "error trying to parse `config.timeout` to int",
              config,
              "ERR_PARSE_TIMEOUT",
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            req.abort();
            reject(createError2(
              "timeout of " + timeout + "ms exceeded",
              config,
              config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
              req
            ));
          });
        }
        if (config.cancelToken) {
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (req.aborted)
              return;
            req.abort();
            reject(cancel);
          });
        }
        if (utils.isStream(data)) {
          data.on("error", function handleStreamError(err) {
            reject(enhanceError(err, config, null, req));
          }).pipe(req);
        } else {
          req.end(data);
        }
      });
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/defaults.js
var require_defaults3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/defaults.js"(exports, module2) {
    "use strict";
    var utils = require_utils5();
    var normalizeHeaderName = require_normalizeHeaderName3();
    var enhanceError = require_enhanceError2();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr3();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_http3();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
    defaults.headers = {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/transformData.js
var require_transformData3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/transformData.js"(exports, module2) {
    "use strict";
    var utils = require_utils5();
    var defaults = require_defaults3();
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/cancel/isCancel.js"(exports, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/dispatchRequest.js"(exports, module2) {
    "use strict";
    var utils = require_utils5();
    var transformData = require_transformData3();
    var isCancel = require_isCancel3();
    var defaults = require_defaults3();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/mergeConfig.js"(exports, module2) {
    "use strict";
    var utils = require_utils5();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      var valueFromConfig2Keys = ["url", "method", "data"];
      var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
      var defaultToConfig2Keys = [
        "baseURL",
        "transformRequest",
        "transformResponse",
        "paramsSerializer",
        "timeout",
        "timeoutMessage",
        "withCredentials",
        "adapter",
        "responseType",
        "xsrfCookieName",
        "xsrfHeaderName",
        "onUploadProgress",
        "onDownloadProgress",
        "decompress",
        "maxContentLength",
        "maxBodyLength",
        "maxRedirects",
        "transport",
        "httpAgent",
        "httpsAgent",
        "cancelToken",
        "socketPath",
        "responseEncoding"
      ];
      var directMergeKeys = ["validateStatus"];
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      }
      utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        }
      });
      utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
      utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      utils.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
      var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
        return axiosKeys.indexOf(key) === -1;
      });
      utils.forEach(otherKeys, mergeDeepProperties);
      return config;
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/validator.js
var require_validator3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/validator.js"(exports, module2) {
    "use strict";
    var pkg = require_package3();
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    var currentVerArr = pkg.version.split(".");
    function isOlderVersion(version, thanVersion) {
      var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
      var destVer = version.split(".");
      for (var i = 0; i < 3; i++) {
        if (pkgVersionArr[i] > destVer[i]) {
          return true;
        } else if (pkgVersionArr[i] < destVer[i]) {
          return false;
        }
      }
      return false;
    }
    validators.transitional = function transitional(validator, version, message) {
      var isDeprecated = version && isOlderVersion(version);
      function formatMessage(opt, desc) {
        return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed in " + version));
        }
        if (isDeprecated && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module2.exports = {
      isOlderVersion,
      assertOptions,
      validators
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/Axios.js
var require_Axios3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/core/Axios.js"(exports, module2) {
    "use strict";
    var utils = require_utils5();
    var buildURL = require_buildURL3();
    var InterceptorManager = require_InterceptorManager3();
    var dispatchRequest = require_dispatchRequest3();
    var mergeConfig = require_mergeConfig3();
    var validator = require_validator3();
    var validators = validator.validators;
    function Axios3(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios3.prototype.request = function request(config) {
      if (typeof config === "string") {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
          forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
          clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios3.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios3.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios3.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module2.exports = Axios3;
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/cancel/Cancel.js
var require_Cancel2 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/cancel/Cancel.js"(exports, module2) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module2.exports = Cancel;
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/cancel/CancelToken.js"(exports, module2) {
    "use strict";
    var Cancel = require_Cancel2();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve2) {
        resolvePromise = resolve2;
      });
      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/spread.js
var require_spread3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/spread.js"(exports, module2) {
    "use strict";
    module2.exports = function spread(callback2) {
      return function wrap(arr) {
        return callback2.apply(null, arr);
      };
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError3 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/helpers/isAxiosError.js"(exports, module2) {
    "use strict";
    module2.exports = function isAxiosError(payload) {
      return typeof payload === "object" && payload.isAxiosError === true;
    };
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/lib/axios.js
var require_axios5 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/lib/axios.js"(exports, module2) {
    "use strict";
    var utils = require_utils5();
    var bind = require_bind3();
    var Axios3 = require_Axios3();
    var mergeConfig = require_mergeConfig3();
    var defaults = require_defaults3();
    function createInstance(defaultConfig) {
      var context = new Axios3(defaultConfig);
      var instance = bind(Axios3.prototype.request, context);
      utils.extend(instance, Axios3.prototype, context);
      utils.extend(instance, context);
      return instance;
    }
    var axios2 = createInstance(defaults);
    axios2.Axios = Axios3;
    axios2.create = function create3(instanceConfig) {
      return createInstance(mergeConfig(axios2.defaults, instanceConfig));
    };
    axios2.Cancel = require_Cancel2();
    axios2.CancelToken = require_CancelToken3();
    axios2.isCancel = require_isCancel3();
    axios2.all = function all(promises) {
      return Promise.all(promises);
    };
    axios2.spread = require_spread3();
    axios2.isAxiosError = require_isAxiosError3();
    module2.exports = axios2;
    module2.exports.default = axios2;
  }
});

// node_modules/dc-delivery-sdk-js/node_modules/axios/index.js
var require_axios6 = __commonJS({
  "node_modules/dc-delivery-sdk-js/node_modules/axios/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_axios5();
  }
});

// node_modules/@contentstack/utils/dist/index.es.js
var require_index_es = __commonJS({
  "node_modules/@contentstack/utils/dist/index.es.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function createMetadata(attribute) {
      return {
        text: attribute["#text"],
        itemUid: attribute["data-sys-entry-uid"] || attribute["data-sys-asset-uid"],
        itemType: attribute.type,
        styleType: attribute["sys-style-type"],
        attributes: attribute,
        contentTypeUid: attribute["data-sys-content-type-uid"]
      };
    }
    function nodeToMetadata(attribute, textNode) {
      return {
        text: textNode.text,
        itemUid: attribute["entry-uid"] || attribute["asset-uid"],
        itemType: attribute.type,
        styleType: attribute["display-type"],
        attributes: attribute,
        contentTypeUid: attribute["content-type-uid"]
      };
    }
    function attributeToString(attributes) {
      var result = "";
      var _loop_1 = function(key2) {
        if (Object.prototype.hasOwnProperty.call(attributes, key2)) {
          var element = attributes[key2];
          if (element instanceof Array) {
            var elementString_1 = "";
            var isFirst_1 = true;
            element.forEach(function(value2) {
              if (isFirst_1) {
                elementString_1 += "".concat(value2);
                isFirst_1 = false;
              } else {
                elementString_1 += ", ".concat(value2);
              }
            });
            element = elementString_1;
          } else if (typeof element === "object") {
            var elementString = "";
            for (var elementKey in element) {
              if (Object.prototype.hasOwnProperty.call(element, elementKey)) {
                var value = element[elementKey];
                elementString += "".concat(elementKey, ":").concat(value, "; ");
              }
            }
            element = elementString;
          }
          result += " ".concat(key2, '="').concat(element, '"');
        }
      };
      for (var key in attributes) {
        _loop_1(key);
      }
      return result;
    }
    var StyleType;
    (function(StyleType2) {
      StyleType2["BLOCK"] = "block";
      StyleType2["INLINE"] = "inline";
      StyleType2["LINK"] = "link";
      StyleType2["DISPLAY"] = "display";
      StyleType2["DOWNLOAD"] = "download";
    })(StyleType || (StyleType = {}));
    var StyleType$1 = StyleType;
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    function __extends(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    function elementToJson(element) {
      var obj = {};
      for (var i = 0; i < element.attributes.length; i++) {
        obj[element.attributes.item(i).name] = element.attributes.item(i).value;
      }
      element.childNodes.forEach(function(chileNode) {
        var node = chileNode;
        obj = __assign(__assign({}, obj), parseElement(node));
      });
      return obj;
    }
    function parseElement(node) {
      var obj = {};
      if (node.nodeType === 3) {
        obj["#text"] = node.textContent;
      } else if (node.nodeType === 1) {
        obj[node.nodeName.toLowerCase()] = elementToJson(node);
      }
      return obj;
    }
    var frameflag = "documentfragmentcontainer";
    String.prototype.forEachEmbeddedItem = function(callbackfn) {
      var str = "<".concat(frameflag, ">").concat(this.toString(), "</").concat(frameflag, ">");
      var root = new DOMParser().parseFromString(str, "text/html");
      var embeddedEntries = root.querySelectorAll(".embedded-entry");
      embeddedEntries.forEach(function(element) {
        callbackfn(element.outerHTML, createMetadata(elementToJson(element)));
      });
      var embeddedAsset = root.querySelectorAll(".embedded-asset");
      embeddedAsset.forEach(function(element) {
        callbackfn(element.outerHTML, createMetadata(elementToJson(element)));
      });
    };
    var _a$1;
    var defaultOptions = (_a$1 = {}, _a$1[StyleType$1.BLOCK] = function(item) {
      return "<div><p>".concat(item.title || item.uid, "</p><p>Content type: <span>").concat(item._content_type_uid || (item.system ? item.system.content_type_uid : ""), "</span></p></div>");
    }, _a$1[StyleType$1.INLINE] = function(item) {
      return "<span>".concat(item.title || item.uid, "</span>");
    }, _a$1[StyleType$1.LINK] = function(item, metadata) {
      return '<a href="'.concat(item.url, '">').concat(metadata.text || item.title || item.uid || (item.system ? item.system.uid : ""), "</a>");
    }, _a$1[StyleType$1.DISPLAY] = function(item, metadata) {
      return '<img src="'.concat(item.url, '" alt="').concat(metadata.attributes.alt || item.title || item.filename || item.uid || (item.system ? item.system.uid : ""), '" />');
    }, _a$1[StyleType$1.DOWNLOAD] = function(item, metadata) {
      return '<a href="'.concat(item.url, '">').concat(metadata.text || item.title || item.uid || (item.system ? item.system.content_type_uid : ""), "</a>");
    }, _a$1);
    function findEmbeddedEntry(uid, contentTypeUid, embeddeditems) {
      if (embeddeditems === void 0) {
        embeddeditems = [];
      }
      return embeddeditems.filter(function(entry) {
        if (entry.uid && entry.uid === uid && entry._content_type_uid === contentTypeUid || entry.system && entry.system.uid === uid && entry.system.content_type_uid === contentTypeUid) {
          return entry;
        }
      });
    }
    function findEmbeddedAsset(uid, embeddedAssets) {
      if (embeddedAssets === void 0) {
        embeddedAssets = [];
      }
      return embeddedAssets.filter(function(asset) {
        if (asset.uid && asset.uid === uid || asset.system && asset.system.uid === uid) {
          return asset;
        }
      });
    }
    function findGQLEmbeddedItems(metadata, items) {
      if (metadata.itemType === "entry") {
        return findEmbeddedEntry(metadata.itemUid, metadata.contentTypeUid, items);
      } else {
        return findEmbeddedAsset(metadata.itemUid, items);
      }
    }
    function findEmbeddedItems(object, entry) {
      if (object && object !== void 0 && entry && entry !== void 0) {
        if (entry._embedded_items !== void 0) {
          var entryEmbedable = entry;
          var items = Object.values(entryEmbedable._embedded_items || []).reduce(function(accumulator, value) {
            return accumulator.concat(value);
          }, []);
          return findGQLEmbeddedItems(object, items);
        }
      }
      return [];
    }
    function findRenderString(item, metadata, renderOptions) {
      if (!item && item === void 0 || !metadata && metadata === void 0) {
        return "";
      }
      if (renderOptions && renderOptions[metadata.styleType] !== void 0) {
        var renderFunction = renderOptions[metadata.styleType];
        if (metadata.attributes["data-sys-content-type-uid"] !== void 0 && typeof renderFunction !== "function" && renderFunction[metadata.attributes["data-sys-content-type-uid"]] !== void 0) {
          return renderFunction[metadata.attributes["data-sys-content-type-uid"]](item, metadata);
        } else if (metadata.attributes["data-sys-content-type-uid"] !== void 0 && typeof renderFunction !== "function" && renderFunction.$default !== void 0) {
          return renderFunction.$default(item, metadata);
        } else if (metadata.contentTypeUid !== void 0 && typeof renderFunction !== "function" && renderFunction[metadata.contentTypeUid] !== void 0) {
          return renderFunction[metadata.contentTypeUid](item, metadata);
        } else if (metadata.contentTypeUid !== void 0 && typeof renderFunction !== "function" && renderFunction.$default !== void 0) {
          return renderFunction.$default(item, metadata);
        } else if (typeof renderFunction === "function") {
          return renderFunction(item, metadata);
        }
      }
      var defaultRenderFunction = defaultOptions[metadata.styleType];
      return defaultRenderFunction(item, metadata);
    }
    function findRenderContent(keyPaths, entry, render3) {
      getContent4(keyPaths.split("."), entry, render3);
    }
    function getContent4(keys, object, render3) {
      if (keys) {
        var key = keys[0];
        if (keys.length === 1 && object[key]) {
          object[key] = render3(object[key]);
        } else if (keys.length > 0) {
          if (object[key]) {
            var newKeys = keys.slice(1);
            if (Array.isArray(object[key])) {
              for (var _i = 0, _a5 = object[key]; _i < _a5.length; _i++) {
                var objKey = _a5[_i];
                getContent4(newKeys, objKey, render3);
              }
            } else if (typeof object[key] === "object") {
              getContent4(newKeys, object[key], render3);
            }
          }
        }
      }
    }
    function render2(option) {
      function findContent(path, entry) {
        findRenderContent(path, entry, function(content) {
          return renderContent(content, { entry, renderOption: option.renderOption });
        });
      }
      function findAndRender(entry) {
        if (!option.paths || option.paths.length === 0) {
          Object.keys(__assign({}, entry._embedded_items)).forEach(function(path) {
            findContent(path, entry);
          });
        } else {
          option.paths.forEach(function(path) {
            findContent(path, entry);
          });
        }
      }
      if (option.entry instanceof Array) {
        option.entry.forEach(function(entry) {
          findAndRender(entry);
        });
      } else {
        findAndRender(option.entry);
      }
    }
    function renderContent(content, option) {
      if (!content || content === void 0) {
        return "";
      }
      if (typeof content === "string") {
        var contentToReplace_1 = content;
        content.forEachEmbeddedItem(function(embededObjectTag, object) {
          contentToReplace_1 = findAndReplaceEmbeddedItem(contentToReplace_1, embededObjectTag, object, option);
        });
        return contentToReplace_1;
      }
      var resultContent = [];
      content.forEach(function(element) {
        resultContent.push(renderContent(element, option));
      });
      return resultContent;
    }
    function findAndReplaceEmbeddedItem(content, embededObjectTag, metadata, option) {
      var embeddedObjects = findEmbeddedItems(metadata, option.entry);
      var renderString = findRenderString(embeddedObjects[0], metadata, option.renderOption);
      return content.replace(embededObjectTag, renderString);
    }
    var NodeType;
    (function(NodeType2) {
      NodeType2["DOCUMENT"] = "doc";
      NodeType2["PARAGRAPH"] = "p";
      NodeType2["LINK"] = "a";
      NodeType2["IMAGE"] = "img";
      NodeType2["EMBED"] = "embed";
      NodeType2["HEADING_1"] = "h1";
      NodeType2["HEADING_2"] = "h2";
      NodeType2["HEADING_3"] = "h3";
      NodeType2["HEADING_4"] = "h4";
      NodeType2["HEADING_5"] = "h5";
      NodeType2["HEADING_6"] = "h6";
      NodeType2["ORDER_LIST"] = "ol";
      NodeType2["UNORDER_LIST"] = "ul";
      NodeType2["LIST_ITEM"] = "li";
      NodeType2["HR"] = "hr";
      NodeType2["TABLE"] = "table";
      NodeType2["TABLE_HEADER"] = "thead";
      NodeType2["TABLE_BODY"] = "tbody";
      NodeType2["TABLE_FOOTER"] = "tfoot";
      NodeType2["TABLE_ROW"] = "tr";
      NodeType2["TABLE_HEAD"] = "th";
      NodeType2["TABLE_DATA"] = "td";
      NodeType2["BLOCK_QUOTE"] = "blockquote";
      NodeType2["CODE"] = "code";
      NodeType2["TEXT"] = "text";
      NodeType2["REFERENCE"] = "reference";
    })(NodeType || (NodeType = {}));
    var NodeType$1 = NodeType;
    var MarkType;
    (function(MarkType2) {
      MarkType2["BOLD"] = "bold";
      MarkType2["ITALIC"] = "italic";
      MarkType2["UNDERLINE"] = "underline";
      MarkType2["STRIKE_THROUGH"] = "strikethrough";
      MarkType2["INLINE_CODE"] = "inlineCode";
      MarkType2["SUBSCRIPT"] = "subscript";
      MarkType2["SUPERSCRIPT"] = "superscript";
    })(MarkType || (MarkType = {}));
    var MarkType$1 = MarkType;
    var Node2 = (
      /** @class */
      function() {
        function Node3() {
        }
        return Node3;
      }()
    );
    var Document2 = (
      /** @class */
      function(_super) {
        __extends(Document3, _super);
        function Document3() {
          var _this = _super.call(this) || this;
          _this.type = NodeType$1.DOCUMENT;
          return _this;
        }
        return Document3;
      }(Node2)
    );
    var TextNode = (
      /** @class */
      function(_super) {
        __extends(TextNode2, _super);
        function TextNode2(text) {
          var _this = _super.call(this) || this;
          _this.text = text;
          return _this;
        }
        return TextNode2;
      }(Node2)
    );
    var _a4;
    var defaultNodeOption = (_a4 = {}, _a4[NodeType$1.DOCUMENT] = function(node) {
      return "";
    }, _a4[NodeType$1.PARAGRAPH] = function(node, next) {
      return "<p>".concat(next(node.children), "</p>");
    }, _a4[NodeType$1.LINK] = function(node, next) {
      return '<a href="'.concat(node.attrs.href || node.attrs.url, '">').concat(next(node.children), "</a>");
    }, _a4[NodeType$1.IMAGE] = function(node, next) {
      return '<img src="'.concat(node.attrs.src || node.attrs.url, '" />').concat(next(node.children));
    }, _a4[NodeType$1.EMBED] = function(node, next) {
      return '<iframe src="'.concat(node.attrs.src || node.attrs.url, '">').concat(next(node.children), "</iframe>");
    }, _a4[NodeType$1.HEADING_1] = function(node, next) {
      return "<h1>".concat(next(node.children), "</h1>");
    }, _a4[NodeType$1.HEADING_2] = function(node, next) {
      return "<h2>".concat(next(node.children), "</h2>");
    }, _a4[NodeType$1.HEADING_3] = function(node, next) {
      return "<h3>".concat(next(node.children), "</h3>");
    }, _a4[NodeType$1.HEADING_4] = function(node, next) {
      return "<h4>".concat(next(node.children), "</h4>");
    }, _a4[NodeType$1.HEADING_5] = function(node, next) {
      return "<h5>".concat(next(node.children), "</h5>");
    }, _a4[NodeType$1.HEADING_6] = function(node, next) {
      return "<h6>".concat(next(node.children), "</h6>");
    }, _a4[NodeType$1.ORDER_LIST] = function(node, next) {
      return "<ol>".concat(next(node.children), "</ol>");
    }, _a4[NodeType$1.UNORDER_LIST] = function(node, next) {
      return "<ul>".concat(next(node.children), "</ul>");
    }, _a4[NodeType$1.LIST_ITEM] = function(node, next) {
      return "<li>".concat(next(node.children), "</li>");
    }, _a4[NodeType$1.HR] = function(node, next) {
      return "<hr>";
    }, _a4[NodeType$1.TABLE] = function(node, next) {
      return "<table>".concat(next(node.children), "</table>");
    }, _a4[NodeType$1.TABLE_HEADER] = function(node, next) {
      return "<thead>".concat(next(node.children), "</thead>");
    }, _a4[NodeType$1.TABLE_BODY] = function(node, next) {
      return "<tbody>".concat(next(node.children), "</tbody>");
    }, _a4[NodeType$1.TABLE_FOOTER] = function(node, next) {
      return "<tfoot>".concat(next(node.children), "</tfoot>");
    }, _a4[NodeType$1.TABLE_ROW] = function(node, next) {
      return "<tr>".concat(next(node.children), "</tr>");
    }, _a4[NodeType$1.TABLE_HEAD] = function(node, next) {
      return "<th>".concat(next(node.children), "</th>");
    }, _a4[NodeType$1.TABLE_DATA] = function(node, next) {
      return "<td>".concat(next(node.children), "</td>");
    }, _a4[NodeType$1.BLOCK_QUOTE] = function(node, next) {
      return "<blockquote>".concat(next(node.children), "</blockquote>");
    }, _a4[NodeType$1.CODE] = function(node, next) {
      return "<code>".concat(next(node.children), "</code>");
    }, _a4["reference"] = function(node, next) {
      return "";
    }, _a4["default"] = function(node, next) {
      return next(node.children);
    }, _a4[MarkType$1.BOLD] = function(text) {
      return "<strong>".concat(text, "</strong>");
    }, _a4[MarkType$1.ITALIC] = function(text) {
      return "<em>".concat(text, "</em>");
    }, _a4[MarkType$1.UNDERLINE] = function(text) {
      return "<u>".concat(text, "</u>");
    }, _a4[MarkType$1.STRIKE_THROUGH] = function(text) {
      return "<strike>".concat(text, "</strike>");
    }, _a4[MarkType$1.INLINE_CODE] = function(text) {
      return "<span>".concat(text, "</span>");
    }, _a4[MarkType$1.SUBSCRIPT] = function(text) {
      return "<sub>".concat(text, "</sub>");
    }, _a4[MarkType$1.SUPERSCRIPT] = function(text) {
      return "<sup>".concat(text, "</sup>");
    }, _a4);
    function enumerate(entries, process2) {
      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
        var entry = entries_1[_i];
        process2(entry);
      }
    }
    function enumerateContents(content, renderOption, renderEmbed) {
      if (!(content instanceof Array) && content.type !== "doc") {
        return content;
      }
      if (content instanceof Array) {
        var result_1 = [];
        content.forEach(function(doc) {
          result_1.push(enumerateContents(doc, renderOption, renderEmbed));
        });
        return result_1;
      }
      var commonRenderOption = __assign(__assign({}, defaultNodeOption), renderOption);
      return nodeChildrenToHTML(content.children, commonRenderOption, renderEmbed);
    }
    function textNodeToHTML(node, renderOption) {
      var text = node.text;
      if (node.superscript) {
        text = renderOption[MarkType$1.SUPERSCRIPT](text);
      }
      if (node.subscript) {
        text = renderOption[MarkType$1.SUBSCRIPT](text);
      }
      if (node.inlineCode) {
        text = renderOption[MarkType$1.INLINE_CODE](text);
      }
      if (node.strikethrough) {
        text = renderOption[MarkType$1.STRIKE_THROUGH](text);
      }
      if (node.underline) {
        text = renderOption[MarkType$1.UNDERLINE](text);
      }
      if (node.italic) {
        text = renderOption[MarkType$1.ITALIC](text);
      }
      if (node.bold) {
        text = renderOption[MarkType$1.BOLD](text);
      }
      return text;
    }
    function referenceToHTML(node, renderOption, renderEmbed) {
      function sendToRenderOption(referenceNode) {
        return renderOption[referenceNode.type](referenceNode, void 0);
      }
      if (!renderEmbed && renderOption[node.type] !== void 0) {
        return sendToRenderOption(node);
      }
      if (!renderEmbed) {
        return "";
      }
      var metadata = nodeToMetadata(node.attrs, node.children && node.children.length > 0 ? node.children[0] : {});
      var item = renderEmbed(metadata);
      if (!item && renderOption[node.type] !== void 0) {
        return sendToRenderOption(node);
      }
      return findRenderString(item, metadata, renderOption);
    }
    function nodeChildrenToHTML(nodes, renderOption, renderEmbed) {
      return nodes.map(function(node) {
        return nodeToHTML(node, renderOption, renderEmbed);
      }).join("");
    }
    function nodeToHTML(node, renderOption, renderEmbed) {
      if (!node.type) {
        return textNodeToHTML(node, renderOption);
      } else if (node.type === "reference") {
        return referenceToHTML(node, renderOption, renderEmbed);
      } else {
        var next = function(nodes) {
          return nodeChildrenToHTML(nodes, renderOption, renderEmbed);
        };
        if (renderOption[node.type] !== void 0) {
          return renderOption[node.type](node, next);
        } else {
          return renderOption.default(node, next);
        }
      }
    }
    function jsonToHTML$1(option) {
      if (option.entry instanceof Array) {
        enumerate(option.entry, function(entry) {
          jsonToHTML$1({ entry, paths: option.paths, renderOption: option.renderOption });
        });
      } else {
        enumerateKeys$1({
          entry: option.entry,
          paths: option.paths,
          renderOption: option.renderOption
        });
      }
    }
    function enumerateKeys$1(option) {
      for (var _i = 0, _a5 = option.paths; _i < _a5.length; _i++) {
        var key = _a5[_i];
        findRenderContent(key, option.entry, function(content) {
          return enumerateContents(content, option.renderOption, function(metadata) {
            return findEmbeddedItems(metadata, option.entry)[0];
          });
        });
      }
    }
    function jsonToHTML(option) {
      if (option.entry instanceof Array) {
        enumerate(option.entry, function(entry) {
          jsonToHTML({ entry, paths: option.paths, renderOption: option.renderOption });
        });
      } else {
        enumerateKeys({
          entry: option.entry,
          paths: option.paths,
          renderOption: option.renderOption
        });
      }
    }
    function enumerateKeys(option) {
      for (var _i = 0, _a5 = option.paths; _i < _a5.length; _i++) {
        var key = _a5[_i];
        findRenderContent(key, option.entry, function(content) {
          if (content && content.json) {
            var edges = content.embedded_itemsConnection ? content.embedded_itemsConnection.edges : [];
            var items_1 = Object.values(edges || []).reduce(function(accumulator, value) {
              return accumulator.concat(value.node);
            }, []);
            return enumerateContents(content.json, option.renderOption, function(metadata) {
              return findGQLEmbeddedItems(metadata, items_1)[0];
            });
          }
          return content;
        });
      }
    }
    var GQL = {
      jsonToHTML
    };
    function addTags(entry, contentTypeUid, tagsAsObject, locale) {
      if (locale === void 0) {
        locale = "en-us";
      }
      if (entry)
        entry.$ = getTag2(entry, "".concat(contentTypeUid, ".").concat(entry.uid, ".").concat(locale), tagsAsObject, locale);
    }
    function getTag2(content, prefix, tagsAsObject, locale) {
      var tags = {};
      Object.entries(content).forEach(function(_a5) {
        var key = _a5[0], value = _a5[1];
        switch (typeof value) {
          case "object":
            if (Array.isArray(value)) {
              value.forEach(function(obj, index2) {
                if (typeof obj !== "undefined" && obj !== null && obj._content_type_uid !== void 0 && obj.uid !== void 0) {
                  value[index2].$ = getTag2(obj, "".concat(obj._content_type_uid, ".").concat(obj.uid, ".").concat(obj.locale || locale), tagsAsObject, locale);
                } else {
                  if (typeof obj === "object") {
                    obj.$ = getTag2(obj, "".concat(prefix, ".").concat(key, ".").concat(index2), tagsAsObject, locale);
                  } else {
                    tags[key] = getTagsValue("".concat(prefix, ".").concat(key), tagsAsObject);
                  }
                }
              });
            } else {
              if (value) {
                value.$ = getTag2(value, "".concat(prefix, ".").concat(key), tagsAsObject, locale);
              }
            }
            break;
          default:
            tags[key] = getTagsValue("".concat(prefix, ".").concat(key), tagsAsObject);
        }
      });
      return tags;
    }
    function getTagsValue(dataValue, tagsAsObject) {
      if (tagsAsObject) {
        return { "data-cslp": dataValue };
      } else {
        return "data-cslp=".concat(dataValue);
      }
    }
    exports.Document = Document2;
    exports.GQL = GQL;
    exports.MarkType = MarkType$1;
    exports.Node = Node2;
    exports.NodeType = NodeType$1;
    exports.StyleType = StyleType$1;
    exports.TextNode = TextNode;
    exports.addEditableTags = addTags;
    exports.attributeToString = attributeToString;
    exports.jsonToHTML = jsonToHTML$1;
    exports.render = render2;
    exports.renderContent = renderContent;
  }
});

// node_modules/es6-promise/dist/es6-promise.js
var require_es6_promise = __commonJS({
  "node_modules/es6-promise/dist/es6-promise.js"(exports, module2) {
    "use strict";
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.ES6Promise = factory();
    })(exports, function() {
      "use strict";
      function objectOrFunction(x) {
        var type = typeof x;
        return x !== null && (type === "object" || type === "function");
      }
      function isFunction(x) {
        return typeof x === "function";
      }
      var _isArray = void 0;
      if (Array.isArray) {
        _isArray = Array.isArray;
      } else {
        _isArray = function(x) {
          return Object.prototype.toString.call(x) === "[object Array]";
        };
      }
      var isArray3 = _isArray;
      var len = 0;
      var vertxNext = void 0;
      var customSchedulerFn = void 0;
      var asap = function asap2(callback2, arg) {
        queue[len] = callback2;
        queue[len + 1] = arg;
        len += 2;
        if (len === 2) {
          if (customSchedulerFn) {
            customSchedulerFn(flush);
          } else {
            scheduleFlush();
          }
        }
      };
      function setScheduler(scheduleFn) {
        customSchedulerFn = scheduleFn;
      }
      function setAsap(asapFn) {
        asap = asapFn;
      }
      var browserWindow = typeof window !== "undefined" ? window : void 0;
      var browserGlobal = browserWindow || {};
      var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
      var isNode2 = typeof self === "undefined" && typeof process !== "undefined" && {}.toString.call(process) === "[object process]";
      var isWorker = typeof Uint8ClampedArray !== "undefined" && typeof importScripts !== "undefined" && typeof MessageChannel !== "undefined";
      function useNextTick() {
        return function() {
          return process.nextTick(flush);
        };
      }
      function useVertxTimer() {
        if (typeof vertxNext !== "undefined") {
          return function() {
            vertxNext(flush);
          };
        }
        return useSetTimeout();
      }
      function useMutationObserver() {
        var iterations = 0;
        var observer = new BrowserMutationObserver(flush);
        var node = document.createTextNode("");
        observer.observe(node, { characterData: true });
        return function() {
          node.data = iterations = ++iterations % 2;
        };
      }
      function useMessageChannel() {
        var channel = new MessageChannel();
        channel.port1.onmessage = flush;
        return function() {
          return channel.port2.postMessage(0);
        };
      }
      function useSetTimeout() {
        var globalSetTimeout = setTimeout;
        return function() {
          return globalSetTimeout(flush, 1);
        };
      }
      var queue = new Array(1e3);
      function flush() {
        for (var i = 0; i < len; i += 2) {
          var callback2 = queue[i];
          var arg = queue[i + 1];
          callback2(arg);
          queue[i] = void 0;
          queue[i + 1] = void 0;
        }
        len = 0;
      }
      function attemptVertx() {
        try {
          var vertx = Function("return this")().require("vertx");
          vertxNext = vertx.runOnLoop || vertx.runOnContext;
          return useVertxTimer();
        } catch (e) {
          return useSetTimeout();
        }
      }
      var scheduleFlush = void 0;
      if (isNode2) {
        scheduleFlush = useNextTick();
      } else if (BrowserMutationObserver) {
        scheduleFlush = useMutationObserver();
      } else if (isWorker) {
        scheduleFlush = useMessageChannel();
      } else if (browserWindow === void 0 && typeof require === "function") {
        scheduleFlush = attemptVertx();
      } else {
        scheduleFlush = useSetTimeout();
      }
      function then(onFulfillment, onRejection) {
        var parent = this;
        var child = new this.constructor(noop2);
        if (child[PROMISE_ID] === void 0) {
          makePromise(child);
        }
        var _state = parent._state;
        if (_state) {
          var callback2 = arguments[_state - 1];
          asap(function() {
            return invokeCallback(_state, child, callback2, parent._result);
          });
        } else {
          subscribe(parent, child, onFulfillment, onRejection);
        }
        return child;
      }
      function resolve$1(object) {
        var Constructor = this;
        if (object && typeof object === "object" && object.constructor === Constructor) {
          return object;
        }
        var promise = new Constructor(noop2);
        resolve2(promise, object);
        return promise;
      }
      var PROMISE_ID = Math.random().toString(36).substring(2);
      function noop2() {
      }
      var PENDING = void 0;
      var FULFILLED = 1;
      var REJECTED = 2;
      function selfFulfillment() {
        return new TypeError("You cannot resolve a promise with itself");
      }
      function cannotReturnOwn() {
        return new TypeError("A promises callback cannot return that same promise.");
      }
      function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
        try {
          then$$1.call(value, fulfillmentHandler, rejectionHandler);
        } catch (e) {
          return e;
        }
      }
      function handleForeignThenable(promise, thenable, then$$1) {
        asap(function(promise2) {
          var sealed = false;
          var error = tryThen(then$$1, thenable, function(value) {
            if (sealed) {
              return;
            }
            sealed = true;
            if (thenable !== value) {
              resolve2(promise2, value);
            } else {
              fulfill(promise2, value);
            }
          }, function(reason) {
            if (sealed) {
              return;
            }
            sealed = true;
            reject(promise2, reason);
          }, "Settle: " + (promise2._label || " unknown promise"));
          if (!sealed && error) {
            sealed = true;
            reject(promise2, error);
          }
        }, promise);
      }
      function handleOwnThenable(promise, thenable) {
        if (thenable._state === FULFILLED) {
          fulfill(promise, thenable._result);
        } else if (thenable._state === REJECTED) {
          reject(promise, thenable._result);
        } else {
          subscribe(thenable, void 0, function(value) {
            return resolve2(promise, value);
          }, function(reason) {
            return reject(promise, reason);
          });
        }
      }
      function handleMaybeThenable(promise, maybeThenable, then$$1) {
        if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
          handleOwnThenable(promise, maybeThenable);
        } else {
          if (then$$1 === void 0) {
            fulfill(promise, maybeThenable);
          } else if (isFunction(then$$1)) {
            handleForeignThenable(promise, maybeThenable, then$$1);
          } else {
            fulfill(promise, maybeThenable);
          }
        }
      }
      function resolve2(promise, value) {
        if (promise === value) {
          reject(promise, selfFulfillment());
        } else if (objectOrFunction(value)) {
          var then$$1 = void 0;
          try {
            then$$1 = value.then;
          } catch (error) {
            reject(promise, error);
            return;
          }
          handleMaybeThenable(promise, value, then$$1);
        } else {
          fulfill(promise, value);
        }
      }
      function publishRejection(promise) {
        if (promise._onerror) {
          promise._onerror(promise._result);
        }
        publish(promise);
      }
      function fulfill(promise, value) {
        if (promise._state !== PENDING) {
          return;
        }
        promise._result = value;
        promise._state = FULFILLED;
        if (promise._subscribers.length !== 0) {
          asap(publish, promise);
        }
      }
      function reject(promise, reason) {
        if (promise._state !== PENDING) {
          return;
        }
        promise._state = REJECTED;
        promise._result = reason;
        asap(publishRejection, promise);
      }
      function subscribe(parent, child, onFulfillment, onRejection) {
        var _subscribers = parent._subscribers;
        var length = _subscribers.length;
        parent._onerror = null;
        _subscribers[length] = child;
        _subscribers[length + FULFILLED] = onFulfillment;
        _subscribers[length + REJECTED] = onRejection;
        if (length === 0 && parent._state) {
          asap(publish, parent);
        }
      }
      function publish(promise) {
        var subscribers = promise._subscribers;
        var settled = promise._state;
        if (subscribers.length === 0) {
          return;
        }
        var child = void 0, callback2 = void 0, detail = promise._result;
        for (var i = 0; i < subscribers.length; i += 3) {
          child = subscribers[i];
          callback2 = subscribers[i + settled];
          if (child) {
            invokeCallback(settled, child, callback2, detail);
          } else {
            callback2(detail);
          }
        }
        promise._subscribers.length = 0;
      }
      function invokeCallback(settled, promise, callback2, detail) {
        var hasCallback = isFunction(callback2), value = void 0, error = void 0, succeeded = true;
        if (hasCallback) {
          try {
            value = callback2(detail);
          } catch (e) {
            succeeded = false;
            error = e;
          }
          if (promise === value) {
            reject(promise, cannotReturnOwn());
            return;
          }
        } else {
          value = detail;
        }
        if (promise._state !== PENDING) {
        } else if (hasCallback && succeeded) {
          resolve2(promise, value);
        } else if (succeeded === false) {
          reject(promise, error);
        } else if (settled === FULFILLED) {
          fulfill(promise, value);
        } else if (settled === REJECTED) {
          reject(promise, value);
        }
      }
      function initializePromise(promise, resolver) {
        try {
          resolver(function resolvePromise(value) {
            resolve2(promise, value);
          }, function rejectPromise(reason) {
            reject(promise, reason);
          });
        } catch (e) {
          reject(promise, e);
        }
      }
      var id = 0;
      function nextId() {
        return id++;
      }
      function makePromise(promise) {
        promise[PROMISE_ID] = id++;
        promise._state = void 0;
        promise._result = void 0;
        promise._subscribers = [];
      }
      function validationError() {
        return new Error("Array Methods must be provided an Array");
      }
      var Enumerator = function() {
        function Enumerator2(Constructor, input) {
          this._instanceConstructor = Constructor;
          this.promise = new Constructor(noop2);
          if (!this.promise[PROMISE_ID]) {
            makePromise(this.promise);
          }
          if (isArray3(input)) {
            this.length = input.length;
            this._remaining = input.length;
            this._result = new Array(this.length);
            if (this.length === 0) {
              fulfill(this.promise, this._result);
            } else {
              this.length = this.length || 0;
              this._enumerate(input);
              if (this._remaining === 0) {
                fulfill(this.promise, this._result);
              }
            }
          } else {
            reject(this.promise, validationError());
          }
        }
        Enumerator2.prototype._enumerate = function _enumerate(input) {
          for (var i = 0; this._state === PENDING && i < input.length; i++) {
            this._eachEntry(input[i], i);
          }
        };
        Enumerator2.prototype._eachEntry = function _eachEntry(entry, i) {
          var c = this._instanceConstructor;
          var resolve$$1 = c.resolve;
          if (resolve$$1 === resolve$1) {
            var _then = void 0;
            var error = void 0;
            var didError = false;
            try {
              _then = entry.then;
            } catch (e) {
              didError = true;
              error = e;
            }
            if (_then === then && entry._state !== PENDING) {
              this._settledAt(entry._state, i, entry._result);
            } else if (typeof _then !== "function") {
              this._remaining--;
              this._result[i] = entry;
            } else if (c === Promise$1) {
              var promise = new c(noop2);
              if (didError) {
                reject(promise, error);
              } else {
                handleMaybeThenable(promise, entry, _then);
              }
              this._willSettleAt(promise, i);
            } else {
              this._willSettleAt(new c(function(resolve$$12) {
                return resolve$$12(entry);
              }), i);
            }
          } else {
            this._willSettleAt(resolve$$1(entry), i);
          }
        };
        Enumerator2.prototype._settledAt = function _settledAt(state, i, value) {
          var promise = this.promise;
          if (promise._state === PENDING) {
            this._remaining--;
            if (state === REJECTED) {
              reject(promise, value);
            } else {
              this._result[i] = value;
            }
          }
          if (this._remaining === 0) {
            fulfill(promise, this._result);
          }
        };
        Enumerator2.prototype._willSettleAt = function _willSettleAt(promise, i) {
          var enumerator = this;
          subscribe(promise, void 0, function(value) {
            return enumerator._settledAt(FULFILLED, i, value);
          }, function(reason) {
            return enumerator._settledAt(REJECTED, i, reason);
          });
        };
        return Enumerator2;
      }();
      function all(entries) {
        return new Enumerator(this, entries).promise;
      }
      function race(entries) {
        var Constructor = this;
        if (!isArray3(entries)) {
          return new Constructor(function(_, reject2) {
            return reject2(new TypeError("You must pass an array to race."));
          });
        } else {
          return new Constructor(function(resolve3, reject2) {
            var length = entries.length;
            for (var i = 0; i < length; i++) {
              Constructor.resolve(entries[i]).then(resolve3, reject2);
            }
          });
        }
      }
      function reject$1(reason) {
        var Constructor = this;
        var promise = new Constructor(noop2);
        reject(promise, reason);
        return promise;
      }
      function needsResolver() {
        throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
      }
      function needsNew() {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
      }
      var Promise$1 = function() {
        function Promise2(resolver) {
          this[PROMISE_ID] = nextId();
          this._result = this._state = void 0;
          this._subscribers = [];
          if (noop2 !== resolver) {
            typeof resolver !== "function" && needsResolver();
            this instanceof Promise2 ? initializePromise(this, resolver) : needsNew();
          }
        }
        Promise2.prototype.catch = function _catch(onRejection) {
          return this.then(null, onRejection);
        };
        Promise2.prototype.finally = function _finally(callback2) {
          var promise = this;
          var constructor = promise.constructor;
          if (isFunction(callback2)) {
            return promise.then(function(value) {
              return constructor.resolve(callback2()).then(function() {
                return value;
              });
            }, function(reason) {
              return constructor.resolve(callback2()).then(function() {
                throw reason;
              });
            });
          }
          return promise.then(callback2, callback2);
        };
        return Promise2;
      }();
      Promise$1.prototype.then = then;
      Promise$1.all = all;
      Promise$1.race = race;
      Promise$1.resolve = resolve$1;
      Promise$1.reject = reject$1;
      Promise$1._setScheduler = setScheduler;
      Promise$1._setAsap = setAsap;
      Promise$1._asap = asap;
      function polyfill() {
        var local = void 0;
        if (typeof global !== "undefined") {
          local = global;
        } else if (typeof self !== "undefined") {
          local = self;
        } else {
          try {
            local = Function("return this")();
          } catch (e) {
            throw new Error("polyfill failed because global object is unavailable in this environment");
          }
        }
        var P = local.Promise;
        if (P) {
          var promiseToString = null;
          try {
            promiseToString = Object.prototype.toString.call(P.resolve());
          } catch (e) {
          }
          if (promiseToString === "[object Promise]" && !P.cast) {
            return;
          }
        }
        local.Promise = Promise$1;
      }
      Promise$1.polyfill = polyfill;
      Promise$1.Promise = Promise$1;
      return Promise$1;
    });
  }
});

// node_modules/localStorage/lib/localStorage.js
var require_localStorage = __commonJS({
  "node_modules/localStorage/lib/localStorage.js"(exports, module2) {
    "use strict";
    (function() {
      "use strict";
      var db;
      function LocalStorage() {
      }
      db = LocalStorage;
      db.prototype.getItem = function(key) {
        if (this.hasOwnProperty(key)) {
          return String(this[key]);
        }
        return null;
      };
      db.prototype.setItem = function(key, val) {
        this[key] = String(val);
      };
      db.prototype.removeItem = function(key) {
        delete this[key];
      };
      db.prototype.clear = function() {
        var self2 = this;
        Object.keys(self2).forEach(function(key) {
          self2[key] = void 0;
          delete self2[key];
        });
      };
      db.prototype.key = function(i) {
        i = i || 0;
        return Object.keys(this)[i];
      };
      db.prototype.__defineGetter__("length", function() {
        return Object.keys(this).length;
      });
      if (global.localStorage) {
        module2.exports = localStorage;
      } else {
        module2.exports = new LocalStorage();
      }
    })();
  }
});

// node_modules/contentstack/dist/node/contentstack.js
var require_contentstack = __commonJS({
  "node_modules/contentstack/dist/node/contentstack.js"(exports, module2) {
    "use strict";
    (() => {
      "use strict";
      var e = { 971: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = { protocol: "https", host: "cdn.contentstack.io", port: 443, version: "v3", urls: { sync: "/stacks/sync", content_types: "/content_types/", entries: "/entries/", assets: "/assets/", environments: "/environments/" }, live_preview: { enable: false, host: "api.contentstack.io" } };
      }, 900: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        var n, i = (n = r2(128)) && n.__esModule ? n : { default: n }, o = { providers: function(e3) {
          if (e3)
            return i.default;
          console.error("Kindly provide valid provider.");
        }, policies: { IGNORE_CACHE: -1, ONLY_NETWORK: 0, CACHE_ELSE_NETWORK: 1, NETWORK_ELSE_CACHE: 2, CACHE_THEN_NETWORK: 3 } };
        t2.default = o;
      }, 128: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        var n = function(e3) {
          if (e3 && e3.__esModule)
            return e3;
          var t3 = {};
          if (null != e3)
            for (var r3 in e3)
              Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
          return t3.default = e3, t3;
        }(r2(821)), i = {};
        function o(e3, t3) {
          !t3 && e3 && e3.length && e3.push("");
          var r3 = void 0, i2 = n.getKeys(), o2 = n.getStorage();
          if (e3 && e3.length) {
            r3 = e3.join(".");
            for (var s = 0, u = i2.length; s < u; s++)
              i2[s] && 0 === i2[s].indexOf(r3) && delete o2[i2[s]];
          } else
            for (var a = 0, c = i2.length; a < c; a++)
              delete o2[i2[a]];
        }
        i.get = function(e3, t3) {
          try {
            t3(null, n.get(e3));
          } catch (e4) {
            t3(e4);
          }
        }, i.set = function(e3, t3, r3) {
          try {
            e3 && t3 && n.set(e3, t3), r3();
          } catch (e4) {
            r3(e4);
          }
        }, i.clearByContentType = function() {
          try {
            if (2 === arguments.length || 3 === arguments.length) {
              var e3 = Array.prototype.slice.call(arguments), t3 = e3.splice(-1, 1).pop(), r3 = [];
              r3.push.apply(r3, e3), o(r3), t3();
            }
          } catch (e4) {
            callback(e4);
          }
        }, i.clearByQuery = function(e3, t3) {
          try {
            for (var r3 = n.getKeys(), i2 = n.getStorage(), o2 = 0, s = r3.length; o2 < s; o2++)
              r3[o2] && ~r3[o2].indexOf(e3) && delete i2[r3[o2]];
            t3();
          } catch (e4) {
            t3(e4);
          }
        }, i.clearAll = function(e3) {
          try {
            o(), e3();
          } catch (t3) {
            e3(t3);
          }
        }, t2.default = i;
      }, 821: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        };
        t2.get = function(e3) {
          var t3 = o.default.getItem(e3);
          try {
            t3 = JSON.parse(t3);
          } catch (e4) {
            return t3;
          }
          return t3 || null;
        }, t2.set = function(e3, t3) {
          try {
            "object" === (void 0 === t3 ? "undefined" : n(t3)) ? o.default.setItem(e3, JSON.stringify(t3)) : o.default.setItem(e3, t3);
          } catch (e4) {
          }
        }, t2.getStorage = function() {
          return o.default || null;
        }, t2.getKeys = function() {
          return o.default ? Object.keys(o.default) : [];
        };
        var i, o = (i = r2(895)) && i.__esModule ? i : { default: i };
      }, 32: (e2, t2, r2) => {
        var n = function() {
          function e3(e4, t3) {
            for (var r3 = 0; r3 < t3.length; r3++) {
              var n2 = t3[r3];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e4, n2.key, n2);
            }
          }
          return function(t3, r3, n2) {
            return r3 && e3(t3.prototype, r3), n2 && e3(t3, n2), t3;
          };
        }(), i = u(r2(533)), o = u(r2(900)), s = u(r2(764));
        function u(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        var a = function() {
          function e3() {
            !function(e4, t3) {
              if (!(e4 instanceof t3))
                throw new TypeError("Cannot call a class as a function");
            }(this, e3), this.CachePolicy = o.default.policies, this.Region = s.default, this.Utils = r2(464);
          }
          return n(e3, [{ key: "Stack", value: function() {
            for (var e4 = arguments.length, t3 = Array(e4), r3 = 0; r3 < e4; r3++)
              t3[r3] = arguments[r3];
            return new (Function.prototype.bind.apply(i.default, [null].concat(t3)))();
          } }]), e3;
        }();
        e2.exports = new a();
      }, 764: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = { EU: "eu", US: "us", AZURE_NA: "azure-na", AZURE_EU: "azure-eu" };
      }, 777: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        };
        t2.default = function(e3, t3) {
          var r3 = e3.requestParams;
          return new Promise(function(i2, o2) {
            var s2 = void 0;
            return r3.headers["Content-Type"] = "application/json; charset=UTF-8", r3.headers["X-User-Agent"] = "contentstack-nodejs/" + u, r3.body && "object" === n(r3.body) && (delete r3.body._method, "object" === n(r3.body.query) && 0 === Object.keys(r3.body.query).length && delete r3.body.query, s2 = function e4(t4, r4) {
              var i3 = [];
              if ("object" === (void 0 === t4 ? "undefined" : n(t4)) && void 0 !== t4.length)
                for (var o3 = 0, s3 = t4.length; o3 < s3; o3++)
                  i3.push(r4 + "[]=" + t4[o3]);
              else
                for (var u2 in t4) {
                  var a2 = r4 ? r4 + "[" + u2 + "]" : u2, c = t4[u2];
                  i3.push(null !== c && "object" === (void 0 === c ? "undefined" : n(c)) && "query" !== u2 ? e4(c, a2) : a2 + "=" + encodeURIComponent("query" !== u2 ? c : JSON.stringify(c)));
                }
              return i3.join("&");
            }(r3.body)), a(e3, s2, t3, i2, o2, t3.retryDelay, t3.retryLimit);
          });
        };
        var i, o = function(e3) {
          if (e3 && e3.__esModule)
            return e3;
          var t3 = {};
          if (null != e3)
            for (var r3 in e3)
              Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
          return t3.default = e3, t3;
        }(r2(540)), s = (i = r2(289)) && i.__esModule ? i : { default: i }, u = "3.17.0";
        function a(e3, t3, r3, n2, i2) {
          var u2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 300, c = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 5, l = e3.requestParams, f = l.url + "?" + t3, h = l.headers, y = o.mergeDeep({ method: "GET", headers: h, timeout: 3e4 }, r3);
          r3.debug && r3.logHandler("info", { url: f, option: y });
          var d = { url: f, option: y }, p = e3.plugins;
          if (p && void 0 !== p)
            for (var v = 0; v < p.length; v++)
              "function" == typeof p[v].onRequest && (d = p[v].onRequest(e3, d));
          (0, s.default)(d.url, d.option).then(function(o2) {
            r3.debug && r3.logHandler("info", o2);
            var s2 = o2.json();
            if (o2.ok && 200 === o2.status)
              s2.then(function(t4) {
                for (var r4 = 0; r4 < p.length && "function" == typeof p[r4].onResponse; r4++)
                  t4 = p[r4].onResponse(e3, d, o2, t4);
                n2(t4);
              });
            else {
              var l2 = o2.status, f2 = o2.statusText;
              s2.then(function(s3) {
                var h2 = { error_message: s3.error_message, error_code: s3.error_code, errors: s3.errors, status: l2, statusText: f2 };
                r3.retryCondition && r3.retryCondition(o2) ? function(o3) {
                  if (0 === c)
                    r3.debug && r3.logHandler("error", o3), i2(o3);
                  else {
                    var s4 = u2;
                    c -= 1;
                    var l3 = r3.retryLimit - c;
                    r3.retryDelayOptions && (r3.retryDelayOptions.base ? s4 = r3.retryDelayOptions.base * l3 : r3.retryDelayOptions.customBackoff && (s4 = r3.retryDelayOptions.customBackoff(l3, o3))), function(e4) {
                      return new Promise(function(t4) {
                        setTimeout(t4, e4);
                      });
                    }(s4).then(function() {
                      return a(e3, t3, r3, n2, i2, u2, c);
                    }).catch(function() {
                      return a(e3, t3, r3, n2, i2, u2, c);
                    });
                  }
                }(h2) : (r3.debug && r3.logHandler("error", h2), i2(h2));
              }).catch(function() {
                r3.debug && r3.logHandler("error", { status: l2, statusText: f2 }), i2({ status: l2, statusText: f2 });
              });
            }
          }).catch(function(e4) {
            r3.debug && r3.logHandler("error", e4), i2(e4);
          });
        }
      }, 540: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        var n = function(e3, t3) {
          if (Array.isArray(e3))
            return e3;
          if (Symbol.iterator in Object(e3))
            return function(e4, t4) {
              var r3 = [], n2 = true, i2 = false, o2 = void 0;
              try {
                for (var s2, u2 = e4[Symbol.iterator](); !(n2 = (s2 = u2.next()).done) && (r3.push(s2.value), !t4 || r3.length !== t4); n2 = true)
                  ;
              } catch (e5) {
                i2 = true, o2 = e5;
              } finally {
                try {
                  !n2 && u2.return && u2.return();
                } finally {
                  if (i2)
                    throw o2;
                }
              }
              return r3;
            }(e3, t3);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }, i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        };
        t2.transform = function(e3) {
          return function() {
            switch (this._query[e3] = this._query[e3] || {}, arguments.length) {
              case 1:
                if (Array.isArray(arguments[0]) || "string" == typeof arguments[0]) {
                  var t3 = this._query[e3].BASE || [];
                  return t3 = t3.concat(arguments[0]), this._query[e3].BASE = t3, this;
                }
                console.error("Kindly provide valid parameters");
                break;
              case 2:
                if ("string" == typeof arguments[0] && (Array.isArray(arguments[1]) || "string" == typeof arguments[1])) {
                  var r3 = this._query[e3][arguments[0]] || [];
                  return r3 = r3.concat(arguments[1]), this._query[e3][arguments[0]] = r3, this;
                }
                console.error("Kindly provide valid parameters");
                break;
              default:
                console.error("Kindly provide valid parameters");
            }
          };
        }, t2._type = function(e3) {
          var t3 = void 0 === e3 ? "undefined" : i(e3);
          return "object" === t3 && Array.isArray(e3) && (t3 = "array"), t3;
        }, t2.mergeDeep = function(e3, t3) {
          var r3 = this;
          return function e4(t4, n2) {
            for (var i2 in n2)
              "object" == r3._type(n2[i2]) && r3._type(t4[i2]) == r3._type(n2[i2]) ? e4(t4[i2], n2[i2]) : "array" == r3._type(n2[i2]) && r3._type(t4[i2]) == r3._type(n2[i2]) ? t4[i2] = t4[i2].concat(n2[i2]) : t4[i2] = n2[i2];
          }(e3, t3), e3;
        }, t2.merge = a, t2.isBrowser = function() {
          return "undefined" != typeof window && "object" === ("undefined" == typeof process ? "undefined" : i(process)) && "browser" === process.title;
        }, t2.parseQueryFromParams = c, t2.getHash = l, t2.generateHash = f, t2.resultWrapper = h, t2.spreadResult = y, t2.sendRequest = function(e3, t3) {
          var r3 = e3.environment_uid;
          r3 ? e3._query.environment_uid = r3 : (e3._query || (e3._query = {}), e3._query.environment = e3.environment);
          var n2 = e3, s2 = void 0 !== n2.queryCachePolicy ? n2.queryCachePolicy : n2.cachePolicy, u2 = void 0 !== n2.tojson && n2.tojson, f2 = !!(n2.entry_uid || n2.singleEntry || n2.asset_uid), p = l(c(n2, f2, u2));
          if (e3 && e3.requestParams && e3.requestParams.body && e3.requestParams.body.query) {
            var v = JSON.parse(JSON.stringify(e3.requestParams.body.query));
            "object" !== (void 0 === v ? "undefined" : i(v)) && (v = JSON.parse(v)), delete e3.requestParams.body.query, e3.requestParams.body = a(e3.requestParams.body, v), e3.live_preview && true === e3.live_preview.enable && e3.live_preview.live_preview && "init" !== e3.live_preview.live_preview && (e3.live_preview.content_type_uid === e3.content_type_uid ? (e3.requestParams.body = a(e3.requestParams.body, { live_preview: e3.live_preview.live_preview || "init" }), s2 = 2, e3.requestParams.body.environment && delete e3.requestParams.body.environment, e3.requestParams.headers.access_token && delete e3.requestParams.headers.access_token, e3.requestParams.headers.authorization = e3.live_preview.management_token) : e3.live_preview.live_preview && (s2 = 1));
          }
          var _ = function() {
            return function(e4, t4) {
              return new Promise(function(r4, n3) {
                try {
                  e4 && n3(e4), u2 || (t4 = h(t4)), r4(y(t4));
                } catch (e5) {
                  n3(e5);
                }
              });
            };
          }, g = function(r4, i2, a2) {
            r4 && (0, o.default)(e3, t3).then(function(t4) {
              try {
                n2.entry_uid = n2.asset_uid = n2.tojson = n2.queryCachePolicy = void 0;
                var r5 = {}, o2 = {};
                if (e3.singleEntry)
                  if (e3.singleEntry = false, t4.schema && (r5.schema = t4.schema), t4.content_type && (r5.content_type = t4.content_type, delete r5.schema), t4.entries && t4.entries.length)
                    r5.entry = t4.entries[0];
                  else {
                    if (!t4.assets || !t4.assets.length)
                      return 2 === s2 && null !== n2.provider ? void n2.provider.get(p, _()) : a2({ error_code: 141, error_message: "The requested entry doesn't exist." });
                    r5.assets = t4.assets[0];
                  }
                else
                  t4.items ? o2 = { items: t4.items, pagination_token: t4.pagination_token, sync_token: t4.sync_token, total_count: t4.total_count } : r5 = t4;
                return -1 !== s2 && null !== n2.provider ? (n2.provider.set(p, r5, function(e4) {
                  try {
                    return e4 && a2(e4), u2 || (r5 = h(r5)), i2(y(r5));
                  } catch (e5) {
                    return a2(e5);
                  }
                }), i2(y(r5))) : Object.keys(o2).length ? i2(o2) : (u2 || (r5 = h(r5)), i2(y(r5)));
              } catch (e4) {
                return a2({ message: e4.message });
              }
            }.bind(n2)).catch(function(e4) {
              if (2 !== s2 || null === n2.provider)
                return a2(e4);
              n2.provider.get(p, _());
            });
          };
          switch (s2) {
            case 1:
              return new Promise(async function(r4, i2) {
                null !== n2.provider ? await n2.provider.get(p, async function(n3, o2) {
                  try {
                    if (n3 || !o2)
                      g(true, r4, i2);
                    else {
                      try {
                        if (e3._query && Array.isArray(e3._query.include) && e3._query.include.length > 0) {
                          var s3 = (a2 = e3._query.include, c2 = {}, a2.forEach(function(e4) {
                            !function(e5) {
                              var t4 = (e5 = e5.replace(/[\[]/gm, ".").replace(/[\]]/gm, "")).split("."), r5 = t4.pop();
                              t4.reduce(function(e6, t5) {
                                return e6[t5] = e6[t5] || {};
                              }, c2)[r5] = {};
                            }(e4);
                          }), c2);
                          f2 ? await d(s3, o2.entry, e3, t3) : await Promise.all(o2.entries.map(async function(r5) {
                            await d(s3, r5, e3, t3);
                          }));
                        }
                      } catch (e4) {
                      }
                      try {
                        return u2 || (o2 = h(o2)), r4(y(o2));
                      } catch (e4) {
                        return i2(e4);
                      }
                    }
                  } catch (e4) {
                    return i2(e4);
                  }
                  var a2, c2;
                }) : g(true, r4, i2);
              });
            case 2:
            case 0:
            case void 0:
            case -1:
              return new Promise(function(e4, t4) {
                g(true, e4, t4);
              });
          }
          if (3 === s2)
            return new Promise(function(e4, t4) {
              null !== n2.provider && n2.provider.get(p, function(r4, n3) {
                try {
                  r4 || !n3 ? t4(r4) : (u2 || (n3 = h(n3)), e4(y(n3)));
                } catch (e5) {
                  t4(e5);
                }
              });
            }).then(function() {
              return new Promise(function(e4, t4) {
                g(true, e4, t4);
              });
            }).catch(function(e4) {
              return new Promise(function(e5, t4) {
                g(true, e5, t4);
              });
            });
        };
        var o = u(r2(777)), s = u(r2(324));
        function u(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        function a(e3, t3) {
          if (e3 && t3)
            for (var r3 in t3)
              e3[r3] = t3[r3];
          return e3;
        }
        function c(e3, t3, r3) {
          if (e3 && e3.requestParams) {
            var n2 = a({}, e3.requestParams.body && e3.requestParams.body.query || {});
            return n2.environment_uid && (delete n2.environment_uid, n2.environment = e3.environment), n2.environment = e3.environment, { content_type_uid: e3.content_type_uid, locale: n2.locale || "en-us", query: n2, entry_uid: e3.entry_uid, asset_uid: e3.asset_uid, single: t3 || "false", toJSON: r3 || "false", api_key: e3.requestParams.headers ? e3.requestParams.headers.api_key : "" };
          }
        }
        function l(e3) {
          try {
            var t3 = f(JSON.stringify(e3)), r3 = [];
            return r3.push(e3.content_type_uid), r3.push(e3.locale), e3.entry_uid && r3.push(e3.entry_uid), e3.asset_uid && r3.push(e3.asset_uid), r3.push(t3), r3.join(".");
          } catch (e4) {
          }
        }
        function f(e3) {
          var t3, r3 = 0, n2 = void 0;
          if (0 === e3.length)
            return r3;
          for (n2 = 0, t3 = e3.length; n2 < t3; n2++)
            r3 = (r3 << 5) - r3 + e3.charCodeAt(n2), r3 |= 0;
          return r3 < -1 ? -1 * r3 : r3;
        }
        function h(e3) {
          if (e3 && void 0 !== e3.entries)
            if (e3.entries && e3.entries.length)
              for (var t3 = 0, r3 = e3.entries.length; t3 < r3; t3++)
                e3.entries[t3] = (0, s.default)(e3.entries[t3]);
            else
              e3.entries = [];
          else if (e3 && e3.assets && void 0 !== e3.assets)
            if (e3.assets && e3.assets.length)
              for (var n2 = 0, i2 = e3.assets.length; n2 < i2; n2++)
                e3.assets[n2] = (0, s.default)(e3.assets[n2]);
            else
              e3.assets = [];
          else
            e3 && void 0 !== e3.entry ? e3.entry = (0, s.default)(e3.entry) : e3 && void 0 !== e3.asset ? e3.asset = (0, s.default)(e3.asset) : e3 && void 0 !== e3.items && (e3.items = (0, s.default)(e3.items).toJSON());
          return e3;
        }
        function y(e3) {
          var t3 = [];
          return e3 && Object.keys(e3).length && (void 0 !== e3.entries && (t3.push(e3.entries), e3.content_type && (t3.schema = e3.content_type)), void 0 !== e3.assets && t3.push(e3.assets), void 0 === e3.content_type && void 0 === e3.schema || t3.push(e3.content_type || e3.schema), void 0 !== e3.count && t3.push(e3.count), void 0 !== e3.entry && (t3 = e3.entry, e3.schema && (t3.schema = e3.schema), e3.content_type && (t3.content_type = e3.content_type)), void 0 !== e3.asset && (t3 = e3.asset), void 0 !== e3.items && t3.push(e3)), t3;
        }
        async function d(e3, t3, r3, i2, s2) {
          var u2 = r3.live_preview, a2 = r3.requestParams, c2 = u2.content_type_uid, l2 = u2.management_token;
          await async function e4(t4, s3, f2) {
            if (void 0 !== s3)
              if (Array.isArray(s3))
                await Promise.all(s3.map(function(r4, n2) {
                  return e4(t4, r4, function(e5) {
                    s3[n2] = e5;
                  });
                }));
              else if (s3._content_type_uid === c2)
                try {
                  r3.requestParams = JSON.parse(JSON.stringify(a2));
                  var h2 = function(e5) {
                    var t5 = [];
                    return function e6(r4, i3) {
                      0 === Object.keys(r4).length ? t5.push(i3.substring(1)) : Object.entries(r4).forEach(function(t6) {
                        var r5 = n(t6, 2), o2 = r5[0];
                        e6(r5[1], [i3, o2].join("."));
                      });
                    }(e5, ""), t5.filter(function(e6) {
                      return "" !== e6;
                    });
                  }(t4);
                  r3.requestParams.body.include = h2, r3.requestParams.body.live_preview = u2.live_preview, r3.requestParams.body.content_type_uid = c2;
                  var y2 = u2.host.match(/^((http[s]?):(\/\/)?)?(.+)$/), d2 = (y2[1] || "https://") + y2[4], p = s3.uid, v = d2 + "/v3/content_types/" + s3._content_type_uid + "/entries/" + p;
                  r3.requestParams.url = v, r3.requestParams.method = "GET", delete r3.requestParams.headers.access_token, r3.requestParams.headers.authorization = l2;
                  var _ = await (0, o.default)(r3, i2);
                  _.entry._content_type_uid = c2, _.entry.uid = p, f2(_.entry);
                } catch (e5) {
                  console.log("errror", e5);
                }
              else
                await Promise.all(Object.entries(t4).map(async function(t5) {
                  var r4 = n(t5, 2), i3 = r4[0], o2 = r4[1];
                  await e4(o2, s3[i3], function() {
                  });
                }));
          }(e3, t3, function() {
          });
        }
        Promise.prototype.spread || (Promise.prototype.spread = function(e3, t3) {
          return t3 = t3 || function(e4) {
          }, this.then(function(t4) {
            return e3.apply(e3, t4);
          }).catch(function(e4) {
            t3(e4);
          });
        });
      }, 173: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        var n = function() {
          function e3(e4, t3) {
            for (var r3 = 0; r3 < t3.length; r3++) {
              var n2 = t3[r3];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e4, n2.key, n2);
            }
          }
          return function(t3, r3, n2) {
            return r3 && e3(t3.prototype, r3), n2 && e3(t3, n2), t3;
          };
        }(), i = function(e3) {
          if (e3 && e3.__esModule)
            return e3;
          var t3 = {};
          if (null != e3)
            for (var r3 in e3)
              Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
          return t3.default = e3, t3;
        }(r2(540)), o = function() {
          function e3() {
            return function(e4, t3) {
              if (!(e4 instanceof t3))
                throw new TypeError("Cannot call a class as a function");
            }(this, e3), this._query = {}, this.only = i.transform("only"), this;
          }
          return n(e3, [{ key: "toJSON", value: function() {
            return this.tojson = true, this;
          } }, { key: "addParam", value: function(e4, t3) {
            if (e4 && "string" == typeof e4 && t3 && "string" == typeof t3)
              return this._query[e4] = t3, this;
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide a valid parameters.");
          } }, { key: "includeFallback", value: function() {
            return this._query.include_fallback = true, this;
          } }, { key: "includeMetadata", value: function() {
            return this._query.include_metadata = true, this;
          } }, { key: "fetch", value: function(e4) {
            if (this.asset_uid) {
              this.requestParams = { method: "POST", headers: this.headers, url: this.config.protocol + "://" + this.config.host + ":" + this.config.port + "/" + this.config.version + this.config.urls.assets + this.asset_uid, body: { _method: "GET", query: this._query } };
              var t3 = i.mergeDeep(this.fetchOptions, e4);
              return i.sendRequest(i.mergeDeep({}, this), t3);
            }
            e4.debug && e4.logHandler("error", "Kindly provide an asset uid. e.g. .Assets('asset_uid')");
          } }]), e3;
        }();
        t2.default = o;
      }, 304: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        }, i = function() {
          function e3(e4, t3) {
            for (var r3 = 0; r3 < t3.length; r3++) {
              var n2 = t3[r3];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e4, n2.key, n2);
            }
          }
          return function(t3, r3, n2) {
            return r3 && e3(t3.prototype, r3), n2 && e3(t3, n2), t3;
          };
        }(), o = function(e3) {
          if (e3 && e3.__esModule)
            return e3;
          var t3 = {};
          if (null != e3)
            for (var r3 in e3)
              Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
          return t3.default = e3, t3;
        }(r2(540)), s = function() {
          function e3() {
            return function(e4, t3) {
              if (!(e4 instanceof t3))
                throw new TypeError("Cannot call a class as a function");
            }(this, e3), this._query = {}, this.only = o.transform("only"), this.except = o.transform("except"), this;
          }
          return i(e3, [{ key: "setCacheProvider", value: function(e4) {
            return e4 && "object" === (void 0 === e4 ? "undefined" : n(e4)) && (this.provider = e4), this;
          } }, { key: "setCachePolicy", value: function(e4) {
            return "number" == typeof e4 && e4 >= -1 && e4 < 4 ? this._query ? this.queryCachePolicy = e4 : this.cachePolicy = e4 : this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide the valid policy"), this;
          } }, { key: "includeReference", value: function() {
            for (var e4 = arguments.length, t3 = Array(e4), r3 = 0; r3 < e4; r3++)
              t3[r3] = arguments[r3];
            if (Array.isArray(t3) || "string" == typeof t3) {
              if (arguments.length)
                for (var n2 = 0; n2 < arguments.length; n2++)
                  this._query.include = this._query.include || [], this._query.include = this._query.include.concat(arguments[n2]);
              return this;
            }
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Argument should be a String or an Array.");
          } }, { key: "language", value: function(e4) {
            if (e4 && "string" == typeof e4)
              return this._query.locale = e4, this;
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Argument should be a String.");
          } }, { key: "addQuery", value: function(e4, t3) {
            if (e4 && t3 && "string" == typeof e4)
              return this._query[e4] = t3, this;
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "First argument should be a String.");
          } }, { key: "includeEmbeddedItems", value: function() {
            return this._query.include_embedded_items = ["BASE"], this;
          } }, { key: "includeSchema", value: function() {
            return this._query.include_schema = true, this;
          } }, { key: "includeReferenceContentTypeUID", value: function() {
            return this._query.include_reference_content_type_uid = true, this;
          } }, { key: "includeFallback", value: function() {
            return this._query.include_fallback = true, this;
          } }, { key: "includeBranch", value: function() {
            return this._query.include_branch = true, this;
          } }, { key: "includeMetadata", value: function() {
            return this._query.include_metadata = true, this;
          } }, { key: "includeContentType", value: function() {
            return this._query.include_content_type = true, this;
          } }, { key: "includeOwner", value: function() {
            return this._query.include_owner = true, this;
          } }, { key: "toJSON", value: function() {
            return this.tojson = true, this;
          } }, { key: "addParam", value: function(e4, t3) {
            if (e4 && t3 && "string" == typeof e4 && "string" == typeof t3)
              return this._query[e4] = t3, this;
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide valid parameters.");
          } }, { key: "fetch", value: function(e4) {
            var t3 = this.config.host + ":" + this.config.port;
            if (this.live_preview && true === this.live_preview.enable && this.live_preview.content_type_uid === this.content_type_uid && (t3 = this.live_preview.host), this.entry_uid) {
              this.requestParams = { method: "POST", headers: this.headers, url: this.config.protocol + "://" + t3 + "/" + this.config.version + this.config.urls.content_types + this.content_type_uid + this.config.urls.entries + this.entry_uid, body: { _method: "GET", query: this._query } };
              var r3 = o.mergeDeep(this.fetchOptions, e4);
              return o.sendRequest(o.mergeDeep({}, this), r3);
            }
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide an entry uid. e.g. .Entry('asset_uid')");
          } }]), e3;
        }();
        t2.default = s;
      }, 566: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        var n, i = function() {
          function e3(e4, t3) {
            for (var r3 = 0; r3 < t3.length; r3++) {
              var n2 = t3[r3];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e4, n2.key, n2);
            }
          }
          return function(t3, r3, n2) {
            return r3 && e3(t3.prototype, r3), n2 && e3(t3, n2), t3;
          };
        }(), o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        }, s = function(e3) {
          if (e3 && e3.__esModule)
            return e3;
          var t3 = {};
          if (null != e3)
            for (var r3 in e3)
              Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
          return t3.default = e3, t3;
        }(r2(540)), u = (n = r2(304)) && n.__esModule ? n : { default: n }, a = function(e3) {
          return function(t3, r3) {
            if (t3 && r3 && "string" == typeof t3 && void 0 !== r3)
              return this._query.query[t3] = this._query.query.file_size || {}, this._query.query[t3][e3] = r3, this;
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide valid parameters.");
          };
        }, c = function(e3) {
          var t3 = e3 ? "$in" : "$nin";
          return function(e4, r3) {
            if (e4 && r3 && "string" == typeof e4 && Array.isArray(r3))
              return this._query.query[e4] = this._query.query[e4] || {}, this._query.query[e4][t3] = this._query.query[e4][t3] || [], this._query.query[e4][t3] = this._query.query[e4][t3].concat(r3), this;
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide valid parameters.");
          };
        }, l = function(e3) {
          return function(t3) {
            if (t3 && "string" == typeof t3)
              return this._query.query[t3] = this._query.query[t3] || {}, this._query.query[t3].$exists = e3, this;
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide valid parameters.");
          };
        }, f = function(e3) {
          return function() {
            for (var t3 = [], r3 = 0, n2 = arguments.length; r3 < n2; r3++)
              arguments[r3] instanceof d && arguments[r3]._query.query ? t3.push(arguments[r3]._query.query) : "object" === o(arguments[r3]) && t3.push(arguments[r3]);
            return this._query.query[e3] ? this._query.query[e3] = this._query.query[e3].concat(t3) : this._query.query[e3] = t3, this;
          };
        }, h = function(e3) {
          return function(t3) {
            if (t3 && "string" == typeof t3)
              return this._query[e3] = t3, this;
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Argument should be a string.");
          };
        }, y = function(e3) {
          return function(t3) {
            if ("number" == typeof t3)
              return this._query[e3] = t3, this;
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Argument should be a number.");
          };
        }, d = function(e3) {
          function t3() {
            !function(e5, t4) {
              if (!(e5 instanceof t4))
                throw new TypeError("Cannot call a class as a function");
            }(this, t3);
            var e4 = function(e5, t4) {
              if (!e5)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !t4 || "object" != typeof t4 && "function" != typeof t4 ? e5 : t4;
            }(this, (t3.__proto__ || Object.getPrototypeOf(t3)).call(this));
            return e4._query = e4._query || {}, e4._query.query = e4._query.query || {}, e4.lessThan = a("$lt"), e4.lessThanOrEqualTo = a("$lte"), e4.greaterThan = a("$gt"), e4.greaterThanOrEqualTo = a("$gte"), e4.notEqualTo = a("$ne"), e4.containedIn = c(true), e4.notContainedIn = c(false), e4.exists = l(true), e4.notExists = l(false), e4.ascending = h("asc"), e4.descending = h("desc"), e4.beforeUid = h("before_uid"), e4.afterUid = h("after_uid"), e4.skip = y("skip"), e4.limit = y("limit"), e4.or = f("$or"), e4.and = f("$and"), e4;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4)
              throw new TypeError("Super expression must either be null or a function, not " + typeof t4);
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, enumerable: false, writable: true, configurable: true } }), t4 && (Object.setPrototypeOf ? Object.setPrototypeOf(e4, t4) : e4.__proto__ = t4);
          }(t3, e3), i(t3, [{ key: "equalTo", value: function(e4, t4) {
            if (e4 && "string" == typeof e4)
              return this._query.query[e4] = t4, this;
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide valid parameters.");
          } }, { key: "where", value: function(e4, t4) {
            if (e4 && "string" == typeof e4)
              return this._query.query[e4] = t4, this;
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide valid parameters.");
          } }, { key: "count", value: function() {
            var e4 = this.config.protocol + "://" + this.config.host + ":" + this.config.port + "/" + this.config.version, t4 = this.type && "asset" === this.type ? e4 + this.config.urls.assets : e4 + this.config.urls.content_types + this.content_type_uid + this.config.urls.entries;
            return this._query.count = true, this.requestParams = { method: "POST", headers: this.headers, url: t4, body: { _method: "GET", query: this._query } }, this;
          } }, { key: "query", value: function(e4) {
            if ("object" === (void 0 === e4 ? "undefined" : o(e4)))
              return this._query.query = s.mergeDeep(this._query.query, e4), this;
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide valid parameters");
          } }, { key: "referenceIn", value: function(e4, r3) {
            var n2 = {};
            return r3 instanceof t3 && r3._query.query ? n2.$in_query = r3._query.query : "object" === (void 0 === r3 ? "undefined" : o(r3)) && (n2.$in_query = r3), this._query.query[e4] ? this._query.query[e4] = this._query.query[e4].concat(n2) : this._query.query[e4] = n2, this;
          } }, { key: "referenceNotIn", value: function(e4, r3) {
            var n2 = {};
            return r3 instanceof t3 && r3._query.query ? n2.$nin_query = r3._query.query : "object" === (void 0 === r3 ? "undefined" : o(r3)) && (n2.$nin_query = r3), this._query.query[e4] ? this._query.query[e4] = this._query.query[e4].concat(n2) : this._query.query[e4] = n2, this;
          } }, { key: "tags", value: function(e4) {
            if (Array.isArray(e4))
              return this._query.tags = e4, this;
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide valid parameters");
          } }, { key: "includeReferenceContentTypeUID", value: function() {
            return this._query.include_reference_content_type_uid = true, this;
          } }, { key: "includeCount", value: function() {
            return this._query.include_count = true, this;
          } }, { key: "addParam", value: function(e4, t4) {
            if (e4 && t4 && "string" == typeof e4 && "string" == typeof t4)
              return this._query[e4] = t4, this;
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide valid parameters.");
          } }, { key: "getQuery", value: function() {
            return this._query.query || {};
          } }, { key: "regex", value: function(e4, t4, r3) {
            if (e4 && t4 && "string" == typeof e4 && "string" == typeof t4)
              return this._query.query[e4] = { $regex: t4 }, r3 && (this._query.query[e4].$options = r3), this;
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide valid parameters.");
          } }, { key: "search", value: function(e4) {
            if (e4 && "string" == typeof e4)
              return this._query.typeahead = e4, this;
            this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide valid parameters.");
          } }, { key: "find", value: function(e4) {
            var t4 = this.config.host + ":" + this.config.port;
            this.type && "asset" !== this.type && this.live_preview && true === this.live_preview.enable && this.live_preview.content_type_uid === this.content_type_uid && (t4 = this.live_preview.host);
            var r3 = this.config.protocol + "://" + t4 + "/" + this.config.version, n2 = this.type && "asset" === this.type ? r3 + this.config.urls.assets : r3 + this.config.urls.content_types + this.content_type_uid + this.config.urls.entries;
            this.requestParams = { method: "POST", headers: this.headers, url: n2, body: { _method: "GET", query: this._query } };
            var i2 = s.mergeDeep(this.fetchOptions, e4);
            return s.sendRequest(s.mergeDeep({}, this), i2);
          } }, { key: "findOne", value: function() {
            var e4 = this.config.protocol + "://" + this.config.host + ":" + this.config.port + "/" + this.config.version;
            this.type && "asset" !== this.type && this.live_preview && true === this.live_preview.enable && this.live_preview.content_type_uid === this.content_type_uid && (e4 = this.config.protocol + "://" + this.live_preview.host + "/" + this.config.version);
            var t4 = this.type && "asset" === this.type ? e4 + this.config.urls.assets : e4 + this.config.urls.content_types + this.content_type_uid + this.config.urls.entries;
            this.singleEntry = true, this._query.limit = 1, this.requestParams = { method: "POST", headers: this.headers, url: t4, body: { _method: "GET", query: this._query } };
            var r3 = s.mergeDeep({}, this.fetchOptions);
            return s.sendRequest(s.mergeDeep({}, this), r3);
          } }]), t3;
        }(u.default);
        t2.default = d;
      }, 324: (e2, t2, r2) => {
        var n = function() {
          function e3(e4, t3) {
            for (var r3 = 0; r3 < t3.length; r3++) {
              var n2 = t3[r3];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e4, n2.key, n2);
            }
          }
          return function(t3, r3, n2) {
            return r3 && e3(t3.prototype, r3), n2 && e3(t3, n2), t3;
          };
        }(), i = function(e3) {
          if (e3 && e3.__esModule)
            return e3;
          var t3 = {};
          if (null != e3)
            for (var r3 in e3)
              Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
          return t3.default = e3, t3;
        }(r2(540)), o = function() {
          function e3(t3) {
            return function(e4, t4) {
              if (!(e4 instanceof t4))
                throw new TypeError("Cannot call a class as a function");
            }(this, e3), t3 && (this.object = function() {
              return t3;
            }), this;
          }
          return n(e3, [{ key: "toJSON", value: function() {
            return this.object() ? i.mergeDeep(JSON.parse(JSON.stringify({})), this.object()) : null;
          } }, { key: "get", value: function(e4) {
            if (this.object() && e4)
              return e4.split(".").reduce(function(e5, t3) {
                return e5[t3];
              }, this.object());
          } }, { key: "getDownloadUrl", value: function(e4) {
            if (this.object()) {
              var t3 = this.object().url ? this.object().url : null;
              return t3 ? t3 + "?disposition=" + (e4 && "string" == typeof e4 ? e4 : "attachment") : null;
            }
          } }]), e3;
        }();
        e2.exports = function(e3) {
          return new o(e3);
        };
      }, 533: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        }, i = function() {
          function e3(e4, t3) {
            for (var r3 = 0; r3 < t3.length; r3++) {
              var n2 = t3[r3];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e4, n2.key, n2);
            }
          }
          return function(t3, r3, n2) {
            return r3 && e3(t3.prototype, r3), n2 && e3(t3, n2), t3;
          };
        }(), o = h(r2(971)), s = function(e3) {
          if (e3 && e3.__esModule)
            return e3;
          var t3 = {};
          if (null != e3)
            for (var r3 in e3)
              Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
          return t3.default = e3, t3;
        }(r2(540)), u = h(r2(304)), a = h(r2(173)), c = h(r2(566)), l = h(r2(777)), f = h(r2(900));
        function h(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        var y = [408, 429], d = function() {
          function e3() {
            var t3 = this;
            !function(e4, t4) {
              if (!(e4 instanceof t4))
                throw new TypeError("Cannot call a class as a function");
            }(this, e3), this.fetchOptions = { retryLimit: 5, retryCondition: function(e4) {
              return !!y.includes(e4.status);
            }, debug: false, logHandler: function(e4, t4) {
              "error" === e4 && t4 ? console.error("[error] " + t4) : "warning" === e4 && t4 ? console.warn("[warning] " + t4) : "info" === e4 && t4 && console.info("[info] " + t4);
            } }, this.config = s.mergeDeep({}, o.default), this.plugins = [];
            for (var r3 = arguments.length, i2 = Array(r3), u2 = 0; u2 < r3; u2++)
              i2[u2] = arguments[u2];
            switch (i2[0].region && void 0 !== i2[0].region && "us" !== i2[0].region && (this.config.host = i2[0].region + "-cdn.contentstack.com"), i2[0].fetchOptions && void 0 !== i2[0].fetchOptions && (this.fetchOptions = s.mergeDeep(this.fetchOptions, i2[0].fetchOptions)), i2[0].plugins && void 0 !== i2[0].plugins && i2[0].plugins.forEach(function(e4) {
              t3.plugins.push(e4);
            }), this.cachePolicy = f.default.policies.IGNORE_CACHE, this.provider = f.default.providers("localstorage"), i2.length) {
              case 1:
                if ("object" === n(i2[0]) && "string" == typeof i2[0].api_key && "string" == typeof i2[0].delivery_token && "string" == typeof i2[0].environment)
                  return this.headers = { api_key: i2[0].api_key, access_token: i2[0].delivery_token }, "object" == n(i2[0].live_preview) && (this.live_preview = s.mergeDeep(this.config.live_preview, i2[0].live_preview)), "string" == typeof i2[0].branch && void 0 !== i2[0].branch && (this.headers.branch = i2[0].branch), this.environment = i2[0].environment, this;
                this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide valid object parameters. The specified API Key, Delivery Token, or Environment Name is invalid.");
              case 3:
                if (this.fetchOptions.debug && this.fetchOptions.logHandler("warning", "WARNING! Obsolete function called. Function 'Contentstack.Stack(api_key, delivery_token, environment)' has been deprecated, please use 'Contentstack.Stack({api_key, delivery_token, environment, region, branch, fetchOptions})' function instead!"), "string" == typeof i2[0] && "string" == typeof i2[1] && "string" == typeof i2[2])
                  return this.headers = { api_key: i2[0], access_token: i2[1] }, this.environment = i2[2], this;
                this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide valid string parameters.");
              case 4:
                return this.fetchOptions.debug && this.fetchOptions.logHandler("warning", "WARNING! Obsolete function called. Function 'Contentstack.Stack(api_key, delivery_token, environment)' has been deprecated, please use 'Contentstack.Stack({api_key, delivery_token, environment, region, branch, fetchOptions})' function instead!"), "string" == typeof i2[0] && "string" == typeof i2[1] && "string" == typeof i2[2] ? (this.headers = { api_key: i2[0], access_token: i2[1] }, this.environment = i2[2]) : this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide valid string parameters."), i2[3] && ("string" == typeof i2[3] && void 0 !== i2[3] && "us" !== i2[3] ? this.config.host = i2[3] + "-cdn.contentstack.com" : "object" === n(i2[3]) && (this.fetchOptions = s.mergeDeep(this.fetchOptions, i2[3]))), this;
              case 5:
                return this.fetchOptions.debug && this.fetchOptions.logHandler("warning", "WARNING! Obsolete function called. Function 'Contentstack.Stack(api_key, delivery_token, environment)' has been deprecated, please use 'Contentstack.Stack({api_key, delivery_token, environment, region, branch, fetchOptions})' function instead!"), "string" == typeof i2[0] && "string" == typeof i2[1] && "string" == typeof i2[2] ? (this.headers = { api_key: i2[0], access_token: i2[1] }, this.environment = i2[2]) : this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide valid string parameters."), i2[3] && ("string" == typeof i2[3] && void 0 !== i2[3] && "us" !== i2[3] ? this.config.host = i2[3] + "-cdn.contentstack.com" : "object" === n(i2[3]) && (this.fetchOptions = s.mergeDeep(this.fetchOptions, i2[3]))), i2[4] && "object" === n(i2[4]) && (this.fetchOptions = s.mergeDeep(this.fetchOptions, i2[4])), this;
              default:
                this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide valid parameters to initialize the Contentstack javascript-SDK Stack.");
            }
          }
          return i(e3, [{ key: "setPort", value: function(e4) {
            return "number" == typeof e4 && (this.config.port = e4), this;
          } }, { key: "setProtocol", value: function(e4) {
            return "string" == typeof e4 && ~["https", "http"].indexOf(e4) && (this.config.protocol = e4), this;
          } }, { key: "setHost", value: function(e4) {
            return "string" == typeof e4 && e4 && (this.config.host = e4), this;
          } }, { key: "setCachePolicy", value: function(e4) {
            return "number" == typeof e4 && e4 >= -1 && e4 < 4 ? this._query ? this.queryCachePolicy = e4 : this.cachePolicy = e4 : this.fetchOptions.debug && this.fetchOptions.logHandler("error", "Kindly provide the valid policy"), this;
          } }, { key: "livePreviewQuery", value: function(e4) {
            this.live_preview && (this.live_preview.live_preview = e4.live_preview || "init", this.live_preview.content_type_uid = e4.content_type_uid, this.live_preview.entry_uid = e4.entry_uid);
          } }, { key: "setCacheProvider", value: function(e4) {
            return e4 && "object" === (void 0 === e4 ? "undefined" : n(e4)) && (this.provider = e4), this;
          } }, { key: "clearByQuery", value: function() {
            if (this.provider && "function" == typeof this.provider.clearByQuery)
              return this.provider.clearByQuery.apply(this.provider, arguments);
          } }, { key: "clearByContentType", value: function() {
            if (this.provider && "function" == typeof this.provider.clearByContentType)
              return this.provider.clearByContentType.apply(this.provider, arguments);
          } }, { key: "clearAll", value: function() {
            if (this.provider && "function" == typeof this.provider.clearAll)
              return this.provider.clearAll.apply(this.provider, arguments);
          } }, { key: "getCacheProvider", value: function() {
            return this.provider;
          } }, { key: "ContentType", value: function(e4) {
            return e4 && "string" == typeof e4 && (this.content_type_uid = e4, this.type = "contentType"), this;
          } }, { key: "Entry", value: function(e4) {
            var t3 = new u.default();
            return e4 && "string" == typeof e4 && (t3.entry_uid = e4), s.merge(t3, this);
          } }, { key: "fetch", value: function(e4) {
            this.requestParams = { method: "POST", headers: this.headers, plugins: this.plugins, url: this.config.protocol + "://" + this.config.host + ":" + this.config.port + "/" + this.config.version + this.config.urls.content_types + this.content_type_uid, body: { _method: "GET", environment: this.environment } };
            var t3 = s.mergeDeep(this.fetchOptions, e4);
            return (0, l.default)(this, t3);
          } }, { key: "Assets", value: function(e4) {
            if (this.type = "asset", e4 && "string" == typeof e4) {
              var t3 = new a.default();
              return t3.asset_uid = e4, s.merge(t3, this);
            }
            return this;
          } }, { key: "Query", value: function() {
            var e4 = new c.default();
            return s.merge(e4, this);
          } }, { key: "getLastActivities", value: function() {
            return this.requestParams = { method: "POST", headers: this.headers, url: this.config.protocol + "://" + this.config.host + ":" + this.config.port + "/" + this.config.version + this.config.urls.content_types, body: { _method: "GET", only_last_activity: true, environment: this.environment } }, (0, l.default)(this, this.fetchOptions);
          } }, { key: "getContentTypes", value: function() {
            var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (this.requestParams = { method: "POST", headers: this.headers, url: this.config.protocol + "://" + this.config.host + ":" + this.config.port + "/" + this.config.version + this.config.urls.content_types, body: { _method: "GET", environment: this.environment } }, e4)
              for (var t3 in e4)
                this.requestParams.body[t3] = e4[t3];
            return (0, l.default)(this, this.fetchOptions);
          } }, { key: "sync", value: function(e4, t3) {
            this._query = {}, this._query = s.mergeDeep(this._query, e4), this.requestParams = { method: "POST", headers: this.headers, url: this.config.protocol + "://" + this.config.host + ":" + this.config.port + "/" + this.config.version + this.config.urls.sync, body: { _method: "GET", query: this._query } };
            var r3 = s.mergeDeep(this.fetchOptions, t3);
            return s.sendRequest(s.mergeDeep({}, this), r3);
          } }, { key: "imageTransform", value: function(e4, t3) {
            if (e4 && "string" == typeof e4 && "object" === (void 0 === t3 ? "undefined" : n(t3)) && void 0 === t3.length) {
              var r3 = [];
              for (var i2 in t3)
                r3.push(i2 + "=" + t3[i2]);
              e4 += e4.indexOf("?") <= -1 ? "?" + r3.join("&") : "&" + r3.join("&");
            }
            return e4;
          } }]), e3;
        }();
        t2.default = d;
      }, 289: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        var n = o(r2(858)), i = o(r2(809));
        function o(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        n.default.polyfill(), t2.default = i.default;
      }, 895: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        var n, i = (n = r2(118)) && n.__esModule ? n : { default: n };
        t2.default = i.default;
      }, 464: (e2) => {
        e2.exports = require_index_es();
      }, 858: (e2) => {
        e2.exports = require_es6_promise();
      }, 118: (e2) => {
        e2.exports = require_localStorage();
      }, 809: (e2) => {
        e2.exports = (init_lib(), __toCommonJS(lib_exports));
      } }, t = {}, r = function r2(n) {
        var i = t[n];
        if (void 0 !== i)
          return i.exports;
        var o = t[n] = { exports: {} };
        return e[n](o, o.exports, r2), o.exports;
      }(32);
      module2.exports = r;
    })();
  }
});

// node_modules/inversify/lib/constants/metadata_keys.js
var require_metadata_keys = __commonJS({
  "node_modules/inversify/lib/constants/metadata_keys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NON_CUSTOM_TAG_KEYS = exports.POST_CONSTRUCT = exports.DESIGN_PARAM_TYPES = exports.PARAM_TYPES = exports.TAGGED_PROP = exports.TAGGED = exports.MULTI_INJECT_TAG = exports.INJECT_TAG = exports.OPTIONAL_TAG = exports.UNMANAGED_TAG = exports.NAME_TAG = exports.NAMED_TAG = void 0;
    exports.NAMED_TAG = "named";
    exports.NAME_TAG = "name";
    exports.UNMANAGED_TAG = "unmanaged";
    exports.OPTIONAL_TAG = "optional";
    exports.INJECT_TAG = "inject";
    exports.MULTI_INJECT_TAG = "multi_inject";
    exports.TAGGED = "inversify:tagged";
    exports.TAGGED_PROP = "inversify:tagged_props";
    exports.PARAM_TYPES = "inversify:paramtypes";
    exports.DESIGN_PARAM_TYPES = "design:paramtypes";
    exports.POST_CONSTRUCT = "post_construct";
    function getNonCustomTagKeys() {
      return [
        exports.INJECT_TAG,
        exports.MULTI_INJECT_TAG,
        exports.NAME_TAG,
        exports.UNMANAGED_TAG,
        exports.NAMED_TAG,
        exports.OPTIONAL_TAG
      ];
    }
    exports.NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();
  }
});

// node_modules/inversify/lib/constants/literal_types.js
var require_literal_types = __commonJS({
  "node_modules/inversify/lib/constants/literal_types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TargetTypeEnum = exports.BindingTypeEnum = exports.BindingScopeEnum = void 0;
    var BindingScopeEnum = {
      Request: "Request",
      Singleton: "Singleton",
      Transient: "Transient"
    };
    exports.BindingScopeEnum = BindingScopeEnum;
    var BindingTypeEnum = {
      ConstantValue: "ConstantValue",
      Constructor: "Constructor",
      DynamicValue: "DynamicValue",
      Factory: "Factory",
      Function: "Function",
      Instance: "Instance",
      Invalid: "Invalid",
      Provider: "Provider"
    };
    exports.BindingTypeEnum = BindingTypeEnum;
    var TargetTypeEnum = {
      ClassProperty: "ClassProperty",
      ConstructorArgument: "ConstructorArgument",
      Variable: "Variable"
    };
    exports.TargetTypeEnum = TargetTypeEnum;
  }
});

// node_modules/inversify/lib/utils/id.js
var require_id = __commonJS({
  "node_modules/inversify/lib/utils/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.id = void 0;
    var idCounter = 0;
    function id() {
      return idCounter++;
    }
    exports.id = id;
  }
});

// node_modules/inversify/lib/bindings/binding.js
var require_binding = __commonJS({
  "node_modules/inversify/lib/bindings/binding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Binding = void 0;
    var literal_types_1 = require_literal_types();
    var id_1 = require_id();
    var Binding = function() {
      function Binding2(serviceIdentifier, scope) {
        this.id = id_1.id();
        this.activated = false;
        this.serviceIdentifier = serviceIdentifier;
        this.scope = scope;
        this.type = literal_types_1.BindingTypeEnum.Invalid;
        this.constraint = function(request) {
          return true;
        };
        this.implementationType = null;
        this.cache = null;
        this.factory = null;
        this.provider = null;
        this.onActivation = null;
        this.dynamicValue = null;
      }
      Binding2.prototype.clone = function() {
        var clone2 = new Binding2(this.serviceIdentifier, this.scope);
        clone2.activated = clone2.scope === literal_types_1.BindingScopeEnum.Singleton ? this.activated : false;
        clone2.implementationType = this.implementationType;
        clone2.dynamicValue = this.dynamicValue;
        clone2.scope = this.scope;
        clone2.type = this.type;
        clone2.factory = this.factory;
        clone2.provider = this.provider;
        clone2.constraint = this.constraint;
        clone2.onActivation = this.onActivation;
        clone2.cache = this.cache;
        return clone2;
      };
      return Binding2;
    }();
    exports.Binding = Binding;
  }
});

// node_modules/inversify/lib/constants/error_msgs.js
var require_error_msgs = __commonJS({
  "node_modules/inversify/lib/constants/error_msgs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.STACK_OVERFLOW = exports.CIRCULAR_DEPENDENCY_IN_FACTORY = exports.POST_CONSTRUCT_ERROR = exports.MULTIPLE_POST_CONSTRUCT_METHODS = exports.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = exports.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = exports.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = exports.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = exports.ARGUMENTS_LENGTH_MISMATCH = exports.INVALID_DECORATOR_OPERATION = exports.INVALID_TO_SELF_VALUE = exports.INVALID_FUNCTION_BINDING = exports.INVALID_MIDDLEWARE_RETURN = exports.NO_MORE_SNAPSHOTS_AVAILABLE = exports.INVALID_BINDING_TYPE = exports.NOT_IMPLEMENTED = exports.CIRCULAR_DEPENDENCY = exports.UNDEFINED_INJECT_ANNOTATION = exports.MISSING_INJECT_ANNOTATION = exports.MISSING_INJECTABLE_ANNOTATION = exports.NOT_REGISTERED = exports.CANNOT_UNBIND = exports.AMBIGUOUS_MATCH = exports.KEY_NOT_FOUND = exports.NULL_ARGUMENT = exports.DUPLICATED_METADATA = exports.DUPLICATED_INJECTABLE_DECORATOR = void 0;
    exports.DUPLICATED_INJECTABLE_DECORATOR = "Cannot apply @injectable decorator multiple times.";
    exports.DUPLICATED_METADATA = "Metadata key was used more than once in a parameter:";
    exports.NULL_ARGUMENT = "NULL argument";
    exports.KEY_NOT_FOUND = "Key Not Found";
    exports.AMBIGUOUS_MATCH = "Ambiguous match found for serviceIdentifier:";
    exports.CANNOT_UNBIND = "Could not unbind serviceIdentifier:";
    exports.NOT_REGISTERED = "No matching bindings found for serviceIdentifier:";
    exports.MISSING_INJECTABLE_ANNOTATION = "Missing required @injectable annotation in:";
    exports.MISSING_INJECT_ANNOTATION = "Missing required @inject or @multiInject annotation in:";
    var UNDEFINED_INJECT_ANNOTATION = function(name) {
      return "@inject called with undefined this could mean that the class " + name + " has a circular dependency problem. You can use a LazyServiceIdentifer to  overcome this limitation.";
    };
    exports.UNDEFINED_INJECT_ANNOTATION = UNDEFINED_INJECT_ANNOTATION;
    exports.CIRCULAR_DEPENDENCY = "Circular dependency found:";
    exports.NOT_IMPLEMENTED = "Sorry, this feature is not fully implemented yet.";
    exports.INVALID_BINDING_TYPE = "Invalid binding type:";
    exports.NO_MORE_SNAPSHOTS_AVAILABLE = "No snapshot available to restore.";
    exports.INVALID_MIDDLEWARE_RETURN = "Invalid return type in middleware. Middleware must return!";
    exports.INVALID_FUNCTION_BINDING = "Value provided to function binding must be a function!";
    exports.INVALID_TO_SELF_VALUE = "The toSelf function can only be applied when a constructor is used as service identifier";
    exports.INVALID_DECORATOR_OPERATION = "The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.";
    var ARGUMENTS_LENGTH_MISMATCH = function() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      return "The number of constructor arguments in the derived class " + (values[0] + " must be >= than the number of constructor arguments of its base class.");
    };
    exports.ARGUMENTS_LENGTH_MISMATCH = ARGUMENTS_LENGTH_MISMATCH;
    exports.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = "Invalid Container constructor argument. Container options must be an object.";
    exports.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = "Invalid Container option. Default scope must be a string ('singleton' or 'transient').";
    exports.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = "Invalid Container option. Auto bind injectable must be a boolean";
    exports.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = "Invalid Container option. Skip base check must be a boolean";
    exports.MULTIPLE_POST_CONSTRUCT_METHODS = "Cannot apply @postConstruct decorator multiple times in the same class";
    var POST_CONSTRUCT_ERROR = function() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      return "@postConstruct error in class " + values[0] + ": " + values[1];
    };
    exports.POST_CONSTRUCT_ERROR = POST_CONSTRUCT_ERROR;
    var CIRCULAR_DEPENDENCY_IN_FACTORY = function() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      return "It looks like there is a circular dependency " + ("in one of the '" + values[0] + "' bindings. Please investigate bindings with") + ("service identifier '" + values[1] + "'.");
    };
    exports.CIRCULAR_DEPENDENCY_IN_FACTORY = CIRCULAR_DEPENDENCY_IN_FACTORY;
    exports.STACK_OVERFLOW = "Maximum call stack size exceeded";
  }
});

// node_modules/inversify/lib/planning/metadata_reader.js
var require_metadata_reader = __commonJS({
  "node_modules/inversify/lib/planning/metadata_reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MetadataReader = void 0;
    var METADATA_KEY = require_metadata_keys();
    var MetadataReader = function() {
      function MetadataReader2() {
      }
      MetadataReader2.prototype.getConstructorMetadata = function(constructorFunc) {
        var compilerGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.PARAM_TYPES, constructorFunc);
        var userGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED, constructorFunc);
        return {
          compilerGeneratedMetadata,
          userGeneratedMetadata: userGeneratedMetadata || {}
        };
      };
      MetadataReader2.prototype.getPropertiesMetadata = function(constructorFunc) {
        var userGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED_PROP, constructorFunc) || [];
        return userGeneratedMetadata;
      };
      return MetadataReader2;
    }();
    exports.MetadataReader = MetadataReader;
  }
});

// node_modules/inversify/lib/bindings/binding_count.js
var require_binding_count = __commonJS({
  "node_modules/inversify/lib/bindings/binding_count.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindingCount = void 0;
    var BindingCount = {
      MultipleBindingsAvailable: 2,
      NoBindingsAvailable: 0,
      OnlyOneBindingAvailable: 1
    };
    exports.BindingCount = BindingCount;
  }
});

// node_modules/inversify/lib/utils/exceptions.js
var require_exceptions = __commonJS({
  "node_modules/inversify/lib/utils/exceptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isStackOverflowExeption = void 0;
    var ERROR_MSGS = require_error_msgs();
    function isStackOverflowExeption(error) {
      return error instanceof RangeError || error.message === ERROR_MSGS.STACK_OVERFLOW;
    }
    exports.isStackOverflowExeption = isStackOverflowExeption;
  }
});

// node_modules/inversify/lib/utils/serialization.js
var require_serialization = __commonJS({
  "node_modules/inversify/lib/utils/serialization.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.circularDependencyToException = exports.listMetadataForTarget = exports.listRegisteredBindingsForServiceIdentifier = exports.getServiceIdentifierAsString = exports.getFunctionName = void 0;
    var ERROR_MSGS = require_error_msgs();
    function getServiceIdentifierAsString(serviceIdentifier) {
      if (typeof serviceIdentifier === "function") {
        var _serviceIdentifier = serviceIdentifier;
        return _serviceIdentifier.name;
      } else if (typeof serviceIdentifier === "symbol") {
        return serviceIdentifier.toString();
      } else {
        var _serviceIdentifier = serviceIdentifier;
        return _serviceIdentifier;
      }
    }
    exports.getServiceIdentifierAsString = getServiceIdentifierAsString;
    function listRegisteredBindingsForServiceIdentifier(container2, serviceIdentifier, getBindings) {
      var registeredBindingsList = "";
      var registeredBindings = getBindings(container2, serviceIdentifier);
      if (registeredBindings.length !== 0) {
        registeredBindingsList = "\nRegistered bindings:";
        registeredBindings.forEach(function(binding) {
          var name = "Object";
          if (binding.implementationType !== null) {
            name = getFunctionName(binding.implementationType);
          }
          registeredBindingsList = registeredBindingsList + "\n " + name;
          if (binding.constraint.metaData) {
            registeredBindingsList = registeredBindingsList + " - " + binding.constraint.metaData;
          }
        });
      }
      return registeredBindingsList;
    }
    exports.listRegisteredBindingsForServiceIdentifier = listRegisteredBindingsForServiceIdentifier;
    function alreadyDependencyChain(request, serviceIdentifier) {
      if (request.parentRequest === null) {
        return false;
      } else if (request.parentRequest.serviceIdentifier === serviceIdentifier) {
        return true;
      } else {
        return alreadyDependencyChain(request.parentRequest, serviceIdentifier);
      }
    }
    function dependencyChainToString(request) {
      function _createStringArr(req, result) {
        if (result === void 0) {
          result = [];
        }
        var serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier);
        result.push(serviceIdentifier);
        if (req.parentRequest !== null) {
          return _createStringArr(req.parentRequest, result);
        }
        return result;
      }
      var stringArr = _createStringArr(request);
      return stringArr.reverse().join(" --> ");
    }
    function circularDependencyToException(request) {
      request.childRequests.forEach(function(childRequest) {
        if (alreadyDependencyChain(childRequest, childRequest.serviceIdentifier)) {
          var services = dependencyChainToString(childRequest);
          throw new Error(ERROR_MSGS.CIRCULAR_DEPENDENCY + " " + services);
        } else {
          circularDependencyToException(childRequest);
        }
      });
    }
    exports.circularDependencyToException = circularDependencyToException;
    function listMetadataForTarget(serviceIdentifierString, target) {
      if (target.isTagged() || target.isNamed()) {
        var m_1 = "";
        var namedTag = target.getNamedTag();
        var otherTags = target.getCustomTags();
        if (namedTag !== null) {
          m_1 += namedTag.toString() + "\n";
        }
        if (otherTags !== null) {
          otherTags.forEach(function(tag) {
            m_1 += tag.toString() + "\n";
          });
        }
        return " " + serviceIdentifierString + "\n " + serviceIdentifierString + " - " + m_1;
      } else {
        return " " + serviceIdentifierString;
      }
    }
    exports.listMetadataForTarget = listMetadataForTarget;
    function getFunctionName(v) {
      if (v.name) {
        return v.name;
      } else {
        var name_1 = v.toString();
        var match = name_1.match(/^function\s*([^\s(]+)/);
        return match ? match[1] : "Anonymous function: " + name_1;
      }
    }
    exports.getFunctionName = getFunctionName;
  }
});

// node_modules/inversify/lib/planning/context.js
var require_context = __commonJS({
  "node_modules/inversify/lib/planning/context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Context = void 0;
    var id_1 = require_id();
    var Context = function() {
      function Context2(container2) {
        this.id = id_1.id();
        this.container = container2;
      }
      Context2.prototype.addPlan = function(plan) {
        this.plan = plan;
      };
      Context2.prototype.setCurrentRequest = function(currentRequest) {
        this.currentRequest = currentRequest;
      };
      return Context2;
    }();
    exports.Context = Context;
  }
});

// node_modules/inversify/lib/planning/metadata.js
var require_metadata = __commonJS({
  "node_modules/inversify/lib/planning/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Metadata = void 0;
    var METADATA_KEY = require_metadata_keys();
    var Metadata = function() {
      function Metadata2(key, value) {
        this.key = key;
        this.value = value;
      }
      Metadata2.prototype.toString = function() {
        if (this.key === METADATA_KEY.NAMED_TAG) {
          return "named: " + this.value.toString() + " ";
        } else {
          return "tagged: { key:" + this.key.toString() + ", value: " + this.value + " }";
        }
      };
      return Metadata2;
    }();
    exports.Metadata = Metadata;
  }
});

// node_modules/inversify/lib/planning/plan.js
var require_plan = __commonJS({
  "node_modules/inversify/lib/planning/plan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Plan = void 0;
    var Plan = function() {
      function Plan2(parentContext, rootRequest) {
        this.parentContext = parentContext;
        this.rootRequest = rootRequest;
      }
      return Plan2;
    }();
    exports.Plan = Plan;
  }
});

// node_modules/inversify/lib/annotation/decorator_utils.js
var require_decorator_utils = __commonJS({
  "node_modules/inversify/lib/annotation/decorator_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tagProperty = exports.tagParameter = exports.decorate = void 0;
    var ERROR_MSGS = require_error_msgs();
    var METADATA_KEY = require_metadata_keys();
    function tagParameter(annotationTarget, propertyName, parameterIndex, metadata) {
      var metadataKey = METADATA_KEY.TAGGED;
      _tagParameterOrProperty(metadataKey, annotationTarget, propertyName, metadata, parameterIndex);
    }
    exports.tagParameter = tagParameter;
    function tagProperty(annotationTarget, propertyName, metadata) {
      var metadataKey = METADATA_KEY.TAGGED_PROP;
      _tagParameterOrProperty(metadataKey, annotationTarget.constructor, propertyName, metadata);
    }
    exports.tagProperty = tagProperty;
    function _tagParameterOrProperty(metadataKey, annotationTarget, propertyName, metadata, parameterIndex) {
      var paramsOrPropertiesMetadata = {};
      var isParameterDecorator = typeof parameterIndex === "number";
      var key = parameterIndex !== void 0 && isParameterDecorator ? parameterIndex.toString() : propertyName;
      if (isParameterDecorator && propertyName !== void 0) {
        throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);
      }
      if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {
        paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);
      }
      var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
      if (!Array.isArray(paramOrPropertyMetadata)) {
        paramOrPropertyMetadata = [];
      } else {
        for (var _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {
          var m = paramOrPropertyMetadata_1[_i];
          if (m.key === metadata.key) {
            throw new Error(ERROR_MSGS.DUPLICATED_METADATA + " " + m.key.toString());
          }
        }
      }
      paramOrPropertyMetadata.push(metadata);
      paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;
      Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
    }
    function _decorate(decorators, target) {
      Reflect.decorate(decorators, target);
    }
    function _param(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    }
    function decorate(decorator, target, parameterIndex) {
      if (typeof parameterIndex === "number") {
        _decorate([_param(parameterIndex, decorator)], target);
      } else if (typeof parameterIndex === "string") {
        Reflect.decorate([decorator], target, parameterIndex);
      } else {
        _decorate([decorator], target);
      }
    }
    exports.decorate = decorate;
  }
});

// node_modules/inversify/lib/annotation/inject.js
var require_inject = __commonJS({
  "node_modules/inversify/lib/annotation/inject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.inject = exports.LazyServiceIdentifer = void 0;
    var error_msgs_1 = require_error_msgs();
    var METADATA_KEY = require_metadata_keys();
    var metadata_1 = require_metadata();
    var decorator_utils_1 = require_decorator_utils();
    var LazyServiceIdentifer = function() {
      function LazyServiceIdentifer2(cb) {
        this._cb = cb;
      }
      LazyServiceIdentifer2.prototype.unwrap = function() {
        return this._cb();
      };
      return LazyServiceIdentifer2;
    }();
    exports.LazyServiceIdentifer = LazyServiceIdentifer;
    function inject2(serviceIdentifier) {
      return function(target, targetKey, index2) {
        if (serviceIdentifier === void 0) {
          throw new Error(error_msgs_1.UNDEFINED_INJECT_ANNOTATION(target.name));
        }
        var metadata = new metadata_1.Metadata(METADATA_KEY.INJECT_TAG, serviceIdentifier);
        if (typeof index2 === "number") {
          decorator_utils_1.tagParameter(target, targetKey, index2, metadata);
        } else {
          decorator_utils_1.tagProperty(target, targetKey, metadata);
        }
      };
    }
    exports.inject = inject2;
  }
});

// node_modules/inversify/lib/planning/queryable_string.js
var require_queryable_string = __commonJS({
  "node_modules/inversify/lib/planning/queryable_string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryableString = void 0;
    var QueryableString = function() {
      function QueryableString2(str) {
        this.str = str;
      }
      QueryableString2.prototype.startsWith = function(searchString) {
        return this.str.indexOf(searchString) === 0;
      };
      QueryableString2.prototype.endsWith = function(searchString) {
        var reverseString = "";
        var reverseSearchString = searchString.split("").reverse().join("");
        reverseString = this.str.split("").reverse().join("");
        return this.startsWith.call({ str: reverseString }, reverseSearchString);
      };
      QueryableString2.prototype.contains = function(searchString) {
        return this.str.indexOf(searchString) !== -1;
      };
      QueryableString2.prototype.equals = function(compareString) {
        return this.str === compareString;
      };
      QueryableString2.prototype.value = function() {
        return this.str;
      };
      return QueryableString2;
    }();
    exports.QueryableString = QueryableString;
  }
});

// node_modules/inversify/lib/planning/target.js
var require_target = __commonJS({
  "node_modules/inversify/lib/planning/target.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Target = void 0;
    var METADATA_KEY = require_metadata_keys();
    var id_1 = require_id();
    var metadata_1 = require_metadata();
    var queryable_string_1 = require_queryable_string();
    var Target = function() {
      function Target2(type, name, serviceIdentifier, namedOrTagged) {
        this.id = id_1.id();
        this.type = type;
        this.serviceIdentifier = serviceIdentifier;
        this.name = new queryable_string_1.QueryableString(name || "");
        this.metadata = new Array();
        var metadataItem = null;
        if (typeof namedOrTagged === "string") {
          metadataItem = new metadata_1.Metadata(METADATA_KEY.NAMED_TAG, namedOrTagged);
        } else if (namedOrTagged instanceof metadata_1.Metadata) {
          metadataItem = namedOrTagged;
        }
        if (metadataItem !== null) {
          this.metadata.push(metadataItem);
        }
      }
      Target2.prototype.hasTag = function(key) {
        for (var _i = 0, _a4 = this.metadata; _i < _a4.length; _i++) {
          var m = _a4[_i];
          if (m.key === key) {
            return true;
          }
        }
        return false;
      };
      Target2.prototype.isArray = function() {
        return this.hasTag(METADATA_KEY.MULTI_INJECT_TAG);
      };
      Target2.prototype.matchesArray = function(name) {
        return this.matchesTag(METADATA_KEY.MULTI_INJECT_TAG)(name);
      };
      Target2.prototype.isNamed = function() {
        return this.hasTag(METADATA_KEY.NAMED_TAG);
      };
      Target2.prototype.isTagged = function() {
        return this.metadata.some(function(metadata) {
          return METADATA_KEY.NON_CUSTOM_TAG_KEYS.every(function(key) {
            return metadata.key !== key;
          });
        });
      };
      Target2.prototype.isOptional = function() {
        return this.matchesTag(METADATA_KEY.OPTIONAL_TAG)(true);
      };
      Target2.prototype.getNamedTag = function() {
        if (this.isNamed()) {
          return this.metadata.filter(function(m) {
            return m.key === METADATA_KEY.NAMED_TAG;
          })[0];
        }
        return null;
      };
      Target2.prototype.getCustomTags = function() {
        if (this.isTagged()) {
          return this.metadata.filter(function(metadata) {
            return METADATA_KEY.NON_CUSTOM_TAG_KEYS.every(function(key) {
              return metadata.key !== key;
            });
          });
        } else {
          return null;
        }
      };
      Target2.prototype.matchesNamedTag = function(name) {
        return this.matchesTag(METADATA_KEY.NAMED_TAG)(name);
      };
      Target2.prototype.matchesTag = function(key) {
        var _this = this;
        return function(value) {
          for (var _i = 0, _a4 = _this.metadata; _i < _a4.length; _i++) {
            var m = _a4[_i];
            if (m.key === key && m.value === value) {
              return true;
            }
          }
          return false;
        };
      };
      return Target2;
    }();
    exports.Target = Target;
  }
});

// node_modules/inversify/lib/planning/reflection_utils.js
var require_reflection_utils = __commonJS({
  "node_modules/inversify/lib/planning/reflection_utils.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFunctionName = exports.getBaseClassDependencyCount = exports.getDependencies = void 0;
    var inject_1 = require_inject();
    var ERROR_MSGS = require_error_msgs();
    var literal_types_1 = require_literal_types();
    var METADATA_KEY = require_metadata_keys();
    var serialization_1 = require_serialization();
    Object.defineProperty(exports, "getFunctionName", { enumerable: true, get: function() {
      return serialization_1.getFunctionName;
    } });
    var target_1 = require_target();
    function getDependencies(metadataReader, func) {
      var constructorName = serialization_1.getFunctionName(func);
      var targets = getTargets(metadataReader, constructorName, func, false);
      return targets;
    }
    exports.getDependencies = getDependencies;
    function getTargets(metadataReader, constructorName, func, isBaseClass) {
      var metadata = metadataReader.getConstructorMetadata(func);
      var serviceIdentifiers = metadata.compilerGeneratedMetadata;
      if (serviceIdentifiers === void 0) {
        var msg = ERROR_MSGS.MISSING_INJECTABLE_ANNOTATION + " " + constructorName + ".";
        throw new Error(msg);
      }
      var constructorArgsMetadata = metadata.userGeneratedMetadata;
      var keys = Object.keys(constructorArgsMetadata);
      var hasUserDeclaredUnknownInjections = func.length === 0 && keys.length > 0;
      var hasOptionalParameters = keys.length > func.length;
      var iterations = hasUserDeclaredUnknownInjections || hasOptionalParameters ? keys.length : func.length;
      var constructorTargets = getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations);
      var propertyTargets = getClassPropsAsTargets(metadataReader, func);
      var targets = __spreadArray(__spreadArray([], constructorTargets), propertyTargets);
      return targets;
    }
    function getConstructorArgsAsTarget(index2, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata) {
      var targetMetadata = constructorArgsMetadata[index2.toString()] || [];
      var metadata = formatTargetMetadata(targetMetadata);
      var isManaged = metadata.unmanaged !== true;
      var serviceIdentifier = serviceIdentifiers[index2];
      var injectIdentifier = metadata.inject || metadata.multiInject;
      serviceIdentifier = injectIdentifier ? injectIdentifier : serviceIdentifier;
      if (serviceIdentifier instanceof inject_1.LazyServiceIdentifer) {
        serviceIdentifier = serviceIdentifier.unwrap();
      }
      if (isManaged) {
        var isObject = serviceIdentifier === Object;
        var isFunction = serviceIdentifier === Function;
        var isUndefined = serviceIdentifier === void 0;
        var isUnknownType = isObject || isFunction || isUndefined;
        if (!isBaseClass && isUnknownType) {
          var msg = ERROR_MSGS.MISSING_INJECT_ANNOTATION + " argument " + index2 + " in class " + constructorName + ".";
          throw new Error(msg);
        }
        var target = new target_1.Target(literal_types_1.TargetTypeEnum.ConstructorArgument, metadata.targetName, serviceIdentifier);
        target.metadata = targetMetadata;
        return target;
      }
      return null;
    }
    function getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations) {
      var targets = [];
      for (var i = 0; i < iterations; i++) {
        var index2 = i;
        var target = getConstructorArgsAsTarget(index2, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata);
        if (target !== null) {
          targets.push(target);
        }
      }
      return targets;
    }
    function getClassPropsAsTargets(metadataReader, constructorFunc) {
      var classPropsMetadata = metadataReader.getPropertiesMetadata(constructorFunc);
      var targets = [];
      var keys = Object.keys(classPropsMetadata);
      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        var targetMetadata = classPropsMetadata[key];
        var metadata = formatTargetMetadata(classPropsMetadata[key]);
        var targetName = metadata.targetName || key;
        var serviceIdentifier = metadata.inject || metadata.multiInject;
        var target = new target_1.Target(literal_types_1.TargetTypeEnum.ClassProperty, targetName, serviceIdentifier);
        target.metadata = targetMetadata;
        targets.push(target);
      }
      var baseConstructor = Object.getPrototypeOf(constructorFunc.prototype).constructor;
      if (baseConstructor !== Object) {
        var baseTargets = getClassPropsAsTargets(metadataReader, baseConstructor);
        targets = __spreadArray(__spreadArray([], targets), baseTargets);
      }
      return targets;
    }
    function getBaseClassDependencyCount(metadataReader, func) {
      var baseConstructor = Object.getPrototypeOf(func.prototype).constructor;
      if (baseConstructor !== Object) {
        var baseConstructorName = serialization_1.getFunctionName(baseConstructor);
        var targets = getTargets(metadataReader, baseConstructorName, baseConstructor, true);
        var metadata = targets.map(function(t) {
          return t.metadata.filter(function(m) {
            return m.key === METADATA_KEY.UNMANAGED_TAG;
          });
        });
        var unmanagedCount = [].concat.apply([], metadata).length;
        var dependencyCount = targets.length - unmanagedCount;
        if (dependencyCount > 0) {
          return dependencyCount;
        } else {
          return getBaseClassDependencyCount(metadataReader, baseConstructor);
        }
      } else {
        return 0;
      }
    }
    exports.getBaseClassDependencyCount = getBaseClassDependencyCount;
    function formatTargetMetadata(targetMetadata) {
      var targetMetadataMap = {};
      targetMetadata.forEach(function(m) {
        targetMetadataMap[m.key.toString()] = m.value;
      });
      return {
        inject: targetMetadataMap[METADATA_KEY.INJECT_TAG],
        multiInject: targetMetadataMap[METADATA_KEY.MULTI_INJECT_TAG],
        targetName: targetMetadataMap[METADATA_KEY.NAME_TAG],
        unmanaged: targetMetadataMap[METADATA_KEY.UNMANAGED_TAG]
      };
    }
  }
});

// node_modules/inversify/lib/planning/request.js
var require_request = __commonJS({
  "node_modules/inversify/lib/planning/request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Request = void 0;
    var id_1 = require_id();
    var Request2 = function() {
      function Request3(serviceIdentifier, parentContext, parentRequest, bindings, target) {
        this.id = id_1.id();
        this.serviceIdentifier = serviceIdentifier;
        this.parentContext = parentContext;
        this.parentRequest = parentRequest;
        this.target = target;
        this.childRequests = [];
        this.bindings = Array.isArray(bindings) ? bindings : [bindings];
        this.requestScope = parentRequest === null ? /* @__PURE__ */ new Map() : null;
      }
      Request3.prototype.addChildRequest = function(serviceIdentifier, bindings, target) {
        var child = new Request3(serviceIdentifier, this.parentContext, this, bindings, target);
        this.childRequests.push(child);
        return child;
      };
      return Request3;
    }();
    exports.Request = Request2;
  }
});

// node_modules/inversify/lib/planning/planner.js
var require_planner = __commonJS({
  "node_modules/inversify/lib/planning/planner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBindingDictionary = exports.createMockRequest = exports.plan = void 0;
    var binding_count_1 = require_binding_count();
    var ERROR_MSGS = require_error_msgs();
    var literal_types_1 = require_literal_types();
    var METADATA_KEY = require_metadata_keys();
    var exceptions_1 = require_exceptions();
    var serialization_1 = require_serialization();
    var context_1 = require_context();
    var metadata_1 = require_metadata();
    var plan_1 = require_plan();
    var reflection_utils_1 = require_reflection_utils();
    var request_1 = require_request();
    var target_1 = require_target();
    function getBindingDictionary(cntnr) {
      return cntnr._bindingDictionary;
    }
    exports.getBindingDictionary = getBindingDictionary;
    function _createTarget(isMultiInject, targetType, serviceIdentifier, name, key, value) {
      var metadataKey = isMultiInject ? METADATA_KEY.MULTI_INJECT_TAG : METADATA_KEY.INJECT_TAG;
      var injectMetadata = new metadata_1.Metadata(metadataKey, serviceIdentifier);
      var target = new target_1.Target(targetType, name, serviceIdentifier, injectMetadata);
      if (key !== void 0) {
        var tagMetadata = new metadata_1.Metadata(key, value);
        target.metadata.push(tagMetadata);
      }
      return target;
    }
    function _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {
      var bindings = getBindings(context.container, target.serviceIdentifier);
      var activeBindings = [];
      if (bindings.length === binding_count_1.BindingCount.NoBindingsAvailable && context.container.options.autoBindInjectable && typeof target.serviceIdentifier === "function" && metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata) {
        context.container.bind(target.serviceIdentifier).toSelf();
        bindings = getBindings(context.container, target.serviceIdentifier);
      }
      if (!avoidConstraints) {
        activeBindings = bindings.filter(function(binding) {
          var request = new request_1.Request(binding.serviceIdentifier, context, parentRequest, binding, target);
          return binding.constraint(request);
        });
      } else {
        activeBindings = bindings;
      }
      _validateActiveBindingCount(target.serviceIdentifier, activeBindings, target, context.container);
      return activeBindings;
    }
    function _validateActiveBindingCount(serviceIdentifier, bindings, target, container2) {
      switch (bindings.length) {
        case binding_count_1.BindingCount.NoBindingsAvailable:
          if (target.isOptional()) {
            return bindings;
          } else {
            var serviceIdentifierString = serialization_1.getServiceIdentifierAsString(serviceIdentifier);
            var msg = ERROR_MSGS.NOT_REGISTERED;
            msg += serialization_1.listMetadataForTarget(serviceIdentifierString, target);
            msg += serialization_1.listRegisteredBindingsForServiceIdentifier(container2, serviceIdentifierString, getBindings);
            throw new Error(msg);
          }
        case binding_count_1.BindingCount.OnlyOneBindingAvailable:
          if (!target.isArray()) {
            return bindings;
          }
        case binding_count_1.BindingCount.MultipleBindingsAvailable:
        default:
          if (!target.isArray()) {
            var serviceIdentifierString = serialization_1.getServiceIdentifierAsString(serviceIdentifier);
            var msg = ERROR_MSGS.AMBIGUOUS_MATCH + " " + serviceIdentifierString;
            msg += serialization_1.listRegisteredBindingsForServiceIdentifier(container2, serviceIdentifierString, getBindings);
            throw new Error(msg);
          } else {
            return bindings;
          }
      }
    }
    function _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {
      var activeBindings;
      var childRequest;
      if (parentRequest === null) {
        activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target);
        childRequest = new request_1.Request(serviceIdentifier, context, null, activeBindings, target);
        var thePlan = new plan_1.Plan(context, childRequest);
        context.addPlan(thePlan);
      } else {
        activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target);
        childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target);
      }
      activeBindings.forEach(function(binding) {
        var subChildRequest = null;
        if (target.isArray()) {
          subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);
        } else {
          if (binding.cache) {
            return;
          }
          subChildRequest = childRequest;
        }
        if (binding.type === literal_types_1.BindingTypeEnum.Instance && binding.implementationType !== null) {
          var dependencies = reflection_utils_1.getDependencies(metadataReader, binding.implementationType);
          if (!context.container.options.skipBaseClassChecks) {
            var baseClassDependencyCount = reflection_utils_1.getBaseClassDependencyCount(metadataReader, binding.implementationType);
            if (dependencies.length < baseClassDependencyCount) {
              var error = ERROR_MSGS.ARGUMENTS_LENGTH_MISMATCH(reflection_utils_1.getFunctionName(binding.implementationType));
              throw new Error(error);
            }
          }
          dependencies.forEach(function(dependency) {
            _createSubRequests(metadataReader, false, dependency.serviceIdentifier, context, subChildRequest, dependency);
          });
        }
      });
    }
    function getBindings(container2, serviceIdentifier) {
      var bindings = [];
      var bindingDictionary = getBindingDictionary(container2);
      if (bindingDictionary.hasKey(serviceIdentifier)) {
        bindings = bindingDictionary.get(serviceIdentifier);
      } else if (container2.parent !== null) {
        bindings = getBindings(container2.parent, serviceIdentifier);
      }
      return bindings;
    }
    function plan(metadataReader, container2, isMultiInject, targetType, serviceIdentifier, key, value, avoidConstraints) {
      if (avoidConstraints === void 0) {
        avoidConstraints = false;
      }
      var context = new context_1.Context(container2);
      var target = _createTarget(isMultiInject, targetType, serviceIdentifier, "", key, value);
      try {
        _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target);
        return context;
      } catch (error) {
        if (exceptions_1.isStackOverflowExeption(error)) {
          if (context.plan) {
            serialization_1.circularDependencyToException(context.plan.rootRequest);
          }
        }
        throw error;
      }
    }
    exports.plan = plan;
    function createMockRequest(container2, serviceIdentifier, key, value) {
      var target = new target_1.Target(literal_types_1.TargetTypeEnum.Variable, "", serviceIdentifier, new metadata_1.Metadata(key, value));
      var context = new context_1.Context(container2);
      var request = new request_1.Request(serviceIdentifier, context, null, [], target);
      return request;
    }
    exports.createMockRequest = createMockRequest;
  }
});

// node_modules/inversify/lib/resolution/instantiation.js
var require_instantiation = __commonJS({
  "node_modules/inversify/lib/resolution/instantiation.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveInstance = void 0;
    var error_msgs_1 = require_error_msgs();
    var literal_types_1 = require_literal_types();
    var METADATA_KEY = require_metadata_keys();
    function _injectProperties(instance, childRequests, resolveRequest) {
      var propertyInjectionsRequests = childRequests.filter(function(childRequest) {
        return childRequest.target !== null && childRequest.target.type === literal_types_1.TargetTypeEnum.ClassProperty;
      });
      var propertyInjections = propertyInjectionsRequests.map(resolveRequest);
      propertyInjectionsRequests.forEach(function(r, index2) {
        var propertyName = "";
        propertyName = r.target.name.value();
        var injection = propertyInjections[index2];
        instance[propertyName] = injection;
      });
      return instance;
    }
    function _createInstance(Func, injections) {
      return new (Func.bind.apply(Func, __spreadArray([void 0], injections)))();
    }
    function _postConstruct(constr, result) {
      if (Reflect.hasMetadata(METADATA_KEY.POST_CONSTRUCT, constr)) {
        var data = Reflect.getMetadata(METADATA_KEY.POST_CONSTRUCT, constr);
        try {
          result[data.value]();
        } catch (e) {
          throw new Error(error_msgs_1.POST_CONSTRUCT_ERROR(constr.name, e.message));
        }
      }
    }
    function resolveInstance(constr, childRequests, resolveRequest) {
      var result = null;
      if (childRequests.length > 0) {
        var constructorInjectionsRequests = childRequests.filter(function(childRequest) {
          return childRequest.target !== null && childRequest.target.type === literal_types_1.TargetTypeEnum.ConstructorArgument;
        });
        var constructorInjections = constructorInjectionsRequests.map(resolveRequest);
        result = _createInstance(constr, constructorInjections);
        result = _injectProperties(result, childRequests, resolveRequest);
      } else {
        result = new constr();
      }
      _postConstruct(constr, result);
      return result;
    }
    exports.resolveInstance = resolveInstance;
  }
});

// node_modules/inversify/lib/resolution/resolver.js
var require_resolver = __commonJS({
  "node_modules/inversify/lib/resolution/resolver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolve = void 0;
    var ERROR_MSGS = require_error_msgs();
    var literal_types_1 = require_literal_types();
    var exceptions_1 = require_exceptions();
    var serialization_1 = require_serialization();
    var instantiation_1 = require_instantiation();
    var invokeFactory = function(factoryType, serviceIdentifier, fn) {
      try {
        return fn();
      } catch (error) {
        if (exceptions_1.isStackOverflowExeption(error)) {
          throw new Error(ERROR_MSGS.CIRCULAR_DEPENDENCY_IN_FACTORY(factoryType, serviceIdentifier.toString()));
        } else {
          throw error;
        }
      }
    };
    var _resolveRequest = function(requestScope) {
      return function(request) {
        request.parentContext.setCurrentRequest(request);
        var bindings = request.bindings;
        var childRequests = request.childRequests;
        var targetIsAnArray = request.target && request.target.isArray();
        var targetParentIsNotAnArray = !request.parentRequest || !request.parentRequest.target || !request.target || !request.parentRequest.target.matchesArray(request.target.serviceIdentifier);
        if (targetIsAnArray && targetParentIsNotAnArray) {
          return childRequests.map(function(childRequest) {
            var _f = _resolveRequest(requestScope);
            return _f(childRequest);
          });
        } else {
          var result = null;
          if (request.target.isOptional() && bindings.length === 0) {
            return void 0;
          }
          var binding_1 = bindings[0];
          var isSingleton = binding_1.scope === literal_types_1.BindingScopeEnum.Singleton;
          var isRequestSingleton = binding_1.scope === literal_types_1.BindingScopeEnum.Request;
          if (isSingleton && binding_1.activated) {
            return binding_1.cache;
          }
          if (isRequestSingleton && requestScope !== null && requestScope.has(binding_1.id)) {
            return requestScope.get(binding_1.id);
          }
          if (binding_1.type === literal_types_1.BindingTypeEnum.ConstantValue) {
            result = binding_1.cache;
            binding_1.activated = true;
          } else if (binding_1.type === literal_types_1.BindingTypeEnum.Function) {
            result = binding_1.cache;
            binding_1.activated = true;
          } else if (binding_1.type === literal_types_1.BindingTypeEnum.Constructor) {
            result = binding_1.implementationType;
          } else if (binding_1.type === literal_types_1.BindingTypeEnum.DynamicValue && binding_1.dynamicValue !== null) {
            result = invokeFactory("toDynamicValue", binding_1.serviceIdentifier, function() {
              return binding_1.dynamicValue(request.parentContext);
            });
          } else if (binding_1.type === literal_types_1.BindingTypeEnum.Factory && binding_1.factory !== null) {
            result = invokeFactory("toFactory", binding_1.serviceIdentifier, function() {
              return binding_1.factory(request.parentContext);
            });
          } else if (binding_1.type === literal_types_1.BindingTypeEnum.Provider && binding_1.provider !== null) {
            result = invokeFactory("toProvider", binding_1.serviceIdentifier, function() {
              return binding_1.provider(request.parentContext);
            });
          } else if (binding_1.type === literal_types_1.BindingTypeEnum.Instance && binding_1.implementationType !== null) {
            result = instantiation_1.resolveInstance(binding_1.implementationType, childRequests, _resolveRequest(requestScope));
          } else {
            var serviceIdentifier = serialization_1.getServiceIdentifierAsString(request.serviceIdentifier);
            throw new Error(ERROR_MSGS.INVALID_BINDING_TYPE + " " + serviceIdentifier);
          }
          if (typeof binding_1.onActivation === "function") {
            result = binding_1.onActivation(request.parentContext, result);
          }
          if (isSingleton) {
            binding_1.cache = result;
            binding_1.activated = true;
          }
          if (isRequestSingleton && requestScope !== null && !requestScope.has(binding_1.id)) {
            requestScope.set(binding_1.id, result);
          }
          return result;
        }
      };
    };
    function resolve2(context) {
      var _f = _resolveRequest(context.plan.rootRequest.requestScope);
      return _f(context.plan.rootRequest);
    }
    exports.resolve = resolve2;
  }
});

// node_modules/inversify/lib/syntax/constraint_helpers.js
var require_constraint_helpers = __commonJS({
  "node_modules/inversify/lib/syntax/constraint_helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.typeConstraint = exports.namedConstraint = exports.taggedConstraint = exports.traverseAncerstors = void 0;
    var METADATA_KEY = require_metadata_keys();
    var metadata_1 = require_metadata();
    var traverseAncerstors = function(request, constraint) {
      var parent = request.parentRequest;
      if (parent !== null) {
        return constraint(parent) ? true : traverseAncerstors(parent, constraint);
      } else {
        return false;
      }
    };
    exports.traverseAncerstors = traverseAncerstors;
    var taggedConstraint = function(key) {
      return function(value) {
        var constraint = function(request) {
          return request !== null && request.target !== null && request.target.matchesTag(key)(value);
        };
        constraint.metaData = new metadata_1.Metadata(key, value);
        return constraint;
      };
    };
    exports.taggedConstraint = taggedConstraint;
    var namedConstraint = taggedConstraint(METADATA_KEY.NAMED_TAG);
    exports.namedConstraint = namedConstraint;
    var typeConstraint = function(type) {
      return function(request) {
        var binding = null;
        if (request !== null) {
          binding = request.bindings[0];
          if (typeof type === "string") {
            var serviceIdentifier = binding.serviceIdentifier;
            return serviceIdentifier === type;
          } else {
            var constructor = request.bindings[0].implementationType;
            return type === constructor;
          }
        }
        return false;
      };
    };
    exports.typeConstraint = typeConstraint;
  }
});

// node_modules/inversify/lib/syntax/binding_when_syntax.js
var require_binding_when_syntax = __commonJS({
  "node_modules/inversify/lib/syntax/binding_when_syntax.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindingWhenSyntax = void 0;
    var binding_on_syntax_1 = require_binding_on_syntax();
    var constraint_helpers_1 = require_constraint_helpers();
    var BindingWhenSyntax = function() {
      function BindingWhenSyntax2(binding) {
        this._binding = binding;
      }
      BindingWhenSyntax2.prototype.when = function(constraint) {
        this._binding.constraint = constraint;
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenTargetNamed = function(name) {
        this._binding.constraint = constraint_helpers_1.namedConstraint(name);
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenTargetIsDefault = function() {
        this._binding.constraint = function(request) {
          var targetIsDefault = request.target !== null && !request.target.isNamed() && !request.target.isTagged();
          return targetIsDefault;
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenTargetTagged = function(tag, value) {
        this._binding.constraint = constraint_helpers_1.taggedConstraint(tag)(value);
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenInjectedInto = function(parent) {
        this._binding.constraint = function(request) {
          return constraint_helpers_1.typeConstraint(parent)(request.parentRequest);
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenParentNamed = function(name) {
        this._binding.constraint = function(request) {
          return constraint_helpers_1.namedConstraint(name)(request.parentRequest);
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenParentTagged = function(tag, value) {
        this._binding.constraint = function(request) {
          return constraint_helpers_1.taggedConstraint(tag)(value)(request.parentRequest);
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
        this._binding.constraint = function(request) {
          return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.typeConstraint(ancestor));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
        this._binding.constraint = function(request) {
          return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.typeConstraint(ancestor));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenAnyAncestorNamed = function(name) {
        this._binding.constraint = function(request) {
          return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.namedConstraint(name));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenNoAncestorNamed = function(name) {
        this._binding.constraint = function(request) {
          return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.namedConstraint(name));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
        this._binding.constraint = function(request) {
          return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.taggedConstraint(tag)(value));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
        this._binding.constraint = function(request) {
          return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.taggedConstraint(tag)(value));
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
        this._binding.constraint = function(request) {
          return constraint_helpers_1.traverseAncerstors(request, constraint);
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
        this._binding.constraint = function(request) {
          return !constraint_helpers_1.traverseAncerstors(request, constraint);
        };
        return new binding_on_syntax_1.BindingOnSyntax(this._binding);
      };
      return BindingWhenSyntax2;
    }();
    exports.BindingWhenSyntax = BindingWhenSyntax;
  }
});

// node_modules/inversify/lib/syntax/binding_on_syntax.js
var require_binding_on_syntax = __commonJS({
  "node_modules/inversify/lib/syntax/binding_on_syntax.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindingOnSyntax = void 0;
    var binding_when_syntax_1 = require_binding_when_syntax();
    var BindingOnSyntax = function() {
      function BindingOnSyntax2(binding) {
        this._binding = binding;
      }
      BindingOnSyntax2.prototype.onActivation = function(handler) {
        this._binding.onActivation = handler;
        return new binding_when_syntax_1.BindingWhenSyntax(this._binding);
      };
      return BindingOnSyntax2;
    }();
    exports.BindingOnSyntax = BindingOnSyntax;
  }
});

// node_modules/inversify/lib/syntax/binding_when_on_syntax.js
var require_binding_when_on_syntax = __commonJS({
  "node_modules/inversify/lib/syntax/binding_when_on_syntax.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindingWhenOnSyntax = void 0;
    var binding_on_syntax_1 = require_binding_on_syntax();
    var binding_when_syntax_1 = require_binding_when_syntax();
    var BindingWhenOnSyntax = function() {
      function BindingWhenOnSyntax2(binding) {
        this._binding = binding;
        this._bindingWhenSyntax = new binding_when_syntax_1.BindingWhenSyntax(this._binding);
        this._bindingOnSyntax = new binding_on_syntax_1.BindingOnSyntax(this._binding);
      }
      BindingWhenOnSyntax2.prototype.when = function(constraint) {
        return this._bindingWhenSyntax.when(constraint);
      };
      BindingWhenOnSyntax2.prototype.whenTargetNamed = function(name) {
        return this._bindingWhenSyntax.whenTargetNamed(name);
      };
      BindingWhenOnSyntax2.prototype.whenTargetIsDefault = function() {
        return this._bindingWhenSyntax.whenTargetIsDefault();
      };
      BindingWhenOnSyntax2.prototype.whenTargetTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenTargetTagged(tag, value);
      };
      BindingWhenOnSyntax2.prototype.whenInjectedInto = function(parent) {
        return this._bindingWhenSyntax.whenInjectedInto(parent);
      };
      BindingWhenOnSyntax2.prototype.whenParentNamed = function(name) {
        return this._bindingWhenSyntax.whenParentNamed(name);
      };
      BindingWhenOnSyntax2.prototype.whenParentTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenParentTagged(tag, value);
      };
      BindingWhenOnSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
      };
      BindingWhenOnSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
      };
      BindingWhenOnSyntax2.prototype.whenAnyAncestorNamed = function(name) {
        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
      };
      BindingWhenOnSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
      };
      BindingWhenOnSyntax2.prototype.whenNoAncestorNamed = function(name) {
        return this._bindingWhenSyntax.whenNoAncestorNamed(name);
      };
      BindingWhenOnSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
      };
      BindingWhenOnSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
      };
      BindingWhenOnSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
      };
      BindingWhenOnSyntax2.prototype.onActivation = function(handler) {
        return this._bindingOnSyntax.onActivation(handler);
      };
      return BindingWhenOnSyntax2;
    }();
    exports.BindingWhenOnSyntax = BindingWhenOnSyntax;
  }
});

// node_modules/inversify/lib/syntax/binding_in_syntax.js
var require_binding_in_syntax = __commonJS({
  "node_modules/inversify/lib/syntax/binding_in_syntax.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindingInSyntax = void 0;
    var literal_types_1 = require_literal_types();
    var binding_when_on_syntax_1 = require_binding_when_on_syntax();
    var BindingInSyntax = function() {
      function BindingInSyntax2(binding) {
        this._binding = binding;
      }
      BindingInSyntax2.prototype.inRequestScope = function() {
        this._binding.scope = literal_types_1.BindingScopeEnum.Request;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
      };
      BindingInSyntax2.prototype.inSingletonScope = function() {
        this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
      };
      BindingInSyntax2.prototype.inTransientScope = function() {
        this._binding.scope = literal_types_1.BindingScopeEnum.Transient;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
      };
      return BindingInSyntax2;
    }();
    exports.BindingInSyntax = BindingInSyntax;
  }
});

// node_modules/inversify/lib/syntax/binding_in_when_on_syntax.js
var require_binding_in_when_on_syntax = __commonJS({
  "node_modules/inversify/lib/syntax/binding_in_when_on_syntax.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindingInWhenOnSyntax = void 0;
    var binding_in_syntax_1 = require_binding_in_syntax();
    var binding_on_syntax_1 = require_binding_on_syntax();
    var binding_when_syntax_1 = require_binding_when_syntax();
    var BindingInWhenOnSyntax = function() {
      function BindingInWhenOnSyntax2(binding) {
        this._binding = binding;
        this._bindingWhenSyntax = new binding_when_syntax_1.BindingWhenSyntax(this._binding);
        this._bindingOnSyntax = new binding_on_syntax_1.BindingOnSyntax(this._binding);
        this._bindingInSyntax = new binding_in_syntax_1.BindingInSyntax(binding);
      }
      BindingInWhenOnSyntax2.prototype.inRequestScope = function() {
        return this._bindingInSyntax.inRequestScope();
      };
      BindingInWhenOnSyntax2.prototype.inSingletonScope = function() {
        return this._bindingInSyntax.inSingletonScope();
      };
      BindingInWhenOnSyntax2.prototype.inTransientScope = function() {
        return this._bindingInSyntax.inTransientScope();
      };
      BindingInWhenOnSyntax2.prototype.when = function(constraint) {
        return this._bindingWhenSyntax.when(constraint);
      };
      BindingInWhenOnSyntax2.prototype.whenTargetNamed = function(name) {
        return this._bindingWhenSyntax.whenTargetNamed(name);
      };
      BindingInWhenOnSyntax2.prototype.whenTargetIsDefault = function() {
        return this._bindingWhenSyntax.whenTargetIsDefault();
      };
      BindingInWhenOnSyntax2.prototype.whenTargetTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenTargetTagged(tag, value);
      };
      BindingInWhenOnSyntax2.prototype.whenInjectedInto = function(parent) {
        return this._bindingWhenSyntax.whenInjectedInto(parent);
      };
      BindingInWhenOnSyntax2.prototype.whenParentNamed = function(name) {
        return this._bindingWhenSyntax.whenParentNamed(name);
      };
      BindingInWhenOnSyntax2.prototype.whenParentTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenParentTagged(tag, value);
      };
      BindingInWhenOnSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
      };
      BindingInWhenOnSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
      };
      BindingInWhenOnSyntax2.prototype.whenAnyAncestorNamed = function(name) {
        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
      };
      BindingInWhenOnSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
      };
      BindingInWhenOnSyntax2.prototype.whenNoAncestorNamed = function(name) {
        return this._bindingWhenSyntax.whenNoAncestorNamed(name);
      };
      BindingInWhenOnSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
      };
      BindingInWhenOnSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
      };
      BindingInWhenOnSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
      };
      BindingInWhenOnSyntax2.prototype.onActivation = function(handler) {
        return this._bindingOnSyntax.onActivation(handler);
      };
      return BindingInWhenOnSyntax2;
    }();
    exports.BindingInWhenOnSyntax = BindingInWhenOnSyntax;
  }
});

// node_modules/inversify/lib/syntax/binding_to_syntax.js
var require_binding_to_syntax = __commonJS({
  "node_modules/inversify/lib/syntax/binding_to_syntax.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindingToSyntax = void 0;
    var ERROR_MSGS = require_error_msgs();
    var literal_types_1 = require_literal_types();
    var binding_in_when_on_syntax_1 = require_binding_in_when_on_syntax();
    var binding_when_on_syntax_1 = require_binding_when_on_syntax();
    var BindingToSyntax = function() {
      function BindingToSyntax2(binding) {
        this._binding = binding;
      }
      BindingToSyntax2.prototype.to = function(constructor) {
        this._binding.type = literal_types_1.BindingTypeEnum.Instance;
        this._binding.implementationType = constructor;
        return new binding_in_when_on_syntax_1.BindingInWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toSelf = function() {
        if (typeof this._binding.serviceIdentifier !== "function") {
          throw new Error("" + ERROR_MSGS.INVALID_TO_SELF_VALUE);
        }
        var self2 = this._binding.serviceIdentifier;
        return this.to(self2);
      };
      BindingToSyntax2.prototype.toConstantValue = function(value) {
        this._binding.type = literal_types_1.BindingTypeEnum.ConstantValue;
        this._binding.cache = value;
        this._binding.dynamicValue = null;
        this._binding.implementationType = null;
        this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toDynamicValue = function(func) {
        this._binding.type = literal_types_1.BindingTypeEnum.DynamicValue;
        this._binding.cache = null;
        this._binding.dynamicValue = func;
        this._binding.implementationType = null;
        return new binding_in_when_on_syntax_1.BindingInWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toConstructor = function(constructor) {
        this._binding.type = literal_types_1.BindingTypeEnum.Constructor;
        this._binding.implementationType = constructor;
        this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toFactory = function(factory) {
        this._binding.type = literal_types_1.BindingTypeEnum.Factory;
        this._binding.factory = factory;
        this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toFunction = function(func) {
        if (typeof func !== "function") {
          throw new Error(ERROR_MSGS.INVALID_FUNCTION_BINDING);
        }
        var bindingWhenOnSyntax = this.toConstantValue(func);
        this._binding.type = literal_types_1.BindingTypeEnum.Function;
        this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
        return bindingWhenOnSyntax;
      };
      BindingToSyntax2.prototype.toAutoFactory = function(serviceIdentifier) {
        this._binding.type = literal_types_1.BindingTypeEnum.Factory;
        this._binding.factory = function(context) {
          var autofactory = function() {
            return context.container.get(serviceIdentifier);
          };
          return autofactory;
        };
        this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toProvider = function(provider) {
        this._binding.type = literal_types_1.BindingTypeEnum.Provider;
        this._binding.provider = provider;
        this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
        return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toService = function(service) {
        this.toDynamicValue(function(context) {
          return context.container.get(service);
        });
      };
      return BindingToSyntax2;
    }();
    exports.BindingToSyntax = BindingToSyntax;
  }
});

// node_modules/inversify/lib/container/container_snapshot.js
var require_container_snapshot = __commonJS({
  "node_modules/inversify/lib/container/container_snapshot.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContainerSnapshot = void 0;
    var ContainerSnapshot = function() {
      function ContainerSnapshot2() {
      }
      ContainerSnapshot2.of = function(bindings, middleware) {
        var snapshot = new ContainerSnapshot2();
        snapshot.bindings = bindings;
        snapshot.middleware = middleware;
        return snapshot;
      };
      return ContainerSnapshot2;
    }();
    exports.ContainerSnapshot = ContainerSnapshot;
  }
});

// node_modules/inversify/lib/container/lookup.js
var require_lookup = __commonJS({
  "node_modules/inversify/lib/container/lookup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Lookup = void 0;
    var ERROR_MSGS = require_error_msgs();
    var Lookup = function() {
      function Lookup2() {
        this._map = /* @__PURE__ */ new Map();
      }
      Lookup2.prototype.getMap = function() {
        return this._map;
      };
      Lookup2.prototype.add = function(serviceIdentifier, value) {
        if (serviceIdentifier === null || serviceIdentifier === void 0) {
          throw new Error(ERROR_MSGS.NULL_ARGUMENT);
        }
        if (value === null || value === void 0) {
          throw new Error(ERROR_MSGS.NULL_ARGUMENT);
        }
        var entry = this._map.get(serviceIdentifier);
        if (entry !== void 0) {
          entry.push(value);
          this._map.set(serviceIdentifier, entry);
        } else {
          this._map.set(serviceIdentifier, [value]);
        }
      };
      Lookup2.prototype.get = function(serviceIdentifier) {
        if (serviceIdentifier === null || serviceIdentifier === void 0) {
          throw new Error(ERROR_MSGS.NULL_ARGUMENT);
        }
        var entry = this._map.get(serviceIdentifier);
        if (entry !== void 0) {
          return entry;
        } else {
          throw new Error(ERROR_MSGS.KEY_NOT_FOUND);
        }
      };
      Lookup2.prototype.remove = function(serviceIdentifier) {
        if (serviceIdentifier === null || serviceIdentifier === void 0) {
          throw new Error(ERROR_MSGS.NULL_ARGUMENT);
        }
        if (!this._map.delete(serviceIdentifier)) {
          throw new Error(ERROR_MSGS.KEY_NOT_FOUND);
        }
      };
      Lookup2.prototype.removeByCondition = function(condition) {
        var _this = this;
        this._map.forEach(function(entries, key) {
          var updatedEntries = entries.filter(function(entry) {
            return !condition(entry);
          });
          if (updatedEntries.length > 0) {
            _this._map.set(key, updatedEntries);
          } else {
            _this._map.delete(key);
          }
        });
      };
      Lookup2.prototype.hasKey = function(serviceIdentifier) {
        if (serviceIdentifier === null || serviceIdentifier === void 0) {
          throw new Error(ERROR_MSGS.NULL_ARGUMENT);
        }
        return this._map.has(serviceIdentifier);
      };
      Lookup2.prototype.clone = function() {
        var copy2 = new Lookup2();
        this._map.forEach(function(value, key) {
          value.forEach(function(b) {
            return copy2.add(key, b.clone());
          });
        });
        return copy2;
      };
      Lookup2.prototype.traverse = function(func) {
        this._map.forEach(function(value, key) {
          func(key, value);
        });
      };
      return Lookup2;
    }();
    exports.Lookup = Lookup;
  }
});

// node_modules/inversify/lib/container/container.js
var require_container = __commonJS({
  "node_modules/inversify/lib/container/container.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Container = void 0;
    var binding_1 = require_binding();
    var ERROR_MSGS = require_error_msgs();
    var literal_types_1 = require_literal_types();
    var METADATA_KEY = require_metadata_keys();
    var metadata_reader_1 = require_metadata_reader();
    var planner_1 = require_planner();
    var resolver_1 = require_resolver();
    var binding_to_syntax_1 = require_binding_to_syntax();
    var id_1 = require_id();
    var serialization_1 = require_serialization();
    var container_snapshot_1 = require_container_snapshot();
    var lookup_1 = require_lookup();
    var Container2 = function() {
      function Container3(containerOptions) {
        this._appliedMiddleware = [];
        var options = containerOptions || {};
        if (typeof options !== "object") {
          throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT);
        }
        if (options.defaultScope === void 0) {
          options.defaultScope = literal_types_1.BindingScopeEnum.Transient;
        } else if (options.defaultScope !== literal_types_1.BindingScopeEnum.Singleton && options.defaultScope !== literal_types_1.BindingScopeEnum.Transient && options.defaultScope !== literal_types_1.BindingScopeEnum.Request) {
          throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE);
        }
        if (options.autoBindInjectable === void 0) {
          options.autoBindInjectable = false;
        } else if (typeof options.autoBindInjectable !== "boolean") {
          throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE);
        }
        if (options.skipBaseClassChecks === void 0) {
          options.skipBaseClassChecks = false;
        } else if (typeof options.skipBaseClassChecks !== "boolean") {
          throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK);
        }
        this.options = {
          autoBindInjectable: options.autoBindInjectable,
          defaultScope: options.defaultScope,
          skipBaseClassChecks: options.skipBaseClassChecks
        };
        this.id = id_1.id();
        this._bindingDictionary = new lookup_1.Lookup();
        this._snapshots = [];
        this._middleware = null;
        this.parent = null;
        this._metadataReader = new metadata_reader_1.MetadataReader();
      }
      Container3.merge = function(container1, container2) {
        var container3 = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          container3[_i - 2] = arguments[_i];
        }
        var container4 = new Container3();
        var targetContainers = __spreadArray([container1, container2], container3).map(function(targetContainer) {
          return planner_1.getBindingDictionary(targetContainer);
        });
        var bindingDictionary = planner_1.getBindingDictionary(container4);
        function copyDictionary(origin, destination) {
          origin.traverse(function(key, value) {
            value.forEach(function(binding) {
              destination.add(binding.serviceIdentifier, binding.clone());
            });
          });
        }
        targetContainers.forEach(function(targetBindingDictionary) {
          copyDictionary(targetBindingDictionary, bindingDictionary);
        });
        return container4;
      };
      Container3.prototype.load = function() {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          modules[_i] = arguments[_i];
        }
        var getHelpers = this._getContainerModuleHelpersFactory();
        for (var _a4 = 0, modules_1 = modules; _a4 < modules_1.length; _a4++) {
          var currentModule = modules_1[_a4];
          var containerModuleHelpers = getHelpers(currentModule.id);
          currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction);
        }
      };
      Container3.prototype.loadAsync = function() {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          modules[_i] = arguments[_i];
        }
        return __awaiter2(this, void 0, void 0, function() {
          var getHelpers, _a4, modules_2, currentModule, containerModuleHelpers;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                getHelpers = this._getContainerModuleHelpersFactory();
                _a4 = 0, modules_2 = modules;
                _b.label = 1;
              case 1:
                if (!(_a4 < modules_2.length))
                  return [3, 4];
                currentModule = modules_2[_a4];
                containerModuleHelpers = getHelpers(currentModule.id);
                return [4, currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction)];
              case 2:
                _b.sent();
                _b.label = 3;
              case 3:
                _a4++;
                return [3, 1];
              case 4:
                return [2];
            }
          });
        });
      };
      Container3.prototype.unload = function() {
        var _this = this;
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          modules[_i] = arguments[_i];
        }
        var conditionFactory = function(expected) {
          return function(item) {
            return item.moduleId === expected;
          };
        };
        modules.forEach(function(module3) {
          var condition = conditionFactory(module3.id);
          _this._bindingDictionary.removeByCondition(condition);
        });
      };
      Container3.prototype.bind = function(serviceIdentifier) {
        var scope = this.options.defaultScope || literal_types_1.BindingScopeEnum.Transient;
        var binding = new binding_1.Binding(serviceIdentifier, scope);
        this._bindingDictionary.add(serviceIdentifier, binding);
        return new binding_to_syntax_1.BindingToSyntax(binding);
      };
      Container3.prototype.rebind = function(serviceIdentifier) {
        this.unbind(serviceIdentifier);
        return this.bind(serviceIdentifier);
      };
      Container3.prototype.unbind = function(serviceIdentifier) {
        try {
          this._bindingDictionary.remove(serviceIdentifier);
        } catch (e) {
          throw new Error(ERROR_MSGS.CANNOT_UNBIND + " " + serialization_1.getServiceIdentifierAsString(serviceIdentifier));
        }
      };
      Container3.prototype.unbindAll = function() {
        this._bindingDictionary = new lookup_1.Lookup();
      };
      Container3.prototype.isBound = function(serviceIdentifier) {
        var bound = this._bindingDictionary.hasKey(serviceIdentifier);
        if (!bound && this.parent) {
          bound = this.parent.isBound(serviceIdentifier);
        }
        return bound;
      };
      Container3.prototype.isBoundNamed = function(serviceIdentifier, named) {
        return this.isBoundTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
      };
      Container3.prototype.isBoundTagged = function(serviceIdentifier, key, value) {
        var bound = false;
        if (this._bindingDictionary.hasKey(serviceIdentifier)) {
          var bindings = this._bindingDictionary.get(serviceIdentifier);
          var request_1 = planner_1.createMockRequest(this, serviceIdentifier, key, value);
          bound = bindings.some(function(b) {
            return b.constraint(request_1);
          });
        }
        if (!bound && this.parent) {
          bound = this.parent.isBoundTagged(serviceIdentifier, key, value);
        }
        return bound;
      };
      Container3.prototype.snapshot = function() {
        this._snapshots.push(container_snapshot_1.ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware));
      };
      Container3.prototype.restore = function() {
        var snapshot = this._snapshots.pop();
        if (snapshot === void 0) {
          throw new Error(ERROR_MSGS.NO_MORE_SNAPSHOTS_AVAILABLE);
        }
        this._bindingDictionary = snapshot.bindings;
        this._middleware = snapshot.middleware;
      };
      Container3.prototype.createChild = function(containerOptions) {
        var child = new Container3(containerOptions || this.options);
        child.parent = this;
        return child;
      };
      Container3.prototype.applyMiddleware = function() {
        var middlewares = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          middlewares[_i] = arguments[_i];
        }
        this._appliedMiddleware = this._appliedMiddleware.concat(middlewares);
        var initial = this._middleware ? this._middleware : this._planAndResolve();
        this._middleware = middlewares.reduce(function(prev, curr) {
          return curr(prev);
        }, initial);
      };
      Container3.prototype.applyCustomMetadataReader = function(metadataReader) {
        this._metadataReader = metadataReader;
      };
      Container3.prototype.get = function(serviceIdentifier) {
        return this._get(false, false, literal_types_1.TargetTypeEnum.Variable, serviceIdentifier);
      };
      Container3.prototype.getTagged = function(serviceIdentifier, key, value) {
        return this._get(false, false, literal_types_1.TargetTypeEnum.Variable, serviceIdentifier, key, value);
      };
      Container3.prototype.getNamed = function(serviceIdentifier, named) {
        return this.getTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
      };
      Container3.prototype.getAll = function(serviceIdentifier) {
        return this._get(true, true, literal_types_1.TargetTypeEnum.Variable, serviceIdentifier);
      };
      Container3.prototype.getAllTagged = function(serviceIdentifier, key, value) {
        return this._get(false, true, literal_types_1.TargetTypeEnum.Variable, serviceIdentifier, key, value);
      };
      Container3.prototype.getAllNamed = function(serviceIdentifier, named) {
        return this.getAllTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
      };
      Container3.prototype.resolve = function(constructorFunction) {
        var tempContainer = this.createChild();
        tempContainer.bind(constructorFunction).toSelf();
        this._appliedMiddleware.forEach(function(m) {
          tempContainer.applyMiddleware(m);
        });
        return tempContainer.get(constructorFunction);
      };
      Container3.prototype._getContainerModuleHelpersFactory = function() {
        var _this = this;
        var setModuleId = function(bindingToSyntax, moduleId) {
          bindingToSyntax._binding.moduleId = moduleId;
        };
        var getBindFunction = function(moduleId) {
          return function(serviceIdentifier) {
            var _bind = _this.bind.bind(_this);
            var bindingToSyntax = _bind(serviceIdentifier);
            setModuleId(bindingToSyntax, moduleId);
            return bindingToSyntax;
          };
        };
        var getUnbindFunction = function(moduleId) {
          return function(serviceIdentifier) {
            var _unbind = _this.unbind.bind(_this);
            _unbind(serviceIdentifier);
          };
        };
        var getIsboundFunction = function(moduleId) {
          return function(serviceIdentifier) {
            var _isBound = _this.isBound.bind(_this);
            return _isBound(serviceIdentifier);
          };
        };
        var getRebindFunction = function(moduleId) {
          return function(serviceIdentifier) {
            var _rebind = _this.rebind.bind(_this);
            var bindingToSyntax = _rebind(serviceIdentifier);
            setModuleId(bindingToSyntax, moduleId);
            return bindingToSyntax;
          };
        };
        return function(mId) {
          return {
            bindFunction: getBindFunction(mId),
            isboundFunction: getIsboundFunction(mId),
            rebindFunction: getRebindFunction(mId),
            unbindFunction: getUnbindFunction(mId)
          };
        };
      };
      Container3.prototype._get = function(avoidConstraints, isMultiInject, targetType, serviceIdentifier, key, value) {
        var result = null;
        var defaultArgs = {
          avoidConstraints,
          contextInterceptor: function(context) {
            return context;
          },
          isMultiInject,
          key,
          serviceIdentifier,
          targetType,
          value
        };
        if (this._middleware) {
          result = this._middleware(defaultArgs);
          if (result === void 0 || result === null) {
            throw new Error(ERROR_MSGS.INVALID_MIDDLEWARE_RETURN);
          }
        } else {
          result = this._planAndResolve()(defaultArgs);
        }
        return result;
      };
      Container3.prototype._planAndResolve = function() {
        var _this = this;
        return function(args) {
          var context = planner_1.plan(_this._metadataReader, _this, args.isMultiInject, args.targetType, args.serviceIdentifier, args.key, args.value, args.avoidConstraints);
          context = args.contextInterceptor(context);
          var result = resolver_1.resolve(context);
          return result;
        };
      };
      return Container3;
    }();
    exports.Container = Container2;
  }
});

// node_modules/inversify/lib/container/container_module.js
var require_container_module = __commonJS({
  "node_modules/inversify/lib/container/container_module.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncContainerModule = exports.ContainerModule = void 0;
    var id_1 = require_id();
    var ContainerModule2 = function() {
      function ContainerModule3(registry) {
        this.id = id_1.id();
        this.registry = registry;
      }
      return ContainerModule3;
    }();
    exports.ContainerModule = ContainerModule2;
    var AsyncContainerModule = function() {
      function AsyncContainerModule2(registry) {
        this.id = id_1.id();
        this.registry = registry;
      }
      return AsyncContainerModule2;
    }();
    exports.AsyncContainerModule = AsyncContainerModule;
  }
});

// node_modules/inversify/lib/annotation/injectable.js
var require_injectable = __commonJS({
  "node_modules/inversify/lib/annotation/injectable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.injectable = void 0;
    var ERRORS_MSGS = require_error_msgs();
    var METADATA_KEY = require_metadata_keys();
    function injectable2() {
      return function(target) {
        if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target)) {
          throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);
        }
        var types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];
        Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);
        return target;
      };
    }
    exports.injectable = injectable2;
  }
});

// node_modules/inversify/lib/annotation/tagged.js
var require_tagged = __commonJS({
  "node_modules/inversify/lib/annotation/tagged.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tagged = void 0;
    var metadata_1 = require_metadata();
    var decorator_utils_1 = require_decorator_utils();
    function tagged(metadataKey, metadataValue) {
      return function(target, targetKey, index2) {
        var metadata = new metadata_1.Metadata(metadataKey, metadataValue);
        if (typeof index2 === "number") {
          decorator_utils_1.tagParameter(target, targetKey, index2, metadata);
        } else {
          decorator_utils_1.tagProperty(target, targetKey, metadata);
        }
      };
    }
    exports.tagged = tagged;
  }
});

// node_modules/inversify/lib/annotation/named.js
var require_named = __commonJS({
  "node_modules/inversify/lib/annotation/named.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.named = void 0;
    var METADATA_KEY = require_metadata_keys();
    var metadata_1 = require_metadata();
    var decorator_utils_1 = require_decorator_utils();
    function named(name) {
      return function(target, targetKey, index2) {
        var metadata = new metadata_1.Metadata(METADATA_KEY.NAMED_TAG, name);
        if (typeof index2 === "number") {
          decorator_utils_1.tagParameter(target, targetKey, index2, metadata);
        } else {
          decorator_utils_1.tagProperty(target, targetKey, metadata);
        }
      };
    }
    exports.named = named;
  }
});

// node_modules/inversify/lib/annotation/optional.js
var require_optional = __commonJS({
  "node_modules/inversify/lib/annotation/optional.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.optional = void 0;
    var METADATA_KEY = require_metadata_keys();
    var metadata_1 = require_metadata();
    var decorator_utils_1 = require_decorator_utils();
    function optional2() {
      return function(target, targetKey, index2) {
        var metadata = new metadata_1.Metadata(METADATA_KEY.OPTIONAL_TAG, true);
        if (typeof index2 === "number") {
          decorator_utils_1.tagParameter(target, targetKey, index2, metadata);
        } else {
          decorator_utils_1.tagProperty(target, targetKey, metadata);
        }
      };
    }
    exports.optional = optional2;
  }
});

// node_modules/inversify/lib/annotation/unmanaged.js
var require_unmanaged = __commonJS({
  "node_modules/inversify/lib/annotation/unmanaged.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unmanaged = void 0;
    var METADATA_KEY = require_metadata_keys();
    var metadata_1 = require_metadata();
    var decorator_utils_1 = require_decorator_utils();
    function unmanaged() {
      return function(target, targetKey, index2) {
        var metadata = new metadata_1.Metadata(METADATA_KEY.UNMANAGED_TAG, true);
        decorator_utils_1.tagParameter(target, targetKey, index2, metadata);
      };
    }
    exports.unmanaged = unmanaged;
  }
});

// node_modules/inversify/lib/annotation/multi_inject.js
var require_multi_inject = __commonJS({
  "node_modules/inversify/lib/annotation/multi_inject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multiInject = void 0;
    var METADATA_KEY = require_metadata_keys();
    var metadata_1 = require_metadata();
    var decorator_utils_1 = require_decorator_utils();
    function multiInject(serviceIdentifier) {
      return function(target, targetKey, index2) {
        var metadata = new metadata_1.Metadata(METADATA_KEY.MULTI_INJECT_TAG, serviceIdentifier);
        if (typeof index2 === "number") {
          decorator_utils_1.tagParameter(target, targetKey, index2, metadata);
        } else {
          decorator_utils_1.tagProperty(target, targetKey, metadata);
        }
      };
    }
    exports.multiInject = multiInject;
  }
});

// node_modules/inversify/lib/annotation/target_name.js
var require_target_name = __commonJS({
  "node_modules/inversify/lib/annotation/target_name.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.targetName = void 0;
    var METADATA_KEY = require_metadata_keys();
    var metadata_1 = require_metadata();
    var decorator_utils_1 = require_decorator_utils();
    function targetName(name) {
      return function(target, targetKey, index2) {
        var metadata = new metadata_1.Metadata(METADATA_KEY.NAME_TAG, name);
        decorator_utils_1.tagParameter(target, targetKey, index2, metadata);
      };
    }
    exports.targetName = targetName;
  }
});

// node_modules/inversify/lib/annotation/post_construct.js
var require_post_construct = __commonJS({
  "node_modules/inversify/lib/annotation/post_construct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.postConstruct = void 0;
    var ERRORS_MSGS = require_error_msgs();
    var METADATA_KEY = require_metadata_keys();
    var metadata_1 = require_metadata();
    function postConstruct() {
      return function(target, propertyKey, descriptor) {
        var metadata = new metadata_1.Metadata(METADATA_KEY.POST_CONSTRUCT, propertyKey);
        if (Reflect.hasOwnMetadata(METADATA_KEY.POST_CONSTRUCT, target.constructor)) {
          throw new Error(ERRORS_MSGS.MULTIPLE_POST_CONSTRUCT_METHODS);
        }
        Reflect.defineMetadata(METADATA_KEY.POST_CONSTRUCT, metadata, target.constructor);
      };
    }
    exports.postConstruct = postConstruct;
  }
});

// node_modules/inversify/lib/utils/binding_utils.js
var require_binding_utils = __commonJS({
  "node_modules/inversify/lib/utils/binding_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multiBindToService = void 0;
    var multiBindToService = function(container2) {
      return function(service) {
        return function() {
          var types = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            types[_i] = arguments[_i];
          }
          return types.forEach(function(t) {
            return container2.bind(t).toService(service);
          });
        };
      };
    };
    exports.multiBindToService = multiBindToService;
  }
});

// node_modules/inversify/lib/inversify.js
var require_inversify = __commonJS({
  "node_modules/inversify/lib/inversify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multiBindToService = exports.getServiceIdentifierAsString = exports.typeConstraint = exports.namedConstraint = exports.taggedConstraint = exports.traverseAncerstors = exports.decorate = exports.id = exports.MetadataReader = exports.postConstruct = exports.targetName = exports.multiInject = exports.unmanaged = exports.optional = exports.LazyServiceIdentifer = exports.inject = exports.named = exports.tagged = exports.injectable = exports.ContainerModule = exports.AsyncContainerModule = exports.TargetTypeEnum = exports.BindingTypeEnum = exports.BindingScopeEnum = exports.Container = exports.METADATA_KEY = void 0;
    var keys = require_metadata_keys();
    exports.METADATA_KEY = keys;
    var container_1 = require_container();
    Object.defineProperty(exports, "Container", { enumerable: true, get: function() {
      return container_1.Container;
    } });
    var literal_types_1 = require_literal_types();
    Object.defineProperty(exports, "BindingScopeEnum", { enumerable: true, get: function() {
      return literal_types_1.BindingScopeEnum;
    } });
    Object.defineProperty(exports, "BindingTypeEnum", { enumerable: true, get: function() {
      return literal_types_1.BindingTypeEnum;
    } });
    Object.defineProperty(exports, "TargetTypeEnum", { enumerable: true, get: function() {
      return literal_types_1.TargetTypeEnum;
    } });
    var container_module_1 = require_container_module();
    Object.defineProperty(exports, "AsyncContainerModule", { enumerable: true, get: function() {
      return container_module_1.AsyncContainerModule;
    } });
    Object.defineProperty(exports, "ContainerModule", { enumerable: true, get: function() {
      return container_module_1.ContainerModule;
    } });
    var injectable_1 = require_injectable();
    Object.defineProperty(exports, "injectable", { enumerable: true, get: function() {
      return injectable_1.injectable;
    } });
    var tagged_1 = require_tagged();
    Object.defineProperty(exports, "tagged", { enumerable: true, get: function() {
      return tagged_1.tagged;
    } });
    var named_1 = require_named();
    Object.defineProperty(exports, "named", { enumerable: true, get: function() {
      return named_1.named;
    } });
    var inject_1 = require_inject();
    Object.defineProperty(exports, "inject", { enumerable: true, get: function() {
      return inject_1.inject;
    } });
    Object.defineProperty(exports, "LazyServiceIdentifer", { enumerable: true, get: function() {
      return inject_1.LazyServiceIdentifer;
    } });
    var optional_1 = require_optional();
    Object.defineProperty(exports, "optional", { enumerable: true, get: function() {
      return optional_1.optional;
    } });
    var unmanaged_1 = require_unmanaged();
    Object.defineProperty(exports, "unmanaged", { enumerable: true, get: function() {
      return unmanaged_1.unmanaged;
    } });
    var multi_inject_1 = require_multi_inject();
    Object.defineProperty(exports, "multiInject", { enumerable: true, get: function() {
      return multi_inject_1.multiInject;
    } });
    var target_name_1 = require_target_name();
    Object.defineProperty(exports, "targetName", { enumerable: true, get: function() {
      return target_name_1.targetName;
    } });
    var post_construct_1 = require_post_construct();
    Object.defineProperty(exports, "postConstruct", { enumerable: true, get: function() {
      return post_construct_1.postConstruct;
    } });
    var metadata_reader_1 = require_metadata_reader();
    Object.defineProperty(exports, "MetadataReader", { enumerable: true, get: function() {
      return metadata_reader_1.MetadataReader;
    } });
    var id_1 = require_id();
    Object.defineProperty(exports, "id", { enumerable: true, get: function() {
      return id_1.id;
    } });
    var decorator_utils_1 = require_decorator_utils();
    Object.defineProperty(exports, "decorate", { enumerable: true, get: function() {
      return decorator_utils_1.decorate;
    } });
    var constraint_helpers_1 = require_constraint_helpers();
    Object.defineProperty(exports, "traverseAncerstors", { enumerable: true, get: function() {
      return constraint_helpers_1.traverseAncerstors;
    } });
    Object.defineProperty(exports, "taggedConstraint", { enumerable: true, get: function() {
      return constraint_helpers_1.taggedConstraint;
    } });
    Object.defineProperty(exports, "namedConstraint", { enumerable: true, get: function() {
      return constraint_helpers_1.namedConstraint;
    } });
    Object.defineProperty(exports, "typeConstraint", { enumerable: true, get: function() {
      return constraint_helpers_1.typeConstraint;
    } });
    var serialization_1 = require_serialization();
    Object.defineProperty(exports, "getServiceIdentifierAsString", { enumerable: true, get: function() {
      return serialization_1.getServiceIdentifierAsString;
    } });
    var binding_utils_1 = require_binding_utils();
    Object.defineProperty(exports, "multiBindToService", { enumerable: true, get: function() {
      return binding_utils_1.multiBindToService;
    } });
  }
});

// node_modules/@bloomreach/spa-sdk/node_modules/emittery/index.js
var require_emittery = __commonJS({
  "node_modules/@bloomreach/spa-sdk/node_modules/emittery/index.js"(exports, module2) {
    "use strict";
    var anyMap = /* @__PURE__ */ new WeakMap();
    var eventsMap = /* @__PURE__ */ new WeakMap();
    var producersMap = /* @__PURE__ */ new WeakMap();
    var anyProducer = Symbol("anyProducer");
    var resolvedPromise = Promise.resolve();
    var listenerAdded = Symbol("listenerAdded");
    var listenerRemoved = Symbol("listenerRemoved");
    function assertEventName(eventName) {
      if (typeof eventName !== "string" && typeof eventName !== "symbol") {
        throw new TypeError("eventName must be a string or a symbol");
      }
    }
    function assertListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError("listener must be a function");
      }
    }
    function getListeners(instance, eventName) {
      const events = eventsMap.get(instance);
      if (!events.has(eventName)) {
        events.set(eventName, /* @__PURE__ */ new Set());
      }
      return events.get(eventName);
    }
    function getEventProducers(instance, eventName) {
      const key = typeof eventName === "string" || typeof eventName === "symbol" ? eventName : anyProducer;
      const producers = producersMap.get(instance);
      if (!producers.has(key)) {
        producers.set(key, /* @__PURE__ */ new Set());
      }
      return producers.get(key);
    }
    function enqueueProducers(instance, eventName, eventData) {
      const producers = producersMap.get(instance);
      if (producers.has(eventName)) {
        for (const producer of producers.get(eventName)) {
          producer.enqueue(eventData);
        }
      }
      if (producers.has(anyProducer)) {
        const item = Promise.all([eventName, eventData]);
        for (const producer of producers.get(anyProducer)) {
          producer.enqueue(item);
        }
      }
    }
    function iterator(instance, eventNames) {
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      let isFinished = false;
      let flush = () => {
      };
      let queue = [];
      const producer = {
        enqueue(item) {
          queue.push(item);
          flush();
        },
        finish() {
          isFinished = true;
          flush();
        }
      };
      for (const eventName of eventNames) {
        getEventProducers(instance, eventName).add(producer);
      }
      return {
        async next() {
          if (!queue) {
            return { done: true };
          }
          if (queue.length === 0) {
            if (isFinished) {
              queue = void 0;
              return this.next();
            }
            await new Promise((resolve2) => {
              flush = resolve2;
            });
            return this.next();
          }
          return {
            done: false,
            value: await queue.shift()
          };
        },
        async return(value) {
          queue = void 0;
          for (const eventName of eventNames) {
            getEventProducers(instance, eventName).delete(producer);
          }
          flush();
          return arguments.length > 0 ? { done: true, value: await value } : { done: true };
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    function defaultMethodNamesOrAssert(methodNames) {
      if (methodNames === void 0) {
        return allEmitteryMethods;
      }
      if (!Array.isArray(methodNames)) {
        throw new TypeError("`methodNames` must be an array of strings");
      }
      for (const methodName of methodNames) {
        if (!allEmitteryMethods.includes(methodName)) {
          if (typeof methodName !== "string") {
            throw new TypeError("`methodNames` element must be a string");
          }
          throw new Error(`${methodName} is not Emittery method`);
        }
      }
      return methodNames;
    }
    var isListenerSymbol = (symbol) => symbol === listenerAdded || symbol === listenerRemoved;
    var Emittery = class _Emittery {
      static mixin(emitteryPropertyName, methodNames) {
        methodNames = defaultMethodNamesOrAssert(methodNames);
        return (target) => {
          if (typeof target !== "function") {
            throw new TypeError("`target` must be function");
          }
          for (const methodName of methodNames) {
            if (target.prototype[methodName] !== void 0) {
              throw new Error(`The property \`${methodName}\` already exists on \`target\``);
            }
          }
          function getEmitteryProperty() {
            Object.defineProperty(this, emitteryPropertyName, {
              enumerable: false,
              value: new _Emittery()
            });
            return this[emitteryPropertyName];
          }
          Object.defineProperty(target.prototype, emitteryPropertyName, {
            enumerable: false,
            get: getEmitteryProperty
          });
          const emitteryMethodCaller = (methodName) => function(...args) {
            return this[emitteryPropertyName][methodName](...args);
          };
          for (const methodName of methodNames) {
            Object.defineProperty(target.prototype, methodName, {
              enumerable: false,
              value: emitteryMethodCaller(methodName)
            });
          }
          return target;
        };
      }
      constructor() {
        anyMap.set(this, /* @__PURE__ */ new Set());
        eventsMap.set(this, /* @__PURE__ */ new Map());
        producersMap.set(this, /* @__PURE__ */ new Map());
      }
      on(eventNames, listener) {
        assertListener(listener);
        eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
        for (const eventName of eventNames) {
          assertEventName(eventName);
          getListeners(this, eventName).add(listener);
          if (!isListenerSymbol(eventName)) {
            this.emit(listenerAdded, { eventName, listener });
          }
        }
        return this.off.bind(this, eventNames, listener);
      }
      off(eventNames, listener) {
        assertListener(listener);
        eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
        for (const eventName of eventNames) {
          assertEventName(eventName);
          getListeners(this, eventName).delete(listener);
          if (!isListenerSymbol(eventName)) {
            this.emit(listenerRemoved, { eventName, listener });
          }
        }
      }
      once(eventNames) {
        return new Promise((resolve2) => {
          const off = this.on(eventNames, (data) => {
            off();
            resolve2(data);
          });
        });
      }
      events(eventNames) {
        eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
        for (const eventName of eventNames) {
          assertEventName(eventName);
        }
        return iterator(this, eventNames);
      }
      async emit(eventName, eventData) {
        assertEventName(eventName);
        enqueueProducers(this, eventName, eventData);
        const listeners = getListeners(this, eventName);
        const anyListeners = anyMap.get(this);
        const staticListeners = [...listeners];
        const staticAnyListeners = isListenerSymbol(eventName) ? [] : [...anyListeners];
        await resolvedPromise;
        await Promise.all([
          ...staticListeners.map(async (listener) => {
            if (listeners.has(listener)) {
              return listener(eventData);
            }
          }),
          ...staticAnyListeners.map(async (listener) => {
            if (anyListeners.has(listener)) {
              return listener(eventName, eventData);
            }
          })
        ]);
      }
      async emitSerial(eventName, eventData) {
        assertEventName(eventName);
        const listeners = getListeners(this, eventName);
        const anyListeners = anyMap.get(this);
        const staticListeners = [...listeners];
        const staticAnyListeners = [...anyListeners];
        await resolvedPromise;
        for (const listener of staticListeners) {
          if (listeners.has(listener)) {
            await listener(eventData);
          }
        }
        for (const listener of staticAnyListeners) {
          if (anyListeners.has(listener)) {
            await listener(eventName, eventData);
          }
        }
      }
      onAny(listener) {
        assertListener(listener);
        anyMap.get(this).add(listener);
        this.emit(listenerAdded, { listener });
        return this.offAny.bind(this, listener);
      }
      anyEvent() {
        return iterator(this);
      }
      offAny(listener) {
        assertListener(listener);
        this.emit(listenerRemoved, { listener });
        anyMap.get(this).delete(listener);
      }
      clearListeners(eventNames) {
        eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
        for (const eventName of eventNames) {
          if (typeof eventName === "string" || typeof eventName === "symbol") {
            getListeners(this, eventName).clear();
            const producers = getEventProducers(this, eventName);
            for (const producer of producers) {
              producer.finish();
            }
            producers.clear();
          } else {
            anyMap.get(this).clear();
            for (const listeners of eventsMap.get(this).values()) {
              listeners.clear();
            }
            for (const producers of producersMap.get(this).values()) {
              for (const producer of producers) {
                producer.finish();
              }
              producers.clear();
            }
          }
        }
      }
      listenerCount(eventNames) {
        eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
        let count = 0;
        for (const eventName of eventNames) {
          if (typeof eventName === "string") {
            count += anyMap.get(this).size + getListeners(this, eventName).size + getEventProducers(this, eventName).size + getEventProducers(this).size;
            continue;
          }
          if (typeof eventName !== "undefined") {
            assertEventName(eventName);
          }
          count += anyMap.get(this).size;
          for (const value of eventsMap.get(this).values()) {
            count += value.size;
          }
          for (const value of producersMap.get(this).values()) {
            count += value.size;
          }
        }
        return count;
      }
      bindMethods(target, methodNames) {
        if (typeof target !== "object" || target === null) {
          throw new TypeError("`target` must be an object");
        }
        methodNames = defaultMethodNamesOrAssert(methodNames);
        for (const methodName of methodNames) {
          if (target[methodName] !== void 0) {
            throw new Error(`The property \`${methodName}\` already exists on \`target\``);
          }
          Object.defineProperty(target, methodName, {
            enumerable: false,
            value: this[methodName].bind(this)
          });
        }
      }
    };
    var allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter((v) => v !== "constructor");
    Emittery.Typed = class extends Emittery {
    };
    Object.defineProperty(Emittery.Typed, "Typed", {
      enumerable: false,
      value: void 0
    });
    Object.defineProperty(Emittery, "listenerAdded", {
      value: listenerAdded,
      writable: false,
      enumerable: true,
      configurable: false
    });
    Object.defineProperty(Emittery, "listenerRemoved", {
      value: listenerRemoved,
      writable: false,
      enumerable: true,
      configurable: false
    });
    module2.exports = Emittery;
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse;
    exports.serialize = serialize;
    var decode = decodeURIComponent;
    var encode = encodeURIComponent;
    var pairSplitRegExp = /; */;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var pairs = str.split(pairSplitRegExp);
      var dec = opt.decode || decode;
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        var eq_idx = pair.indexOf("=");
        if (eq_idx < 0) {
          continue;
        }
        var key = pair.substr(0, eq_idx).trim();
        var val = pair.substr(++eq_idx, pair.length).trim();
        if ('"' == val[0]) {
          val = val.slice(1, -1);
        }
        if (void 0 == obj[key]) {
          obj[key] = tryDecode(val, dec);
        }
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString !== "function") {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e) {
        return str;
      }
    }
  }
});

// index.ts
var backend_exports = {};
__export(backend_exports, {
  default: () => backend_default
});
module.exports = __toCommonJS(backend_exports);
var import_stable = __toESM(require_stable());
var import_runtime = __toESM(require_runtime());

// commerce-commercetools/actionControllers/AccountController.ts
var AccountController_exports = {};
__export(AccountController_exports, {
  addAddress: () => addAddress,
  addBillingAddress: () => addBillingAddress,
  addShippingAddress: () => addShippingAddress,
  confirm: () => confirm,
  deleteAccount: () => deleteAccount,
  getAccount: () => getAccount,
  login: () => login,
  logout: () => logout,
  password: () => password,
  register: () => register,
  removeAddress: () => removeAddress,
  requestConfirmationEmail: () => requestConfirmationEmail,
  requestReset: () => requestReset,
  reset: () => reset,
  setDefaultBillingAddress: () => setDefaultBillingAddress,
  setDefaultShippingAddress: () => setDefaultShippingAddress,
  update: () => update,
  updateAddress: () => updateAddress
});

// commerce-commercetools/utils/Guid.ts
var import_performance_now = __toESM(require_performance_now());
var Guid = class {
};
Guid.newGuid = (noHyphens, [regular, withHyphens] = ["xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx", "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"]) => {
  let d = (/* @__PURE__ */ new Date()).getTime();
  if (typeof import_performance_now.default === "function") {
    d += (0, import_performance_now.default)();
  }
  const shellGuid = noHyphens ? regular : withHyphens;
  return shellGuid.replace(/[xy]/g, function(c) {
    const r = (d + Math.random() * 16) % 16 | 0;
    d = Math.floor(d / 16);
    return (c === "x" ? r : r & (3 | 8)).toString(16);
  });
};
Guid.empty = "00000000-0000-0000-0000-000000000000";

// commerce-commercetools/mappers/AccountMapper.ts
var AccountMapper = class {
  static commercetoolsCustomerToAccount(commercetoolsCustomer) {
    return {
      accountId: commercetoolsCustomer.id,
      email: commercetoolsCustomer.email,
      salutation: commercetoolsCustomer == null ? void 0 : commercetoolsCustomer.salutation,
      firstName: commercetoolsCustomer == null ? void 0 : commercetoolsCustomer.firstName,
      lastName: commercetoolsCustomer == null ? void 0 : commercetoolsCustomer.lastName,
      birthday: (commercetoolsCustomer == null ? void 0 : commercetoolsCustomer.dateOfBirth) ? new Date(commercetoolsCustomer.dateOfBirth) : void 0,
      confirmed: commercetoolsCustomer.isEmailVerified,
      version: commercetoolsCustomer.version,
      addresses: this.commercetoolsAddressesToAddresses(
        commercetoolsCustomer.addresses,
        commercetoolsCustomer.defaultBillingAddressId,
        commercetoolsCustomer.defaultShippingAddressId,
        commercetoolsCustomer.billingAddressIds,
        commercetoolsCustomer.shippingAddressIds
      )
    };
  }
  static commercetoolsAddressesToAddresses(commercetoolsAddresses, defaultBillingAddressId, defaultShippingAddressId, billingAddressIds, shippingAddressIds) {
    const addresses = [];
    commercetoolsAddresses.forEach((commercetoolsAddress) => {
      addresses.push({
        ...this.commercetoolsAddressToAddress(commercetoolsAddress),
        isDefaultBillingAddress: commercetoolsAddress.id === defaultBillingAddressId,
        isDefaultShippingAddress: commercetoolsAddress.id === defaultShippingAddressId,
        isBillingAddress: billingAddressIds.includes(commercetoolsAddress.id),
        isShippingAddress: shippingAddressIds.includes(commercetoolsAddress.id)
      });
    });
    return addresses;
  }
  static commercetoolsAddressToAddress(commercetoolsAddress) {
    var _a4, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
    return {
      addressId: commercetoolsAddress.id,
      key: (_a4 = commercetoolsAddress == null ? void 0 : commercetoolsAddress.key) != null ? _a4 : void 0,
      salutation: (_b = commercetoolsAddress.salutation) != null ? _b : void 0,
      firstName: (_c = commercetoolsAddress.firstName) != null ? _c : void 0,
      lastName: (_d = commercetoolsAddress.lastName) != null ? _d : void 0,
      streetName: (_e = commercetoolsAddress.streetName) != null ? _e : void 0,
      streetNumber: (_f = commercetoolsAddress.streetNumber) != null ? _f : void 0,
      additionalStreetInfo: (_g = commercetoolsAddress.additionalStreetInfo) != null ? _g : void 0,
      additionalAddressInfo: (_h = commercetoolsAddress.additionalAddressInfo) != null ? _h : void 0,
      postalCode: (_i = commercetoolsAddress.postalCode) != null ? _i : void 0,
      city: (_j = commercetoolsAddress.city) != null ? _j : void 0,
      country: (_k = commercetoolsAddress.country) != null ? _k : void 0,
      state: (_l = commercetoolsAddress.state) != null ? _l : void 0,
      phone: (_m = commercetoolsAddress.phone) != null ? _m : void 0
    };
  }
};
AccountMapper.commercetoolsCustomerToAddresses = (commercetoolsCustomer, locale) => {
  const addresses = [];
  commercetoolsCustomer.addresses.forEach((commercetoolsAddress) => {
    addresses.push({
      isDefaultBillingAddress: commercetoolsAddress.id === commercetoolsCustomer.defaultBillingAddressId,
      isBillingAddress: commercetoolsCustomer.billingAddressIds.includes(commercetoolsAddress.id),
      isDefaultShippingAddress: commercetoolsAddress.id === commercetoolsCustomer.defaultShippingAddressId,
      isShippingAddress: commercetoolsCustomer.shippingAddressIds.includes(commercetoolsAddress.id)
    });
  });
  return addresses;
};
AccountMapper.addressToCommercetoolsAddress = (address) => {
  return {
    id: address.addressId,
    key: Guid.newGuid(),
    salutation: address.salutation,
    firstName: address.firstName,
    lastName: address.lastName,
    streetName: address.streetName,
    streetNumber: address.streetNumber,
    additionalStreetInfo: address.additionalStreetInfo,
    additionalAddressInfo: address.additionalAddressInfo,
    postalCode: address.postalCode,
    city: address.city,
    country: address.country,
    state: address.state,
    phone: address.phone
  };
};

// commerce-commercetools/errors/Errors.ts
var ExtensionError = class extends Error {
  constructor({ message, errors, statusCode }) {
    var _a4;
    super(message || ((_a4 = errors[0]) == null ? void 0 : _a4.message));
    this.errors = errors || [{ message }];
    this.statusCode = isNaN(statusCode) ? 503 : statusCode;
  }
};

// commerce-commercetools/errors/AccountEmailDuplicatedError.ts
var AccountEmailDuplicatedError = class _AccountEmailDuplicatedError extends ExtensionError {
  constructor(options) {
    super(options);
    this.errorName = _AccountEmailDuplicatedError.ACCOUNT_EMAIL_DUPLICATED_ERROR_NAME;
  }
};

// commerce-commercetools/errors/AccountAuthenticationError.ts
var AccountAuthenticationError = class _AccountAuthenticationError extends ExtensionError {
  constructor(options) {
    super(options);
    this.errorName = _AccountAuthenticationError.ACCOUNT_AUTHENTICATION_ERROR_NAME;
  }
};

// commerce-commercetools/apis/BaseApi.ts
var import_crypto = __toESM(require("crypto"));
init_lib();

// node_modules/@commercetools/platform-sdk/dist/commercetools-platform-sdk.esm.js
function toPrimitive(t, r) {
  if ("object" != typeof t || !t)
    return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i)
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function isDefined(value) {
  return typeof value !== "undefined" && value !== null;
}
function stringify(object) {
  const params = new URLSearchParams(object);
  for (const [key, value] of Object.entries(object)) {
    if (Array.isArray(value)) {
      params.delete(key);
      value.filter(Boolean).forEach((v) => params.append(key, v));
    }
  }
  return params.toString();
}
function cleanObject(obj) {
  return Object.keys(obj).reduce((result, key) => {
    const value = obj[key];
    if (Array.isArray(value)) {
      const values = value.filter(isDefined);
      if (!values.length) {
        return result;
      }
      return {
        ...result,
        [key]: values
      };
    }
    if (isDefined(value)) {
      return {
        ...result,
        [key]: value
      };
    }
    return result;
  }, {});
}
function formatQueryString(variableMap) {
  const map = cleanObject(variableMap);
  const result = stringify(map);
  if (result === "") {
    return "";
  }
  return `?${result}`;
}
function buildRelativeUri(commonRequest) {
  const pathMap = commonRequest.pathVariables;
  var uri = commonRequest.uriTemplate;
  for (const param in pathMap) {
    const value = encodeURIComponent(`${pathMap[param]}`);
    uri = uri.replace(`{${param}}`, `${value}`);
  }
  const resQuery = formatQueryString(commonRequest.queryParams || {});
  return `${uri}${resQuery}`;
}
var ApiRequest = class {
  constructor(request, requestExecutor) {
    this.requestExecutor = requestExecutor;
    _defineProperty(this, "request", void 0);
    this.request = {
      ...request,
      uri: buildRelativeUri(request)
    };
  }
  clientRequest() {
    return this.request;
  }
  execute() {
    return this.requestExecutor(this.request);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyMeActiveCartRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves the Customer's most recently modified active Cart in the Store specified by the `storeKey` path parameter.
   *
   *	Carts with `Merchant` or `Quote` [CartOrigin](ctp:api:type:CartOrigin) are ignored.
   *
   *	If no active Cart exists, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/active-cart",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an active Cart exists. Returns a `200 OK` status if an active Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/active-cart",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeActiveCartRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves the Customer's most recently modified active Cart.
   *	Carts with `Merchant` or `Quote` [CartOrigin](ctp:api:type:CartOrigin) are ignored.
   *
   *	If no active Cart exists, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/active-cart",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an active Cart exists. Returns a `200 OK` status if an active Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/active-cart",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
};
var ByProjectKeyApiClientsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/api-clients/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an API Client exists for a given `id`. Returns a `200 OK` status if the API Client exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/api-clients/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/api-clients/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
};
var ByProjectKeyApiClientsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyApiClientsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/api-clients",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an API Client exists for a given Query Predicate. Returns a `200 OK` status if any API Clients match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/api-clients",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/api-clients",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdBusinessUnitsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/business-units/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given `id`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/business-units/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/business-units/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdBusinessUnitsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/business-units/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given `key`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/business-units/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/business-units/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdBusinessUnitsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdBusinessUnitsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdBusinessUnitsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/business-units",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given Query Predicate. Returns a `200 OK` status if any BusinessUnits match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/business-units",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/business-units",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalFlowsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-flows/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-flows/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalFlowsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalFlowsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-flows",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsReplicateRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Creates a new Cart by replicating an existing Cart or Order. Can be useful in cases where a customer wants to cancel a recent order to make some changes or reorder a previous order.
   *
   *	The replicated Cart preserves Customer information, Line Items and Custom Line Items, Custom Fields, Discount Codes, and other settings of the Cart or Order. If the Line Items become invalid, for example, due to removed Products or Prices, they are removed from the new Cart. If the Customer switches to another Customer Group, the new Cart is updated with the new value. It has up-to-date Tax Rates, Prices, and Line Item product data and is in `Active` [CartState](ctp:api:type:CartState).
   *
   *	The new Cart does not contain Payments or Deliveries. The [State](ctp:api:type:ItemState) of Line Items and Custom Line Items is reset to `initial`.
   *
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/replicate",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given `id`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given `key`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  replicate() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsReplicateRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given Query Predicate. Returns a `200 OK` status if any Carts match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creates a [Cart](ctp:api:type:Cart) in the [BusinessUnit](ctp:api:type:BusinessUnit) referenced by `businessUnitKey`. As such, the `businessUnit` field on [CartDraft](ctp:api:type:CartDraft) is ignored for this request.
   *	Creating a Cart can fail with an [InvalidOperation](ctp:api:type:InvalidOperationError) if the referenced [ShippingMethod](ctp:api:type:ShippingMethod) in the [CartDraft](ctp:api:type:CartDraft) has a predicate that does not match the Cart.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersQuotesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Creates an Order from a [Quote](ctp:api:type:Cart) in a [BusinessUnit](ctp:api:type:BusinessUnit).
   *	Creating an Order fails with an [InvalidOperation](ctp:api:type:InvalidOperationError) if the Quote does not reference the same BusinessUnit as the `businessUnitKey` path parameter.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/quotes",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Order exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given `id`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Order exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersOrderNumberByOrderNumberRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Order exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/order-number={orderNumber}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given `orderNumber`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/order-number={orderNumber}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Order exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/order-number={orderNumber}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  orderQuote() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withOrderNumber(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersOrderNumberByOrderNumberRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given Query Predicate. Returns a `200 OK` status if any Orders match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creates an Order from a [Cart](ctp:api:type:Cart) in a [BusinessUnit](ctp:api:type:BusinessUnit).
   *	The Cart must have a shipping address set before creating an Order.
   *	Creating an Order fails with an [InvalidOperation](ctp:api:type:InvalidOperationError) if the Cart does not reference the same BusinessUnit as the `businessUnitKey` path parameter.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the QuoteRequest exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a QuoteRequest exists for a given `id`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the QuoteRequest exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the QuoteRequest exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a QuoteRequest exists for a given `key`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the QuoteRequest exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a QuoteRequest exists for a given Query Predicate. Returns a `200 OK` status if any QuoteRequests match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creates a QuoteRequest in a [BusinessUnit](ctp:api:type:BusinessUnit). Creating QuoteRequest fails with an [InvalidOperation](ctp:api:type:InvalidOperationError) if the Cart does not reference the same BusinessUnit as the `businessUnitKey` path parameter.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Quote exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given `id`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Quote exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Quote exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given `key`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Quote exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given Query Predicate. Returns a `200 OK` status if any Quotes match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	An Approval Rule describes the conditions determining whether an Order that matches the predicate needs approval by an approver before it can be ordered by an requester within a Business Unit.
   */
  approvalRules() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Approval Flows connect Orders that require approval with the Approval Rules that initiate the approval requirement.
   *	They represent the approval process by including information about approvals, rejections, and all involved parties.
   *
   */
  approvalFlows() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalFlowsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A shopping cart holds product variants and can be ordered.
   */
  carts() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  orders() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A quote holds the negotiated offer.
   */
  quotes() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  quoteRequests() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
};
var ByProjectKeyAsAssociateByAssociateIdRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	A Business Unit can represent a Company or a Division.
   */
  businessUnits() {
    return new ByProjectKeyAsAssociateByAssociateIdBusinessUnitsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  inBusinessUnitKeyWithBusinessUnitKeyValue(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
};
var ByProjectKeyAsAssociateRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withAssociateIdValue(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
};
var ByProjectKeyAssociateRolesByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/associate-roles/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an AssociateRole exists for a given `id`. Returns a `200 OK` status if the AssociateRole exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/associate-roles/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/associate-roles/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/associate-roles/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAssociateRolesKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/associate-roles/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an AssociateRole exists for a given `key`. Returns a `200 OK` status if the AssociateRole exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/associate-roles/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/associate-roles/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting an AssociateRole generates the [AssociateRoleDeleted](ctp:api:type:AssociateRoleDeletedMessage) Message. An AssociateRole can only be deleted if it is not assigned to any [Associates](ctp:api:type:Associate).
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/associate-roles/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAssociateRolesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyAssociateRolesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyAssociateRolesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/associate-roles",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an AssociateRole exists for a given Query Predicate. Returns a `200 OK` status if any AssociateRole match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/associate-roles",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creating a Associate Role generates the [AssociateRoleCreated](ctp:api:type:AssociateRoleCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/associate-roles",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAttributeGroupsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/attribute-groups/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an AttributeGroup exists for a given `id`. Returns a `200 OK` status if the AttributeGroup exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/attribute-groups/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/attribute-groups/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/attribute-groups/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAttributeGroupsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/attribute-groups/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an AttributeGroup exists for a given `key`. Returns `200 OK` status if the AttributeGroup exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/attribute-groups/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/attribute-groups/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/attribute-groups/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyAttributeGroupsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyAttributeGroupsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyAttributeGroupsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/attribute-groups",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an AttributeGroup exists for a given Query Predicate. Returns `200 OK` status if any AttributeGroups match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/attribute-groups",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/attribute-groups",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyBusinessUnitsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/business-units/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given `id`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/business-units/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/business-units/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/business-units/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyBusinessUnitsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/business-units/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given `key`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/business-units/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/business-units/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/business-units/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyBusinessUnitsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyBusinessUnitsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyBusinessUnitsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/business-units",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given Query Predicate. Returns a `200 OK` status if any BusinessUnits match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/business-units",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/business-units",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCartDiscountsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/cart-discounts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CartDiscount exists for a given `id`. Returns a `200 OK` status if the CartDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/cart-discounts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/cart-discounts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting a Cart Discount produces the [CartDiscountDeleted](ctp:api:type:CartDiscountDeletedMessage) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/cart-discounts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCartDiscountsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/cart-discounts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CartDiscount exists for a given `key`. Returns a `200 OK` status if the CartDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/cart-discounts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/cart-discounts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting a Cart Discount produces the [CartDiscountDeleted](ctp:api:type:CartDiscountDeletedMessage) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/cart-discounts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCartDiscountsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyCartDiscountsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyCartDiscountsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/cart-discounts",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CartDiscount exists for a given Query Predicate. Returns a `200 OK` status if any CartDiscounts match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/cart-discounts",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creating a Cart Discount produces the [CartDiscountCreated](ctp:api:type:CartDiscountCreatedMessage) Message.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/cart-discounts",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCartsReplicateRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Creates a new Cart by replicating an existing Cart or Order. Can be useful in cases where a customer wants to cancel a recent order to make some changes or reorder a previous order.
   *
   *	The replicated Cart preserves Customer information, Line Items and Custom Line Items, Custom Fields, Discount Codes, and other settings of the Cart or Order. If the Line Items become invalid, for example, due to removed Products or Prices, they are removed from the new Cart. If the Customer switches to another Customer Group, the new Cart is updated with the new value. It has up-to-date Tax Rates, Prices, and Line Item product data and is in `Active` [CartState](ctp:api:type:CartState).
   *
   *	The new Cart does not contain Payments or Deliveries. The [State](ctp:api:type:ItemState) of Line Items and Custom Line Items is reset to `initial`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/carts/replicate",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCartsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given `id`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCartsCustomerIdByCustomerIdRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves the recently modified active Cart of a Customer with [CartOrigin](ctp:api:type:CartOrigin) `Customer`. If no active Cart exists, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/carts/customer-id={customerId}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart of a Customer exists. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/carts/customer-id={customerId}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCartsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/carts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given `key`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/carts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/carts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/carts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCartsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  replicate() {
    return new ByProjectKeyCartsReplicateRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withCustomerId(childPathArgs) {
    return new ByProjectKeyCartsCustomerIdByCustomerIdRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyCartsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyCartsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/carts",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given Query Predicate. Returns a `200 OK` status if any Carts match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/carts",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creating a Cart fails with an [InvalidOperation](ctp:api:type:InvalidOperationError) error if the
   *	[ShippingMethod](ctp:api:type:ShippingMethod) referenced in the CartDraft
   *	has a `predicate` that does not match the Cart.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/carts",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCategoriesByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Either the [scope](/../api/scopes) `view_products:{projectKey}` or `view_categories:{projectKey}` is required.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/categories/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Category exists for a given `id`. Returns a `200 OK` status if the Category exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/categories/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Either the [scope](/../api/scopes) `manage_products:{projectKey}` or `manage_categories:{projectKey}` is required.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/categories/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Either the [scope](/../api/scopes) `manage_products:{projectKey}` or `manage_categories:{projectKey}` is required.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/categories/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCategoriesKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Either the [scope](/../api/scopes) `view_products:{projectKey}` or `view_categories:{projectKey}` is required.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/categories/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Category exists for a given `key`. Returns a `200 OK` status if the Category exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/categories/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Either the [scope](/../api/scopes) `manage_products:{projectKey}` or `manage_categories:{projectKey}` is required.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/categories/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Either the [scope](/../api/scopes) `manage_products:{projectKey}` or `manage_categories:{projectKey}` is required.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/categories/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCategoriesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyCategoriesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyCategoriesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Either the [scope](/../api/scopes) `view_products:{projectKey}` or `view_categories:{projectKey}` is required.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/categories",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Category exists for on a given Query Predicate. Returns a `200 OK` status if any Categories match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/categories",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Either the [scope](/../api/scopes) `manage_products:{projectKey}` or `manage_categories:{projectKey}` is required.
   *
   *	Creating a Category produces the [CategoryCreated](ctp:api:type:CategoryCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/categories",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyChannelsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/channels/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Channel exists for a given `id`. Returns a `200 OK` status if the Channel exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/channels/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/channels/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/channels/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyChannelsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyChannelsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/channels",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Channel exists for a given Query Predicate. Returns a `200 OK` status if any Channels match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/channels",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/channels",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCustomObjectsByContainerByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/custom-objects/{container}/{key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/custom-objects/{container}/{key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCustomObjectsByContainerRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/custom-objects/{container}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCustomObjectsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withContainerAndKey(childPathArgs) {
    return new ByProjectKeyCustomObjectsByContainerByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withContainer(childPathArgs) {
    return new ByProjectKeyCustomObjectsByContainerRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	For performance reasons, it is highly advisable to query for Custom Objects in a container by using the `container` field in the `where` predicate.
   *
   */
  /**
   * @deprecated
   **/
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/custom-objects",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CustomObject exists for a given Query Predicate. Returns a `200 OK` status if any CustomObjects match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/custom-objects",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	If an object with the given container/key exists, the object will be replaced with the new value and the version is incremented.
   *	If the request contains a version and an object with the given container/key, then the version must match the version of the existing object. Concurrent updates to the same Custom Object returns a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error even if the version is not provided.
   *
   *	Fields with `null` values will **not be saved**.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/custom-objects",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCustomerGroupsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/customer-groups/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CustomerGroup exists for a given `id`. Returns a `200 OK` status if the CustomerGroup exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/customer-groups/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/customer-groups/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/customer-groups/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCustomerGroupsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/customer-groups/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CustomerGroup exists for a given `key`. Returns a `200 OK` status if the CustomerGroup exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/customer-groups/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/customer-groups/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/customer-groups/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCustomerGroupsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyCustomerGroupsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyCustomerGroupsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/customer-groups",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CustomerGroup exists for a given Query Predicate. Returns a `200 OK` status if any CustomerGroup match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/customer-groups",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/customer-groups",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCustomersEmailConfirmRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Verifying the email of the Customer produces the [CustomerEmailVerified](ctp:api:type:CustomerEmailVerifiedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/customers/email/confirm",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCustomersEmailTokenRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Produces the [CustomerEmailTokenCreated](ctp:api:type:CustomerEmailTokenCreatedMessage) Message.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/customers/email-token",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCustomersPasswordTokenRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/customers/password-token",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCustomersPasswordRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Changing the password produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=false`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/customers/password",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCustomersPasswordResetRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Resetting the password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=true`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/customers/password/reset",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCustomersByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/customers/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Customer exists for a given `id`. Returns a `200 OK` status if the Customer exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/customers/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/customers/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting a Customer produces the [CustomerDeleted](ctp:api:type:CustomerDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/customers/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCustomersEmailTokenByEmailTokenRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/customers/email-token={emailToken}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCustomersKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/customers/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Customer exists for a given `key`. Returns a `200 OK` status if the Customer exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/customers/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/customers/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting a Customer produces the [CustomerDeleted](ctp:api:type:CustomerDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/customers/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCustomersPasswordTokenByPasswordTokenRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/customers/password-token={passwordToken}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyCustomersRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withPasswordToken(childPathArgs) {
    return new ByProjectKeyCustomersPasswordTokenByPasswordTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withEmailToken(childPathArgs) {
    return new ByProjectKeyCustomersEmailTokenByEmailTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  emailToken() {
    return new ByProjectKeyCustomersEmailTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  emailConfirm() {
    return new ByProjectKeyCustomersEmailConfirmRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  password() {
    return new ByProjectKeyCustomersPasswordRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  passwordReset() {
    return new ByProjectKeyCustomersPasswordResetRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Produces the [CustomerPasswordTokenCreated](ctp:api:type:CustomerPasswordTokenCreatedMessage) Message.
   */
  passwordToken() {
    return new ByProjectKeyCustomersPasswordTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyCustomersKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyCustomersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/customers",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Customer exists for a given Query Predicate. Returns a `200 OK` status if any Customers match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/customers",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	If the `anonymousCart` field is set on the [CustomerDraft](ctp:api:type:CustomerDraft), then the newly created Customer will be assigned to that [Cart](ctp:api:type:Cart).
   *	Similarly, if the `anonymousId` field is set, the Customer will be set on all [Carts](ctp:api:type:Cart), [Orders](ctp:api:type:Order), [ShoppingLists](ctp:api:type:ShoppingList) and [Payments](ctp:api:type:Payment) with the same `anonymousId`.
   *	Creating a Customer produces the [CustomerCreated](ctp:api:type:CustomerCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/customers",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyDiscountCodesByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Deprecated scope: `view_orders:{projectKey}`
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/discount-codes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a DiscountCode exists for a given `id`. Returns a `200 OK` status if the DiscountCode exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/discount-codes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Deprecated scope: `manage_orders:{projectKey}`
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/discount-codes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting a Discount Code produces the [DiscountCodeDeleted](ctp:api:type:DiscountCodeDeletedMessage) Message.
   *
   *	Deprecated scope: `manage_orders:{projectKey}`
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/discount-codes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyDiscountCodesKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Deprecated scope: `view_orders:{projectKey}`
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/discount-codes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a DiscountCode exists for a given `key`. Returns a `200 OK` status if the DiscountCode exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/discount-codes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Deprecated scope: `manage_orders:{projectKey}`
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/discount-codes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting a Discount Code produces the [DiscountCodeDeleted](ctp:api:type:DiscountCodeDeletedMessage) Message.
   *
   *	Deprecated scope: `manage_orders:{projectKey}`
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/discount-codes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyDiscountCodesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyDiscountCodesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyDiscountCodesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Deprecated scope: `view_orders:{projectKey}`
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/discount-codes",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a DiscountCode exists for a given Query Predicate. Returns a `200 OK` status if any DiscountCodes match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/discount-codes",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creating a Discount Code produces the [DiscountCodeCreated](ctp:api:type:DiscountCodeCreatedMessage) Message.
   *
   *	Deprecated scope: `manage_orders:{projectKey}`
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/discount-codes",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyExtensionsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/extensions/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Extension exists for a given `id`. Returns a `200 OK` status if the Extension exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/extensions/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/extensions/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/extensions/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyExtensionsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/extensions/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Extension exists for a given `key`. Returns a `200 OK` status if the Extension exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/extensions/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/extensions/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/extensions/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyExtensionsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyExtensionsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyExtensionsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/extensions",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Extension exists for a given Query Predicate. Returns a `200 OK` status if any Extensions match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/extensions",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/extensions",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyGraphqlRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Execute a GraphQL query
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/graphql",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/graphql",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyMeCustomersRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	The My Business Unit endpoint does not support assigning existing Customers to a Business Unit.
   *	Associates with the `UpdateAssociates` [Permission](ctp:api:type:Permission) can use this endpoint to create a new Customer and associate it with the Business Unit.
   *	If the required [Permission](/projects/associate-roles#permission) is missing, an [AssociateMissingPermission](/errors#associatemissingpermission) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-business-unit/key={businessUnitKey}/me/customers",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyMeRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  customers() {
    return new ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyMeCustomersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
};
var ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  me() {
    return new ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyMeRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCartDiscountsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/cart-discounts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CartDiscount exists for a given `id`. Returns a `200 OK` status if the CartDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/cart-discounts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	To update a CartDiscount, you must have permissions for all Stores the CartDiscount is associated with, except when [removing a Store](ctp:api:type:CartDiscountRemoveStoreAction).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/cart-discounts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	To delete a CartDiscount, specify the `manage_cart_discounts:{projectKey}:{storeKey}` scope for all Stores associated with the CartDiscount.
   *
   *	Deleting a Cart Discount produces the [CartDiscountDeleted](ctp:api:type:CartDiscountDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/cart-discounts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCartDiscountsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/cart-discounts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CartDiscount exists for a given `key`. Returns a `200 OK` status if the CartDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/cart-discounts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	To update a CartDiscount, you must have permissions for all Stores the CartDiscount is associated with, except when [removing a Store](ctp:api:type:CartDiscountRemoveStoreAction).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/cart-discounts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	To delete a CartDiscount, specify the `manage_cart_discounts:{projectKey}:{storeKey}` scope for all Stores associated with the CartDiscount.
   *
   *	Deleting a Cart Discount produces the [CartDiscountDeleted](ctp:api:type:CartDiscountDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/cart-discounts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCartDiscountsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCartDiscountsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCartDiscountsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/cart-discounts",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CartDiscount exists for a given Query Predicate. Returns a `200 OK` status if any CartDiscounts match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/cart-discounts",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	When using the endpoint, the Store specified in the path and the Stores specified in the payload's `stores` field are added to the CartDiscount.
   *
   *	Creating a Cart Discount produces the [CartDiscountCreated](ctp:api:type:CartDiscountCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/cart-discounts",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCartsReplicateRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Creates a new Cart by replicating an existing Cart or Order. Can be useful in cases where a customer wants to cancel a recent order to make some changes or reorder a previous order.
   *
   *	The replicated Cart preserves Customer information, Line Items and Custom Line Items, Custom Fields, Discount Codes, and other settings of the Cart or Order. If the Line Items become invalid, for example, due to removed Products or Prices, they are removed from the new Cart. If the Customer switches to another Customer Group, the new Cart is updated with the new value. It has up-to-date Tax Rates, Prices, and Line Item product data and is in `Active` [CartState](ctp:api:type:CartState).
   *
   *	The new Cart does not contain payments or deliveries. The [State](ctp:api:type:ItemState) of Line Items and Custom Line Items is reset to `initial`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/carts/replicate",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCartsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given `id`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Updates a [Cart](ctp:api:type:Cart) in the [Store](ctp:api:type:Store) specified by `storeKey`.
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCartsCustomerIdByCustomerIdRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves the recently modified active Cart of a Customer with [CartOrigin](ctp:api:type:CartOrigin) `Customer`. If no active Cart exists, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/carts/customer-id={customerId}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart of a Customer exists. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/carts/customer-id={customerId}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCartsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/carts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given `key`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/carts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/carts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/carts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCartsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withCustomerId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCartsCustomerIdByCustomerIdRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCartsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  replicate() {
    return new ByProjectKeyInStoreKeyByStoreKeyCartsReplicateRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCartsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Queries carts in a specific [Store](ctp:api:type:Store).
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/carts",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given Query Predicate. Returns a `200 OK` status if any Carts match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/carts",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creates a [Cart](ctp:api:type:Cart) in the [Store](ctp:api:type:Store) specified by `storeKey`.
   *	When using this endpoint the Cart's `store` field is always set to the [Store](ctp:api:type:Store) specified in the path parameter.
   *	If the referenced [ShippingMethod](ctp:api:type:ShippingMethod) in the [CartDraft](ctp:api:type:CartDraft) has a predicate that does not match, an [InvalidOperation](ctp:api:type:InvalidOperationError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/carts",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCustomersEmailConfirmRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	The customer verifies the email using the token value.
   *	Verifying the email of the Customer produces the [CustomerEmailVerified](ctp:api:type:CustomerEmailVerifiedMessage) Message.
   *
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers/email/confirm",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCustomersEmailTokenRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers/email-token",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordTokenRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers/password-token",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Changing the password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=false`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers/password",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordResetRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Resetting the password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=true`.
   *
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers/password/reset",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCustomersByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Customer exists for a given `id`. Returns a `200 OK` status if the Customer exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting a Customer produces the [CustomerDeleted](ctp:api:type:CustomerDeletedMessage) Message.
   *
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCustomersEmailTokenByEmailTokenRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers/email-token={emailToken}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCustomersKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Customer exists for a given `key`. Returns a `200 OK` status if the Customer exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting a Customer produces the [CustomerDeleted](ctp:api:type:CustomerDeletedMessage) Message.
   *
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordTokenByPasswordTokenRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers/password-token={passwordToken}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyCustomersRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withPasswordToken(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordTokenByPasswordTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withEmailToken(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersEmailTokenByEmailTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  emailToken() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersEmailTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  emailConfirm() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersEmailConfirmRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  password() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  passwordReset() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordResetRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  passwordToken() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Customer exists for a given Query Predicate. Returns a `200 OK` status if any Customers match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	When using this endpoint, if omitted, the Customer `stores` field is set to the [Store](ctp:api:type:Store) specified in the path parameter.
   *
   *	If the `anonymousCart` field is set on the [CustomerDraft](ctp:api:type:CustomerDraft), then the newly created Customer will be assigned to that [Cart](ctp:api:type:Cart).
   *	Similarly, if the `anonymousId` field is set, the Customer will be set on all [Carts](ctp:api:type:Cart), [Orders](ctp:api:type:Order), [ShoppingLists](ctp:api:type:ShoppingList) and [Payments](ctp:api:type:Payment) with the same `anonymousId`.
   *	If a Cart with a `store` field specified, the `store` field must reference the same [Store](ctp:api:type:Store) specified in the `{storeKey}` path parameter.
   *	Creating a Customer produces the [CustomerCreated](ctp:api:type:CustomerCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/customers",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyLoginRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Authenticates a Customer associated with a [Store](ctp:api:type:Store). For more information, see [Global versus Store-specific Customers](/../api/customers-overview#global-versus-store-specific-customers).
   *
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns an [InvalidCredentials](ctp:api:type:InvalidCredentialsError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/login",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyMeCartsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks ifa My Cart exists for a given `id`. Returns a `200 OK` status if the My Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyMeCartsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyMeCartsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/carts",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given Query Predicate. Returns a `200 OK` status if any Carts match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/carts",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	The `store` field in the created [Cart](ctp:api:type:Cart) is set to the Store specified by the `storeKey` path parameter.
   *
   *	Specific Error Codes: [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/carts",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyMeEmailConfirmRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	This is the last step in the [email verification process of a Customer](/../api/projects/customers#email-verification-of-customer-in-store).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/email/confirm",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyMeLoginRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves the authenticated Customer (that matches the given email/password pair) if they are part of a specific [Store](ctp:api:type:Store).
   *
   *	- If the Customer does not have a Cart, the most recently modified anonymous cart becomes the Customer's Cart.
   *	- If the Customer already has a Cart, the most recently modified anonymous cart is handled according to [AnonymousCartSignInMode](ctp:api:type:AnonymousCartSignInMode).
   *
   *	If a Cart is returned as part of [CustomerSignInResult](ctp:api:type:CustomerSignInResult), it has been [recalculated](ctp:api:type:MyCartRecalculateAction) with up-to-date prices, taxes, discounts, and invalid line items removed.
   *
   *	If an account with the given credentials is not found, an [InvalidCredentials](ctp:api:type:InvalidCredentialsError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/login",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyMeOrdersByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/orders/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given `id`. Returns a `200 OK` status if the My Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/orders/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyMeOrdersRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyMeOrdersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/orders",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given Query Predicate. Returns a `200 OK` status if any Orders match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/orders",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	The Cart must have a [shipping address set](ctp:api:type:CartSetShippingAddressAction) for taxes to be calculated. When creating [B2B Orders](/associates-overview#b2b-resources), the Customer must have the `CreateMyOrdersFromMyCarts` [Permission](ctp:api:type:Permission).
   *
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [DiscountCodeNonApplicable](ctp:api:type:DiscountCodeNonApplicableError)
   *	- [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *	- [AssociateMissingPermission](ctp:api:type:AssociateMissingPermissionError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/orders",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyMePasswordResetRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	This is the last step in the [password reset process of the authenticated Customer](/../api/projects/customers#password-reset-of-customer-in-store).
   *
   *	Resetting a password produces the of the Customer [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=true`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/password/reset",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyMePasswordRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  reset() {
    return new ByProjectKeyInStoreKeyByStoreKeyMePasswordResetRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Changing the password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=false`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/password",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/shopping-lists/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given `id`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/shopping-lists/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/shopping-lists/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/shopping-lists/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store), the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/shopping-lists/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given `key`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/shopping-lists/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/shopping-lists/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/shopping-lists/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/shopping-lists",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given Query Predicate. Returns a `200 OK` status if any ShoppingLists match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/shopping-lists",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	When using this endpoint, the `store` field of a ShoppingList is always set to the [Store](ctp:api:type:Store) specified in the path parameter.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/shopping-lists",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyMeSignupRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If omitted in the request body, the [Customer](ctp:api:type:Customer) `stores` field is set to the [Store](ctp:api:type:Store) specified in the path parameter.
   *
   *	Creating a Customer produces the [CustomerCreated](ctp:api:type:CustomerCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me/signup",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyMeRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	A shopping cart holds product variants and can be ordered.
   */
  carts() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeCartsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	An order can be created from a order, usually after a checkout process has been completed.
   */
  orders() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeOrdersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  activeCart() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeActiveCartRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	shopping-lists e.g. for wishlist support
   *
   */
  shoppingLists() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  emailConfirm() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeEmailConfirmRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  password() {
    return new ByProjectKeyInStoreKeyByStoreKeyMePasswordRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  signup() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeSignupRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  login() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeLoginRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/me",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyOrdersByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/orders/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given `id`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/orders/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/orders/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	Deleting an Order produces the [OrderDeleted](ctp:api:type:OrderDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/orders/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyOrdersOrderNumberByOrderNumberRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/orders/order-number={orderNumber}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given `orderNumber`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/orders/order-number={orderNumber}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/orders/order-number={orderNumber}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	Deleting an Order produces the [OrderDeleted](ctp:api:type:OrderDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/orders/order-number={orderNumber}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyOrdersRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withOrderNumber(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyOrdersOrderNumberByOrderNumberRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyOrdersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/orders",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given Query Predicate. Returns a `200 OK` status if any Orders match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/orders",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Before you create an Order, the Cart must have a [shipping address set](ctp:api:type:CartSetShippingAddressAction).
   *	The shipping address is used for tax calculation for a Cart with `Platform` [TaxMode](ctp:api:type:TaxMode).
   *
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [DiscountCodeNonApplicable](ctp:api:type:DiscountCodeNonApplicableError)
   *	- [ShippingMethodDoesNotMatchCart](ctp:api:type:ShippingMethodDoesNotMatchCartError)
   *	- [InvalidItemShippingDetails](ctp:api:type:InvalidItemShippingDetailsError)
   *	- [MatchingPriceNotFound](ctp:api:type:MatchingPriceNotFoundError)
   *	- [MissingTaxRateForCountry](ctp:api:type:MissingTaxRateForCountryError)
   *	- [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/orders",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyProductProjectionsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Gets the current or staged representation of a [Product](ctp:api:type:Product) by its ID from the specified [Store](ctp:api:type:Store).
   *	If the Store has defined some languages, countries, distribution, supply Channels, and/or Product Selection,
   *	they are used for projections based on [locale](ctp:api:type:ProductProjectionLocales), [price](ctp:api:type:ProductProjectionPrices)
   *	and [inventory](ctp:api:type:ProductProjectionInventoryEntries).
   *
   *	If [ProductSelection](ctp:api:type:ProductSelection) is used, it affects the [availability of the Product](/projects/stores#products-available-in-store) in the specified Store.
   *
   *	When used with an API Client that has the `view_published_products:{projectKey}` scope, this endpoint only returns published (current) Product Projections.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/product-projections/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if the current or staged representations of a Product exists for a given `id` in the specified [Store](ctp:api:type:Store). Returns a `200 OK` status if the ProductProjection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/product-projections/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyProductProjectionsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Gets the current or staged representation of a [Product](ctp:api:type:Product) by its key from the specified [Store](ctp:api:type:Store).
   *	If the Store has defined some languages, countries, distribution, supply Channels, and/or Product Selection,
   *	they are used for projections based on [locale](ctp:api:type:ProductProjectionLocales), [price](ctp:api:type:ProductProjectionPrices)
   *	and [inventory](ctp:api:type:ProductProjectionInventoryEntries).
   *
   *	If [ProductSelection](ctp:api:type:ProductSelection) is used, it affects the [availability of the Product](/projects/stores#products-available-in-store) in the specified Store.
   *
   *	When used with an API Client that has the `view_published_products:{projectKey}` scope, this endpoint only returns published (current) Product Projections.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/product-projections/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if the current or staged representations of a Product exists for a given `key` in the specified [Store](ctp:api:type:Store). Returns a `200 OK` status if the ProductProjection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/product-projections/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyProductProjectionsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyProductProjectionsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyProductProjectionsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
};
var ByProjectKeyInStoreKeyByStoreKeyProductSelectionAssignmentsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Queries Product Selection assignments in a specific [Store](ctp:api:type:Store).
   *
   *	The response will include duplicate Products whenever more than one active Product Selection of the Store
   *	includes a Product. To make clear through which Product Selection a Product is available in the Store
   *	the response contains assignments including both the Product and the Product Selection.
   *	Only Products of Product Selections that are activated in the Store will be returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/product-selection-assignments",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyShippingMethodsMatchingCartRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves all the ShippingMethods that can ship to the shipping address of the given Cart in a given [Store](ctp:api:type:Store).
   *	Each ShippingMethod contains exactly one ShippingRate with the flag `isMatching` set to `true`.
   *	This ShippingRate is used when the ShippingMethod is [added to the Cart](ctp:api:type:CartSetShippingMethodAction).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/shipping-methods/matching-cart",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShippingMethod that can ship to the shipping address of the given Cart exists in the given [Store](ctp:api:type:Store). Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/shipping-methods/matching-cart",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyShippingMethodsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Get ShippingMethods for a cart in a store
   */
  matchingCart() {
    return new ByProjectKeyInStoreKeyByStoreKeyShippingMethodsMatchingCartRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
};
var ByProjectKeyInStoreKeyByStoreKeyShoppingListsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/shopping-lists/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given `id`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/shopping-lists/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/shopping-lists/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/shopping-lists/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyShoppingListsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/shopping-lists/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given `key`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/shopping-lists/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/shopping-lists/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/shopping-lists/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyShoppingListsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyShoppingListsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyShoppingListsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/shopping-lists",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given Query Predicate. Returns a `200 OK` status if any ShoppingLists match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/shopping-lists",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	When using this endpoint, the `store` field of a ShoppingList is always set to the [Store](ctp:api:type:Store) specified in the path parameter.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/in-store/key={storeKey}/shopping-lists",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInStoreKeyByStoreKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	A shopping cart holds product variants and can be ordered.
   */
  carts() {
    return new ByProjectKeyInStoreKeyByStoreKeyCartsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	An order can be created from a cart, usually after a checkout process has been completed.
   */
  orders() {
    return new ByProjectKeyInStoreKeyByStoreKeyOrdersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  me() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A Customer is a person purchasing products. Carts, Orders,
   *	Comments and Reviews can be associated to a Customer.
   *
   */
  customers() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Retrieves the authenticated customer.
   */
  login() {
    return new ByProjectKeyInStoreKeyByStoreKeyLoginRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  shippingMethods() {
    return new ByProjectKeyInStoreKeyByStoreKeyShippingMethodsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	shopping-lists e.g. for wishlist support
   *
   */
  shoppingLists() {
    return new ByProjectKeyInStoreKeyByStoreKeyShoppingListsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  productProjections() {
    return new ByProjectKeyInStoreKeyByStoreKeyProductProjectionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  productSelectionAssignments() {
    return new ByProjectKeyInStoreKeyByStoreKeyProductSelectionAssignmentsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  cartDiscounts() {
    return new ByProjectKeyInStoreKeyByStoreKeyCartDiscountsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
};
var ByProjectKeyInventoryByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/inventory/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an InventoryEntry exists for a given `id`. Returns a `200 OK` status if the InventoryEntry exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/inventory/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/inventory/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Produces the [InventoryEntryDeleted](ctp:api:type:InventoryEntryDeletedMessage) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/inventory/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInventoryKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/inventory/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an InventoryEntry exists for a given `key`. Returns a `200 OK` status if the InventoryEntry exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/inventory/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/inventory/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Produces the [InventoryEntryDeleted](ctp:api:type:InventoryEntryDeletedMessage) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/inventory/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyInventoryRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyInventoryByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyInventoryKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/inventory",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an InventoryEntry exists for a given Query Predicate. Returns a `200 OK` status if any Inventory Entries match the Query Predicate, a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/inventory",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Produces the [InventoryEntryCreated](ctp:api:type:InventoryEntryCreatedMessage) Message.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/inventory",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyLoginRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Authenticates a global Customer not associated with a Store.
   *	For more information, see [Global versus Store-specific Customers](/../api/customers-overview#global-versus-store-specific-customers).
   *	If the Customer is registered in a Store, use the [Authenticate (sign in) Customer in Store](ctp:api:endpoint:/{projectKey}/in-store/key={storeKey}/login:POST) method.
   *
   *	If an account with the given credentials is not found, an [InvalidCredentials](ctp:api:type:InvalidCredentialsError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/login",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeBusinessUnitsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/business-units/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given `id`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/business-units/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/business-units/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/me/business-units/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeBusinessUnitsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/business-units/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given `key`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/business-units/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/business-units/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/me/business-units/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeBusinessUnitsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyMeBusinessUnitsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyMeBusinessUnitsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/business-units",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given Query Predicate. Returns a `200 OK` status if any BusinessUnits match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/business-units",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Automatically assigns the Associate to the Business Unit in the default [Associate Role](ctp:api:type:AssociateRole) defined in [BusinessUnitConfiguration](ctp:api:type:BusinessUnitConfiguration). If there is no default Associate Role configured, this request fails with an [InvalidOperation](ctp:api:type:InvalidOperationError) error. When creating a Division, the Associate must have the `AddChildUnits` [Permission](ctp:api:type:Permission) in the parent unit. If the required [Permission](/projects/associate-roles#permission) is missing, an [AssociateMissingPermission](/errors#associatemissingpermission) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/business-units",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeCartsReplicateRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Creates a new Cart by replicating an existing Cart or Order of the authenticated Customer.
   *	This can be useful in cases where a customer wants to cancel a recent order to make some changes or reorder a previous order.
   *
   *	The replicated Cart preserves Customer information, Line Items and Custom Line Items, Custom Fields, Discount Codes, and other settings of the Cart or Order.
   *	If the Line Items become invalid, for example, due to removed Products or Prices, they are removed from the new Cart.
   *	If the Customer switches to another Customer Group, the new Cart is updated with the new value.
   *	It has up-to-date Tax Rates, Prices, and Line Item product data and is in `Active` [CartState](ctp:api:type:CartState).
   *
   *	The new Cart does not contain Payments or Deliveries. The [State](ctp:api:type:ItemState) of Line Items and Custom Line Items is reset to `initial`.
   *
   *	In case the Cart or Order to be replicated does not belong to the authenticaed Customer, the API returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/carts/replicate",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeCartsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given `id`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/me/carts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeCartsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/carts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given `key`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/carts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/carts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/me/carts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeCartsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyMeCartsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyMeCartsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  replicate() {
    return new ByProjectKeyMeCartsReplicateRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/carts",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given Query Predicate. Returns a `200 OK` status if any Carts match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/carts",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/carts",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeEmailConfirmRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	This is the last step in the [email verification process of a Customer](/../api/projects/customers#email-verification-of-customer).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/email/confirm",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeLoginRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves the authenticated customer (that matches the given email/password pair).
   *
   *	If used with [an access token for an anonymous session](ctp:api:type:AnonymousSession), all Orders and Carts that belong to the `anonymousId` are assigned to the newly logged-in Customer.
   *
   *	- If the Customer does not have a Cart yet, the most recently modified anonymous cart becomes the Customer's Cart.
   *	- If the Customer already has a Cart, the most recently modified anonymous cart is handled in accordance with [AnonymousCartSignInMode](ctp:api:type:AnonymousCartSignInMode).
   *
   *	A Cart returned as part of the [CustomerSignInResult](ctp:api:type:CustomerSignInResult) is [recalculated](ctp:api:type:MyCartRecalculateAction) with up-to-date prices, taxes, discounts, and invalid line items removed.
   *
   *	If an account with the given credentials is not found, an [InvalidCredentials](ctp:api:type:InvalidCredentialsError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/login",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeOrdersQuotesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	When creating [B2B Orders](/associates-overview#b2b-resources), the Customer must have the `CreateMyOrdersFromMyQuotes` [Permission](ctp:api:type:Permission).
   *
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [InvalidItemShippingDetails](ctp:api:type:InvalidItemShippingDetailsError)
   *	- [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *	- [AssociateMissingPermission](ctp:api:type:AssociateMissingPermissionError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/orders/quotes",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeOrdersByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/orders/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given `id`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/orders/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeOrdersRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyMeOrdersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  orderQuote() {
    return new ByProjectKeyMeOrdersQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/orders",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given Query Predicate. Returns a `200 OK` status if any Orders match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/orders",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	The Cart must have a [shipping address set](ctp:api:type:CartSetShippingAddressAction) for taxes to be calculated. When creating [B2B Orders](/associates-overview#b2b-resources), the Customer must have the `CreateMyOrdersFromMyCarts` [Permission](ctp:api:type:Permission).
   *
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [DiscountCodeNonApplicable](ctp:api:type:DiscountCodeNonApplicableError)
   *	- [AssociateMissingPermission](ctp:api:type:AssociateMissingPermissionError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/orders",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMePasswordResetRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	This is the last step in the [password reset process of a Customer](/../api/projects/customers#password-reset-of-customer).
   *
   *	Resetting a password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=true`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/password/reset",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMePasswordRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  reset() {
    return new ByProjectKeyMePasswordResetRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Changing the password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=false`.
   *
   *	If the current password does not match, an [InvalidCurrentPassword](ctp:api:type:InvalidCurrentPasswordError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/password",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMePaymentsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/payments/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Payment exists for a given `id`. Returns a `200 OK` status if the Payment exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/payments/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	This endpoint can only update a Payment when it has no [Transactions](ctp:api:type:Transaction).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/payments/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	This endpoint can only delete a Payment when it has no [Transactions](ctp:api:type:Transaction).
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/me/payments/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMePaymentsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyMePaymentsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/payments",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Payment exists for a given Query Predicate. Returns a `200 OK` status if any Payments match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/payments",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creating a Payment produces the [PaymentCreated](ctp:api:type:PaymentCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/payments",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeQuoteRequestsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/quote-requests/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if my QuoteRequest exists for a given `id`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/quote-requests/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/quote-requests/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/me/quote-requests/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeQuoteRequestsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/quote-requests/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if my QuoteRequest exists for a given `key`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/quote-requests/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/quote-requests/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/me/quote-requests/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeQuoteRequestsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyMeQuoteRequestsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyMeQuoteRequestsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/quote-requests",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if my QuoteRequest exists for a given Query Predicate. Returns a `200 OK` status if any QuoteRequests match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/quote-requests",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/quote-requests",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeQuotesByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/quotes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given `id`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/quotes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/quotes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeQuotesKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/quotes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given `key`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/quotes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/quotes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeQuotesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyMeQuotesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyMeQuotesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/quotes",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given Query Predicate. Returns a `200 OK` status if any Quotes match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/quotes",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeShoppingListsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/shopping-lists/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given `id`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/shopping-lists/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/shopping-lists/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/me/shopping-lists/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeShoppingListsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/shopping-lists/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given `key`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/shopping-lists/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/shopping-lists/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/me/shopping-lists/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeShoppingListsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyMeShoppingListsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyMeShoppingListsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me/shopping-lists",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given Query Predicate. Returns a `200 OK` status if any ShoppingLists match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/me/shopping-lists",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/shopping-lists",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeSignupRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If used with an [access token for an anonymous session](ctp:api:type:AnonymousSession), all Orders and Carts that belong to the `anonymousId` are assigned to the newly created Customer.
   *
   *	Creating a Customer produces the [CustomerCreated](ctp:api:type:CustomerCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me/signup",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMeRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  emailConfirm() {
    return new ByProjectKeyMeEmailConfirmRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  password() {
    return new ByProjectKeyMePasswordRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  signup() {
    return new ByProjectKeyMeSignupRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  login() {
    return new ByProjectKeyMeLoginRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  activeCart() {
    return new ByProjectKeyMeActiveCartRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	MyBusinessUnit creates and provides access to Business Units scoped to a specific user.
   */
  businessUnits() {
    return new ByProjectKeyMeBusinessUnitsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A shopping cart holds product variants and can be ordered.
   */
  carts() {
    return new ByProjectKeyMeCartsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	An order can be created from a cart, usually after a checkout process has been completed.
   */
  orders() {
    return new ByProjectKeyMeOrdersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	The My Payments endpoint creates and provides access to payments scoped to a specific user.
   */
  payments() {
    return new ByProjectKeyMePaymentsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	The My Quote Requests endpoint creates and provides access to Quote Requests scoped to a specific user.
   */
  quoteRequests() {
    return new ByProjectKeyMeQuoteRequestsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	The My Quote endpoint provides access to Quotes scoped to a specific user.
   */
  quotes() {
    return new ByProjectKeyMeQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	The My Shopping Lists endpoint creates and provides access to Shopping Lists scoped to a specific user.
   */
  shoppingLists() {
    return new ByProjectKeyMeShoppingListsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/me",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/me",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/me",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMessagesByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Deprecated scope: `view_orders:{projectKey}`
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/messages/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Message exists for a given `id`. Returns a `200 OK` status if the Message exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/messages/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
};
var ByProjectKeyMessagesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyMessagesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Deprecated scope: `view_orders:{projectKey}`
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/messages",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Message exists for a given Query Predicate. Returns a `200 OK` status if any Messages match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/messages",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyOrdersEditsByIDApplyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Applying an OrderEdit produces the [OrderEditApplied](ctp:api:type:OrderEditAppliedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/orders/edits/{ID}/apply",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyOrdersEditsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  apply() {
    return new ByProjectKeyOrdersEditsByIDApplyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/orders/edits/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an OrderEdit exists for a given `id`. Returns a `200 OK` status if the OrderEdit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/orders/edits/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/orders/edits/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/orders/edits/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyOrdersEditsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/orders/edits/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an OrderEdit exists for a given `key`. Returns a `200 OK` status if the OrderEdit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/orders/edits/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/orders/edits/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/orders/edits/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyOrdersEditsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyOrdersEditsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyOrdersEditsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/orders/edits",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an OrderEdit exists for a given Query Predicate. Returns a `200 OK` status if any OrderEdits match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/orders/edits",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	You can either create multiple Order Edits for an Order and apply them sequentially to an Order, or create multiple Order Edits parallelly (as alternatives to each other) and apply one of them to the Order.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/orders/edits",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyOrdersImportRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Importing an Order produces the [Order Imported](ctp:api:type:OrderImportedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/orders/import",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyOrdersQuotesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [InvalidItemShippingDetails](ctp:api:type:InvalidItemShippingDetailsError)
   *	- [InvalidOperation](ctp:api:type:InvalidOperationError)
   *	- [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/orders/quotes",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyOrdersSearchRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/orders/search",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Checks whether a search index for the Project's Orders exists.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/orders/search",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
};
var ByProjectKeyOrdersByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/orders/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given `id`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/orders/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/orders/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting an Order produces the [OrderDeleted](ctp:api:type:OrderDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/orders/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyOrdersOrderNumberByOrderNumberRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/orders/order-number={orderNumber}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given `orderNumber`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/orders/order-number={orderNumber}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/orders/order-number={orderNumber}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting an Order produces the [OrderDeleted](ctp:api:type:OrderDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/orders/order-number={orderNumber}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyOrdersRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  importOrder() {
    return new ByProjectKeyOrdersImportRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  orderQuote() {
    return new ByProjectKeyOrdersQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withOrderNumber(childPathArgs) {
    return new ByProjectKeyOrdersOrderNumberByOrderNumberRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	OrderEdit are containers for financial changes after an Order has been placed.
   */
  edits() {
    return new ByProjectKeyOrdersEditsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyOrdersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	This endpoint provides high performance search queries over Orders. The order search allows searching through all orders (currently supporting a limit of the 10.000.000 newest orders) in your project.
   *
   */
  search() {
    return new ByProjectKeyOrdersSearchRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/orders",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given Query Predicate. Returns a `200 OK` status if any Orders match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/orders",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Before you create an Order, the Cart must have a [shipping address set](ctp:api:type:CartSetShippingAddressAction).
   *	The shipping address is used for tax calculation for a Cart with `Platform` [TaxMode](ctp:api:type:TaxMode).
   *
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [DiscountCodeNonApplicable](ctp:api:type:DiscountCodeNonApplicableError)
   *	- [ShippingMethodDoesNotMatchCart](ctp:api:type:ShippingMethodDoesNotMatchCartError)
   *	- [InvalidItemShippingDetails](ctp:api:type:InvalidItemShippingDetailsError)
   *	- [MatchingPriceNotFound](ctp:api:type:MatchingPriceNotFoundError)
   *	- [MissingTaxRateForCountry](ctp:api:type:MissingTaxRateForCountryError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/orders",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyPaymentsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/payments/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Payment exists for a given `id`. Returns a `200 OK` status if the Payment exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/payments/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/payments/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/payments/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyPaymentsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/payments/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Payment exists for a given `key`. Returns a `200 OK` status if the Payment exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/payments/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/payments/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/payments/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyPaymentsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyPaymentsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyPaymentsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/payments",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Payment exists for a given Query Predicate. Returns a `200 OK` status if any Payments match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/payments",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creating a Payment produces the [PaymentCreated](ctp:api:type:PaymentCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/payments",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductDiscountsMatchingRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	This endpoint can be used to simulate which Product Discounts would be applied if a specified Product Variant had a specified Price.
   *	Given Product and Product Variant IDs and a Price, this endpoint will return the [ProductDiscount](ctp:api:type:ProductDiscount) that would have been applied to that Price.
   *
   *	If a Product Discount could not be found that could be applied to the Price of a Product Variant, a [NoMatchingProductDiscountFound](ctp:api:type:NoMatchingProductDiscountFoundError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/product-discounts/matching",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductDiscountsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/product-discounts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductDiscount exists for a given `id`. Returns a `200 OK` status if the ProductDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/product-discounts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/product-discounts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/product-discounts/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductDiscountsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/product-discounts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductDiscount exists for a given `key`. Returns a `200 OK` status if the ProductDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/product-discounts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/product-discounts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/product-discounts/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductDiscountsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  matching() {
    return new ByProjectKeyProductDiscountsMatchingRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyProductDiscountsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyProductDiscountsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/product-discounts",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductDiscount exists for a given Query Predicate. Returns a `200 OK` status if any ProductDiscounts match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/product-discounts",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/product-discounts",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductProjectionsSearchRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Product Projection Search
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/product-projections/search",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Product Projection Search
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/product-projections/search",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductProjectionsSuggestRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/product-projections/suggest",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductProjectionsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Gets the current or staged representation of a [Product](ctp:api:type:Product) by its ID. When used with an API Client that has the `view_published_products:{projectKey}` scope, this endpoint only returns published (current) Product Projections.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/product-projections/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if the current or staged representation of a Product exists for a given `id`. Returns a `200 OK` status if the ProductProjection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/product-projections/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductProjectionsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Gets the current or staged representation of a [Product](ctp:api:type:Product) found by Key.
   *	When used with an API Client that has the `view_published_products:{projectKey}` scope,
   *	this endpoint only returns published (current) Product Projections.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/product-projections/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if the current or staged representation of a Product exists for a given `key`. Returns a `200 OK` status if the ProductProjection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/product-projections/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductProjectionsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	This endpoint provides high performance search queries over ProductProjections. The query result contains the
   *	ProductProjections for which at least one ProductVariant matches the search query. This means that variants can
   *	be included in the result also for which the search query does not match. To determine which ProductVariants match
   *	the search query, the returned ProductProjections include the additional field isMatchingVariant.
   *
   */
  search() {
    return new ByProjectKeyProductProjectionsSearchRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	The source of data for suggestions is the searchKeyword field in a product
   */
  suggest() {
    return new ByProjectKeyProductProjectionsSuggestRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyProductProjectionsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyProductProjectionsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Use the Product Projections query endpoint to get the current or staged representations of Products.
   *	When used with an API Client that has the `view_published_products:{projectKey}` scope,
   *	this endpoint only returns published (current) Product Projections.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/product-projections",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if the current or staged representation of a Product exists for a given Query Predicate. Returns a `200 OK` status if any ProductProjections match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/product-projections",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductSelectionsByIDProductsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/product-selections/{ID}/products",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductSelectionsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  products() {
    return new ByProjectKeyProductSelectionsByIDProductsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/product-selections/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductSelection exists for a given `id`. Returns a `200 OK` status if the ProductSelection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/product-selections/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/product-selections/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Deletion will only succeed if the Product Selection is not assigned to any [Store](ctp:api:type:Store).
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/product-selections/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductSelectionsKeyByKeyProductsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/product-selections/key={key}/products",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductSelectionsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  products() {
    return new ByProjectKeyProductSelectionsKeyByKeyProductsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/product-selections/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductSelection exists for a given `key`. Returns a `200 OK` status if the ProductSelection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/product-selections/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/product-selections/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Deletion will only succeed if the Product Selection is not assigned to any [Store](ctp:api:type:Store).
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/product-selections/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductSelectionsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyProductSelectionsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyProductSelectionsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/product-selections",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductSelection exists for a given Query Predicate. Returns a `200 OK` status if any ProductSelections match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/product-selections",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/product-selections",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductTypesByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/product-types/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductType exists for a given `id`. Returns a `200 OK` status if the ProductType exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/product-types/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/product-types/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/product-types/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductTypesKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/product-types/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductType exists for a given `key`. Returns a `200 OK` status if the ProductType exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/product-types/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/product-types/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/product-types/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductTypesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyProductTypesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyProductTypesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/product-types",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductType exists for a given Query Predicate. Returns a `200 OK` status if any ProductTypes match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/product-types",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/product-types",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductsByIDImagesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Upload a JPEG, PNG and GIF file to a [ProductVariant](ctp:api:type:ProductVariant). The maximum file size of the image is 10MB. `variant` or `sku` is required to update a specific ProductVariant. The image is uploaded to the Master Variant if `variant` or `sku` are not included. Produces the [ProductImageAdded](/projects/messages#product-image-added) Message when the `Small` version of the image has been uploaded to the CDN.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/products/{ID}/images",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductsByIDProductSelectionsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/products/{ID}/product-selections",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  images() {
    return new ByProjectKeyProductsByIDImagesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  productSelections() {
    return new ByProjectKeyProductsByIDProductSelectionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/products/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Product exists for a given `id`. Returns a `200 OK` status if the Product exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/products/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   *
   *	A failed response can return a [DuplicatePriceScope](ctp:api:type:DuplicatePriceScopeError), [DuplicateVariantValues](ctp:api:type:DuplicateVariantValuesError), [DuplicateAttributeValue](ctp:api:type:DuplicateAttributeValueError), or [DuplicateAttributeValues](ctp:api:type:DuplicateAttributeValuesError) error.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/products/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   *	Produces the [ProductDeleted](/projects/messages#product-deleted) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/products/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductsKeyByKeyProductSelectionsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/products/key={key}/product-selections",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  productSelections() {
    return new ByProjectKeyProductsKeyByKeyProductSelectionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/products/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Product exists for a given `key`. Returns a `200 OK` status if the Product exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/products/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	A failed response can return a [DuplicatePriceScope](ctp:api:type:DuplicatePriceScopeError), [DuplicateVariantValues](ctp:api:type:DuplicateVariantValuesError), [DuplicateAttributeValue](ctp:api:type:DuplicateAttributeValueError), or [DuplicateAttributeValues](ctp:api:type:DuplicateAttributeValuesError) error.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/products/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   *	Produces the [ProductDeleted](/projects/messages#product-deleted) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/products/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyProductsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyProductsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyProductsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/products",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Product exists for a given Query Predicate. Returns a `200 OK` status if any Products match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/products",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	To create a new Product, send a representation that is going to become the initial _staged_ and _current_ representation of the new Product in the catalog.
   *	If [Price Selection](ctp:api:type:ProductPriceSelection) query parameters are provided, selected Prices will be added to the response.
   *	Produces the [ProductCreated](/projects/messages#product-created) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/products",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyQuoteRequestsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/quote-requests/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a QuoteRequest exists for a given `id`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/quote-requests/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/quote-requests/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/quote-requests/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyQuoteRequestsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/quote-requests/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a QuoteRequest exists for a given `key`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/quote-requests/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/quote-requests/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/quote-requests/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyQuoteRequestsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyQuoteRequestsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyQuoteRequestsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/quote-requests",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a QuoteRequest exists for a given Query Predicate. Returns a `200 OK` status if any QuoteRequests match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/quote-requests",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/quote-requests",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyQuotesByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/quotes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given `id`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/quotes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/quotes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/quotes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyQuotesKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/quotes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given `key`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/quotes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/quotes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/quotes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyQuotesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyQuotesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyQuotesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/quotes",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given Query Predicate. Returns a `200 OK` status if any Quotes match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/quotes",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/quotes",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyReviewsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/reviews/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Review exists for a given `id`. Returns a `200 OK` status if the Review exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/reviews/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/reviews/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/reviews/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyReviewsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/reviews/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Review exists for a given `key`. Returns a `200 OK` status if the Review exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/reviews/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/reviews/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/reviews/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyReviewsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyReviewsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyReviewsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/reviews",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Review exists for a given Query Predicate. Returns a `200 OK` status if any Reviews match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/reviews",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/reviews",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyShippingMethodsMatchingCartLocationRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves all the ShippingMethods that can ship to the given [Location](ctp:api:type:Location)
   *	with a `predicate` that matches the given Cart.
   *	Each ShippingMethod contains exactly one ShippingRate with the flag `isMatching` set to `true`.
   *	This ShippingRate is used when the ShippingMethod is [added to the Cart](ctp:api:type:CartSetShippingMethodAction).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/shipping-methods/matching-cart-location",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShippingMethod that can ship to the given [Location](ctp:api:type:Location) exists for the given Cart. Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/shipping-methods/matching-cart-location",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyShippingMethodsMatchingCartRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves all the ShippingMethods that can ship to the shipping address of the given Cart.
   *	Each ShippingMethod contains exactly one ShippingRate with the flag `isMatching` set to `true`.
   *	This ShippingRate is used when the ShippingMethod is [added to the Cart](ctp:api:type:CartSetShippingMethodAction).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/shipping-methods/matching-cart",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShippingMethod exists for the given Cart. Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/shipping-methods/matching-cart",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyShippingMethodsMatchingLocationRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves all the ShippingMethods that can ship to the given [Location](/projects/zones#location).
   *	ShippingMethods that have a `predicate` defined are automatically disqualified.
   *	If the `currency` parameter is given, then the ShippingMethods must also have a rate defined in the specified currency.
   *	Each ShippingMethod contains at least one ShippingRate with the flag `isMatching` set to `true`.
   *	If the `currency` parameter is given, exactly one ShippingRate will contain it.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/shipping-methods/matching-location",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShippingMethod that can ship to the given [Location](ctp:api:type:Location) exists. Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/shipping-methods/matching-location",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyShippingMethodsMatchingOrdereditRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves all the ShippingMethods that can ship to the given [Location](ctp:api:type:Location) for an [OrderEdit](ctp:api:type:OrderEdit).
   *
   *	If the OrderEdit preview cannot be generated, an [EditPreviewFailed](ctp:api:type:EditPreviewFailedError) error is returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/shipping-methods/matching-orderedit",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShippingMethod that can ship to the given [Location](ctp:api:type:Location) exists for the given [OrderEdit](ctp:api:type:OrderEdit). Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/shipping-methods/matching-orderedit",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyShippingMethodsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/shipping-methods/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShippingMethod exists for a given `id`. Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/shipping-methods/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/shipping-methods/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/shipping-methods/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyShippingMethodsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/shipping-methods/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShippingMethod exists for a given `key`. Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/shipping-methods/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/shipping-methods/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/shipping-methods/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyShippingMethodsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyShippingMethodsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Get ShippingMethods for a cart
   */
  matchingCart() {
    return new ByProjectKeyShippingMethodsMatchingCartRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Get ShippingMethods for a cart and location
   */
  matchingCartLocation() {
    return new ByProjectKeyShippingMethodsMatchingCartLocationRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Get ShippingMethods for an order edit
   */
  matchingOrderedit() {
    return new ByProjectKeyShippingMethodsMatchingOrdereditRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Get ShippingMethods for a location
   */
  matchingLocation() {
    return new ByProjectKeyShippingMethodsMatchingLocationRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyShippingMethodsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/shipping-methods",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShippingMethod exists for a given Query Predicate. Returns a `200 OK` status if any ShippingMethods match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/shipping-methods",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/shipping-methods",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyShoppingListsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/shopping-lists/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given `id`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/shopping-lists/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/shopping-lists/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/shopping-lists/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyShoppingListsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/shopping-lists/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given `key`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/shopping-lists/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/shopping-lists/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/shopping-lists/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyShoppingListsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyShoppingListsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyShoppingListsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/shopping-lists",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given Query Predicate. Returns a `200 OK` status if any ShoppingLists match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/shopping-lists",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/shopping-lists",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyStagedQuotesByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/staged-quotes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a StagedQuote exists for a given `id`. Returns a `200 OK` status if the StagedQuote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/staged-quotes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/staged-quotes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/staged-quotes/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyStagedQuotesKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/staged-quotes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a StagedQuote exists for a given `key`. Returns a `200 OK` status if the StagedQuote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/staged-quotes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/staged-quotes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/staged-quotes/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyStagedQuotesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyStagedQuotesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyStagedQuotesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/staged-quotes",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a StagedQuote exists for a given Query Predicate. Returns a `200 OK` status if any StagedQuotes match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/staged-quotes",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/staged-quotes",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyStandalonePricesByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/standalone-prices/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a StandalonePrice exists for a given `id`. Returns a `200 OK` status if the StandalonePrice exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/standalone-prices/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/standalone-prices/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Produces the [StandalonePriceDeleted](ctp:api:type:StandalonePriceDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/standalone-prices/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyStandalonePricesKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/standalone-prices/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a StandalonePrice exists for a given `key`. Returns a `200 OK` status if the StandalonePrice exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/standalone-prices/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/standalone-prices/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  /**
   *	Produces the [StandalonePriceDeleted](ctp:api:type:StandalonePriceDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/standalone-prices/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyStandalonePricesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyStandalonePricesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyStandalonePricesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/standalone-prices",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a StandalonePrice exists for a given Query Predicate. Returns a `200 OK` status if any StandalonePrices match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/standalone-prices",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Produces the [StandalonePriceCreated](ctp:api:type:StandalonePriceCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/standalone-prices",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyStatesByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/states/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a State exists for a given `id`. Returns a `200 OK` status if the State exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/states/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/states/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/states/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyStatesKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/states/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a State exists for a given `key`. Returns a `200 OK` status if the State exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/states/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/states/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/states/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyStatesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyStatesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyStatesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/states",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a State exists for a given Query Predicate. Returns a `200 OK` status if any States match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/states",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/states",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyStoresByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/stores/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Store exists for a given `id`. Returns a `200 OK` status if the Store exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/stores/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/stores/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/stores/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyStoresKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/stores/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Store exists for a given `key`. Returns a `200 OK` status if the Store exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/stores/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/stores/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/stores/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyStoresRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyStoresKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyStoresByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/stores",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Store exists for a given Query Predicate. Returns a `200 OK` status if any Stores match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/stores",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/stores",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeySubscriptionsByIDHealthRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  /**
   *	This endpoint can be polled by a monitoring or alerting system that checks the health of your Subscriptions. To ease integration with such systems this endpoint does not require [Authorization](/../api/authorization).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/subscriptions/{ID}/health",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
};
var ByProjectKeySubscriptionsByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withIdHealth() {
    return new ByProjectKeySubscriptionsByIDHealthRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/subscriptions/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Subscription exists for a given `id`. Returns a `200 OK` status if the Subscription exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/subscriptions/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/subscriptions/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/subscriptions/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeySubscriptionsKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/subscriptions/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Subscription exists for a given `key`. Returns a `200 OK` status if the Subscription exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/subscriptions/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/subscriptions/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/subscriptions/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeySubscriptionsRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeySubscriptionsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeySubscriptionsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/subscriptions",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Subscription exists for a given Query Predicate. Returns a `200 OK` status if any Subscriptions match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/subscriptions",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	A test message is sent to ensure the correct configuration of the Destination. If the message cannot be delivered, the Subscription will not be created. The payload of the test message is a notification of type [ResourceCreated](/../api/projects/subscriptions#resourcecreateddeliverypayload) for the `resourceTypeId` `subscription`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/subscriptions",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyTaxCategoriesByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/tax-categories/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a TaxCategory exists for a given `id`. Returns a `200 OK` status if the TaxCategory exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/tax-categories/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/tax-categories/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/tax-categories/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyTaxCategoriesKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/tax-categories/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a TaxCategory exists for a given `key`. Returns a `200 OK` status if the Tax Category exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/tax-categories/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/tax-categories/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/tax-categories/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyTaxCategoriesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyTaxCategoriesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyTaxCategoriesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/tax-categories",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a TaxCategory exists for a given Query Predicate. Returns a `200 OK` status if any TaxCategories match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/tax-categories",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/tax-categories",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyTypesByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/types/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Type exists for a given `id`. Returns a `200 OK` status if the Type exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/types/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/types/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/types/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyTypesKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/types/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Type exists for a given `key`. Returns a `200 OK` status if the Type exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/types/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/types/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/types/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyTypesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyTypesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyTypesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/types",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Type exists for a given Query Predicate. Returns a `200 OK` status if any Types match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/types",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/types",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyZonesByIDRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/zones/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Zone exists for a given `id`. Returns a `200 OK` status if the Zone exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/zones/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/zones/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/zones/{ID}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyZonesKeyByKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/zones/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Zone exists for a given `key`. Returns a `200 OK` status if the Zone exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/zones/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/zones/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "DELETE",
      uriTemplate: "/{projectKey}/zones/key={key}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
};
var ByProjectKeyZonesRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyZonesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyZonesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}/zones",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Zone exists for a given Query Predicate. Returns a `200 OK` status if any Zones match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}/zones",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}/zones",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ByProjectKeyRequestBuilder = class {
  constructor(args) {
    this.args = args;
  }
  asAssociate() {
    return new ByProjectKeyAsAssociateRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	An Associate Role enables permissions over a Business Unit to an Associate.
   */
  associateRoles() {
    return new ByProjectKeyAssociateRolesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A Business Unit can represent a Company or a Division.
   */
  businessUnits() {
    return new ByProjectKeyBusinessUnitsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Categories are used to organize products in a hierarchical structure.
   */
  categories() {
    return new ByProjectKeyCategoriesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A shopping cart holds product variants and can be ordered.
   */
  carts() {
    return new ByProjectKeyCartsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Cart discounts are used to change the prices of different elements within a cart.
   */
  cartDiscounts() {
    return new ByProjectKeyCartDiscountsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Channels represent a source or destination of different entities. They can be used to model warehouses or stores.
   *
   */
  channels() {
    return new ByProjectKeyChannelsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A Customer is a person purchasing products. Carts, Orders, Quotes, Reviews and Payments can be associated to a Customer.
   *
   */
  customers() {
    return new ByProjectKeyCustomersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	customer-groups are used to evaluate products and channels.
   */
  customerGroups() {
    return new ByProjectKeyCustomerGroupsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Store custom JSON values.
   */
  customObjects() {
    return new ByProjectKeyCustomObjectsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Discount Codes can be added to a discount-code to enable certain discount-code discounts.
   */
  discountCodes() {
    return new ByProjectKeyDiscountCodesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	commercetools Composable Commerce provides a GraphQL API
   */
  graphql() {
    return new ByProjectKeyGraphqlRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Inventory allows you to track stock quantities.
   */
  inventory() {
    return new ByProjectKeyInventoryRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Retrieves the authenticated customer.
   */
  login() {
    return new ByProjectKeyLoginRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A message represents a change or an action performed on a resource (like an Order or a Product).
   */
  messages() {
    return new ByProjectKeyMessagesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	An order can be created from a order, usually after a checkout process has been completed.
   */
  orders() {
    return new ByProjectKeyOrdersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Payments hold information about the current state of receiving and/or refunding money
   */
  payments() {
    return new ByProjectKeyPaymentsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Products themselves are not sellable. Instead, they act as a parent structure for sellable Product Variants.
   *
   */
  products() {
    return new ByProjectKeyProductsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Product discounts are used to change certain product prices.
   */
  productDiscounts() {
    return new ByProjectKeyProductDiscountsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A projected representation of a product shows the product with its current or staged data. The current or staged
   *	representation of a product in a catalog is called a product projection.
   *
   */
  productProjections() {
    return new ByProjectKeyProductProjectionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Manage individual Store assortments through Product Selections.
   *
   *	After you have created Product Selections and populated them with Products,
   *	you can manage Store assortments by assigning Product Selections to Stores.
   *	Product Selections may be used by a single Store or shared across several Stores.
   *
   *	As a good practice, we recommend first creating Products in the project, and then creating Product Selection.
   *
   */
  productSelections() {
    return new ByProjectKeyProductSelectionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Product Types are used to describe common characteristics, most importantly common custom attributes,
   *	of many concrete products.
   *
   */
  productTypes() {
    return new ByProjectKeyProductTypesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A quote holds the negotiated offer.
   */
  quotes() {
    return new ByProjectKeyQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A request for a Quote holds product variants and can be ordered.
   */
  quoteRequests() {
    return new ByProjectKeyQuoteRequestsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A staged quote holds the negotiation between the [Buyer](/../api/quotes-overview#buyer) and the [Seller](/../api/quotes-overview#seller).
   */
  stagedQuotes() {
    return new ByProjectKeyStagedQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Reviews are used to evaluate products and channels.
   */
  reviews() {
    return new ByProjectKeyReviewsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	ShippingMethods define where orders can be shipped and what the costs are.
   */
  shippingMethods() {
    return new ByProjectKeyShippingMethodsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	shopping-lists e.g. for wishlist support
   */
  shoppingLists() {
    return new ByProjectKeyShoppingListsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	commercetools Composable Commerce allows you to model states of certain objects, such as orders, line items, products,
   *	reviews, and payments in order to define finite state machines reflecting the business logic you'd like to
   *	implement.
   *
   */
  states() {
    return new ByProjectKeyStatesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Subscriptions allow you to be notified of new messages or changes via a Message Queue of your choice
   */
  subscriptions() {
    return new ByProjectKeySubscriptionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Tax Categories define how products are to be taxed in different countries.
   */
  taxCategories() {
    return new ByProjectKeyTaxCategoriesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Types define custom fields that are used to enhance resources as you need.
   */
  types() {
    return new ByProjectKeyTypesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Zones allow defining ShippingRates for specific Locations.
   */
  zones() {
    return new ByProjectKeyZonesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  me() {
    return new ByProjectKeyMeRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Extend the behavior of an API with your business logic
   */
  extensions() {
    return new ByProjectKeyExtensionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Manage your API Clients via an API. Useful for Infrastructure-as-Code tooling, and regularly rotating API secrets.
   *
   */
  apiClients() {
    return new ByProjectKeyApiClientsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Stores let you model the context your customers shop in.
   */
  stores() {
    return new ByProjectKeyStoresRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  inStoreKeyWithStoreKeyValue(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A standalone price assigns a price to a product variant for a given scope. The API will use the standalone prices associated with a Product if its field [`priceMode`](/projects/products#pricemode) is set to `Standalone` [ProductPriceMode](ctp:api:type:ProductPriceModeEnum).
   */
  standalonePrices() {
    return new ByProjectKeyStandalonePricesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  inBusinessUnitKeyWithBusinessUnitKeyValue(childPathArgs) {
    return new ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Attribute groups ... TODO
   */
  attributeGroups() {
    return new ByProjectKeyAttributeGroupsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "GET",
      uriTemplate: "/{projectKey}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Project exists for a given `projectKey`. Returns a `200 OK` status if the Project exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "HEAD",
      uriTemplate: "/{projectKey}",
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: "POST",
      uriTemplate: "/{projectKey}",
      pathVariables: this.args.pathArgs,
      headers: {
        "Content-Type": "application/json",
        ...methodArgs == null ? void 0 : methodArgs.headers
      },
      body: methodArgs == null ? void 0 : methodArgs.body
    }, this.args.executeRequest);
  }
};
var ApiRoot = class {
  constructor(args) {
    _defineProperty(this, "executeRequest", void 0);
    _defineProperty(this, "baseUri", void 0);
    this.executeRequest = args.executeRequest;
    this.baseUri = args.baseUri || "https://api.europe-west1.gcp.commercetools.com";
  }
  /**
   *	The Project endpoint is used to retrieve certain information from a project.
   */
  withProjectKey(childPathArgs) {
    return new ByProjectKeyRequestBuilder({
      pathArgs: {
        ...childPathArgs
      },
      executeRequest: this.executeRequest,
      baseUri: this.baseUri
    });
  }
};
function createApiBuilderFromCtpClient(ctpClient, baseUri) {
  return new ApiRoot({
    executeRequest: ctpClient.execute,
    baseUri
  });
}

// node_modules/@commercetools/sdk-client-v2/dist/commercetools-sdk-client-v2.esm.js
init_lib();
var import_buffer = __toESM(require_buffer());
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function urlParser(url) {
  const object = {};
  const data = new URLSearchParams(url);
  for (let x of data.keys()) {
    if (data.getAll(x).length > 1) {
      object[x] = data.getAll(x);
    } else {
      object[x] = data.get(x);
    }
  }
  return object;
}
function parseURLString(url, parser = urlParser) {
  return parser(url);
}
var METHODS = ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE"];
function validate(funcName, request, options = {
  allowedMethods: METHODS
}) {
  if (!request)
    throw new Error(`The "${funcName}" function requires a "Request" object as an argument. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest`);
  if (typeof request.uri !== "string")
    throw new Error(`The "${funcName}" Request object requires a valid uri. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest`);
  if (!options.allowedMethods.includes(request.method))
    throw new Error(`The "${funcName}" Request object requires a valid method. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest`);
}
var _options;
function compose(...funcs) {
  funcs = funcs.filter((func) => typeof func === "function");
  if (funcs.length === 1)
    return funcs[0];
  return funcs.reduce((a, b) => (...args) => a(b(...args)));
}
function process$1(request, fn, processOpt) {
  validate("process", request, {
    allowedMethods: ["GET"]
  });
  if (typeof fn !== "function")
    throw new Error('The "process" function accepts a "Function" as a second argument that returns a Promise. See https://commercetools.github.io/nodejs/sdk/api/sdkClient.html#processrequest-processfn-options');
  const opt = {
    total: Number.POSITIVE_INFINITY,
    accumulate: true,
    ...processOpt
  };
  return new Promise((resolve2, reject) => {
    let _path, _queryString = "";
    if (request && request.uri) {
      const [path, queryString] = request.uri.split("?");
      _path = path;
      _queryString = queryString;
    }
    const requestQuery = {
      ...parseURLString(_queryString)
    };
    const query2 = {
      // defaults
      limit: 20,
      // merge given query params
      ...requestQuery
    };
    let hasFirstPageBeenProcessed = false;
    let itemsToGet = opt.total;
    const processPage = async (lastId, acc = []) => {
      const limit = query2.limit < itemsToGet ? query2.limit : itemsToGet;
      const originalQueryString = new URLSearchParams({
        ...query2,
        limit
      }).toString();
      const enhancedQuery = {
        sort: "id asc",
        withTotal: false,
        ...lastId ? {
          where: `id > "${lastId}"`
        } : {}
      };
      const enhancedQueryString = new URLSearchParams(enhancedQuery).toString();
      const enhancedRequest = {
        ...request,
        uri: `${_path}?${enhancedQueryString}&${originalQueryString}`
      };
      try {
        const payload = await createClient(_options).execute(enhancedRequest);
        const {
          results,
          count: resultsLength
        } = payload.body;
        if (!resultsLength && hasFirstPageBeenProcessed) {
          return resolve2(acc || []);
        }
        const result = await Promise.resolve(fn(payload));
        let accumulated;
        hasFirstPageBeenProcessed = true;
        if (opt.accumulate)
          accumulated = acc.concat(result || []);
        itemsToGet -= resultsLength;
        if (resultsLength < query2.limit || !itemsToGet) {
          return resolve2(accumulated || []);
        }
        const last = results[resultsLength - 1];
        const newLastId = last && last.id;
        processPage(newLastId, accumulated);
      } catch (error) {
        reject(error);
      }
    };
    processPage();
  });
}
function createClient(options) {
  _options = options;
  if (!options)
    throw new Error("Missing required options");
  if (options.middlewares && !Array.isArray(options.middlewares))
    throw new Error("Middlewares should be an array");
  if (!options.middlewares || !Array.isArray(options.middlewares) || !options.middlewares.length)
    throw new Error("You need to provide at least one middleware");
  return {
    /**
     * Given a request object,
     */
    process: process$1,
    execute(request) {
      validate("exec", request);
      return new Promise((resolve2, reject) => {
        const resolver = (rq, rs) => {
          if (rs.error)
            rs.reject(rs.error);
          else {
            const resObj = {
              body: rs.body || {},
              statusCode: rs.statusCode
            };
            if (rs.headers)
              resObj.headers = rs.headers;
            if (rs.request)
              resObj.request = rs.request;
            rs.resolve(resObj);
          }
        };
        const dispatch = compose(...options.middlewares)(resolver);
        dispatch(
          request,
          // Initial response shape
          {
            resolve: resolve2,
            reject,
            body: void 0,
            error: void 0
          }
        );
      });
    }
  };
}
function buildRequestForClientCredentialsFlow(options) {
  if (!options)
    throw new Error("Missing required options");
  if (!options.host)
    throw new Error("Missing required option (host)");
  if (!options.projectKey)
    throw new Error("Missing required option (projectKey)");
  if (!options.credentials)
    throw new Error("Missing required option (credentials)");
  const {
    clientId,
    clientSecret
  } = options.credentials;
  if (!(clientId && clientSecret))
    throw new Error("Missing required credentials (clientId, clientSecret)");
  const scope = options.scopes ? options.scopes.join(" ") : void 0;
  const basicAuth = import_buffer.Buffer.from(`${clientId}:${clientSecret}`).toString("base64");
  const oauthUri = options.oauthUri || "/oauth/token";
  const url = options.host.replace(/\/$/, "") + oauthUri;
  const body = `grant_type=client_credentials${scope ? `&scope=${scope}` : ""}`;
  return {
    basicAuth,
    url,
    body
  };
}
function buildRequestForPasswordFlow(options) {
  if (!options)
    throw new Error("Missing required options");
  if (!options.host)
    throw new Error("Missing required option (host)");
  if (!options.projectKey)
    throw new Error("Missing required option (projectKey)");
  if (!options.credentials)
    throw new Error("Missing required option (credentials)");
  const {
    clientId,
    clientSecret,
    user
  } = options.credentials;
  const pKey = options.projectKey;
  if (!(clientId && clientSecret && user))
    throw new Error("Missing required credentials (clientId, clientSecret, user)");
  const {
    username,
    password: password2
  } = user;
  if (!(username && password2))
    throw new Error("Missing required user credentials (username, password)");
  const scope = (options.scopes || []).join(" ");
  const scopeStr = scope ? `&scope=${scope}` : "";
  const basicAuth = import_buffer.Buffer.from(`${clientId}:${clientSecret}`).toString("base64");
  const oauthUri = options.oauthUri || `/oauth/${pKey}/customers/token`;
  const url = options.host.replace(/\/$/, "") + oauthUri;
  const body = `grant_type=password&username=${encodeURIComponent(username)}&password=${encodeURIComponent(password2)}${scopeStr}`;
  return {
    basicAuth,
    url,
    body
  };
}
function buildRequestForRefreshTokenFlow(options) {
  if (!options)
    throw new Error("Missing required options");
  if (!options.host)
    throw new Error("Missing required option (host)");
  if (!options.projectKey)
    throw new Error("Missing required option (projectKey)");
  if (!options.credentials)
    throw new Error("Missing required option (credentials)");
  if (!options.refreshToken)
    throw new Error("Missing required option (refreshToken)");
  const {
    clientId,
    clientSecret
  } = options.credentials;
  if (!(clientId && clientSecret))
    throw new Error("Missing required credentials (clientId, clientSecret)");
  const basicAuth = import_buffer.Buffer.from(`${clientId}:${clientSecret}`).toString("base64");
  const oauthUri = options.oauthUri || "/oauth/token";
  const url = options.host.replace(/\/$/, "") + oauthUri;
  const body = `grant_type=refresh_token&refresh_token=${encodeURIComponent(options.refreshToken)}`;
  return {
    basicAuth,
    url,
    body
  };
}
function buildRequestForAnonymousSessionFlow(options) {
  if (!options)
    throw new Error("Missing required options");
  if (!options.projectKey)
    throw new Error("Missing required option (projectKey)");
  const pKey = options.projectKey;
  options.oauthUri = options.oauthUri || `/oauth/${pKey}/anonymous/token`;
  const result = buildRequestForClientCredentialsFlow(options);
  if (options.credentials.anonymousId)
    result.body += `&anonymous_id=${options.credentials.anonymousId}`;
  return {
    ...result
  };
}
function mergeAuthHeader(token, req) {
  return {
    ...req,
    headers: {
      ...req.headers,
      Authorization: `Bearer ${token}`
    }
  };
}
function calculateExpirationTime(expiresIn) {
  return Date.now() + // Add a gap of 5 minutes before expiration time.
  expiresIn * 1e3 - 5 * 60 * 1e3;
}
async function executeRequest({
  fetcher,
  url,
  basicAuth,
  body,
  tokenCache,
  requestState,
  pendingTasks,
  response,
  tokenCacheKey
}) {
  try {
    const _res = await fetcher(url, {
      method: "POST",
      headers: {
        Authorization: `Basic ${basicAuth}`,
        "Content-Length": import_buffer.Buffer.byteLength(body).toString(),
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body
    });
    if (_res.ok) {
      const {
        access_token: token,
        expires_in: expiresIn,
        refresh_token: refreshToken
      } = await _res.json();
      const expirationTime = calculateExpirationTime(expiresIn);
      tokenCache.set({
        token,
        expirationTime,
        refreshToken
      }, tokenCacheKey);
      requestState.set(false);
      const executionQueue = pendingTasks.slice();
      pendingTasks = [];
      executionQueue.forEach((task) => {
        const requestWithAuth = mergeAuthHeader(token, task.request);
        task.next(requestWithAuth, task.response);
      });
      return;
    }
    let parsed;
    const text = await _res.text();
    try {
      parsed = JSON.parse(text);
    } catch (error2) {
    }
    const error = new Error(parsed ? parsed.message : text);
    if (parsed)
      error.body = parsed;
    requestState.set(false);
    response.reject(error);
  } catch (error) {
    requestState.set(false);
    if (response && typeof response.reject === "function")
      response.reject(error);
  }
}
function authMiddlewareBase({
  request,
  response,
  url,
  basicAuth,
  body,
  pendingTasks,
  requestState,
  tokenCache,
  tokenCacheKey,
  fetch: fetcher
}, next, userOptions) {
  if (!fetcher && typeof fetch === "undefined")
    throw new Error("`fetch` is not available. Please pass in `fetch` as an option or have it globally available.");
  if (!fetcher)
    fetcher = fetch;
  if (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) {
    next(request, response);
    return;
  }
  const tokenObj = tokenCache.get(tokenCacheKey);
  if (tokenObj && tokenObj.token && Date.now() < tokenObj.expirationTime) {
    const requestWithAuth = mergeAuthHeader(tokenObj.token, request);
    next(requestWithAuth, response);
    return;
  }
  pendingTasks.push({
    request,
    response,
    next
  });
  if (requestState.get())
    return;
  requestState.set(true);
  if (tokenObj && tokenObj.refreshToken && (!tokenObj.token || tokenObj.token && Date.now() > tokenObj.expirationTime)) {
    if (!userOptions)
      throw new Error("Missing required options");
    executeRequest({
      fetcher,
      ...buildRequestForRefreshTokenFlow({
        ...userOptions,
        refreshToken: tokenObj.refreshToken
      }),
      tokenCacheKey,
      tokenCache,
      requestState,
      pendingTasks,
      response
    });
    return;
  }
  executeRequest({
    fetcher,
    url,
    basicAuth,
    body,
    tokenCacheKey,
    tokenCache,
    requestState,
    pendingTasks,
    response
  });
}
function store(initVal) {
  let value = initVal;
  return {
    get: (TokenCacheOption) => value,
    set: (val, TokenCacheOption) => {
      value = val;
    }
  };
}
function createAuthMiddlewareForAnonymousSessionFlow$1(options) {
  const tokenCache = options.tokenCache || store({
    token: "",
    expirationTime: -1
  });
  const pendingTasks = [];
  const requestState = store(false);
  return (next) => (request, response) => {
    if (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) {
      next(request, response);
      return;
    }
    const params = {
      request,
      response,
      ...buildRequestForAnonymousSessionFlow(options),
      pendingTasks,
      requestState,
      tokenCache,
      fetch: options.fetch
    };
    authMiddlewareBase(params, next, options);
  };
}
function buildTokenCacheKey(options) {
  return {
    clientId: options.credentials.clientId,
    host: options.host,
    projectKey: options.projectKey
  };
}
function createAuthMiddlewareForClientCredentialsFlow$1(options) {
  const tokenCache = options.tokenCache || store({
    token: "",
    expirationTime: -1
  });
  const requestState = store(false);
  const pendingTasks = [];
  return (next) => (request, response) => {
    if (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) {
      next(request, response);
      return;
    }
    const params = {
      request,
      response,
      ...buildRequestForClientCredentialsFlow(options),
      pendingTasks,
      requestState,
      tokenCache,
      tokenCacheKey: buildTokenCacheKey(options),
      fetch: options.fetch
    };
    authMiddlewareBase(params, next);
  };
}
function createAuthMiddlewareWithExistingToken$1(authorization = "", options = {}) {
  return (next) => (request, response) => {
    if (typeof authorization !== "string")
      throw new Error("authorization must be a string");
    const force = options.force === void 0 ? true : options.force;
    if (!authorization || (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) && force === false) {
      return next(request, response);
    }
    const requestWithAuth = {
      ...request,
      headers: {
        ...request.headers,
        Authorization: authorization
      }
    };
    return next(requestWithAuth, response);
  };
}
function createAuthMiddlewareForPasswordFlow$1(options) {
  const tokenCache = options.tokenCache || store({});
  const pendingTasks = [];
  const requestState = store(false);
  return (next) => (request, response) => {
    if (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) {
      next(request, response);
      return;
    }
    const params = {
      request,
      response,
      ...buildRequestForPasswordFlow(options),
      pendingTasks,
      requestState,
      tokenCache,
      fetch: options.fetch
    };
    authMiddlewareBase(params, next, options);
  };
}
function createAuthMiddlewareForRefreshTokenFlow$1(options) {
  const tokenCache = options.tokenCache || store({
    token: "",
    expirationTime: -1
  });
  const pendingTasks = [];
  const requestState = store(false);
  return (next) => (request, response) => {
    if (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) {
      next(request, response);
      return;
    }
    const params = {
      request,
      response,
      ...buildRequestForRefreshTokenFlow(options),
      pendingTasks,
      requestState,
      tokenCache,
      fetch: options.fetch
    };
    authMiddlewareBase(params, next);
  };
}
var authMiddlewares = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createAuthMiddlewareForAnonymousSessionFlow: createAuthMiddlewareForAnonymousSessionFlow$1,
  createAuthMiddlewareForClientCredentialsFlow: createAuthMiddlewareForClientCredentialsFlow$1,
  createAuthMiddlewareWithExistingToken: createAuthMiddlewareWithExistingToken$1,
  createAuthMiddlewareForPasswordFlow: createAuthMiddlewareForPasswordFlow$1,
  createAuthMiddlewareForRefreshTokenFlow: createAuthMiddlewareForRefreshTokenFlow$1
});
function createCorrelationIdMiddleware(options) {
  return (next) => (request, response) => {
    const nextRequest = {
      ...request,
      headers: {
        ...request.headers,
        "X-Correlation-ID": options.generate()
      }
    };
    next(nextRequest, response);
  };
}
function defineError(statusCode, message, meta = {}) {
  this.status = this.statusCode = this.code = statusCode;
  this.message = message;
  Object.assign(this, meta);
  this.name = this.constructor.name;
  this.constructor.prototype.__proto__ = Error.prototype;
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, this.constructor);
}
function NetworkError(...args) {
  defineError.call(this, 0, ...args);
}
function HttpError(...args) {
  defineError.call(this, ...args);
}
function BadRequest(...args) {
  defineError.call(this, 400, ...args);
}
function Unauthorized(...args) {
  defineError.call(this, 401, ...args);
}
function Forbidden(...args) {
  defineError.call(this, 403, ...args);
}
function NotFound(...args) {
  defineError.call(this, 404, ...args);
}
function ConcurrentModification(...args) {
  defineError.call(this, 409, ...args);
}
function InternalServerError(...args) {
  defineError.call(this, 500, ...args);
}
function ServiceUnavailable(...args) {
  defineError.call(this, 503, ...args);
}
function getErrorByCode(code) {
  switch (code) {
    case 0:
      return NetworkError;
    case 400:
      return BadRequest;
    case 401:
      return Unauthorized;
    case 403:
      return Forbidden;
    case 404:
      return NotFound;
    case 409:
      return ConcurrentModification;
    case 500:
      return InternalServerError;
    case 503:
      return ServiceUnavailable;
    default:
      return void 0;
  }
}
function parseHeaders(headers) {
  if (headers.raw)
    return headers.raw();
  if (!headers.forEach)
    return {};
  const map = {};
  headers.forEach((value, name) => {
    map[name] = value;
  });
  return map;
}
function isBuffer(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function createError({
  statusCode,
  message,
  ...rest
}) {
  let errorMessage = message || "Unexpected non-JSON error response";
  if (statusCode === 404) {
    var _rest$originalRequest;
    errorMessage = `URI not found: ${((_rest$originalRequest = rest.originalRequest) === null || _rest$originalRequest === void 0 ? void 0 : _rest$originalRequest.uri) || rest.uri}`;
    delete rest.uri;
  }
  const ResponseError = getErrorByCode(statusCode);
  if (ResponseError)
    return new ResponseError(errorMessage, rest);
  return new HttpError(statusCode, errorMessage, rest);
}
function calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay) {
  if (backoff)
    return retryCount !== 0 ? Math.min(Math.round((Math.random() + 1) * retryDelay * 2 ** retryCount), maxDelay) : retryDelay;
  return retryDelay;
}
function maskAuthData(request, maskSensitiveHeaderData) {
  if (maskSensitiveHeaderData) {
    if (request && request.headers && request.headers.authorization)
      request.headers.authorization = "Bearer ********";
    if (request && request.headers && request.headers.Authorization)
      request.headers.Authorization = "Bearer ********";
  }
}
function createHttpMiddleware({
  host,
  credentialsMode,
  includeResponseHeaders,
  includeOriginalRequest,
  includeRequestInErrorResponse = true,
  maskSensitiveHeaderData = true,
  headersWithStringBody = [],
  enableRetry,
  timeout,
  retryConfig: {
    // encourage exponential backoff to prevent spamming the server if down
    maxRetries = 10,
    backoff = true,
    retryDelay = 200,
    maxDelay = Infinity,
    // If set to true reinitialize the abort controller when the timeout is reached and apply the retry config
    retryOnAbort = false,
    retryCodes = [503]
  } = {},
  fetch: fetcher,
  getAbortController
}) {
  if (!fetcher)
    throw new Error("`fetch` is not available. Please pass in `fetch` as an option or have it globally available.");
  if (timeout && !getAbortController)
    throw new Error("`AbortController` is not available. Please pass in `getAbortController` as an option or have AbortController globally available when using timeout.");
  let fetchFunction;
  if (fetcher) {
    fetchFunction = fetcher;
  } else {
    fetchFunction = fetch;
  }
  if (!Array.isArray(retryCodes)) {
    throw new Error("`retryCodes` option must be an array of retry status (error) codes.");
  }
  if (!Array.isArray(headersWithStringBody)) {
    throw new Error("`headersWithStringBody` option must be an array of strings");
  }
  return (next) => (request, response) => {
    const url = host.replace(/\/$/, "") + request.uri;
    const requestHeader = {
      ...request.headers
    };
    if (!(Object.prototype.hasOwnProperty.call(requestHeader, "Content-Type") || Object.prototype.hasOwnProperty.call(requestHeader, "content-type"))) {
      requestHeader["Content-Type"] = "application/json";
    }
    if (requestHeader["Content-Type"] === null) {
      delete requestHeader["Content-Type"];
    }
    const body = ["application/json", "application/graphql", ...headersWithStringBody].indexOf(requestHeader["Content-Type"]) > -1 && typeof request.body === "string" || isBuffer(request.body) ? request.body : JSON.stringify(request.body || void 0);
    if (body && (typeof body === "string" || isBuffer(body))) {
      requestHeader["Content-Length"] = import_buffer.Buffer.byteLength(body).toString();
    }
    const fetchOptions = {
      method: request.method,
      headers: requestHeader
    };
    if (credentialsMode) {
      fetchOptions.credentialsMode = credentialsMode;
    }
    if (body) {
      fetchOptions.body = body;
    }
    let retryCount = 0;
    function executeFetch() {
      let timer;
      let abortController;
      if (timeout) {
        abortController = (getAbortController ? getAbortController() : null) || new AbortController();
        fetchOptions.signal = abortController.signal;
        timer = setTimeout(() => {
          abortController.abort();
        }, timeout);
      }
      fetchFunction(url, fetchOptions).then(
        (res) => {
          if (res.ok) {
            if (fetchOptions.method === "HEAD") {
              next(request, {
                ...response,
                statusCode: res.status
              });
              return;
            }
            res.text().then((result) => {
              let parsed;
              try {
                parsed = result.length > 0 ? JSON.parse(result) : {};
              } catch (err) {
                if (enableRetry && retryCount < maxRetries) {
                  setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
                  retryCount += 1;
                  return;
                }
                parsed = result;
              }
              const parsedResponse = {
                ...response,
                body: parsed,
                statusCode: res.status
              };
              if (includeResponseHeaders)
                parsedResponse.headers = parseHeaders(res.headers);
              if (includeOriginalRequest) {
                parsedResponse.request = {
                  ...fetchOptions
                };
                maskAuthData(parsedResponse.request, maskSensitiveHeaderData);
              }
              next(request, parsedResponse);
            }).catch((err) => {
              if (enableRetry && retryCount < maxRetries) {
                setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
                retryCount += 1;
                return;
              }
              const error = new NetworkError(err.message, {
                ...includeRequestInErrorResponse ? {
                  originalRequest: request
                } : {},
                retryCount
              });
              maskAuthData(error.originalRequest, maskSensitiveHeaderData);
              next(request, {
                ...response,
                error,
                statusCode: 0
              });
            });
            return;
          }
          res.text().then((text) => {
            let parsed;
            try {
              parsed = JSON.parse(text);
            } catch (error2) {
              parsed = text;
            }
            const error = createError({
              statusCode: res.status,
              ...includeRequestInErrorResponse ? {
                originalRequest: request
              } : res.status === 404 ? {
                uri: request.uri
              } : {},
              retryCount,
              headers: parseHeaders(res.headers),
              ...typeof parsed === "object" ? {
                message: parsed.message,
                body: parsed
              } : {
                message: parsed,
                body: parsed
              }
            });
            if (enableRetry && (retryCodes.indexOf(error.statusCode) !== -1 || (retryCodes === null || retryCodes === void 0 ? void 0 : retryCodes.indexOf(error.message)) !== -1)) {
              if (retryCount < maxRetries) {
                setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
                retryCount += 1;
                return;
              }
            }
            maskAuthData(error.originalRequest, maskSensitiveHeaderData);
            const parsedResponse = {
              ...response,
              error,
              statusCode: res.status
            };
            next(request, parsedResponse);
          });
        },
        // We know that this is a "network" error thrown by the `fetch` library
        (e) => {
          if (enableRetry && (retryOnAbort || !abortController || !abortController.signal)) {
            if (retryCount < maxRetries) {
              setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
              retryCount += 1;
              return;
            }
          }
          const error = new NetworkError(e.message, {
            ...includeRequestInErrorResponse ? {
              originalRequest: request
            } : {},
            retryCount
          });
          maskAuthData(error.originalRequest, maskSensitiveHeaderData);
          next(request, {
            ...response,
            error,
            statusCode: 0
          });
        }
      ).finally(() => {
        clearTimeout(timer);
      });
    }
    executeFetch();
  };
}
function createLoggerMiddleware() {
  return (next) => (request, response) => {
    const {
      error,
      body,
      statusCode
    } = response;
    console.log("Request: ", request);
    console.log("Response: ", {
      error,
      body,
      statusCode
    });
    next(request, response);
  };
}
function createQueueMiddleware({
  concurrency = 20
}) {
  const queue = [];
  let runningCount = 0;
  const dequeue = (next) => {
    runningCount -= 1;
    if (queue.length && runningCount <= concurrency) {
      const nextTask = queue.shift();
      runningCount += 1;
      next(nextTask.request, nextTask.response);
    }
  };
  return (next) => (request, response) => {
    const patchedResponse = {
      ...response,
      resolve(data) {
        response.resolve(data);
        dequeue(next);
      },
      reject(error) {
        response.reject(error);
        dequeue(next);
      }
    };
    queue.push({
      request,
      response: patchedResponse
    });
    if (runningCount < concurrency) {
      const nextTask = queue.shift();
      runningCount += 1;
      next(nextTask.request, nextTask.response);
    }
  };
}
var packageJson = {
  name: "@commercetools/sdk-client-v2",
  version: "2.3.0",
  engines: {
    node: ">=14"
  },
  description: "commercetools Composable Commerce TypeScript SDK client.",
  keywords: [
    "commercetools",
    "composable commerce",
    "sdk",
    "typescript",
    "client",
    "middleware",
    "http",
    "oauth",
    "auth"
  ],
  homepage: "https://github.com/commercetools/commercetools-sdk-typescript",
  license: "MIT",
  directories: {
    lib: "lib",
    test: "test"
  },
  publishConfig: {
    access: "public"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/commercetools/commercetools-sdk-typescript.git"
  },
  bugs: {
    url: "https://github.com/commercetools/commercetools-sdk-typescript/issues"
  },
  dependencies: {
    buffer: "^6.0.3",
    "node-fetch": "^2.6.1"
  },
  files: [
    "dist",
    "CHANGELOG.md"
  ],
  author: "Chukwuemeka Ajima <meeky.ae@gmail.com>",
  main: "dist/commercetools-sdk-client-v2.cjs.js",
  module: "dist/commercetools-sdk-client-v2.esm.js",
  browser: {
    "./dist/commercetools-sdk-client-v2.cjs.js": "./dist/commercetools-sdk-client-v2.browser.cjs.js",
    "./dist/commercetools-sdk-client-v2.esm.js": "./dist/commercetools-sdk-client-v2.browser.esm.js"
  },
  devDependencies: {
    "abort-controller": "3.0.0",
    "common-tags": "1.8.2",
    dotenv: "16.3.1",
    jest: "29.6.2",
    nock: "12.0.3",
    "organize-imports-cli": "0.10.0"
  },
  scripts: {
    organize_imports: "find src -type f -name '*.ts' | xargs organize-imports-cli",
    postbuild: "yarn organize_imports",
    post_process_generate: "yarn organize_imports"
  }
};
var isBrowser = () => typeof window !== "undefined" && window.document && window.document.nodeType === 9;
function getSystemInfo() {
  var _process;
  if (isBrowser())
    return window.navigator.userAgent;
  const nodeVersion = ((_process = process) === null || _process === void 0 ? void 0 : _process.version.slice(1)) || "12";
  return `node.js/${nodeVersion}`;
}
function createUserAgent(options) {
  if (!options || Object.keys(options).length === 0 || !{}.hasOwnProperty.call(options, "name"))
    throw new Error("Missing required option `name`");
  const baseInfo = options.version ? `${options.name}/${options.version}` : options.name;
  let libraryInfo = null;
  if (options.libraryName && !options.libraryVersion)
    libraryInfo = options.libraryName;
  else if (options.libraryName && options.libraryVersion)
    libraryInfo = `${options.libraryName}/${options.libraryVersion}`;
  let contactInfo = null;
  if (options.contactUrl && !options.contactEmail)
    contactInfo = `(+${options.contactUrl})`;
  else if (!options.contactUrl && options.contactEmail)
    contactInfo = `(+${options.contactEmail})`;
  else if (options.contactUrl && options.contactEmail)
    contactInfo = `(+${options.contactUrl}; +${options.contactEmail})`;
  const systemInfo = getSystemInfo();
  const customAgent = options.customAgent || "";
  return [baseInfo, systemInfo, libraryInfo, contactInfo, customAgent].filter(Boolean).join(" ");
}
function createUserAgentMiddleware(options) {
  const userAgent = createUserAgent({
    ...options,
    name: `commercetools-sdk-javascript-v2/${packageJson.version}`
  });
  return (next) => (request, response) => {
    const requestWithUserAgent = {
      ...request,
      headers: {
        ...request.headers,
        "User-Agent": userAgent
      }
    };
    next(requestWithUserAgent, response);
  };
}
var {
  createAuthMiddlewareForPasswordFlow,
  createAuthMiddlewareForAnonymousSessionFlow,
  createAuthMiddlewareForClientCredentialsFlow,
  createAuthMiddlewareForRefreshTokenFlow,
  createAuthMiddlewareWithExistingToken
} = authMiddlewares;
var ClientBuilder = class {
  constructor() {
    _defineProperty2(this, "projectKey", void 0);
    _defineProperty2(this, "authMiddleware", void 0);
    _defineProperty2(this, "httpMiddleware", void 0);
    _defineProperty2(this, "userAgentMiddleware", void 0);
    _defineProperty2(this, "correlationIdMiddleware", void 0);
    _defineProperty2(this, "loggerMiddleware", void 0);
    _defineProperty2(this, "queueMiddleware", void 0);
    _defineProperty2(this, "telemetryMiddleware", void 0);
    _defineProperty2(this, "middlewares", []);
  }
  withProjectKey(key) {
    this.projectKey = key;
    return this;
  }
  defaultClient(baseUri, credentials, oauthUri, projectKey) {
    return this.withClientCredentialsFlow({
      host: oauthUri,
      projectKey: projectKey || this.projectKey,
      credentials
    }).withHttpMiddleware({
      host: baseUri,
      fetch: lib_default
    }).withLoggerMiddleware().withUserAgentMiddleware();
  }
  withAuthMiddleware(authMiddleware) {
    this.authMiddleware = authMiddleware;
    return this;
  }
  withMiddleware(middleware) {
    this.middlewares.push(middleware);
    return this;
  }
  withClientCredentialsFlow(options) {
    return this.withAuthMiddleware(createAuthMiddlewareForClientCredentialsFlow({
      host: options.host || "https://auth.europe-west1.gcp.commercetools.com",
      projectKey: options.projectKey || this.projectKey,
      credentials: {
        clientId: options.credentials.clientId || "",
        clientSecret: options.credentials.clientSecret || ""
      },
      oauthUri: options.oauthUri || "",
      scopes: options.scopes,
      fetch: options.fetch || lib_default,
      ...options
    }));
  }
  withPasswordFlow(options) {
    return this.withAuthMiddleware(createAuthMiddlewareForPasswordFlow({
      host: options.host || "https://auth.europe-west1.gcp.commercetools.com",
      projectKey: options.projectKey || this.projectKey,
      credentials: {
        clientId: options.credentials.clientId || "",
        clientSecret: options.credentials.clientSecret || "",
        user: {
          username: options.credentials.user.username || "",
          password: options.credentials.user.password || ""
        }
      },
      fetch: options.fetch || lib_default,
      ...options
    }));
  }
  withAnonymousSessionFlow(options) {
    return this.withAuthMiddleware(createAuthMiddlewareForAnonymousSessionFlow({
      host: options.host || "https://auth.europe-west1.gcp.commercetools.com",
      projectKey: this.projectKey || options.projectKey,
      credentials: {
        clientId: options.credentials.clientId || "",
        clientSecret: options.credentials.clientSecret || "",
        anonymousId: options.credentials.anonymousId || ""
      },
      fetch: options.fetch || lib_default,
      ...options
    }));
  }
  withRefreshTokenFlow(options) {
    return this.withAuthMiddleware(createAuthMiddlewareForRefreshTokenFlow({
      host: options.host || "https://auth.europe-west1.gcp.commercetools.com",
      projectKey: this.projectKey || options.projectKey,
      credentials: {
        clientId: options.credentials.clientId || "",
        clientSecret: options.credentials.clientSecret || ""
      },
      fetch: options.fetch || lib_default,
      refreshToken: options.refreshToken || "",
      ...options
    }));
  }
  withExistingTokenFlow(authorization, options) {
    return this.withAuthMiddleware(createAuthMiddlewareWithExistingToken(authorization, {
      force: options.force || true,
      ...options
    }));
  }
  withHttpMiddleware(options) {
    this.httpMiddleware = createHttpMiddleware({
      host: options.host || "https://api.europe-west1.gcp.commercetools.com",
      fetch: options.fetch || lib_default,
      ...options
    });
    return this;
  }
  withUserAgentMiddleware(options) {
    this.userAgentMiddleware = createUserAgentMiddleware(options);
    return this;
  }
  withQueueMiddleware(options) {
    this.queueMiddleware = createQueueMiddleware({
      concurrency: options.concurrency || 20,
      ...options
    });
    return this;
  }
  withLoggerMiddleware() {
    this.loggerMiddleware = createLoggerMiddleware();
    return this;
  }
  withCorrelationIdMiddleware(options) {
    this.correlationIdMiddleware = createCorrelationIdMiddleware({
      generate: options.generate || null,
      ...options
    });
    return this;
  }
  withTelemetryMiddleware(options) {
    const {
      createTelemetryMiddleware,
      ...rest
    } = options;
    this.withUserAgentMiddleware({
      customAgent: (rest === null || rest === void 0 ? void 0 : rest.userAgent) || "typescript-sdk-apm-middleware"
    });
    this.telemetryMiddleware = createTelemetryMiddleware(rest);
    return this;
  }
  build() {
    const middlewares = this.middlewares.slice();
    if (this.telemetryMiddleware)
      middlewares.push(this.telemetryMiddleware);
    if (this.correlationIdMiddleware)
      middlewares.push(this.correlationIdMiddleware);
    if (this.userAgentMiddleware)
      middlewares.push(this.userAgentMiddleware);
    if (this.authMiddleware)
      middlewares.push(this.authMiddleware);
    if (this.queueMiddleware)
      middlewares.push(this.queueMiddleware);
    if (this.httpMiddleware)
      middlewares.push(this.httpMiddleware);
    if (this.loggerMiddleware)
      middlewares.push(this.loggerMiddleware);
    return createClient({
      middlewares
    });
  }
};

// commerce-commercetools/ClientFactory.ts
init_lib();
var _ClientFactory = class _ClientFactory {
  static getClientBuilderWithRefreshTokenFlow(clientConfig, tokenCache, refreshToken, httpMiddlewareOptions) {
    const refreshAuthMiddlewareOptions = {
      host: clientConfig.authUrl,
      projectKey: clientConfig.projectKey,
      credentials: {
        clientId: clientConfig.clientId,
        clientSecret: clientConfig.clientSecret
      },
      // scopes: ['manage_project:' + clientConfig.projectKey],
      fetch: lib_default,
      tokenCache,
      refreshToken
    };
    return new ClientBuilder().withHttpMiddleware(httpMiddlewareOptions).withRefreshTokenFlow(refreshAuthMiddlewareOptions);
  }
  static getClientBuilderWithClientCredentialsFlow(clientConfig, tokenCache, httpMiddlewareOptions) {
    const authMiddlewareOptions = {
      host: clientConfig.authUrl,
      projectKey: clientConfig.projectKey,
      credentials: {
        clientId: clientConfig.clientId,
        clientSecret: clientConfig.clientSecret
      },
      // scopes: ['manage_project:' + clientConfig.projectKey],
      fetch: lib_default,
      tokenCache
    };
    return new ClientBuilder().withHttpMiddleware(httpMiddlewareOptions).withClientCredentialsFlow(authMiddlewareOptions);
  }
};
_ClientFactory.factor = (clientConfig, environment, tokenCache, refreshToken) => {
  const httpMiddlewareOptions = {
    host: clientConfig.hostUrl,
    fetch: lib_default
  };
  let clientBuilder;
  switch (true) {
    case refreshToken !== void 0:
      clientBuilder = _ClientFactory.getClientBuilderWithRefreshTokenFlow(
        clientConfig,
        tokenCache,
        refreshToken,
        httpMiddlewareOptions
      );
      break;
    default:
      clientBuilder = _ClientFactory.getClientBuilderWithClientCredentialsFlow(
        clientConfig,
        tokenCache,
        httpMiddlewareOptions
      );
      break;
  }
  if (environment !== void 0 && environment !== "prod" && environment !== "production") {
    clientBuilder = clientBuilder.withLoggerMiddleware();
  }
  return clientBuilder.build();
};
var ClientFactory = _ClientFactory;

// commerce-commercetools/utils/Context.ts
var projectConfigurationOverrides = {};
var isDevEnv = (context) => {
  return context.environment === "development" || context.environment === "dev";
};
var getFromProjectConfig = (key, context) => {
  if (isDevEnv(context) && projectConfigurationOverrides[key]) {
    return projectConfigurationOverrides[key];
  }
  return context.projectConfiguration[key];
};

// commerce-commercetools/utils/NormalizeData.ts
var import_url2 = require("url");

// commerce-commercetools/errors/ValidationError.ts
var ValidationError = class _ValidationError extends ExtensionError {
  constructor(options) {
    super(options);
    this.errorName = _ValidationError.VALIDATION_ERROR_NAME;
  }
};

// commerce-commercetools/utils/NormalizeData.ts
var normalizeUrl = (url) => {
  try {
    url = url.replace(/\/$/, "");
    url = encodeURI(url);
    new import_url2.URL(url);
    return url;
  } catch (error) {
    throw new ValidationError({ message: `Invalid URL: ${url}` });
  }
};

// commerce-commercetools/utils/GetConfig.ts
var getConfig = (context, engine, locale) => {
  var _a4, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
  const prefix = `EXTENSION_${engine.toUpperCase()}`;
  const clientConfig = {
    authUrl: getFromProjectConfig(`${prefix}_AUTH_URL`, context),
    clientId: getFromProjectConfig(`${prefix}_CLIENT_ID`, context),
    clientSecret: getFromProjectConfig(`${prefix}_CLIENT_SECRET`, context),
    hostUrl: getFromProjectConfig(`${prefix}_HOST_URL`, context),
    projectKey: getFromProjectConfig(`${prefix}_PROJECT_KEY`, context),
    productIdField: getFromProjectConfig(`${prefix}_PRODUCT_ID_FIELD`, context),
    categoryIdField: getFromProjectConfig(`${prefix}_CATEGORY_ID_FIELD`, context),
    sessionUrl: getFromProjectConfig(`${prefix}_SESSION_URL`, context),
    checkoutApplicationKey: getFromProjectConfig(`${prefix}_CHECKOUT_APPLICATION_KEY`, context)
  };
  if (!clientConfig.authUrl) {
    clientConfig.authUrl = (_b = (_a4 = context.project.configuration) == null ? void 0 : _a4[engine]) == null ? void 0 : _b.authUrl;
  }
  if (!clientConfig.clientId) {
    clientConfig.clientId = (_d = (_c = context.project.configuration) == null ? void 0 : _c[engine]) == null ? void 0 : _d.clientId;
  }
  if (!clientConfig.clientSecret) {
    clientConfig.clientSecret = (_f = (_e = context.project.configuration) == null ? void 0 : _e[engine]) == null ? void 0 : _f.clientSecret;
  }
  if (!clientConfig.hostUrl) {
    clientConfig.hostUrl = (_h = (_g = context.project.configuration) == null ? void 0 : _g[engine]) == null ? void 0 : _h.hostUrl;
  }
  if (!clientConfig.projectKey) {
    clientConfig.projectKey = (_j = (_i = context.project.configuration) == null ? void 0 : _i[engine]) == null ? void 0 : _j.projectKey;
  }
  if (!clientConfig.productIdField) {
    clientConfig.productIdField = (_l = (_k = context.project.configuration) == null ? void 0 : _k[engine]) == null ? void 0 : _l.productIdField;
  }
  if (!clientConfig.categoryIdField) {
    clientConfig.categoryIdField = (_n = (_m = context.project.configuration) == null ? void 0 : _m[engine]) == null ? void 0 : _n.categoryIdField;
  }
  if (!clientConfig.sessionUrl) {
    clientConfig.sessionUrl = (_p = (_o = context.project.configuration) == null ? void 0 : _o[engine]) == null ? void 0 : _p.sessionUrl;
  }
  if (!clientConfig.checkoutApplicationKey) {
    clientConfig.checkoutApplicationKey = (_r = (_q = context.project.configuration) == null ? void 0 : _q[engine]) == null ? void 0 : _r.checkoutApplicationKey;
  }
  clientConfig.authUrl = normalizeUrl(clientConfig.authUrl);
  clientConfig.hostUrl = normalizeUrl(clientConfig.hostUrl);
  clientConfig.sessionUrl = normalizeUrl(clientConfig.sessionUrl);
  return clientConfig;
};

// commerce-commercetools/errors/LocaleError.ts
var LocaleError = class _LocaleError extends ExtensionError {
  constructor(options) {
    super(options);
    this.errorName = _LocaleError.LOCALE_ERROR_NAME;
  }
};

// commerce-commercetools/utils/Token.ts
var tokenHasExpired = (token) => {
  if (token === void 0) {
    return true;
  }
  return Date.now() >= token.expirationTime;
};

// commerce-commercetools/errors/ExternalError.ts
var ExternalError = class _ExternalError extends ExtensionError {
  constructor(props) {
    var _a4, _b, _c, _d, _e, _f;
    super(props);
    this.statusCode = isNaN(props.statusCode) ? 503 : props.statusCode;
    this.errorName = _ExternalError.EXTERNAL_ERROR_NAME;
    if (((_c = (_b = (_a4 = props.body) == null ? void 0 : _a4["errors"]) == null ? void 0 : _b[0]) == null ? void 0 : _c["code"]) === "AssociateMissingPermission") {
      this.statusCode = 403;
      this.message = "Not enough permissions to perform this action";
      this.errorName = _ExternalError.ASSOCIATE_MISSING_PERMISSION_ERROR_NAME;
    }
    if (((_f = (_e = (_d = props.body) == null ? void 0 : _d["errors"]) == null ? void 0 : _e[0]) == null ? void 0 : _f["code"]) === "DuplicateField") {
      this.errorName = _ExternalError.DUPLICATED_FIELD_ERROR_NAME;
    }
  }
};

// commerce-commercetools/apis/BaseApi.ts
var defaultCurrency = "USD";
var localeRegex = /^(?<language>[a-z]{2,})(?:_(?<territory>[A-Z0-9]{2,}))?(?:\.(?<codeset>[A-Z0-9_+-]+))?(?:@(?<modifier>[A-Za-z]+))?$/;
var languageToTerritory = {
  en: "US"
};
var modifierToCurrency = {
  dollar: "USD",
  euro: "EUR"
};
var territoryToCurrency = {
  AD: "EUR",
  AE: "AED",
  AF: "AFN",
  AG: "XCD",
  AI: "XCD",
  AL: "ALL",
  AM: "AMD",
  AN: "ANG",
  AO: "AOA",
  AQ: "AQD",
  AR: "ARS",
  AS: "EUR",
  AT: "EUR",
  AU: "AUD",
  AW: "ANG",
  AX: "EUR",
  AZ: "AZN",
  BA: "BAM",
  BB: "BBD",
  BD: "BDT",
  BE: "EUR",
  BF: "XOF",
  BG: "BGN",
  BH: "BHD",
  BI: "BIF",
  BJ: "XOF",
  BL: "EUR",
  BM: "BMD",
  BN: "BND",
  BO: "BOB",
  BR: "BRL",
  BS: "BSD",
  BT: "INR",
  BV: "NOK",
  BW: "BWP",
  BY: "BYR",
  BZ: "BZD",
  CA: "CAD",
  CC: "AUD",
  CD: "CDF",
  CF: "XAF",
  CG: "XAF",
  CH: "CHF",
  CI: "XOF",
  CK: "NZD",
  CL: "CLP",
  CM: "XAF",
  CN: "CNY",
  CO: "COP",
  CR: "CRC",
  CU: "CUP",
  CV: "CVE",
  CX: "AUD",
  CY: "CYP",
  CZ: "CZK",
  DE: "EUR",
  DJ: "DJF",
  DK: "DKK",
  DM: "XCD",
  DO: "DOP",
  DZ: "DZD",
  EC: "ECS",
  EE: "EEK",
  EG: "EGP",
  EH: "MAD",
  ER: "ETB",
  ES: "EUR",
  ET: "ETB",
  FI: "EUR",
  FJ: "FJD",
  FK: "FKP",
  FM: "USD",
  FO: "DKK",
  FR: "EUR",
  GA: "XAF",
  GB: "GBP",
  GD: "XCD",
  GE: "GEL",
  GF: "EUR",
  GG: "GGP",
  GH: "GHS",
  GI: "GIP",
  GL: "DKK",
  GM: "GMD",
  GN: "GNF",
  GP: "EUR",
  GQ: "XAF",
  GR: "EUR",
  GS: "GBP",
  GT: "GTQ",
  GU: "USD",
  GW: "XOF",
  GY: "GYD",
  HK: "HKD",
  HM: "AUD",
  HN: "HNL",
  HR: "HRK",
  HT: "HTG",
  HU: "HUF",
  ID: "IDR",
  IE: "EUR",
  IL: "ILS",
  IM: "GBP",
  IN: "INR",
  IO: "USD",
  IQ: "IQD",
  IR: "IRR",
  IS: "ISK",
  IT: "EUR",
  JE: "GBP",
  JM: "JMD",
  JO: "JOD",
  JP: "JPY",
  KE: "KES",
  KG: "KGS",
  KH: "KHR",
  KI: "AUD",
  KM: "KMF",
  KN: "XCD",
  KP: "KPW",
  KR: "KRW",
  KW: "KWD",
  KY: "KYD",
  KZ: "KZT",
  LA: "LAK",
  LB: "LBP",
  LC: "XCD",
  LI: "CHF",
  LK: "LKR",
  LR: "LRD",
  LS: "LSL",
  LT: "LTL",
  LU: "EUR",
  LV: "LVL",
  LY: "LYD",
  MA: "MAD",
  MC: "EUR",
  MD: "MDL",
  ME: "EUR",
  MF: "ANG",
  MG: "MGA",
  MH: "USD",
  MK: "MKD",
  ML: "XOF",
  MM: "MMK",
  MN: "MNT",
  MO: "MOP",
  MP: "USD",
  MQ: "EUR",
  MR: "MRO",
  MS: "XCD",
  MT: "MTL",
  MU: "MUR",
  MV: "MVR",
  MW: "MWK",
  MX: "MXN",
  MY: "MYR",
  MZ: "MZN",
  NA: "NAD",
  NC: "XPF",
  NE: "XOF",
  NF: "AUD",
  NG: "NGN",
  NI: "NIO",
  NL: "EUR",
  NO: "NOK",
  NP: "NPR",
  NR: "AUD",
  NU: "NZD",
  NZ: "NZD",
  OM: "OMR",
  PA: "PAB",
  PE: "PEN",
  PF: "XPF",
  PG: "PGK",
  PH: "PHP",
  PK: "PKR",
  PL: "PLN",
  PM: "EUR",
  PN: "NZD",
  PR: "USD",
  PS: "JOD",
  PT: "EUR",
  PW: "USD",
  PY: "PYG",
  QA: "QAR",
  RE: "EUR",
  RO: "RON",
  RS: "RSD",
  RU: "RUB",
  RW: "RWF",
  SA: "SAR",
  SB: "SBD",
  SC: "SCR",
  SD: "SDG",
  SE: "SEK",
  SG: "SGD",
  SH: "GBP",
  SI: "EUR",
  SJ: "NOK",
  SK: "SKK",
  SL: "SLL",
  SM: "EUR",
  SN: "XOF",
  SO: "SOS",
  SR: "SRD",
  ST: "STD",
  SV: "SVC",
  SY: "SYP",
  SZ: "SZL",
  TC: "USD",
  TD: "XAF",
  TF: "EUR",
  TG: "XOF",
  TH: "THB",
  TJ: "TJS",
  TK: "NZD",
  TM: "TMT",
  TN: "TND",
  TO: "TOP",
  TP: "IDR",
  TR: "TRY",
  TT: "TTD",
  TV: "AUD",
  TW: "TWD",
  TZ: "TZS",
  UA: "UAH",
  UG: "UGX",
  UM: "USD",
  USAF: "USD",
  US: "USD",
  UY: "UYU",
  UZ: "UZS",
  VA: "EUR",
  VC: "XCD",
  VE: "VEF",
  VG: "USD",
  VI: "USD",
  VN: "VND",
  VU: "VUV",
  WF: "XPF",
  WS: "EUR",
  YE: "YER",
  YT: "EUR",
  ZA: "ZAR",
  ZM: "ZMK",
  ZW: "ZWD"
};
var parseLocale = (locale, currency) => {
  const matches = locale.match(localeRegex);
  if (matches === null) {
    throw new LocaleError({ message: `Invalid locale: ${locale}` });
  }
  const language = matches.groups.language;
  let territory = matches.groups.territory;
  if (territory === void 0) {
    if (language in languageToTerritory) {
      territory = languageToTerritory[language];
    } else {
      territory = language.toUpperCase();
    }
  }
  if (!currency) {
    currency = defaultCurrency;
    if (territory in territoryToCurrency) {
      currency = territoryToCurrency[territory];
    }
    const modifier = matches.groups.modifier;
    if (modifier !== void 0) {
      if (modifier in modifierToCurrency) {
        currency = modifierToCurrency[modifier];
      } else {
        const foundCurrency = Object.values(territoryToCurrency).find(
          (currency2) => currency2 === modifier.toUpperCase()
        );
        if (foundCurrency !== void 0) {
          currency = foundCurrency;
        }
      }
    }
  }
  return {
    language,
    territory,
    currency
  };
};
var projectCacheTtlMilliseconds = 10 * 60 * 1e3;
var projectCache = {};
var productTypesCache = {};
var pickCandidate = (candidates, availableOptions) => {
  for (const candidate of candidates) {
    const found = availableOptions.find((option) => option.toLowerCase() === candidate.toLowerCase());
    if (found !== void 0) {
      return found;
    }
  }
  return void 0;
};
var pickCommercetoolsLanguage = (parsedLocale, availableLanguages) => {
  const candidates = [`${parsedLocale.language}-${parsedLocale.territory}`, parsedLocale.language];
  const foundCandidate = pickCandidate(candidates, availableLanguages);
  if (foundCandidate !== void 0) {
    return foundCandidate;
  }
  const prefix = `${parsedLocale.language.toLowerCase()}-`;
  const foundPrefix = availableLanguages.find((option) => option.toLowerCase().startsWith(prefix));
  if (foundPrefix !== void 0) {
    return foundPrefix;
  }
  return void 0;
};
var pickCommercetoolsCountry = (parsedLocale, language, availableCountries) => {
  const candidates = [parsedLocale.territory, parsedLocale.language, language];
  const foundCandidate = pickCandidate(candidates, availableCountries);
  if (foundCandidate !== void 0) {
    return foundCandidate;
  }
  return void 0;
};
var pickCommercetoolsCurrency = (parsedLocale, availableCurrencies) => {
  const candidates = [
    parsedLocale.currency,
    parseLocale(`${parsedLocale.language}_${parsedLocale.territory}`).currency
  ];
  const foundCandidate = pickCandidate(candidates, availableCurrencies);
  if (foundCandidate !== void 0) {
    return foundCandidate;
  }
  return void 0;
};
var clientTokensStored = /* @__PURE__ */ new Map();
var BaseApi = class {
  constructor(commercetoolsFrontendContext, locale, currency, request) {
    var _a4, _b, _c;
    this.defaultLocale = commercetoolsFrontendContext.project.defaultLocale;
    this.defaultCurrency = defaultCurrency;
    this.locale = locale !== null ? locale : this.defaultLocale;
    this.currency = currency;
    const engine = "commercetools";
    this.clientSettings = getConfig(commercetoolsFrontendContext, engine, this.locale);
    this.environment = commercetoolsFrontendContext.environment;
    this.projectKey = this.clientSettings.projectKey;
    this.productIdField = ((_a4 = this.clientSettings) == null ? void 0 : _a4.productIdField) || "key";
    this.categoryIdField = ((_b = this.clientSettings) == null ? void 0 : _b.categoryIdField) || "key";
    this.token = clientTokensStored.get(this.getClientHashKey());
    this.sessionData = (_c = request == null ? void 0 : request.sessionData) != null ? _c : {};
  }
  getSessionData() {
    return this.sessionData;
  }
  invalidateSessionCheckoutData() {
    this.invalidateSessionAnonymousId();
    this.invalidateSessionCheckoutSessionToken();
  }
  invalidateSessionAnonymousId() {
    var _a4;
    if ((_a4 = this.sessionData) == null ? void 0 : _a4.anonymousId) {
      this.sessionData.anonymousId = void 0;
    }
  }
  invalidateSessionCheckoutSessionToken() {
    var _a4;
    if ((_a4 = this.sessionData) == null ? void 0 : _a4.checkoutSessionToken) {
      this.sessionData.checkoutSessionToken = void 0;
    }
  }
  async setSessionCheckoutSessionToken(cartId, token) {
    const checkoutHashKey = await this.getCheckoutHashKey(cartId);
    this.sessionData.checkoutSessionToken = {};
    this.sessionData.checkoutSessionToken[checkoutHashKey] = token;
  }
  async getSessionCheckoutSessionToken(cartId) {
    var _a4, _b, _c;
    const checkoutHashKey = await this.getCheckoutHashKey(cartId);
    return (_c = (_b = (_a4 = this.sessionData) == null ? void 0 : _a4.checkoutSessionToken) == null ? void 0 : _b[checkoutHashKey]) != null ? _c : void 0;
  }
  getAnonymousIdFromSessionData() {
    var _a4;
    if ((_a4 = this.sessionData) == null ? void 0 : _a4.anonymousId) {
      return this.sessionData.anonymousId;
    }
    this.sessionData = {
      ...this.sessionData,
      anonymousId: Guid.newGuid()
    };
    return this.sessionData.anonymousId;
  }
  requestBuilder() {
    return this.getApiRoot().withProjectKey({ projectKey: this.projectKey });
  }
  async getCommercetoolsLocal() {
    var _a4, _b, _c, _d, _e, _f;
    const parsedLocale = parseLocale(this.locale, this.currency);
    const parsedDefaultLocale = parseLocale(this.defaultLocale, this.currency);
    const project = await this.getProject();
    const language = (_b = (_a4 = pickCommercetoolsLanguage(parsedLocale, project.languages)) != null ? _a4 : pickCommercetoolsLanguage(parsedDefaultLocale, project.languages)) != null ? _b : project.languages[0];
    const country = (_d = (_c = pickCommercetoolsCountry(parsedLocale, language, project.countries)) != null ? _c : pickCommercetoolsCountry(parsedDefaultLocale, language, project.countries)) != null ? _d : project.countries[0];
    const currency = (_f = (_e = pickCommercetoolsCurrency(parsedLocale, project.currencies)) != null ? _e : pickCommercetoolsCurrency(parsedDefaultLocale, project.currencies)) != null ? _f : project.currencies[0];
    return Promise.resolve({
      language,
      country,
      currency
    });
  }
  async getProductTypes() {
    const now2 = Date.now();
    if (this.projectKey in productTypesCache) {
      const cacheEntry = productTypesCache[this.projectKey];
      if (now2 < cacheEntry.expiryTime) {
        return cacheEntry.productTypes;
      }
    }
    return await this.requestBuilder().productTypes().get().execute().then((response) => {
      const productTypes = response.body.results;
      productTypesCache[this.projectKey] = {
        productTypes,
        expiryTime: projectCacheTtlMilliseconds * 1e3 + now2
      };
      return productTypes;
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async getProject() {
    const now2 = Date.now();
    if (this.projectKey in projectCache) {
      const cacheEntry = projectCache[this.projectKey];
      if (now2 < cacheEntry.expiryTime) {
        return cacheEntry.project;
      }
    }
    const response = await this.requestBuilder().get().execute().catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
    const project = response.body;
    projectCache[this.projectKey] = {
      project,
      expiryTime: projectCacheTtlMilliseconds * 1e3 + now2
    };
    return project;
  }
  async generateCheckoutSessionToken(cartId) {
    const checkoutSessionToken = await this.getSessionCheckoutSessionToken(cartId);
    if (!tokenHasExpired(checkoutSessionToken)) {
      return checkoutSessionToken;
    }
    if (checkoutSessionToken) {
      try {
        return await this.refreshCheckoutSessionToken(cartId, checkoutSessionToken);
      } catch (error) {
      }
    }
    const url = `${this.clientSettings.sessionUrl}/${this.projectKey}/sessions`;
    const body = JSON.stringify({
      cart: {
        cartRef: {
          id: cartId
        }
      },
      metadata: {
        applicationKey: this.clientSettings.checkoutApplicationKey
      }
    });
    return await this.fetchCheckoutSessionToken(cartId, url, body);
  }
  async refreshCheckoutSessionToken(cartId, checkoutSessionToken) {
    const url = `${this.clientSettings.sessionUrl}/${this.projectKey}/sessions/${checkoutSessionToken.token}`;
    const body = JSON.stringify({
      actions: [
        {
          action: "refresh"
        }
      ]
    });
    return await this.fetchCheckoutSessionToken(cartId, url, body);
  }
  async fetchCheckoutSessionToken(cartId, url, body) {
    const headers = {
      "Content-Type": "application/json",
      Authorization: `Bearer ${this.token.token}`
    };
    const requestOptions = {
      method: "POST",
      headers,
      body
    };
    const response = await lib_default(url, requestOptions).then((response2) => {
      return response2.json();
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error });
    });
    if (response == null ? void 0 : response.errors) {
      throw new ExternalError({
        statusCode: response == null ? void 0 : response.statusCode,
        message: response.errors[0].message,
        body: response,
        errors: response == null ? void 0 : response.errors
      });
    }
    const token = {
      token: response == null ? void 0 : response.id,
      expirationTime: (response == null ? void 0 : response.expiryAt) ? new Date(response == null ? void 0 : response.expiryAt).getTime() : void 0
    };
    await this.setSessionCheckoutSessionToken(cartId, token);
    return token;
  }
  commercetoolsTokenCache() {
    return (() => {
      const get = () => {
        if (this.token === void 0) {
          return void 0;
        }
        const tokenStore = {
          token: this.token.token,
          expirationTime: this.token.expirationTime,
          refreshToken: this.token.refreshToken
        };
        return tokenStore;
      };
      const set = (tokenStore) => {
        this.token = {
          token: tokenStore.token,
          expirationTime: tokenStore.expirationTime,
          refreshToken: tokenStore.refreshToken
        };
        clientTokensStored.set(this.getClientHashKey(), this.token);
      };
      return { get, set };
    })();
  }
  async getCheckoutHashKey(cartId) {
    if (this.checkoutHashKey) {
      return this.checkoutHashKey;
    }
    this.checkoutHashKey = import_crypto.default.createHash("md5").update(this.clientSettings.checkoutApplicationKey + cartId).digest("hex");
    return this.checkoutHashKey;
  }
  getClientHashKey() {
    if (this.clientHashKey) {
      return this.clientHashKey;
    }
    this.clientHashKey = import_crypto.default.createHash("md5").update(this.clientSettings.clientId + this.clientSettings.clientSecret + this.clientSettings.projectKey).digest("hex");
    return this.clientHashKey;
  }
  getApiRoot() {
    var _a4;
    let refreshToken;
    if (this.apiRoot && tokenHasExpired(this.token)) {
      this.apiRoot = void 0;
      refreshToken = (_a4 = this.token) == null ? void 0 : _a4.refreshToken;
    }
    if (this.apiRoot) {
      return this.apiRoot;
    }
    const client = ClientFactory.factor(
      this.clientSettings,
      this.environment,
      this.commercetoolsTokenCache(),
      refreshToken
    );
    this.apiRoot = createApiBuilderFromCtpClient(client);
    return this.apiRoot;
  }
};

// commerce-commercetools/apis/AccountApi.ts
var AccountApi = class extends BaseApi {
  constructor() {
    super(...arguments);
    this.create = async (account, cart) => {
      const locale = await this.getCommercetoolsLocal();
      const {
        commercetoolsAddresses,
        billingAddresses,
        shippingAddresses,
        defaultBillingAddress,
        defaultShippingAddress
      } = this.extractAddresses(account);
      const customerDraft = {
        key: Guid.newGuid(),
        email: account.email,
        password: account.password,
        salutation: account == null ? void 0 : account.salutation,
        firstName: account == null ? void 0 : account.firstName,
        lastName: account == null ? void 0 : account.lastName,
        dateOfBirth: (account == null ? void 0 : account.birthday) ? account.birthday.getFullYear() + "-" + account.birthday.getMonth() + "-" + account.birthday.getDate() : void 0,
        isEmailVerified: account == null ? void 0 : account.confirmed,
        addresses: commercetoolsAddresses.length > 0 ? commercetoolsAddresses : void 0,
        defaultBillingAddress,
        defaultShippingAddress,
        billingAddresses: billingAddresses.length > 0 ? billingAddresses : void 0,
        shippingAddresses: shippingAddresses.length > 0 ? shippingAddresses : void 0,
        anonymousCart: cart !== void 0 ? {
          typeId: "cart",
          id: cart.cartId
        } : void 0
      };
      account = await this.requestBuilder().customers().post({
        body: customerDraft
      }).execute().then((response) => {
        return AccountMapper.commercetoolsCustomerToAccount(response.body.customer);
      }).catch((error) => {
        if (error.code === 400) {
          if (error instanceof ExternalError && (error == null ? void 0 : error.errorName) === ExternalError.DUPLICATED_FIELD_ERROR_NAME) {
            throw new AccountEmailDuplicatedError({ message: `The account ${account.email} does already exist.` });
          }
          if (cart) {
            return this.create(account, void 0);
          }
        }
        throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
      });
      if (!account.confirmed) {
        account.confirmationToken = await this.getConfirmationToken(account);
      }
      return account;
    };
    this.confirmEmail = async (token) => {
      const locale = await this.getCommercetoolsLocal();
      return await this.requestBuilder().customers().emailConfirm().post({
        body: {
          tokenValue: token
        }
      }).execute().then((response) => {
        return AccountMapper.commercetoolsCustomerToAccount(response.body);
      }).catch((error) => {
        throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
      });
    };
    this.login = async (account, cart) => {
      const locale = await this.getCommercetoolsLocal();
      const accountCredentials = {
        email: account.email,
        password: account.password
      };
      account = await this.requestBuilder().login().post({
        body: {
          email: account.email,
          password: account.password,
          anonymousCart: cart !== void 0 ? {
            typeId: "cart",
            id: cart.cartId
          } : void 0
        }
      }).execute().then((response) => {
        return AccountMapper.commercetoolsCustomerToAccount(response.body.customer);
      }).catch((error) => {
        var _a4, _b, _c;
        if (error.code && error.code === 400) {
          if (error.body && ((_c = (_b = (_a4 = error.body) == null ? void 0 : _a4.errors) == null ? void 0 : _b[0]) == null ? void 0 : _c.code) === "InvalidCredentials") {
            throw new AccountAuthenticationError({
              message: "Failed to login account with the given credentials"
            });
          }
          if (cart) {
            return this.login(account, void 0);
          }
        }
        throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
      });
      if (!account.confirmed) {
        account.confirmationToken = await this.getConfirmationToken(account);
      }
      return account;
    };
    this.updatePassword = async (account, oldPassword, newPassword) => {
      const locale = await this.getCommercetoolsLocal();
      const accountVersion = await this.fetchAccountVersion(account);
      account = await this.requestBuilder().customers().password().post({
        body: {
          id: account.accountId,
          version: accountVersion,
          currentPassword: oldPassword,
          newPassword
        }
      }).execute().then((response) => {
        return AccountMapper.commercetoolsCustomerToAccount(response.body);
      }).catch((error) => {
        throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
      });
      return account;
    };
    this.generatePasswordResetToken = async (email) => {
      return await this.requestBuilder().customers().passwordToken().post({
        body: {
          email,
          ttlMinutes: 2 * 24 * 60
        }
      }).execute().then((response) => {
        return {
          email,
          token: response.body.value,
          tokenValidUntil: new Date(response.body.expiresAt)
        };
      }).catch((error) => {
        throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
      });
    };
    this.resetPassword = async (token, newPassword) => {
      const locale = await this.getCommercetoolsLocal();
      return await this.requestBuilder().customers().passwordReset().post({
        body: {
          tokenValue: token,
          newPassword
        }
      }).execute().then((response) => {
        return AccountMapper.commercetoolsCustomerToAccount(response.body);
      }).catch((error) => {
        throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
      });
    };
    this.update = async (account) => {
      const customerUpdateActions = [];
      if (account.firstName) {
        customerUpdateActions.push({ action: "setFirstName", firstName: account.firstName });
      }
      if (account.lastName) {
        customerUpdateActions.push({ action: "setLastName", lastName: account.lastName });
      }
      if (account.email) {
        customerUpdateActions.push({ action: "changeEmail", email: account.email });
      }
      if (account.salutation) {
        customerUpdateActions.push({ action: "setSalutation", salutation: account.salutation });
      }
      if (account.birthday) {
        customerUpdateActions.push({
          action: "setDateOfBirth",
          dateOfBirth: account.birthday.getFullYear() + "-" + account.birthday.getMonth() + "-" + account.birthday.getDate()
        });
      }
      account = await this.updateAccount(account, customerUpdateActions);
      if (!account.confirmed) {
        account.confirmationToken = await this.getConfirmationToken(account);
      }
      return account;
    };
    this.addAddress = async (account, address) => {
      const customerUpdateActions = [];
      let addressData = AccountMapper.addressToCommercetoolsAddress(address);
      if (addressData.id !== void 0) {
        addressData = {
          ...addressData,
          id: void 0
        };
      }
      if (address.isDefaultBillingAddress || address.isDefaultShippingAddress) {
        addressData = {
          ...addressData,
          key: Guid.newGuid()
        };
      }
      customerUpdateActions.push({ action: "addAddress", address: addressData });
      if (address.isDefaultBillingAddress) {
        customerUpdateActions.push({ action: "setDefaultBillingAddress", addressKey: addressData.key });
      }
      if (address.isDefaultShippingAddress) {
        customerUpdateActions.push({ action: "setDefaultShippingAddress", addressKey: addressData.key });
      }
      return await this.updateAccount(account, customerUpdateActions);
    };
    this.addShippingAddress = async (account, address) => {
      const customerUpdateActions = [];
      let addressData = AccountMapper.addressToCommercetoolsAddress(address);
      if (addressData.id !== void 0) {
        addressData = {
          ...addressData,
          id: void 0
        };
      }
      customerUpdateActions.push({ action: "addAddress", address: addressData });
      customerUpdateActions.push({ action: "addShippingAddressId", addressKey: addressData.key });
      if (address.isDefaultShippingAddress) {
        customerUpdateActions.push({ action: "setDefaultShippingAddress", addressKey: addressData.key });
      }
      return await this.updateAccount(account, customerUpdateActions);
    };
    this.addBillingAddress = async (account, address) => {
      const customerUpdateActions = [];
      let addressData = AccountMapper.addressToCommercetoolsAddress(address);
      if (addressData.id !== void 0) {
        addressData = {
          ...addressData,
          id: void 0
        };
      }
      customerUpdateActions.push({ action: "addAddress", address: addressData });
      customerUpdateActions.push({ action: "addBillingAddressId", addressKey: addressData.key });
      if (address.isDefaultBillingAddress) {
        customerUpdateActions.push({ action: "setDefaultBillingAddress", addressKey: addressData.key });
      }
      return await this.updateAccount(account, customerUpdateActions);
    };
    this.updateAddress = async (account, address) => {
      const customerUpdateActions = [];
      let addressData = AccountMapper.addressToCommercetoolsAddress(address);
      if (addressData.id !== void 0) {
        addressData = {
          ...addressData,
          id: void 0
        };
      }
      if (address.isDefaultBillingAddress || address.isDefaultShippingAddress) {
        addressData = {
          ...addressData,
          key: Guid.newGuid()
        };
      }
      customerUpdateActions.push({ action: "changeAddress", addressId: address.addressId, address: addressData });
      if (address.isDefaultBillingAddress) {
        customerUpdateActions.push({ action: "setDefaultBillingAddress", addressKey: addressData.key });
      }
      if (address.isDefaultShippingAddress) {
        customerUpdateActions.push({ action: "setDefaultShippingAddress", addressKey: addressData.key });
      }
      return await this.updateAccount(account, customerUpdateActions);
    };
    this.removeAddress = async (account, address) => {
      const customerUpdateActions = [];
      const addressData = AccountMapper.addressToCommercetoolsAddress(address);
      if (addressData.id === void 0) {
        throw new ValidationError({ message: `The address passed doesn't contain an id.` });
      }
      customerUpdateActions.push({ action: "removeAddress", addressId: address.addressId });
      return await this.updateAccount(account, customerUpdateActions);
    };
    this.setDefaultBillingAddress = async (account, address) => {
      const customerUpdateActions = [];
      const addressData = AccountMapper.addressToCommercetoolsAddress(address);
      customerUpdateActions.push({ action: "setDefaultBillingAddress", addressId: addressData.id });
      return await this.updateAccount(account, customerUpdateActions);
    };
    this.setDefaultShippingAddress = async (account, address) => {
      const customerUpdateActions = [];
      const addressData = AccountMapper.addressToCommercetoolsAddress(address);
      customerUpdateActions.push({ action: "setDefaultShippingAddress", addressId: addressData.id });
      return await this.updateAccount(account, customerUpdateActions);
    };
  }
  extractAddresses(account) {
    const commercetoolsAddresses = [];
    const billingAddresses = [];
    const shippingAddresses = [];
    let defaultBillingAddress;
    let defaultShippingAddress;
    account.addresses.forEach((address, key) => {
      const addressData = AccountMapper.addressToCommercetoolsAddress(address);
      commercetoolsAddresses.push(addressData);
      if (address.isDefaultBillingAddress) {
        billingAddresses.push(key);
        defaultBillingAddress = key;
      }
      if (address.isDefaultShippingAddress) {
        shippingAddresses.push(key);
        defaultShippingAddress = key;
      }
    });
    return {
      commercetoolsAddresses,
      billingAddresses,
      shippingAddresses,
      defaultBillingAddress,
      defaultShippingAddress
    };
  }
  async fetchAccountVersion(account) {
    var _a4;
    const commercetoolsAccount = await this.requestBuilder().customers().withId({ ID: account.accountId }).get().execute().catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
    return (_a4 = commercetoolsAccount.body) == null ? void 0 : _a4.version;
  }
  async updateAccount(account, customerUpdateActions) {
    const locale = await this.getCommercetoolsLocal();
    const accountVersion = await this.fetchAccountVersion(account);
    const customerUpdate = {
      version: accountVersion,
      actions: customerUpdateActions
    };
    return await this.requestBuilder().customers().withId({ ID: account.accountId }).post({
      body: customerUpdate
    }).execute().then((response) => {
      return AccountMapper.commercetoolsCustomerToAccount(response.body);
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async getConfirmationToken(account) {
    return await this.requestBuilder().customers().emailToken().post({
      body: {
        id: account.accountId,
        ttlMinutes: 2 * 7 * 24 * 60
      }
    }).execute().then((response) => {
      const accountToken = {
        email: account.email,
        token: response.body.value,
        tokenValidUntil: new Date(response.body.expiresAt)
      };
      return accountToken;
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async delete(account) {
    return this.requestBuilder().customers().withId({ ID: account.accountId }).delete({
      queryArgs: {
        version: account.version,
        dataErasure: true
      }
    }).execute().then((response) => response.body).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
};

// commerce-commercetools/utils/CartFetcher.ts
var CartFetcher = class {
  static async fetchCart(cartApi, request) {
    const cart = await this.fetchCartFromSession(cartApi, request);
    if (cart) {
      return cart;
    }
    return await cartApi.getAnonymous();
  }
  static async fetchCartFromSession(cartApi, request) {
    var _a4, _b;
    if (((_a4 = request.sessionData) == null ? void 0 : _a4.cartId) !== void 0) {
      try {
        return await cartApi.getActiveCartById(request.sessionData.cartId);
      } catch (error) {
        console.info(`It was not possible to fetch the cart ${request.sessionData.cartId}. ${error}`);
      }
    }
    if (((_b = request.sessionData) == null ? void 0 : _b.account) !== void 0) {
      return await cartApi.getForUser(request.sessionData.account);
    }
    return void 0;
  }
};

// commerce-commercetools/utils/Request.ts
var getPath = (request) => {
  var _a4;
  return (_a4 = getHeader(request, ["frontastic-path" /* frontasticPath */, "commercetools-frontend-path" /* commercetoolsFrontendPath */])) != null ? _a4 : request.query.path;
};
var getLocale = (request) => {
  var _a4;
  const locale = (_a4 = getHeader(request, ["commercetools-frontend-locale" /* commercetoolsFrontendLocale */, "frontastic-locale" /* frontasticLocale */])) != null ? _a4 : request.query.locale;
  if (locale !== void 0) {
    return locale;
  }
  throw new ValidationError({ message: `Locale is missing from request ${request}` });
};
var getCurrency = (request) => {
  var _a4;
  if (request !== void 0) {
    const currency = (_a4 = getHeader(request, ["commercetools-frontend-currency" /* commercetoolsFrontendCurrency */, "frontastic-currency" /* frontasticCurrency */])) != null ? _a4 : request.query["currency"];
    if (currency !== void 0) {
      return currency;
    }
  }
  return null;
};
var getHeader = (request, headers) => {
  for (const header of headers) {
    const foundHeader = request.headers[header.toLowerCase()];
    if (foundHeader !== void 0) {
      if (Array.isArray(foundHeader)) {
        return foundHeader[0];
      }
      return foundHeader;
    }
  }
  return null;
};

// email-sendgrid/apis/EmailApi.ts
var import_mail = __toESM(require_mail3());

// email-sendgrid/utils/Price.ts
var formatPrice = (money, locale) => {
  return new Intl.NumberFormat(locale, {
    style: "currency",
    currency: money.currencyCode,
    minimumFractionDigits: money.fractionDigits,
    maximumFractionDigits: money.fractionDigits
  }).format(money.centAmount / 100);
};

// email-sendgrid/utils/Context.ts
var projectConfigurationOverrides2 = {};
var isDevEnv2 = (context) => {
  return context.environment === "development" || context.environment === "dev";
};
var getFromProjectConfig2 = (key, context) => {
  if (isDevEnv2(context) && projectConfigurationOverrides2[key]) {
    return projectConfigurationOverrides2[key];
  }
  return context.projectConfiguration[key];
};

// email-sendgrid/apis/EmailApi.ts
var EmailApi = class {
  constructor(frontasticContext, locale) {
    var _a4, _b, _c, _d, _e, _f, _g, _h;
    this.client = import_mail.default;
    let apiKey = getFromProjectConfig2("EXTENSION_SENDGRID_API_KEY", frontasticContext);
    if (!apiKey) {
      apiKey = (_b = (_a4 = frontasticContext.project.configuration) == null ? void 0 : _a4.sendgrid) == null ? void 0 : _b.apiKey;
    }
    this.client.setApiKey(apiKey);
    this.locale = locale;
    this.configuration = {
      sender: getFromProjectConfig2("EXTENSION_SENDGRID_SENDER", frontasticContext),
      clientHost: getFromProjectConfig2("EXTENSION_SENDGRID_CLIENT_HOST", frontasticContext),
      templateIds: getFromProjectConfig2("EXTENSION_SENDGRID_TEMPLATE_IDS", frontasticContext)
    };
    if (!this.configuration.sender) {
      this.configuration.sender = (_d = (_c = frontasticContext.project.configuration) == null ? void 0 : _c.sendgrid) == null ? void 0 : _d.sender;
    }
    if (!this.configuration.clientHost) {
      this.configuration.clientHost = (_f = (_e = frontasticContext.project.configuration) == null ? void 0 : _e.sendgrid) == null ? void 0 : _f.clientHost;
    }
    if (!this.configuration.templateIds) {
      this.configuration.templateIds = (_h = (_g = frontasticContext.project.configuration) == null ? void 0 : _g.sendgrid) == null ? void 0 : _h.templateIds;
    }
  }
  async sendAccountVerificationEmail(customer) {
    await this.client.send({
      from: this.configuration.sender,
      personalizations: [
        {
          to: [customer.email],
          dynamicTemplateData: {
            customer,
            url: `${this.configuration.clientHost}/verify?token=${customer.confirmationToken.token}`
          }
        }
      ],
      templateId: this.configuration.templateIds.accountVerification
    });
  }
  async sendPasswordResetEmail(customer, token) {
    await this.client.send({
      from: this.configuration.sender,
      personalizations: [
        {
          to: [customer.email],
          dynamicTemplateData: {
            customer,
            url: `${this.configuration.clientHost}/reset-password?token=${token}`
          }
        }
      ],
      templateId: this.configuration.templateIds.passwordReset
    });
  }
  async sendOrderConfirmationEmail(order) {
    var _a4, _b;
    const locale = (_a4 = this.locale) == null ? void 0 : _a4.replace("_", "-");
    await this.client.send({
      from: this.configuration.sender,
      personalizations: [
        {
          to: [order.email],
          dynamicTemplateData: {
            order: {
              ...order,
              formattedTotalPrice: formatPrice(order.sum, locale),
              lineItems: order.lineItems.map((lineItem) => ({
                ...lineItem,
                formattedPrice: formatPrice(lineItem.totalPrice, locale),
                imageUrl: lineItem.variant.images[0]
              })),
              shippingInfo: {
                ...order.shippingInfo,
                formattedPrice: formatPrice((_b = order.shippingInfo) == null ? void 0 : _b.price, locale)
              }
            }
          }
        }
      ],
      templateId: this.configuration.templateIds.orderConfirmation
    });
  }
  async sendWelcomeCustomerEmail(customer) {
    await this.client.send({
      from: this.configuration.sender,
      personalizations: [
        {
          to: [customer.email],
          dynamicTemplateData: { customer }
        }
      ],
      templateId: this.configuration.templateIds.welcomeCustomer
    });
  }
  async sendAccountDeletionEmail(customer) {
    await this.client.send({
      from: this.configuration.sender,
      personalizations: [
        {
          to: [customer.email],
          dynamicTemplateData: { customer }
        }
      ],
      templateId: this.configuration.templateIds.accountDeletion
    });
  }
};

// email-smtp/apis/EmailApi.ts
var nodemailer = __toESM(require_nodemailer());

// email-smtp/errors/SmtpConfigurationError.ts
var SmtpConfigurationError = class _SmtpConfigurationError extends ExtensionError {
  constructor(options) {
    super(options);
    this.errorName = _SmtpConfigurationError.SMTP_CONFIGURATION_ERROR_NAME;
  }
};

// email-smtp/utils/get-customer-name.ts
var getCustomerName = (customer) => {
  if (customer.firstName && customer.lastName) {
    return `${customer.firstName} ${customer.lastName}`;
  }
  if (customer.firstName) {
    return customer.firstName;
  }
  return "";
};
var get_customer_name_default = getCustomerName;

// email-smtp/utils/Context.ts
var projectConfigurationOverrides3 = {};
var isDevEnv3 = (context) => {
  return context.environment === "development" || context.environment === "dev";
};
var getFromProjectConfig3 = (key, context) => {
  if (isDevEnv3(context) && projectConfigurationOverrides3[key]) {
    return projectConfigurationOverrides3[key];
  }
  return context.projectConfiguration[key];
};

// email-smtp/apis/EmailApi.ts
var EmailApi2 = class {
  constructor(frontasticContext, locale) {
    const smtpConfig = this.getSmtpConfig(frontasticContext);
    this.client_host = smtpConfig.client_host;
    this.sender = smtpConfig.sender;
    this.locale = locale;
    this.transport = nodemailer.createTransport({
      host: smtpConfig.host,
      port: +smtpConfig.port,
      secure: smtpConfig.port == 465,
      auth: {
        user: smtpConfig.user,
        pass: smtpConfig.password
      }
    });
  }
  getSmtpConfigValue(key, context) {
    var _a4, _b;
    let value = getFromProjectConfig3(`EXTENSION_SMTP_${key}`, context);
    if (!value) {
      value = (_b = (_a4 = context.project.configuration) == null ? void 0 : _a4.smtp) == null ? void 0 : _b[key.toLowerCase()];
    }
    if (!value) {
      throw new SmtpConfigurationError({
        message: `The SMTP configuration option "${key}" is missing in project "${context.project.projectId}"`
      });
    }
    return value;
  }
  getSmtpConfig(context) {
    const smtpConfig = {
      host: this.getSmtpConfigValue("HOST", context),
      port: this.getSmtpConfigValue("PORT", context),
      encryption: this.getSmtpConfigValue("ENCRYPTION", context),
      user: this.getSmtpConfigValue("USER", context),
      password: this.getSmtpConfigValue("PASSWORD", context),
      sender: this.getSmtpConfigValue("SENDER", context),
      client_host: this.getSmtpConfigValue("CLIENT_HOST", context)
    };
    return smtpConfig;
  }
  async sendEmail(data) {
    const from = this.sender;
    const { to, text, html, subject } = data;
    return await this.transport.sendMail({ from, to, subject, text, html });
  }
  async sendAccountVerificationEmail(customer) {
    var _a4;
    if (!((_a4 = customer.confirmationToken) == null ? void 0 : _a4.token)) {
      console.error("No valid confirmation token");
      return;
    }
    const verificationUrl = `${this.client_host}/verify?token=${customer.confirmationToken.token}`;
    const htmlVerificationMessage = `
      <h1>Thanks for your registration!</h1>
      <p style="margin-top: 10px;color:gray;">Please activate your account by clicking the below link</p>
      <a href="${verificationUrl}">${verificationUrl}</a>
    `;
    await this.sendEmail({
      to: customer.email,
      subject: "Account Verification",
      html: htmlVerificationMessage
    });
  }
  async sendPasswordResetEmail(customer, token) {
    if (!token) {
      console.error("No valid reset token");
      return;
    }
    const url = `${this.client_host}/reset-password?token=${token}`;
    const htmlResetPasswordMessage = `
      <h1>You requested a password reset!</h1>
      <p style="margin-top: 10px;color:gray;">Please click the link below to proceed.</p>
      <a href="${url}">${url}</a>
    `;
    await this.sendEmail({
      to: customer.email,
      subject: "Password Reset",
      html: htmlResetPasswordMessage
    });
  }
  async sendOrderConfirmationEmail(order) {
    const htmlPaymentConfirmationMessage = `
      <h1>Thanks for your order!</h1>
      <p style="margin-top: 10px;color:gray;">Your payment has been confirmed.</p>
    `;
    await this.sendEmail({
      to: order.email,
      subject: "Order confirmed",
      html: htmlPaymentConfirmationMessage
    });
  }
  async sendWelcomeCustomerEmail(customer) {
    const customerName = get_customer_name_default(customer);
    const htmlWelcomeCustomerMessage = `
      <h1>Hello ${customerName}</h1>
      <p>We are so happy to have you here!</p>
    `;
    await this.sendEmail({
      to: customer.email,
      subject: "Welcome",
      html: htmlWelcomeCustomerMessage
    });
  }
  async sendAccountDeletionEmail(customer) {
    const customerName = get_customer_name_default(customer);
    const htmlWelcomeCustomerMessage = `
      <h1>Hello ${customerName}</h1>
      <p>Your account has been deleted successfully!</p>
    `;
    await this.sendEmail({
      to: customer.email,
      subject: "Account deleted",
      html: htmlWelcomeCustomerMessage
    });
  }
};

// commerce-commercetools/utils/EmailApiFactory.ts
var EmailApiFactory = class {
  static getSmtpApi(context, locale) {
    return new EmailApi2(context, locale);
  }
  static getSendgridApi(context, locale) {
    return new EmailApi(context, locale);
  }
  static getDefaultApi(context, locale) {
    return this.getSmtpApi(context, locale);
  }
};

// commerce-commercetools/utils/Cart.ts
var hasUser = (cart) => {
  return cart.email !== void 0;
};
var hasShippingAddress = (cart) => {
  return cart.shippingAddress !== void 0 && cart.shippingAddress.firstName !== void 0 && cart.shippingAddress.lastName !== void 0 && cart.shippingAddress.postalCode !== void 0 && cart.shippingAddress.city !== void 0 && cart.shippingAddress.country !== void 0;
};
var hasBillingAddress = (cart) => {
  return cart.billingAddress !== void 0 && cart.billingAddress.firstName !== void 0 && cart.billingAddress.lastName !== void 0 && cart.billingAddress.postalCode !== void 0 && cart.billingAddress.city !== void 0 && cart.billingAddress.country !== void 0;
};
var hasAddresses = (cart) => {
  return hasShippingAddress(cart) && hasBillingAddress(cart);
};
var isReadyForCheckout = (cart) => {
  return hasUser(cart) && hasAddresses(cart);
};

// commerce-commercetools/errors/CartNotCompleteError.ts
var CartNotCompleteError = class _CartNotCompleteError extends ExtensionError {
  constructor(options) {
    super(options);
    this.errorName = _CartNotCompleteError.CART_NOT_COMPLETE_ERROR_NAME;
  }
};

// commerce-commercetools/errors/CartPaymentNotFoundError.ts
var CartPaymentNotFoundError = class _CartPaymentNotFoundError extends ExtensionError {
  constructor(options) {
    super(options);
    this.errorName = _CartPaymentNotFoundError.CART_PAYMENT_NOT_FOUND_ERROR_NAME;
  }
};

// commerce-commercetools/errors/CartRedeemDiscountCodeError.ts
var CartRedeemDiscountCodeError = class _CartRedeemDiscountCodeError extends ExtensionError {
  constructor(options) {
    super(options);
    this.errorName = _CartRedeemDiscountCodeError.CART_REDEEM_DISCOUNT_CODE_ERROR_NAME;
  }
};

// commerce-commercetools/utils/LocalizedValue.ts
var LocalizedValue = class {
};
LocalizedValue.getLocalizedValue = (locale, defaultLocale, productValue) => {
  if (!productValue) {
    return "";
  }
  if (productValue[locale.language]) {
    return productValue[locale.language];
  }
  if (productValue[defaultLocale]) {
    return productValue[defaultLocale];
  }
  return productValue[0];
};

// commerce-commercetools/mappers/ProductMapper.ts
var TypeMap = /* @__PURE__ */ new Map([
  ["boolean", "boolean" /* BOOLEAN */],
  ["enum", "enum" /* ENUM */],
  ["text", "text" /* TEXT */],
  ["number", "number" /* NUMBER */],
  ["lenum", "enum" /* ENUM */],
  ["ltext", "text" /* TEXT */],
  ["money", "money" /* MONEY */]
]);
var _ProductMapper = class _ProductMapper {
  static commercetoolsCategoriesToTreeCategory(commercetoolsCategories, categoryIdField, locale) {
    var _a4;
    const nodes = {};
    for (const category of commercetoolsCategories) {
      category.subCategories = [];
      nodes[category.id] = category;
    }
    for (const category of commercetoolsCategories) {
      if (!((_a4 = category.parent) == null ? void 0 : _a4.id))
        continue;
      nodes[category.parent.id].subCategories.push(category);
    }
    return commercetoolsCategories.filter((category) => category.ancestors.length === 0).map((category) => this.commercetoolsCategoryToCategory(category, categoryIdField, locale));
  }
  static extractAttributeValue(commercetoolsAttributeValue, locale) {
    if (commercetoolsAttributeValue["key"] !== void 0 && commercetoolsAttributeValue["label"] !== void 0) {
      return {
        key: commercetoolsAttributeValue["key"],
        label: _ProductMapper.extractAttributeValue(commercetoolsAttributeValue["label"], locale)
      };
    }
    if (commercetoolsAttributeValue instanceof Array) {
      return commercetoolsAttributeValue.map((value) => _ProductMapper.extractAttributeValue(value, locale));
    }
    return commercetoolsAttributeValue[locale.language] || commercetoolsAttributeValue;
  }
  static commercetoolsProductDiscountValueToProductDiscountValue(commercetoolsProductDiscountValue, locale) {
    var _a4;
    const productDiscountValue = {
      type: commercetoolsProductDiscountValue.value.type,
      description: (_a4 = commercetoolsProductDiscountValue.description) == null ? void 0 : _a4[locale.language]
    };
    if (commercetoolsProductDiscountValue.value.type == "relative") {
      Object.assign(productDiscountValue, {
        permyriad: commercetoolsProductDiscountValue.value.permyriad
      });
    }
    if (commercetoolsProductDiscountValue.value.type == "absolute") {
      const discountValues = commercetoolsProductDiscountValue.value.money.map((money) => {
        return this.commercetoolsMoneyToMoney(money);
      });
      Object.assign(productDiscountValue, {
        value: discountValues
      });
    }
    return [productDiscountValue];
  }
  static extractPriceAndDiscounts(commercetoolsVariant, locale) {
    var _a4, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B;
    let price;
    let discountedPrice;
    let discounts;
    if (commercetoolsVariant == null ? void 0 : commercetoolsVariant.scopedPrice) {
      price = this.commercetoolsMoneyToMoney((_a4 = commercetoolsVariant.scopedPrice) == null ? void 0 : _a4.value);
      if ((_c = (_b = commercetoolsVariant.scopedPrice) == null ? void 0 : _b.discounted) == null ? void 0 : _c.value) {
        discountedPrice = this.commercetoolsMoneyToMoney((_e = (_d = commercetoolsVariant.scopedPrice) == null ? void 0 : _d.discounted) == null ? void 0 : _e.value);
      }
      if ((_h = (_g = (_f = commercetoolsVariant.scopedPrice) == null ? void 0 : _f.discounted) == null ? void 0 : _g.discount) == null ? void 0 : _h.obj) {
        discounts = this.commercetoolsProductDiscountValueToProductDiscountValue(
          (_k = (_j = (_i = commercetoolsVariant.scopedPrice) == null ? void 0 : _i.discounted) == null ? void 0 : _j.discount) == null ? void 0 : _k.obj,
          locale
        );
      }
      return { price, discountedPrice, discounts };
    }
    if (commercetoolsVariant == null ? void 0 : commercetoolsVariant.price) {
      price = this.commercetoolsMoneyToMoney((_l = commercetoolsVariant.price) == null ? void 0 : _l.value);
      if ((_n = (_m = commercetoolsVariant.price) == null ? void 0 : _m.discounted) == null ? void 0 : _n.value) {
        discountedPrice = this.commercetoolsMoneyToMoney((_p = (_o = commercetoolsVariant.price) == null ? void 0 : _o.discounted) == null ? void 0 : _p.value);
      }
      if ((_s = (_r = (_q = commercetoolsVariant.price) == null ? void 0 : _q.discounted) == null ? void 0 : _r.discount) == null ? void 0 : _s.obj) {
        discounts = this.commercetoolsProductDiscountValueToProductDiscountValue(
          (_v = (_u = (_t = commercetoolsVariant.price) == null ? void 0 : _t.discounted) == null ? void 0 : _u.discount) == null ? void 0 : _v.obj,
          locale
        );
      }
      return { price, discountedPrice, discounts };
    }
    if (commercetoolsVariant == null ? void 0 : commercetoolsVariant.prices) {
      let commercetoolsPrice = commercetoolsVariant == null ? void 0 : commercetoolsVariant.prices.find((price2) => {
        return !price2.hasOwnProperty("channel") && !price2.hasOwnProperty("customerGroup") && price2.country === locale.country && price2.value.currencyCode === locale.currency;
      });
      if (!commercetoolsPrice) {
        commercetoolsPrice = commercetoolsVariant == null ? void 0 : commercetoolsVariant.prices.find((price2) => {
          return !price2.hasOwnProperty("channel") && !price2.hasOwnProperty("customerGroup") && !price2.hasOwnProperty("country") && price2.value.currencyCode === locale.currency;
        });
      }
      price = this.commercetoolsMoneyToMoney(commercetoolsPrice == null ? void 0 : commercetoolsPrice.value);
      if ((_w = commercetoolsPrice == null ? void 0 : commercetoolsPrice.discounted) == null ? void 0 : _w.value) {
        discountedPrice = this.commercetoolsMoneyToMoney((_x = commercetoolsPrice == null ? void 0 : commercetoolsPrice.discounted) == null ? void 0 : _x.value);
      }
      if ((_z = (_y = commercetoolsPrice == null ? void 0 : commercetoolsPrice.discounted) == null ? void 0 : _y.discount) == null ? void 0 : _z.obj) {
        discounts = this.commercetoolsProductDiscountValueToProductDiscountValue(
          (_B = (_A = commercetoolsPrice == null ? void 0 : commercetoolsPrice.discounted) == null ? void 0 : _A.discount) == null ? void 0 : _B.obj,
          locale
        );
      }
      return { price, discountedPrice, discounts };
    }
    return { price, discountedPrice, discounts };
  }
  static commercetoolsMoneyToMoney(commercetoolsMoney) {
    if (commercetoolsMoney === void 0) {
      return void 0;
    }
    return {
      fractionDigits: commercetoolsMoney.hasOwnProperty("fractionDigits") && commercetoolsMoney.fractionDigits !== void 0 ? commercetoolsMoney.fractionDigits : 2,
      centAmount: commercetoolsMoney.centAmount,
      currencyCode: commercetoolsMoney.currencyCode
    };
  }
  static commercetoolsProductTypesToFilterFields(commercetoolsProductTypes, locale) {
    const filterFields = [];
    commercetoolsProductTypes == null ? void 0 : commercetoolsProductTypes.forEach((productType) => {
      var _a4;
      (_a4 = productType.attributes) == null ? void 0 : _a4.forEach((attribute) => {
        if (!attribute.isSearchable) {
          return;
        }
        filterFields.push(_ProductMapper.commercetoolsAttributeDefinitionToFilterField(attribute, locale));
      });
    });
    return filterFields;
  }
  static commercetoolsAttributeDefinitionToFilterField(commercetoolsAttributeDefinition, locale) {
    var _a4, _b, _c, _d, _e;
    let commercetoolsAttributeTypeName = commercetoolsAttributeDefinition.type.name;
    let commercetoolsAttributeValues = ((_a4 = commercetoolsAttributeDefinition.type) == null ? void 0 : _a4.hasOwnProperty("values")) ? commercetoolsAttributeDefinition.type.values : [];
    if (commercetoolsAttributeTypeName === "set") {
      const elementType = commercetoolsAttributeDefinition.type.elementType;
      commercetoolsAttributeTypeName = elementType.name;
      commercetoolsAttributeValues = (elementType == null ? void 0 : elementType.hasOwnProperty("values")) ? elementType.values : [];
    }
    const filterFieldValues = [];
    for (const value of commercetoolsAttributeValues) {
      filterFieldValues.push({
        value: value.key,
        name: (_c = (_b = value == null ? void 0 : value.label) == null ? void 0 : _b[locale.language]) != null ? _c : value == null ? void 0 : value.label
      });
    }
    return {
      field: `variants.attributes.${commercetoolsAttributeDefinition.name}`,
      type: TypeMap.has(commercetoolsAttributeTypeName) ? TypeMap.get(commercetoolsAttributeTypeName) : commercetoolsAttributeTypeName,
      label: (_e = (_d = commercetoolsAttributeDefinition.label) == null ? void 0 : _d[locale.language]) != null ? _e : commercetoolsAttributeDefinition.name,
      values: filterFieldValues.length > 0 ? filterFieldValues : void 0,
      translatable: false
    };
  }
  static commercetoolsProductTypesToFacetDefinitions(commercetoolsProductTypes, locale) {
    const facetDefinitionsIndex = {};
    const facetDefinitions = [];
    commercetoolsProductTypes == null ? void 0 : commercetoolsProductTypes.forEach((productType) => {
      var _a4;
      (_a4 = productType.attributes) == null ? void 0 : _a4.forEach((attribute) => {
        if (!attribute.isSearchable) {
          return;
        }
        const facetDefinition = {
          attributeType: attribute.type.name,
          attributeId: `variants.attributes.${attribute.name}`,
          attributeLabel: attribute.label[locale.language] !== void 0 && attribute.label[locale.language].length > 0 ? attribute.label[locale.language] : attribute.name
        };
        if (facetDefinition.attributeId)
          facetDefinitionsIndex[facetDefinition.attributeId] = facetDefinition;
      });
    });
    for (const [attributeId, facetDefinition] of Object.entries(facetDefinitionsIndex)) {
      facetDefinitions.push(facetDefinition);
    }
    return facetDefinitions;
  }
  static facetDefinitionsToCommercetoolsQueryArgFacets(facetDefinitions, locale) {
    const queryArgFacets = [];
    facetDefinitions == null ? void 0 : facetDefinitions.forEach((facetDefinition) => {
      let facet;
      switch (facetDefinition.attributeType) {
        case "money":
          facet = `${facetDefinition.attributeId}.centAmount:range (0 to *)`;
          break;
        case "enum":
          facet = `${facetDefinition.attributeId}.label`;
          break;
        case "lenum":
          facet = `${facetDefinition.attributeId}.label.${locale.language}`;
          break;
        case "ltext":
          facet = `${facetDefinition.attributeId}.${locale.language}`;
          break;
        case "number":
        case "boolean":
        case "text":
        case "reference":
        default:
          facet = facetDefinition.attributeId;
          break;
      }
      queryArgFacets.push(`${facet} as ${facetDefinition.attributeId}`);
    });
    return queryArgFacets;
  }
  static facetDefinitionsToFilterQueries(queryFilters, facetDefinitions, locale) {
    const filterQueries = [];
    const typeLookup = {};
    if (facetDefinitions.length === 0) {
      return filterQueries;
    }
    facetDefinitions.forEach((facetDefinition) => {
      if (facetDefinition.attributeId)
        typeLookup[facetDefinition.attributeId] = facetDefinition.attributeType || "";
    });
    queryFilters.forEach((queryFilter) => {
      var _a4, _b, _c, _d;
      if (!(typeLookup == null ? void 0 : typeLookup.hasOwnProperty(queryFilter.identifier))) {
        return;
      }
      switch (typeLookup[queryFilter.identifier]) {
        case "money":
          filterQueries.push(
            `${queryFilter.identifier}.centAmount:range (${queryFilter.min} to ${queryFilter.max})`
          );
          break;
        case "enum":
          filterQueries.push(`${queryFilter.identifier}.label:"${(_a4 = queryFilter.terms) == null ? void 0 : _a4.join('","')}"`);
          break;
        case "lenum":
          filterQueries.push(
            `${queryFilter.identifier}.label.${locale.language}:"${(_b = queryFilter.terms) == null ? void 0 : _b.join('","')}"`
          );
          break;
        case "ltext":
          filterQueries.push(
            `${queryFilter.identifier}.${locale.language}:"${(_c = queryFilter.terms) == null ? void 0 : _c.join('","')}"`
          );
          break;
        case "number":
        case "boolean":
        case "text":
        case "reference":
        default:
          if (queryFilter.type === "term" /* TERM */) {
            filterQueries.push(`${queryFilter.identifier}:"${(_d = queryFilter.terms) == null ? void 0 : _d.join('","')}"`);
            break;
          }
          if (queryFilter.type === "boolean" /* BOOLEAN */) {
            filterQueries.push(
              `${queryFilter.identifier}:"${queryFilter.terms[0] === "T" ? "true" : "false"}"`
            );
            break;
          }
          filterQueries.push(
            `${queryFilter.identifier}:range (${queryFilter.min} to ${queryFilter.max})`
          );
          break;
      }
    });
    return filterQueries;
  }
  static facetDefinitionsToFilterFacets(queryFacets, facetDefinitions, locale) {
    const filterFacets = [];
    const typeLookup = {};
    if (facetDefinitions.length === 0) {
      return filterFacets;
    }
    facetDefinitions.forEach((facetDefinition) => {
      if (facetDefinition.attributeId)
        typeLookup[facetDefinition.attributeId] = facetDefinition.attributeType || "";
    });
    queryFacets.forEach((queryFacet) => {
      var _a4, _b, _c, _d;
      if (!(typeLookup == null ? void 0 : typeLookup.hasOwnProperty(queryFacet.identifier))) {
        return;
      }
      switch (typeLookup[queryFacet.identifier]) {
        case "money":
          filterFacets.push(
            `${queryFacet.identifier}.centAmount:range (${queryFacet.min} to ${queryFacet.max})`
          );
          break;
        case "enum":
          filterFacets.push(`${queryFacet.identifier}.label:"${(_a4 = queryFacet.terms) == null ? void 0 : _a4.join('","')}"`);
          break;
        case "lenum":
          filterFacets.push(
            `${queryFacet.identifier}.label.${locale.language}:"${(_b = queryFacet.terms) == null ? void 0 : _b.join('","')}"`
          );
          break;
        case "ltext":
          filterFacets.push(
            `${queryFacet.identifier}.${locale.language}:"${(_c = queryFacet.terms) == null ? void 0 : _c.join('","')}"`
          );
          break;
        case "number":
        case "boolean":
        case "text":
        case "reference":
        default:
          if (queryFacet.type === "term" /* TERM */) {
            filterFacets.push(`${queryFacet.identifier}:"${(_d = queryFacet.terms) == null ? void 0 : _d.join('","')}"`);
            break;
          }
          if (queryFacet.type === "boolean" /* BOOLEAN */) {
            filterFacets.push(
              `${queryFacet.identifier}:"${queryFacet.terms[0] === "T" ? "true" : "false"}"`
            );
            break;
          }
          filterFacets.push(
            `${queryFacet.identifier}:range (${queryFacet.min} to ${queryFacet.max})`
          );
          break;
      }
    });
    return filterFacets;
  }
  static commercetoolsFacetResultsToFacets(facetDefinitions, commercetoolsFacetResults, productQuery, locale) {
    const facets = [];
    let facetLabel;
    for (const [facetKey, facetResult] of Object.entries(commercetoolsFacetResults)) {
      const facetQuery = this.findFacetQuery(productQuery, facetKey);
      facetDefinitions.filter((facet) => {
        if (facet.attributeId === facetKey) {
          facetLabel = facet.attributeLabel;
        }
      });
      switch (facetResult.type) {
        case "range":
          facets.push(
            _ProductMapper.commercetoolsRangeFacetResultToRangeFacet(
              facetLabel,
              facetKey,
              facetResult,
              facetQuery
            )
          );
          break;
        case "terms":
          if (facetResult.dataType === "number") {
            facets.push(
              _ProductMapper.commercetoolsTermNumberFacetResultToRangeFacet(
                facetLabel,
                facetKey,
                facetResult,
                facetQuery
              )
            );
            break;
          }
          facets.push(
            _ProductMapper.commercetoolsTermFacetResultToTermFacet(
              facetLabel,
              facetKey,
              facetResult,
              facetQuery
            )
          );
          break;
        case "filter":
          facets.push(
            _ProductMapper.commercetoolsFilteredFacetResultToFacet(
              facetLabel,
              facetKey,
              facetResult,
              facetQuery
            )
          );
          break;
        default:
          break;
      }
    }
    return facets;
  }
  static commercetoolsRangeFacetResultToRangeFacet(facetLabel, facetKey, facetResult, facetQuery) {
    const rangeFacet = {
      type: "range" /* RANGE */,
      identifier: facetKey,
      label: facetLabel,
      key: facetKey,
      min: facetResult.ranges[0].min,
      max: facetResult.ranges[0].max,
      selected: facetQuery !== void 0,
      minSelected: facetQuery ? facetQuery.min : void 0,
      maxSelected: facetQuery ? facetQuery.max : void 0
    };
    return rangeFacet;
  }
  static commercetoolsTermFacetResultToTermFacet(facetLabel, facetKey, facetResult, facetQuery) {
    const termFacet = {
      type: facetResult.dataType === "boolean" ? "boolean" /* BOOLEAN */ : "term" /* TERM */,
      identifier: facetKey,
      label: facetLabel,
      key: facetKey,
      count: facetResult.total,
      selected: facetQuery !== void 0,
      terms: facetResult.terms.map((facetResultTerm) => {
        var _a4;
        const term = {
          identifier: facetResultTerm.term.toString(),
          label: facetResultTerm.term.toString(),
          count: facetResultTerm.count,
          key: facetResultTerm.term.toString(),
          selected: facetQuery !== void 0 && ((_a4 = facetQuery.terms) == null ? void 0 : _a4.includes(facetResultTerm.term.toString()))
        };
        return term;
      })
    };
    return termFacet;
  }
  static commercetoolsFilteredFacetResultToFacet(facetLabel, facetKey, facetResult, facetQuery) {
    const facet = {
      type: "term" /* TERM */,
      identifier: facetKey,
      label: facetLabel,
      key: facetKey,
      count: facetResult.count,
      selected: facetQuery !== void 0
    };
    return facet;
  }
  static commercetoolsTermNumberFacetResultToRangeFacet(facetLabel, facetKey, facetResult, facetQuery) {
    var _a4, _b;
    const rangeFacet = {
      type: "range" /* RANGE */,
      identifier: facetKey,
      label: facetLabel,
      key: facetKey,
      count: facetResult.total,
      min: (_a4 = Math.min(...facetResult.terms.map((facetResultTerm) => facetResultTerm.term))) != null ? _a4 : Number.MIN_SAFE_INTEGER,
      max: (_b = Math.max(...facetResult.terms.map((facetResultTerm) => facetResultTerm.term))) != null ? _b : Number.MAX_SAFE_INTEGER
    };
    if (facetQuery) {
      rangeFacet.selected = true;
      rangeFacet.minSelected = facetQuery.min;
      rangeFacet.maxSelected = facetQuery.max;
    }
    return rangeFacet;
  }
  static calculatePreviousCursor(offset, count) {
    return offset - count >= 0 ? `offset:${offset - count}` : void 0;
  }
  static calculateNextCursor(offset, count, total) {
    return offset + count < total ? `offset:${offset + count}` : void 0;
  }
  static findFacetQuery(productQuery, facetKey) {
    if (productQuery.facets !== void 0) {
      for (const facet of productQuery.facets) {
        if (facet.identifier === facetKey) {
          return facet;
        }
      }
    }
    return void 0;
  }
};
_ProductMapper.commercetoolsProductProjectionToProduct = (commercetoolsProduct, productIdField, categoryIdField, locale, defaultLocale) => {
  var _a4;
  const product = {
    productId: commercetoolsProduct == null ? void 0 : commercetoolsProduct[productIdField],
    version: (_a4 = commercetoolsProduct == null ? void 0 : commercetoolsProduct.version) == null ? void 0 : _a4.toString(),
    name: LocalizedValue.getLocalizedValue(locale, defaultLocale, commercetoolsProduct == null ? void 0 : commercetoolsProduct.name),
    slug: LocalizedValue.getLocalizedValue(locale, defaultLocale, commercetoolsProduct == null ? void 0 : commercetoolsProduct.slug),
    description: LocalizedValue.getLocalizedValue(locale, defaultLocale, commercetoolsProduct == null ? void 0 : commercetoolsProduct.description),
    categories: _ProductMapper.commercetoolsCategoryReferencesToCategories(
      commercetoolsProduct.categories,
      categoryIdField,
      locale
    ),
    variants: _ProductMapper.commercetoolsProductProjectionToVariants(commercetoolsProduct, locale)
  };
  product._url = ProductRouter.generateUrlFor(product);
  return product;
};
_ProductMapper.commercetoolsProductProjectionToVariants = (commercetoolsProduct, locale) => {
  const variants = [];
  if (commercetoolsProduct == null ? void 0 : commercetoolsProduct.masterVariant) {
    variants.push(_ProductMapper.commercetoolsProductVariantToVariant(commercetoolsProduct.masterVariant, locale));
  }
  for (let i = 0; i < commercetoolsProduct.variants.length; i++) {
    variants.push(_ProductMapper.commercetoolsProductVariantToVariant(commercetoolsProduct.variants[i], locale));
  }
  return variants;
};
_ProductMapper.commercetoolsProductVariantToVariant = (commercetoolsVariant, locale) => {
  var _a4, _b, _c, _d, _e, _f, _g, _h, _i;
  const attributes = commercetoolsVariant.attributes ? _ProductMapper.commercetoolsAttributesToAttributes(commercetoolsVariant.attributes, locale) : [];
  const { price, discountedPrice, discounts } = _ProductMapper.extractPriceAndDiscounts(commercetoolsVariant, locale);
  return {
    id: (_a4 = commercetoolsVariant.id) == null ? void 0 : _a4.toString(),
    sku: (_b = commercetoolsVariant.sku) == null ? void 0 : _b.toString(),
    images: [
      ...(_d = (_c = commercetoolsVariant == null ? void 0 : commercetoolsVariant.assets) == null ? void 0 : _c.map((asset) => {
        var _a5;
        return (_a5 = asset.sources) == null ? void 0 : _a5[0].uri;
      })) != null ? _d : [],
      ...(_f = (_e = commercetoolsVariant == null ? void 0 : commercetoolsVariant.images) == null ? void 0 : _e.map((image) => image.url)) != null ? _f : []
    ],
    groupId: (attributes == null ? void 0 : attributes.baseId) || void 0,
    attributes,
    price,
    discountedPrice,
    discounts,
    isOnStock: (_g = commercetoolsVariant.availability) == null ? void 0 : _g.isOnStock,
    restockableInDays: (_h = commercetoolsVariant.availability) == null ? void 0 : _h.restockableInDays,
    availableQuantity: (_i = commercetoolsVariant.availability) == null ? void 0 : _i.availableQuantity
  };
};
_ProductMapper.commercetoolsAttributesToAttributes = (commercetoolsAttributes, locale) => {
  const attributes = {};
  commercetoolsAttributes == null ? void 0 : commercetoolsAttributes.forEach((commercetoolsAttribute) => {
    attributes[commercetoolsAttribute.name] = _ProductMapper.extractAttributeValue(
      commercetoolsAttribute.value,
      locale
    );
  });
  return attributes;
};
_ProductMapper.commercetoolsCategoryReferencesToCategories = (commercetoolsCategoryReferences, categoryIdField, locale) => {
  const categories = [];
  commercetoolsCategoryReferences.forEach((commercetoolsCategory) => {
    let category = {
      categoryId: commercetoolsCategory.id
    };
    if (commercetoolsCategory.obj) {
      category = _ProductMapper.commercetoolsCategoryToCategory(commercetoolsCategory.obj, categoryIdField, locale);
    }
    categories.push(category);
  });
  return categories;
};
_ProductMapper.commercetoolsCategoryToCategory = (commercetoolsCategory, categoryIdField, locale) => {
  var _a4, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  return {
    categoryId: commercetoolsCategory == null ? void 0 : commercetoolsCategory[categoryIdField],
    parentId: (_b = (_a4 = commercetoolsCategory.parent) == null ? void 0 : _a4.obj) == null ? void 0 : _b[categoryIdField],
    name: (_d = (_c = commercetoolsCategory.name) == null ? void 0 : _c[locale.language]) != null ? _d : void 0,
    slug: (_f = (_e = commercetoolsCategory.slug) == null ? void 0 : _e[locale.language]) != null ? _f : void 0,
    depth: commercetoolsCategory.ancestors.length,
    subCategories: (_g = commercetoolsCategory.subCategories) == null ? void 0 : _g.map(
      (subCategory) => _ProductMapper.commercetoolsCategoryToCategory(subCategory, categoryIdField, locale)
    ),
    _url: commercetoolsCategory.ancestors.length > 0 ? `/${(_h = commercetoolsCategory.ancestors) == null ? void 0 : _h.map((ancestor) => {
      var _a5, _b2, _c2;
      return (_c2 = (_b2 = (_a5 = ancestor.obj) == null ? void 0 : _a5.slug) == null ? void 0 : _b2[locale.language]) != null ? _c2 : ancestor.id;
    }).join("/")}/${(_j = (_i = commercetoolsCategory.slug) == null ? void 0 : _i[locale.language]) != null ? _j : commercetoolsCategory.id}` : `/${(_l = (_k = commercetoolsCategory.slug) == null ? void 0 : _k[locale.language]) != null ? _l : commercetoolsCategory.id}`
  };
};
var ProductMapper = _ProductMapper;

// commerce-commercetools/apis/ProductApi.ts
var ProductApi = class extends BaseApi {
  async query(productQuery) {
    const locale = await this.getCommercetoolsLocal();
    const limit = +productQuery.limit || 24;
    const filterQuery = [];
    const filterFacets = [];
    const sortAttributes = [];
    const facetDefinitions = [
      ...ProductMapper.commercetoolsProductTypesToFacetDefinitions(await this.getProductTypes(), locale),
      // Include Category facet
      {
        attributeId: "categories.id",
        attributeType: "text"
      },
      // Include Scoped Price facet
      {
        attributeId: "variants.scopedPrice.value",
        attributeType: "money"
      },
      // Include Price facet
      {
        attributeId: "variants.price",
        attributeType: "money"
      },
      // Include Scoped Price discount facet
      {
        attributeId: "variants.scopedPriceDiscounted",
        attributeType: "boolean"
      }
    ];
    const queryArgFacets = ProductMapper.facetDefinitionsToCommercetoolsQueryArgFacets(facetDefinitions, locale);
    if (productQuery.productIds !== void 0 && productQuery.productIds.length !== 0) {
      filterQuery.push(`${this.productIdField}:"${productQuery.productIds.join('","')}"`);
    }
    if (productQuery.skus !== void 0 && productQuery.skus.length !== 0) {
      filterQuery.push(`variants.sku:"${productQuery.skus.join('","')}"`);
    }
    if (productQuery.categories !== void 0 && productQuery.categories.length !== 0) {
      let categoryIds = productQuery.categories.filter(function uniqueCategories(value, index2, self2) {
        return self2.indexOf(value) === index2;
      });
      if (this.categoryIdField !== "id") {
        const categoriesMethodArgs = {
          queryArgs: {
            where: [`key in ("${categoryIds.join('","')}")`]
          }
        };
        categoryIds = await this.getCommercetoolsCategoryPagedQueryResponse(categoriesMethodArgs).then((response) => {
          return response.body.results.map((category) => {
            return category.id;
          });
        });
      }
      filterQuery.push(
        `categories.id: ${categoryIds.map((category) => {
          return `subtree("${category}")`;
        })}`
      );
    }
    if (productQuery.filters !== void 0) {
      filterQuery.push(
        ...ProductMapper.facetDefinitionsToFilterQueries(productQuery.filters, facetDefinitions, locale)
      );
    }
    if (productQuery.facets !== void 0) {
      filterFacets.push(...ProductMapper.facetDefinitionsToFilterFacets(productQuery.facets, facetDefinitions, locale));
    }
    switch (true) {
      case productQuery.sortAttributes !== void 0:
        Object.keys(productQuery.sortAttributes).map((field, directionIndex) => {
          sortAttributes.push(`${field} ${Object.values(productQuery.sortAttributes)[directionIndex]}`);
        });
        break;
      default:
        sortAttributes.push(`score desc`, `id desc`);
    }
    const methodArgs = {
      queryArgs: {
        sort: sortAttributes,
        limit,
        offset: this.getOffsetFromCursor(productQuery.cursor),
        priceCurrency: locale.currency,
        priceCountry: locale.country,
        facet: queryArgFacets.length > 0 ? queryArgFacets : void 0,
        filter: filterFacets.length > 0 ? filterFacets : void 0,
        "filter.facets": filterFacets.length > 0 ? filterFacets : void 0,
        "filter.query": filterQuery.length > 0 ? filterQuery : void 0,
        [`text.${locale.language}`]: productQuery.query,
        expand: ["categories[*].ancestors[*]", "categories[*].parent"],
        fuzzy: true
      }
    };
    return await this.requestBuilder().productProjections().search().get(methodArgs).execute().then((response) => {
      const items = response.body.results.map(
        (product) => ProductMapper.commercetoolsProductProjectionToProduct(
          product,
          this.productIdField,
          this.categoryIdField,
          locale,
          this.defaultLocale
        )
      );
      const result = {
        total: response.body.total,
        items,
        count: response.body.count,
        facets: ProductMapper.commercetoolsFacetResultsToFacets(
          facetDefinitions,
          response.body.facets,
          productQuery,
          locale
        ),
        previousCursor: ProductMapper.calculatePreviousCursor(response.body.offset, response.body.count),
        nextCursor: ProductMapper.calculateNextCursor(response.body.offset, response.body.count, response.body.total),
        query: productQuery
      };
      return result;
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async getProduct(productQuery) {
    const result = await this.query(productQuery);
    return result.items.shift();
  }
  async getSearchableAttributes() {
    const locale = await this.getCommercetoolsLocal();
    const response = await this.requestBuilder().productTypes().get().execute().catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
    const filterFields = ProductMapper.commercetoolsProductTypesToFilterFields(response.body.results, locale);
    filterFields.push({
      field: "categoryIds",
      type: "enum" /* ENUM */,
      label: "Category",
      values: await this.queryCategories({ limit: 250, format: "tree" /* TREE */ }).then((result) => {
        return result.items.map((item) => {
          return {
            value: item.categoryId,
            name: item.name
          };
        });
      })
    });
    filterFields.push({
      field: "variants.price",
      type: "money" /* MONEY */,
      label: "Variants price"
      // TODO: localize label
    });
    filterFields.push({
      field: "variants.scopedPrice.value",
      type: "money" /* MONEY */,
      label: "Variants scoped price"
      // TODO: localize label
    });
    return filterFields;
  }
  async queryCategories(categoryQuery) {
    const locale = await this.getCommercetoolsLocal();
    const limit = +categoryQuery.limit || 24;
    const where = [];
    if (categoryQuery.slug) {
      where.push(`slug(${locale.language}="${categoryQuery.slug}")`);
    }
    if (categoryQuery.parentId) {
      where.push(`parent(id="${categoryQuery.parentId}")`);
    }
    const methodArgs = {
      queryArgs: {
        limit,
        offset: this.getOffsetFromCursor(categoryQuery.cursor),
        where: where.length > 0 ? where : void 0,
        expand: ["ancestors[*]", "parent"]
      }
    };
    return await this.getCommercetoolsCategoryPagedQueryResponse(methodArgs).then((response) => {
      const items = categoryQuery.format === "tree" /* TREE */ ? ProductMapper.commercetoolsCategoriesToTreeCategory(response.body.results, this.categoryIdField, locale) : response.body.results.map(
        (category) => ProductMapper.commercetoolsCategoryToCategory(category, this.categoryIdField, locale)
      );
      const result = {
        total: response.body.total,
        items,
        count: response.body.count,
        previousCursor: ProductMapper.calculatePreviousCursor(response.body.offset, response.body.count),
        nextCursor: ProductMapper.calculateNextCursor(response.body.offset, response.body.count, response.body.total),
        query: categoryQuery
      };
      return result;
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  getOffsetFromCursor(cursor) {
    if (cursor === void 0) {
      return void 0;
    }
    const offsetMach = cursor.match(/(?<=offset:).+/);
    return offsetMach !== null ? +Object.values(offsetMach)[0] : void 0;
  }
  async getCommercetoolsCategoryPagedQueryResponse(methodArgs) {
    return await this.requestBuilder().categories().get(methodArgs).execute().catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
};

// commerce-commercetools/utils/routers/ProductRouter.ts
var _ProductRouter = class _ProductRouter {
  static isProduct(product) {
    return product.hasOwnProperty("slug");
  }
  static generateUrlFor(item) {
    if (_ProductRouter.isProduct(item)) {
      return `/${item.slug}/p/${item.variants[0].sku}`;
    }
    return `/slug/p/${item.variant.sku}`;
  }
  static identifyFrom(request) {
    var _a4;
    if ((_a4 = getPath(request)) == null ? void 0 : _a4.match(/\/p\/([^\/]+)/)) {
      return true;
    }
    return false;
  }
};
_ProductRouter.loadFor = async (request, commercetoolsFrontendContext) => {
  var _a4;
  const productApi = new ProductApi(commercetoolsFrontendContext, getLocale(request), getCurrency(request), request);
  const urlMatches = (_a4 = getPath(request)) == null ? void 0 : _a4.match(/\/p\/([^\/]+)/);
  if (urlMatches) {
    const productQuery = {
      skus: [urlMatches[1]]
    };
    return productApi.getProduct(productQuery);
  }
  return null;
};
var ProductRouter = _ProductRouter;

// commerce-commercetools/mappers/CartMapper.ts
var _CartMapper = class _CartMapper {
  static commercetoolsDiscountedPricesPerQuantityToDiscountedPricePerCount(commercetoolsDiscountedLineItemPricesForQuantity, locale, defaultLocale) {
    return commercetoolsDiscountedLineItemPricesForQuantity == null ? void 0 : commercetoolsDiscountedLineItemPricesForQuantity.map((commercetoolsDiscountedLineItemPriceForQuantity) => {
      return {
        count: commercetoolsDiscountedLineItemPriceForQuantity.quantity,
        discounts: commercetoolsDiscountedLineItemPriceForQuantity.discountedPrice.includedDiscounts.map(
          (commercetoolsDiscountedLineItemPortion) => this.commercetoolsDiscountedLineItemPortionToDiscount(
            commercetoolsDiscountedLineItemPortion,
            locale,
            defaultLocale
          )
        )
      };
    });
  }
  static commercetoolsTaxedItemPriceToTaxed(commercetoolsTaxedPrice) {
    if (commercetoolsTaxedPrice === void 0) {
      return void 0;
    }
    return {
      netAmount: ProductMapper.commercetoolsMoneyToMoney(commercetoolsTaxedPrice.totalNet),
      grossAmount: ProductMapper.commercetoolsMoneyToMoney(commercetoolsTaxedPrice.totalGross),
      taxAmount: ProductMapper.commercetoolsMoneyToMoney(commercetoolsTaxedPrice.totalTax)
    };
  }
  static commercetoolsTaxRateToTaxRate(commercetoolsTaxRate) {
    if (commercetoolsTaxRate === void 0) {
      return void 0;
    }
    return {
      taxRateId: commercetoolsTaxRate == null ? void 0 : commercetoolsTaxRate.id,
      taxRateKey: commercetoolsTaxRate == null ? void 0 : commercetoolsTaxRate.key,
      name: commercetoolsTaxRate == null ? void 0 : commercetoolsTaxRate.name,
      amount: commercetoolsTaxRate == null ? void 0 : commercetoolsTaxRate.amount,
      includedInPrice: commercetoolsTaxRate == null ? void 0 : commercetoolsTaxRate.includedInPrice,
      country: commercetoolsTaxRate == null ? void 0 : commercetoolsTaxRate.country,
      state: commercetoolsTaxRate == null ? void 0 : commercetoolsTaxRate.state
    };
  }
  static commercetoolsCartOriginToCartOrigin(commercetoolsCartOrigin) {
    let cartOrigin;
    switch (true) {
      case commercetoolsCartOrigin === "Merchant":
        cartOrigin = "Merchant";
        break;
      case commercetoolsCartOrigin === "Customer":
      default:
        cartOrigin = "Customer";
        break;
    }
    return cartOrigin;
  }
  static commercetoolsCartStateToCartState(commercetoolsCartState) {
    let cartState;
    switch (true) {
      case commercetoolsCartState === "Frozen":
        cartState = "Frozen";
        break;
      case commercetoolsCartState === "Merged":
        cartState = "Merged";
        break;
      case commercetoolsCartState === "Ordered":
        cartState = "Ordered";
        break;
      case commercetoolsCartState === "Active":
      default:
        cartState = "Active";
        break;
    }
    return cartState;
  }
  static commercetoolsOrderStateToOrderState(commercetoolsOrderState) {
    let orderState;
    switch (true) {
      case commercetoolsOrderState === "Cancelled":
        orderState = "Cancelled";
        break;
      case commercetoolsOrderState === "Complete":
        orderState = "Complete";
        break;
      case commercetoolsOrderState === "Confirmed":
        orderState = "Confirmed";
        break;
      case commercetoolsOrderState === "Open":
      default:
        orderState = "Open";
        break;
    }
    return orderState;
  }
  static commercetoolsReturnInfoToReturnInfo(commercetoolsReturnInfo) {
    return commercetoolsReturnInfo.map((returnInfo) => ({
      returnDate: new Date(returnInfo.returnDate),
      returnTrackingId: returnInfo.returnTrackingId,
      lineItems: returnInfo.items.map((returnItem) => ({
        returnLineItemId: returnItem.id,
        count: returnItem.quantity,
        lineItemId: returnItem == null ? void 0 : returnItem.lineItemId,
        comment: returnItem.comment,
        createdAt: new Date(returnItem.createdAt)
      }))
    }));
  }
  static returnLineItemToCommercetoolsReturnItemDraft(returnItem) {
    return returnItem.map((item) => ({
      quantity: item.count,
      lineItemId: item.lineItemId,
      shipmentState: "Returned",
      //Initial state for Return Items that are refundable.
      comment: item == null ? void 0 : item.comment
    }));
  }
  static isCartDiscountReference(reference) {
    return reference.obj !== void 0;
  }
};
_CartMapper.commercetoolsCartToCart = (commercetoolsCart, locale, defaultLocale) => {
  var _a4, _b, _c, _d;
  return {
    cartId: commercetoolsCart.id,
    accountId: commercetoolsCart.customerId,
    cartVersion: commercetoolsCart.version.toString(),
    lineItems: _CartMapper.commercetoolsLineItemsToLineItems(commercetoolsCart.lineItems, locale, defaultLocale),
    email: commercetoolsCart == null ? void 0 : commercetoolsCart.customerEmail,
    sum: ProductMapper.commercetoolsMoneyToMoney(commercetoolsCart.totalPrice),
    shippingAddress: _CartMapper.commercetoolsAddressToAddress(commercetoolsCart.shippingAddress),
    billingAddress: _CartMapper.commercetoolsAddressToAddress(commercetoolsCart.billingAddress),
    shippingInfo: _CartMapper.commercetoolsShippingInfoToShippingInfo(
      commercetoolsCart.shippingInfo,
      locale,
      defaultLocale
    ),
    payments: _CartMapper.commercetoolsPaymentInfoToPayments(commercetoolsCart.paymentInfo, locale),
    discountCodes: _CartMapper.commercetoolsDiscountCodesInfoToDiscount(
      commercetoolsCart.discountCodes,
      locale,
      defaultLocale
    ),
    taxed: _CartMapper.commercetoolsTaxedPriceToTaxed(commercetoolsCart.taxedPrice, locale),
    discountedAmount: ProductMapper.commercetoolsMoneyToMoney(
      (_a4 = commercetoolsCart.discountOnTotalPrice) == null ? void 0 : _a4.discountedAmount
    ),
    itemShippingAddresses: commercetoolsCart.itemShippingAddresses,
    origin: _CartMapper.commercetoolsCartOriginToCartOrigin(commercetoolsCart.origin),
    cartState: _CartMapper.commercetoolsCartStateToCartState(commercetoolsCart.cartState),
    storeKey: (_b = commercetoolsCart.store) == null ? void 0 : _b.key,
    availableShippingMethods: [
      _CartMapper.commercetoolsShippingMethodToShippingMethod(
        (_d = (_c = commercetoolsCart.shippingInfo) == null ? void 0 : _c.shippingMethod) == null ? void 0 : _d.obj,
        locale,
        defaultLocale
      )
    ]
  };
};
_CartMapper.commercetoolsLineItemsToLineItems = (commercetoolsLineItems, locale, defaultLocale) => {
  const lineItems = [];
  commercetoolsLineItems == null ? void 0 : commercetoolsLineItems.forEach((commercetoolsLineItem) => {
    var _a4, _b, _c;
    const item = {
      lineItemId: commercetoolsLineItem.id,
      productId: commercetoolsLineItem.productId,
      name: LocalizedValue.getLocalizedValue(locale, defaultLocale, commercetoolsLineItem == null ? void 0 : commercetoolsLineItem.name) || "",
      type: "variant",
      count: commercetoolsLineItem.quantity,
      price: ProductMapper.commercetoolsMoneyToMoney((_a4 = commercetoolsLineItem.price) == null ? void 0 : _a4.value),
      discountedPrice: ProductMapper.commercetoolsMoneyToMoney((_c = (_b = commercetoolsLineItem.price) == null ? void 0 : _b.discounted) == null ? void 0 : _c.value),
      discountTexts: _CartMapper.commercetoolsDiscountedPricesPerQuantityToDiscountTexts(
        commercetoolsLineItem.discountedPricePerQuantity,
        locale,
        defaultLocale
      ),
      discounts: _CartMapper.commercetoolsDiscountedPricesPerQuantityToDiscounts(
        commercetoolsLineItem.discountedPricePerQuantity,
        locale,
        defaultLocale
      ),
      discountedPricePerCount: _CartMapper.commercetoolsDiscountedPricesPerQuantityToDiscountedPricePerCount(
        commercetoolsLineItem.discountedPricePerQuantity,
        locale,
        defaultLocale
      ),
      totalPrice: ProductMapper.commercetoolsMoneyToMoney(commercetoolsLineItem.totalPrice),
      taxed: _CartMapper.commercetoolsTaxedItemPriceToTaxed(commercetoolsLineItem.taxedPrice),
      taxRate: _CartMapper.commercetoolsTaxRateToTaxRate(commercetoolsLineItem.taxRate),
      variant: ProductMapper.commercetoolsProductVariantToVariant(commercetoolsLineItem.variant, locale),
      isGift: (commercetoolsLineItem == null ? void 0 : commercetoolsLineItem.lineItemMode) !== void 0 && commercetoolsLineItem.lineItemMode === "GiftLineItem"
    };
    item._url = ProductRouter.generateUrlFor(item);
    lineItems.push(item);
  });
  return lineItems;
};
_CartMapper.commercetoolsAddressToAddress = (commercetoolsAddress) => {
  return {
    addressId: commercetoolsAddress == null ? void 0 : commercetoolsAddress.id,
    salutation: commercetoolsAddress == null ? void 0 : commercetoolsAddress.salutation,
    firstName: commercetoolsAddress == null ? void 0 : commercetoolsAddress.firstName,
    lastName: commercetoolsAddress == null ? void 0 : commercetoolsAddress.lastName,
    streetName: commercetoolsAddress == null ? void 0 : commercetoolsAddress.streetName,
    streetNumber: commercetoolsAddress == null ? void 0 : commercetoolsAddress.streetNumber,
    additionalStreetInfo: commercetoolsAddress == null ? void 0 : commercetoolsAddress.additionalStreetInfo,
    additionalAddressInfo: commercetoolsAddress == null ? void 0 : commercetoolsAddress.additionalAddressInfo,
    postalCode: commercetoolsAddress == null ? void 0 : commercetoolsAddress.postalCode,
    city: commercetoolsAddress == null ? void 0 : commercetoolsAddress.city,
    country: commercetoolsAddress == null ? void 0 : commercetoolsAddress.country,
    state: commercetoolsAddress == null ? void 0 : commercetoolsAddress.state,
    phone: commercetoolsAddress == null ? void 0 : commercetoolsAddress.phone
  };
};
_CartMapper.commercetoolsShipmentStateToShipmentState = (commercetoolsShipmentState) => {
  switch (commercetoolsShipmentState) {
    case "backorder":
      return "Backorder" /* BACKORDER */;
    case "delayed":
      return "Delayed" /* DELAYED */;
    case "delivered":
      return "Delivered" /* DELIVERED */;
    case "partial":
      return "Partial" /* PARTIAL */;
    case "ready":
      return "Ready" /* READY */;
    case "shipped":
      return "Shipped" /* SHIPPED */;
    case "pending":
    default:
      return "Pending" /* PENDING */;
  }
};
_CartMapper.addressToCommercetoolsAddress = (address) => {
  return {
    id: address == null ? void 0 : address.addressId,
    salutation: address == null ? void 0 : address.salutation,
    firstName: address == null ? void 0 : address.firstName,
    lastName: address == null ? void 0 : address.lastName,
    streetName: address == null ? void 0 : address.streetName,
    streetNumber: address == null ? void 0 : address.streetNumber,
    additionalStreetInfo: address == null ? void 0 : address.additionalStreetInfo,
    additionalAddressInfo: address == null ? void 0 : address.additionalAddressInfo,
    postalCode: address == null ? void 0 : address.postalCode,
    city: address == null ? void 0 : address.city,
    country: address == null ? void 0 : address.country,
    state: address == null ? void 0 : address.state,
    phone: address == null ? void 0 : address.phone
  };
};
_CartMapper.commercetoolsOrderToOrder = (commercetoolsOrder, locale, defaultLocale) => {
  var _a4, _b;
  return {
    cartId: (_a4 = commercetoolsOrder.cart) == null ? void 0 : _a4.id,
    origin: _CartMapper.commercetoolsCartOriginToCartOrigin(commercetoolsOrder.origin),
    orderState: _CartMapper.commercetoolsOrderStateToOrderState(commercetoolsOrder.orderState),
    orderId: commercetoolsOrder.id,
    orderNumber: commercetoolsOrder.orderNumber,
    purchaseOrderNumber: commercetoolsOrder.purchaseOrderNumber,
    orderVersion: commercetoolsOrder.version.toString(),
    createdAt: new Date(commercetoolsOrder.createdAt),
    lineItems: _CartMapper.commercetoolsLineItemsToLineItems(commercetoolsOrder.lineItems, locale, defaultLocale),
    email: commercetoolsOrder == null ? void 0 : commercetoolsOrder.customerEmail,
    shippingAddress: _CartMapper.commercetoolsAddressToAddress(commercetoolsOrder.shippingAddress),
    billingAddress: _CartMapper.commercetoolsAddressToAddress(commercetoolsOrder.billingAddress),
    sum: ProductMapper.commercetoolsMoneyToMoney(commercetoolsOrder.totalPrice),
    taxed: _CartMapper.commercetoolsTaxedPriceToTaxed(commercetoolsOrder.taxedPrice, locale),
    discountedAmount: ProductMapper.commercetoolsMoneyToMoney(
      (_b = commercetoolsOrder.discountOnTotalPrice) == null ? void 0 : _b.discountedAmount
    ),
    payments: _CartMapper.commercetoolsPaymentInfoToPayments(commercetoolsOrder.paymentInfo, locale),
    shipmentState: _CartMapper.commercetoolsShipmentStateToShipmentState(commercetoolsOrder.shipmentState)
  };
};
_CartMapper.commercetoolsShippingInfoToShippingInfo = (commercetoolsShippingInfo, locale, defaultLocale) => {
  var _a4, _b, _c, _d;
  if (commercetoolsShippingInfo === void 0) {
    return void 0;
  }
  let shippingMethod = {
    shippingMethodId: (_a4 = commercetoolsShippingInfo == null ? void 0 : commercetoolsShippingInfo.shippingMethod) == null ? void 0 : _a4.id
  };
  if (commercetoolsShippingInfo.shippingMethod.obj) {
    shippingMethod = {
      ..._CartMapper.commercetoolsShippingMethodToShippingMethod(
        commercetoolsShippingInfo.shippingMethod.obj,
        locale,
        defaultLocale
      )
    };
  }
  return {
    ...shippingMethod,
    price: ProductMapper.commercetoolsMoneyToMoney(commercetoolsShippingInfo.price),
    taxed: _CartMapper.commercetoolsTaxedItemPriceToTaxed(commercetoolsShippingInfo.taxedPrice),
    taxIncludedInPrice: (_b = commercetoolsShippingInfo.taxRate) == null ? void 0 : _b.includedInPrice,
    discounts: (_d = (_c = commercetoolsShippingInfo.discountedPrice) == null ? void 0 : _c.includedDiscounts) == null ? void 0 : _d.map(
      (commercetoolsDiscountedLineItemPortion) => {
        return _CartMapper.commercetoolsDiscountedLineItemPortionToDiscount(
          commercetoolsDiscountedLineItemPortion,
          locale,
          defaultLocale
        );
      }
    )
  };
};
_CartMapper.commercetoolsShippingMethodToShippingMethod = (commercetoolsShippingMethod, locale, defaultLocale) => {
  return {
    shippingMethodId: (commercetoolsShippingMethod == null ? void 0 : commercetoolsShippingMethod.id) || void 0,
    name: LocalizedValue.getLocalizedValue(locale, defaultLocale, commercetoolsShippingMethod == null ? void 0 : commercetoolsShippingMethod.localizedName) || void 0,
    description: LocalizedValue.getLocalizedValue(locale, defaultLocale, commercetoolsShippingMethod == null ? void 0 : commercetoolsShippingMethod.localizedDescription) || void 0,
    rates: _CartMapper.commercetoolsZoneRatesToRates(commercetoolsShippingMethod == null ? void 0 : commercetoolsShippingMethod.zoneRates, locale)
  };
};
_CartMapper.commercetoolsZoneRatesToRates = (commercetoolsZoneRates, locale) => {
  if (commercetoolsZoneRates === void 0) {
    return void 0;
  }
  const shippingRates = [];
  commercetoolsZoneRates.forEach((commercetoolsZoneRate) => {
    var _a4, _b, _c, _d, _e;
    const shippingRateId = commercetoolsZoneRate.zone.id;
    const name = ((_b = (_a4 = commercetoolsZoneRate.zone) == null ? void 0 : _a4.obj) == null ? void 0 : _b.name) || void 0;
    const locations = (_e = (_d = (_c = commercetoolsZoneRate.zone) == null ? void 0 : _c.obj) == null ? void 0 : _d.locations) == null ? void 0 : _e.map((location) => {
      return {
        country: location.country,
        state: location.state
      };
    });
    const matchingShippingRates = commercetoolsZoneRate.shippingRates.filter(function(shippingRate) {
      if (shippingRate.isMatching !== void 0 && shippingRate.isMatching !== true) {
        return false;
      }
      return true;
    });
    matchingShippingRates.forEach((matchingShippingRates2) => {
      const matchingShippingRatePriceTiers = matchingShippingRates2.tiers.filter(function(shippingRatePriceTier) {
        if (shippingRatePriceTier.isMatching !== true) {
          return false;
        }
        return true;
      });
      shippingRates.push({
        shippingRateId,
        name,
        locations,
        price: (
          // If there are multiple matching price, we only consider the first match.
          matchingShippingRatePriceTiers.length > 0 ? ProductMapper.commercetoolsMoneyToMoney(matchingShippingRatePriceTiers[0].price) : ProductMapper.commercetoolsMoneyToMoney(matchingShippingRates2.price)
        )
      });
    });
  });
  return shippingRates;
};
_CartMapper.commercetoolsPaymentInfoToPayments = (commercetoolsPaymentInfo, locale) => {
  var _a4;
  const payments = [];
  (_a4 = commercetoolsPaymentInfo == null ? void 0 : commercetoolsPaymentInfo.payments) == null ? void 0 : _a4.forEach((commercetoolsPayment) => {
    if (commercetoolsPayment.obj) {
      payments.push(_CartMapper.commercetoolsPaymentToPayment(commercetoolsPayment.obj, locale));
    }
  });
  return payments;
};
_CartMapper.commercetoolsPaymentToPayment = (commercetoolsPayment, locale) => {
  var _a4, _b, _c, _d, _e, _f;
  return {
    id: (_a4 = commercetoolsPayment.id) != null ? _a4 : null,
    paymentId: (_b = commercetoolsPayment.interfaceId) != null ? _b : null,
    paymentProvider: (_c = commercetoolsPayment.paymentMethodInfo.paymentInterface) != null ? _c : null,
    paymentMethod: (_d = commercetoolsPayment.paymentMethodInfo.method) != null ? _d : null,
    amountPlanned: ProductMapper.commercetoolsMoneyToMoney(commercetoolsPayment.amountPlanned),
    debug: JSON.stringify(commercetoolsPayment),
    paymentStatus: (_e = commercetoolsPayment.paymentStatus.interfaceCode) != null ? _e : null,
    version: (_f = commercetoolsPayment.version) != null ? _f : 0
  };
};
_CartMapper.commercetoolsDiscountCodesInfoToDiscount = (commercetoolsDiscountCodesInfo, locale, defaultLocale) => {
  const discounts = [];
  commercetoolsDiscountCodesInfo == null ? void 0 : commercetoolsDiscountCodesInfo.forEach((commercetoolsDiscountCodeInfo) => {
    discounts.push(
      _CartMapper.commercetoolsDiscountCodeInfoToDiscountCode(commercetoolsDiscountCodeInfo, locale, defaultLocale)
    );
  });
  return discounts;
};
_CartMapper.commercetoolsDiscountCodeInfoToDiscountCode = (commercetoolsDiscountCodeInfo, locale, defaultLocale) => {
  let discount = {
    state: commercetoolsDiscountCodeInfo.state
  };
  if (commercetoolsDiscountCodeInfo.discountCode.obj) {
    const commercetoolsDiscountCode = commercetoolsDiscountCodeInfo.discountCode.obj;
    discount = {
      ...discount,
      discountId: commercetoolsDiscountCode.id,
      code: commercetoolsDiscountCode.code,
      name: LocalizedValue.getLocalizedValue(locale, defaultLocale, commercetoolsDiscountCode.name) || void 0,
      description: LocalizedValue.getLocalizedValue(locale, defaultLocale, commercetoolsDiscountCode.description) || void 0
    };
  }
  return discount;
};
_CartMapper.commercetoolsDiscountedPricesPerQuantityToDiscountTexts = (commercetoolsDiscountedLineItemPricesForQuantity, locale, defaultLocale) => {
  const discountTexts = [];
  commercetoolsDiscountedLineItemPricesForQuantity == null ? void 0 : commercetoolsDiscountedLineItemPricesForQuantity.forEach((commercetoolsDiscountedLineItemPriceForQuantity) => {
    commercetoolsDiscountedLineItemPriceForQuantity.discountedPrice.includedDiscounts.forEach(
      (commercetoolsDiscountedLineItemPortion) => {
        var _a4;
        if (_CartMapper.isCartDiscountReference(commercetoolsDiscountedLineItemPortion.discount)) {
          discountTexts.push(
            LocalizedValue.getLocalizedValue(
              locale,
              defaultLocale,
              (_a4 = commercetoolsDiscountedLineItemPortion.discount.obj) == null ? void 0 : _a4.name
            )
          );
        }
      }
    );
  });
  return discountTexts;
};
_CartMapper.commercetoolsDiscountedPricesPerQuantityToDiscounts = (commercetoolsDiscountedLineItemPricesForQuantity, locale, defaultLocale) => {
  const discounts = [];
  commercetoolsDiscountedLineItemPricesForQuantity == null ? void 0 : commercetoolsDiscountedLineItemPricesForQuantity.forEach((commercetoolsDiscountedLineItemPriceForQuantity) => {
    commercetoolsDiscountedLineItemPriceForQuantity.discountedPrice.includedDiscounts.forEach(
      (commercetoolsDiscountedLineItemPortion) => {
        discounts.push(
          _CartMapper.commercetoolsDiscountedLineItemPortionToDiscount(
            commercetoolsDiscountedLineItemPortion,
            locale,
            defaultLocale
          )
        );
      }
    );
  });
  return discounts;
};
_CartMapper.commercetoolsDiscountedLineItemPortionToDiscount = (commercetoolsDiscountedLineItemPortion, locale, defaultLocale) => {
  let discount = {
    discountedAmount: ProductMapper.commercetoolsMoneyToMoney(
      commercetoolsDiscountedLineItemPortion.discountedAmount
    )
  };
  if (_CartMapper.isCartDiscountReference(commercetoolsDiscountedLineItemPortion.discount)) {
    const commercetoolsCartDiscount = commercetoolsDiscountedLineItemPortion.discount.obj;
    discount = {
      ...discount,
      discountId: commercetoolsCartDiscount.id,
      name: LocalizedValue.getLocalizedValue(locale, defaultLocale, commercetoolsCartDiscount.name) || void 0,
      description: LocalizedValue.getLocalizedValue(locale, defaultLocale, commercetoolsCartDiscount.description) || void 0
    };
  }
  return discount;
};
_CartMapper.commercetoolsTaxedPriceToTaxed = (commercetoolsTaxedPrice, locale) => {
  if (commercetoolsTaxedPrice === void 0) {
    return void 0;
  }
  return {
    netAmount: ProductMapper.commercetoolsMoneyToMoney(commercetoolsTaxedPrice.totalNet),
    grossAmount: ProductMapper.commercetoolsMoneyToMoney(commercetoolsTaxedPrice.totalGross),
    taxAmount: ProductMapper.commercetoolsMoneyToMoney(commercetoolsTaxedPrice.totalTax),
    taxPortions: commercetoolsTaxedPrice.taxPortions.map((commercetoolsTaxPortion) => {
      const taxPortion = {
        amount: ProductMapper.commercetoolsMoneyToMoney(commercetoolsTaxPortion.amount),
        name: commercetoolsTaxPortion.name,
        rate: commercetoolsTaxPortion.rate
      };
      return taxPortion;
    })
  };
};
var CartMapper = _CartMapper;

// commerce-commercetools/utils/Pagination.ts
var getOffsetFromCursor = (cursor) => {
  if (cursor === void 0) {
    return void 0;
  }
  const offsetMach = cursor.match(/(?<=offset:).+/);
  return offsetMach !== null ? +Object.values(offsetMach)[0] : void 0;
};

// commerce-commercetools/errors/CartNotActiveError.ts
var CartNotActiveError = class _CartNotActiveError extends ExtensionError {
  constructor(options) {
    super(options);
    this.errorName = _CartNotActiveError.CART_NOT_ACTIVE_ERROR_NAME;
  }
};

// commerce-commercetools/apis/CartApi.ts
var CartApi = class extends BaseApi {
  constructor(commercetoolsFrontendContext, locale, currency, request) {
    super(commercetoolsFrontendContext, locale, currency, request);
    this.buildCartWithAvailableShippingMethods = async (commercetoolsCart, locale) => {
      const cart = await this.assertCorrectLocale(commercetoolsCart, locale);
      if (cart.shippingAddress !== void 0 && cart.shippingAddress.country !== void 0) {
        cart.availableShippingMethods = await this.getAvailableShippingMethods(cart);
      }
      return cart;
    };
    this.assertCorrectLocale = async (commercetoolsCart, locale) => {
      if (commercetoolsCart.totalPrice.currencyCode !== locale.currency.toLocaleUpperCase()) {
        return this.recreate(commercetoolsCart, locale);
      }
      if (this.doesCartNeedLocaleUpdate(commercetoolsCart, locale)) {
        const cartUpdate = {
          version: commercetoolsCart.version,
          actions: [
            {
              action: "setCountry",
              country: locale.country
            },
            {
              action: "setLocale",
              country: locale.language
            }
          ]
        };
        commercetoolsCart = await this.updateCart(commercetoolsCart.id, cartUpdate, locale);
        return CartMapper.commercetoolsCartToCart(commercetoolsCart, locale, this.defaultLocale);
      }
      return CartMapper.commercetoolsCartToCart(commercetoolsCart, locale, this.defaultLocale);
    };
    this.productApi = new ProductApi(commercetoolsFrontendContext, locale, currency, request);
  }
  async replicateCart(orderId) {
    const locale = await this.getCommercetoolsLocal();
    const response = await this.requestBuilder().carts().replicate().post({
      body: {
        reference: {
          id: orderId,
          typeId: "order"
        }
      }
    }).execute().catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
    return await this.buildCartWithAvailableShippingMethods(response.body, locale);
  }
  async getForUser(account) {
    const locale = await this.getCommercetoolsLocal();
    const response = await this.requestBuilder().carts().get({
      queryArgs: {
        limit: 1,
        expand: [
          "lineItems[*].discountedPrice.includedDiscounts[*].discount",
          "discountCodes[*].discountCode",
          "paymentInfo.payments[*]"
        ],
        where: [`customerId="${account.accountId}"`, `cartState="Active"`],
        sort: "lastModifiedAt desc"
      }
    }).execute().catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
    if (response.body.count >= 1) {
      return this.buildCartWithAvailableShippingMethods(response.body.results[0], locale);
    }
    this.invalidateSessionCheckoutData();
    const cartDraft = {
      currency: locale.currency,
      country: locale.country,
      locale: locale.language,
      customerId: account.accountId,
      inventoryMode: "ReserveOnOrder"
    };
    return await this.requestBuilder().carts().post({
      queryArgs: {
        expand: [
          "lineItems[*].discountedPrice.includedDiscounts[*].discount",
          "discountCodes[*].discountCode",
          "paymentInfo.payments[*]"
        ]
      },
      body: cartDraft
    }).execute().then((response2) => {
      return this.buildCartWithAvailableShippingMethods(response2.body, locale);
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async getAnonymous() {
    const locale = await this.getCommercetoolsLocal();
    const response = await this.requestBuilder().carts().get({
      queryArgs: {
        limit: 1,
        expand: [
          "lineItems[*].discountedPrice.includedDiscounts[*].discount",
          "discountCodes[*].discountCode",
          "paymentInfo.payments[*]"
        ],
        where: [`anonymousId="${this.getAnonymousIdFromSessionData()}"`, `cartState="Active"`],
        sort: "createdAt desc"
      }
    }).execute().catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
    if (response.body.count >= 1) {
      return this.buildCartWithAvailableShippingMethods(response.body.results[0], locale);
    }
    this.invalidateSessionAnonymousId();
    const cartDraft = {
      currency: locale.currency,
      country: locale.country,
      locale: locale.language,
      anonymousId: this.getAnonymousIdFromSessionData(),
      inventoryMode: "ReserveOnOrder"
    };
    return await this.requestBuilder().carts().post({
      queryArgs: {
        expand: [
          "lineItems[*].discountedPrice.includedDiscounts[*].discount",
          "discountCodes[*].discountCode",
          "paymentInfo.payments[*]"
        ]
      },
      body: cartDraft
    }).execute().then((response2) => {
      return this.buildCartWithAvailableShippingMethods(response2.body, locale);
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async getActiveCartById(cartId) {
    const locale = await this.getCommercetoolsLocal();
    return await this.requestBuilder().carts().withId({
      ID: cartId
    }).get({
      queryArgs: {
        limit: 1,
        expand: [
          "lineItems[*].discountedPrice.includedDiscounts[*].discount",
          "discountCodes[*].discountCode",
          "paymentInfo.payments[*]"
        ]
      }
    }).execute().then((response) => {
      if (response.body.cartState !== "Active") {
        throw new CartNotActiveError({ message: `Cart ${cartId} is not active.` });
      }
      return this.buildCartWithAvailableShippingMethods(response.body, locale);
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async addToCart(cart, lineItem) {
    const locale = await this.getCommercetoolsLocal();
    const cartUpdate = {
      version: +cart.cartVersion,
      actions: [
        {
          action: "addLineItem",
          sku: lineItem.variant.sku,
          quantity: +lineItem.count
        }
      ]
    };
    const commercetoolsCart = await this.updateCart(cart.cartId, cartUpdate, locale);
    return this.buildCartWithAvailableShippingMethods(commercetoolsCart, locale);
  }
  async updateLineItem(cart, lineItem) {
    const locale = await this.getCommercetoolsLocal();
    const cartUpdate = {
      version: +cart.cartVersion,
      actions: [
        {
          action: "changeLineItemQuantity",
          lineItemId: lineItem.lineItemId,
          quantity: +lineItem.count
        }
      ]
    };
    const commercetoolsCart = await this.updateCart(cart.cartId, cartUpdate, locale);
    return this.buildCartWithAvailableShippingMethods(commercetoolsCart, locale);
  }
  async removeLineItem(cart, lineItem) {
    const locale = await this.getCommercetoolsLocal();
    const cartUpdate = {
      version: +cart.cartVersion,
      actions: [
        {
          action: "removeLineItem",
          lineItemId: lineItem.lineItemId
        }
      ]
    };
    const commercetoolsCart = await this.updateCart(cart.cartId, cartUpdate, locale);
    return this.buildCartWithAvailableShippingMethods(commercetoolsCart, locale);
  }
  async setEmail(cart, email) {
    const locale = await this.getCommercetoolsLocal();
    const cartUpdate = {
      version: +cart.cartVersion,
      actions: [
        {
          action: "setCustomerEmail",
          email
        }
      ]
    };
    const commercetoolsCart = await this.updateCart(cart.cartId, cartUpdate, locale);
    return this.buildCartWithAvailableShippingMethods(commercetoolsCart, locale);
  }
  async setShippingAddress(cart, address) {
    const locale = await this.getCommercetoolsLocal();
    const cartUpdate = {
      version: +cart.cartVersion,
      actions: [
        {
          action: "setShippingAddress",
          address: CartMapper.addressToCommercetoolsAddress(address)
        }
      ]
    };
    const commercetoolsCart = await this.updateCart(cart.cartId, cartUpdate, locale);
    return this.buildCartWithAvailableShippingMethods(commercetoolsCart, locale);
  }
  async setBillingAddress(cart, address) {
    const locale = await this.getCommercetoolsLocal();
    const cartUpdate = {
      version: +cart.cartVersion,
      actions: [
        {
          action: "setBillingAddress",
          address: CartMapper.addressToCommercetoolsAddress(address)
        }
      ]
    };
    const commercetoolsCart = await this.updateCart(cart.cartId, cartUpdate, locale);
    return this.buildCartWithAvailableShippingMethods(commercetoolsCart, locale);
  }
  async setShippingMethod(cart, shippingMethod) {
    const locale = await this.getCommercetoolsLocal();
    const cartUpdate = {
      version: +cart.cartVersion,
      actions: [
        {
          action: "setShippingMethod",
          shippingMethod: {
            typeId: "shipping-method",
            id: shippingMethod.shippingMethodId
          }
        }
      ]
    };
    const commercetoolsCart = await this.updateCart(cart.cartId, cartUpdate, locale);
    return this.buildCartWithAvailableShippingMethods(commercetoolsCart, locale);
  }
  async order(cart, purchaseOrderNumber) {
    const locale = await this.getCommercetoolsLocal();
    const date = /* @__PURE__ */ new Date();
    const orderFromCartDraft = {
      cart: {
        typeId: "cart",
        id: cart.cartId
      },
      version: +cart.cartVersion,
      orderNumber: `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}-${String(Date.now()).slice(-6, -1)}`,
      purchaseOrderNumber: purchaseOrderNumber !== void 0 ? purchaseOrderNumber : void 0
    };
    if (!isReadyForCheckout(cart)) {
      throw new CartNotCompleteError({ message: "Cart not complete yet." });
    }
    return await this.requestBuilder().orders().post({
      queryArgs: {
        expand: [
          "lineItems[*].discountedPrice.includedDiscounts[*].discount",
          "discountCodes[*].discountCode",
          "paymentInfo.payments[*]"
        ]
      },
      body: orderFromCartDraft
    }).execute().then((response) => {
      return CartMapper.commercetoolsOrderToOrder(response.body, locale, this.defaultLocale);
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async getOrders(account) {
    const locale = await this.getCommercetoolsLocal();
    return await this.requestBuilder().orders().get({
      queryArgs: {
        expand: [
          "lineItems[*].discountedPrice.includedDiscounts[*].discount",
          "discountCodes[*].discountCode",
          "paymentInfo.payments[*]"
        ],
        where: `customerId="${account.accountId}"`,
        sort: "createdAt desc"
      }
    }).execute().then((response) => {
      return response.body.results.map(
        (order) => CartMapper.commercetoolsOrderToOrder(order, locale, this.defaultLocale)
      );
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async getShippingMethods(onlyMatching) {
    const locale = await this.getCommercetoolsLocal();
    const methodArgs = {
      queryArgs: {
        expand: ["zoneRates[*].zone"],
        country: void 0
      }
    };
    let requestBuilder = this.requestBuilder().shippingMethods().get(methodArgs);
    if (onlyMatching) {
      methodArgs.queryArgs.country = locale.country;
      requestBuilder = this.requestBuilder().shippingMethods().matchingLocation().get(methodArgs);
    }
    return await requestBuilder.execute().then((response) => {
      return response.body.results.map(
        (shippingMethod) => CartMapper.commercetoolsShippingMethodToShippingMethod(shippingMethod, locale, this.defaultLocale)
      );
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async getAvailableShippingMethods(cart) {
    const locale = await this.getCommercetoolsLocal();
    return await this.requestBuilder().shippingMethods().matchingCart().get({
      queryArgs: {
        expand: ["zoneRates[*].zone"],
        cartId: cart.cartId
      }
    }).execute().then((response) => {
      return response.body.results.map(
        (shippingMethod) => CartMapper.commercetoolsShippingMethodToShippingMethod(shippingMethod, locale, this.defaultLocale)
      );
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async addPayment(cart, payment) {
    const locale = await this.getCommercetoolsLocal();
    const paymentDraft = {
      key: payment.id,
      amountPlanned: {
        centAmount: payment.amountPlanned.centAmount,
        currencyCode: payment.amountPlanned.currencyCode
      },
      interfaceId: payment.paymentId,
      paymentMethodInfo: {
        paymentInterface: payment.paymentProvider,
        method: payment.paymentMethod
      },
      paymentStatus: {
        interfaceCode: payment.paymentStatus,
        interfaceText: payment.debug
      }
    };
    const paymentResponse = await this.requestBuilder().payments().post({
      body: paymentDraft
    }).execute();
    const cartUpdate = {
      version: +cart.cartVersion,
      actions: [
        {
          action: "addPayment",
          payment: {
            typeId: "payment",
            id: paymentResponse.body.id
          }
        }
      ]
    };
    const commercetoolsCart = await this.updateCart(cart.cartId, cartUpdate, locale);
    return this.buildCartWithAvailableShippingMethods(commercetoolsCart, locale);
  }
  async updatePayment(cart, payment) {
    const locale = await this.getCommercetoolsLocal();
    const originalPayment = cart.payments.find((cartPayment) => cartPayment.id === payment.id);
    if (originalPayment === void 0) {
      throw new CartPaymentNotFoundError({ message: `Payment ${payment.id} not found in cart ${cart.cartId}` });
    }
    const paymentUpdateActions = [];
    if (payment.paymentStatus) {
      paymentUpdateActions.push({
        action: "setStatusInterfaceCode",
        interfaceCode: payment.paymentStatus
      });
    }
    if (payment.debug) {
      paymentUpdateActions.push({
        action: "setStatusInterfaceText",
        interfaceText: payment.debug
      });
    }
    if (payment.paymentId) {
      paymentUpdateActions.push({
        action: "setInterfaceId",
        interfaceId: payment.paymentId
      });
    }
    if (paymentUpdateActions.length === 0) {
      return payment;
    }
    return await this.requestBuilder().payments().withKey({
      key: originalPayment.id
    }).post({
      body: {
        version: originalPayment.version,
        actions: paymentUpdateActions
      }
    }).execute().then((response) => {
      return CartMapper.commercetoolsPaymentToPayment(response.body, locale);
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async getPayment(paymentId) {
    return await this.requestBuilder().payments().withId({
      ID: paymentId
    }).get().execute();
  }
  async updateOrderByNumber(orderNumber, payload) {
    const locale = await this.getCommercetoolsLocal();
    const order = await this.requestBuilder().orders().withOrderNumber({ orderNumber }).get().execute().then((res) => res.body);
    const orderUpdateActions = [];
    if (payload.orderState) {
      orderUpdateActions.push({
        action: "changeOrderState",
        orderState: payload.orderState
      });
    }
    if (payload.payments) {
      payload.payments.forEach((payment) => {
        orderUpdateActions.push({
          action: "addPayment",
          payment: {
            typeId: "payment",
            id: payment.id
          }
        });
      });
    }
    if (payload.paymentState) {
      orderUpdateActions.push({
        action: "changePaymentState",
        paymentState: payload.paymentState
      });
    }
    return this.requestBuilder().orders().withOrderNumber({ orderNumber }).post({ body: { version: order.version, actions: orderUpdateActions } }).execute().then((response) => CartMapper.commercetoolsOrderToOrder(response.body, locale, this.defaultLocale)).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async createPayment(payload) {
    const locale = await this.getCommercetoolsLocal();
    const payment = this.requestBuilder().payments().post({ body: payload }).execute().then((response) => CartMapper.commercetoolsPaymentToPayment(response.body, locale));
    return payment;
  }
  async updateOrderPayment(paymentId, paymentDraft) {
    const locale = await this.getCommercetoolsLocal();
    const paymentUpdateActions = [];
    if (paymentDraft.paymentMethod) {
      paymentUpdateActions.push({
        action: "setMethodInfoMethod",
        method: paymentDraft.paymentMethod
      });
    }
    if (paymentDraft.amountPlanned) {
      paymentUpdateActions.push({
        action: "changeAmountPlanned",
        amount: {
          centAmount: paymentDraft.amountPlanned.centAmount,
          currencyCode: paymentDraft.amountPlanned.currencyCode
        }
      });
    }
    if (paymentDraft.paymentStatus) {
      paymentUpdateActions.push({
        action: "setStatusInterfaceCode",
        interfaceCode: paymentDraft.paymentStatus
      });
    }
    return await this.requestBuilder().payments().withId({
      ID: paymentId
    }).post({
      body: {
        version: paymentDraft.version,
        actions: paymentUpdateActions
      }
    }).execute().then((response) => {
      return CartMapper.commercetoolsPaymentToPayment(response.body, locale);
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async redeemDiscountCode(cart, code) {
    const locale = await this.getCommercetoolsLocal();
    const cartUpdate = {
      version: +cart.cartVersion,
      actions: [
        {
          action: "addDiscountCode",
          code
        }
      ]
    };
    const commercetoolsCart = await this.updateCart(cart.cartId, cartUpdate, locale).catch((error) => {
      if (error instanceof ExternalError) {
        throw new CartRedeemDiscountCodeError({
          message: `Redeem discount code '${code}' failed. ${error.message}`,
          statusCode: error.statusCode
        });
      }
      throw error;
    });
    return this.buildCartWithAvailableShippingMethods(commercetoolsCart, locale);
  }
  async removeDiscountCode(cart, discount) {
    const locale = await this.getCommercetoolsLocal();
    const cartUpdate = {
      version: +cart.cartVersion,
      actions: [
        {
          action: "removeDiscountCode",
          discountCode: {
            typeId: "discount-code",
            id: discount.discountId
          }
        }
      ]
    };
    const commercetoolsCart = await this.updateCart(cart.cartId, cartUpdate, locale);
    return this.buildCartWithAvailableShippingMethods(commercetoolsCart, locale);
  }
  async queryOrders(orderQuery) {
    const locale = await this.getCommercetoolsLocal();
    const limit = +orderQuery.limit || void 0;
    const sortAttributes = [];
    if (orderQuery.sortAttributes !== void 0) {
      Object.keys(orderQuery.sortAttributes).map((field, directionIndex) => {
        sortAttributes.push(`${field} ${Object.values(orderQuery.sortAttributes)[directionIndex]}`);
      });
    } else {
      sortAttributes.push(`lastModifiedAt desc`);
    }
    const whereClause = [];
    if (orderQuery.accountId !== void 0) {
      whereClause.push(`customerId="${orderQuery.accountId}"`);
    }
    if (orderQuery.orderIds !== void 0 && orderQuery.orderIds.length !== 0) {
      whereClause.push(`id in ("${orderQuery.orderIds.join('","')}")`);
    }
    if (orderQuery.orderNumbers !== void 0 && orderQuery.orderNumbers.length !== 0) {
      whereClause.push(`orderNumber in ("${orderQuery.orderNumbers.join('","')}")`);
    }
    if (orderQuery.orderState !== void 0 && orderQuery.orderState.length > 0) {
      whereClause.push(`orderState in ("${orderQuery.orderState.join('","')}")`);
    }
    if (orderQuery.businessUnitKey !== void 0) {
      whereClause.push(`businessUnit(key="${orderQuery.businessUnitKey}")`);
    }
    const searchQuery = orderQuery.query && orderQuery.query;
    return this.requestBuilder().orders().get({
      queryArgs: {
        where: whereClause,
        expand: ["orderState"],
        limit,
        offset: getOffsetFromCursor(orderQuery.cursor),
        sort: sortAttributes,
        [`text.${locale.language}`]: searchQuery
      }
    }).execute().then((response) => {
      const orders = response.body.results.map((commercetoolsQuote) => {
        return CartMapper.commercetoolsOrderToOrder(commercetoolsQuote, locale, this.defaultLocale);
      });
      return {
        total: response.body.total,
        items: orders,
        count: response.body.count,
        previousCursor: ProductMapper.calculatePreviousCursor(response.body.offset, response.body.count),
        nextCursor: ProductMapper.calculateNextCursor(response.body.offset, response.body.count, response.body.total),
        query: orderQuery
      };
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async getCheckoutSessionToken(cartId) {
    return await this.generateCheckoutSessionToken(cartId);
  }
  async updateCart(cartId, cartUpdate, locale) {
    return await this.requestBuilder().carts().withId({
      ID: cartId
    }).post({
      queryArgs: {
        expand: [
          "lineItems[*].discountedPrice.includedDiscounts[*].discount",
          "discountCodes[*].discountCode",
          "paymentInfo.payments[*]"
        ]
      },
      body: cartUpdate
    }).execute().then((response) => {
      return response.body;
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async recreate(primaryCommercetoolsCart, locale) {
    const primaryCartId = primaryCommercetoolsCart.id;
    const cartVersion = primaryCommercetoolsCart.version;
    const lineItems = primaryCommercetoolsCart.lineItems;
    const cartDraft = {
      currency: locale.currency,
      country: locale.country,
      locale: locale.language
    };
    const propertyList = [
      "customerEmail",
      "customerGroup",
      "store",
      "inventoryMode",
      "taxMode",
      "taxRoundingMode",
      "taxCalculationMode",
      "shippingAddress",
      "billingAddress",
      "shippingMethod",
      "externalTaxRateForShippingMethod",
      "deleteDaysAfterLastModification",
      "origin",
      "shippingRateInput",
      "itemShippingAddresses"
    ];
    primaryCommercetoolsCart.customerId !== void 0 ? propertyList.push("customerId") : propertyList.push("anonymousId");
    for (const key of propertyList) {
      if (primaryCommercetoolsCart.hasOwnProperty(key)) {
        cartDraft[key] = primaryCommercetoolsCart[key];
      }
    }
    let replicatedCommercetoolsCart = await this.requestBuilder().carts().post({
      queryArgs: {
        expand: [
          "lineItems[*].discountedPrice.includedDiscounts[*].discount",
          "discountCodes[*].discountCode",
          "paymentInfo.payments[*]"
        ]
      },
      body: cartDraft
    }).execute().then((response) => {
      return response.body;
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
    for (const lineItem of lineItems) {
      try {
        const cartUpdate = {
          version: +replicatedCommercetoolsCart.version,
          actions: [
            {
              action: "addLineItem",
              sku: lineItem.variant.sku,
              quantity: +lineItem.quantity
            }
          ]
        };
        replicatedCommercetoolsCart = await this.updateCart(replicatedCommercetoolsCart.id, cartUpdate, locale);
      } catch (error) {
      }
    }
    await this.requestBuilder().carts().withId({
      ID: primaryCartId
    }).delete({
      queryArgs: {
        version: cartVersion
      }
    }).execute().catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
    return CartMapper.commercetoolsCartToCart(replicatedCommercetoolsCart, locale, this.defaultLocale);
  }
  doesCartNeedLocaleUpdate(commercetoolsCart, locale) {
    if (commercetoolsCart.country === void 0) {
      return true;
    }
    if (commercetoolsCart.locale === void 0) {
      return true;
    }
    return commercetoolsCart.country !== locale.country || commercetoolsCart.locale !== locale.language;
  }
};

// commerce-commercetools/utils/handleError.ts
var handleError = (error, request) => {
  var _a4;
  if (error instanceof ExtensionError) {
    const statusCode = (_a4 = error.statusCode) != null ? _a4 : 503;
    return {
      statusCode,
      body: JSON.stringify({
        statusCode,
        message: error.message
      }),
      sessionData: request == null ? void 0 : request.sessionData
    };
  }
  const errorResponse = error;
  return {
    statusCode: 500,
    body: JSON.stringify({
      statusCode: 500,
      message: errorResponse == null ? void 0 : errorResponse.message
    }),
    sessionData: request == null ? void 0 : request.sessionData
  };
};
var handleError_default = handleError;

// commerce-commercetools/actionControllers/AccountController.ts
function getAccountApi(request, actionContext) {
  return new AccountApi(actionContext.frontasticContext, getLocale(request), getCurrency(request), request);
}
function getCartApi(request, actionContext) {
  return new CartApi(actionContext.frontasticContext, getLocale(request), getCurrency(request), request);
}
async function loginAccount(request, actionContext, account) {
  const accountApi = getAccountApi(request, actionContext);
  const cartApi = getCartApi(request, actionContext);
  const cart = await CartFetcher.fetchCart(cartApi, request);
  account = await accountApi.login(account, cart);
  if (!account.confirmed) {
    const response2 = {
      statusCode: 401,
      body: JSON.stringify(`Your email address "${account.email}" was not yet verified.`),
      sessionData: {
        ...accountApi.getSessionData()
      }
    };
    return response2;
  }
  const response = {
    statusCode: 200,
    body: JSON.stringify(account),
    sessionData: {
      ...accountApi.getSessionData(),
      account,
      cartId: void 0
      // We unset the cartId as it could have been changed after login
    }
  };
  return response;
}
function assertIsAuthenticated(request) {
  const account = fetchAccountFromSession(request);
  if (account === void 0) {
    throw new AccountAuthenticationError({ message: "Not logged in." });
  }
}
function fetchAccountFromSession(request) {
  var _a4;
  if (((_a4 = request.sessionData) == null ? void 0 : _a4.account) !== void 0) {
    return request.sessionData.account;
  }
  return void 0;
}
function parseBirthday(accountRegisterBody) {
  if (accountRegisterBody.birthdayYear) {
    return new Date(
      +accountRegisterBody.birthdayYear,
      +(accountRegisterBody == null ? void 0 : accountRegisterBody.birthdayMonth),
      +(accountRegisterBody == null ? void 0 : accountRegisterBody.birthdayDay)
    );
  }
  return null;
}
function mapRequestToAccount(request) {
  const accountRegisterBody = JSON.parse(request.body);
  const account = {
    email: accountRegisterBody == null ? void 0 : accountRegisterBody.email,
    password: accountRegisterBody == null ? void 0 : accountRegisterBody.password,
    salutation: accountRegisterBody == null ? void 0 : accountRegisterBody.salutation,
    firstName: accountRegisterBody == null ? void 0 : accountRegisterBody.firstName,
    lastName: accountRegisterBody == null ? void 0 : accountRegisterBody.lastName,
    birthday: parseBirthday(accountRegisterBody),
    addresses: []
  };
  if (accountRegisterBody.billingAddress) {
    accountRegisterBody.billingAddress.isDefaultBillingAddress = true;
    accountRegisterBody.billingAddress.isDefaultShippingAddress = !(accountRegisterBody.shippingAddress !== void 0);
    account.addresses.push(accountRegisterBody.billingAddress);
  }
  if (accountRegisterBody.shippingAddress) {
    accountRegisterBody.shippingAddress.isDefaultShippingAddress = true;
    accountRegisterBody.shippingAddress.isDefaultBillingAddress = !(accountRegisterBody.billingAddress !== void 0);
    account.addresses.push(accountRegisterBody.shippingAddress);
  }
  return account;
}
var getAccount = async (request) => {
  try {
    const account = fetchAccountFromSession(request);
    if (account === void 0) {
      return {
        statusCode: 200,
        body: JSON.stringify({
          loggedIn: false
        })
      };
    }
    const response = {
      statusCode: 200,
      body: JSON.stringify({
        loggedIn: true,
        account
      }),
      sessionData: {
        ...request.sessionData,
        account
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var register = async (request, actionContext) => {
  try {
    const locale = getLocale(request);
    const accountApi = getAccountApi(request, actionContext);
    const cartApi = getCartApi(request, actionContext);
    const accountData = mapRequestToAccount(request);
    const cart = await CartFetcher.fetchCart(cartApi, request);
    const account = await accountApi.create(accountData, cart);
    const emailApi = EmailApiFactory.getDefaultApi(actionContext.frontasticContext, locale);
    emailApi.sendWelcomeCustomerEmail(account);
    if (!account.confirmed) {
      emailApi.sendAccountVerificationEmail(account);
    }
    account.confirmationToken = null;
    const response = {
      statusCode: 200,
      body: JSON.stringify(account),
      sessionData: {
        ...accountApi.getSessionData()
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var requestConfirmationEmail = async (request, actionContext) => {
  try {
    const locale = getLocale(request);
    const accountApi = getAccountApi(request, actionContext);
    const cartApi = getCartApi(request, actionContext);
    const accountLoginBody = JSON.parse(request.body);
    let account = {
      email: accountLoginBody.email,
      password: accountLoginBody.password
    };
    const cart = await CartFetcher.fetchCart(cartApi, request);
    account = await accountApi.login(account, cart);
    if (account.confirmed) {
      const response2 = {
        statusCode: 405,
        body: JSON.stringify(`Your email address "${account.email}" was verified already.`),
        sessionData: {
          ...accountApi.getSessionData(),
          account
        }
      };
      return response2;
    }
    const emailApi = EmailApiFactory.getDefaultApi(actionContext.frontasticContext, locale);
    emailApi.sendAccountVerificationEmail(account);
    const response = {
      statusCode: 200,
      body: JSON.stringify({}),
      sessionData: {
        ...accountApi.getSessionData()
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var confirm = async (request, actionContext) => {
  try {
    const accountApi = new AccountApi(actionContext.frontasticContext, getLocale(request), getCurrency(request));
    const accountConfirmBody = JSON.parse(request.body);
    const account = await accountApi.confirmEmail(accountConfirmBody.token);
    const response = {
      statusCode: 200,
      body: JSON.stringify(account),
      sessionData: {
        ...accountApi.getSessionData(),
        account
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var login = async (request, actionContext) => {
  try {
    const accountLoginBody = JSON.parse(request.body);
    const account = {
      email: accountLoginBody.email,
      password: accountLoginBody.password
    };
    return await loginAccount(request, actionContext, account);
  } catch (error) {
    return handleError_default(error, request);
  }
};
var logout = async (request, actionContext) => {
  const accountApi = getAccountApi(request, actionContext);
  return {
    statusCode: 200,
    body: JSON.stringify({}),
    sessionData: {
      ...accountApi.getSessionData(),
      account: void 0,
      cartId: void 0,
      wishlistId: void 0
    }
  };
};
var password = async (request, actionContext) => {
  try {
    assertIsAuthenticated(request);
    let account = fetchAccountFromSession(request);
    const accountApi = new AccountApi(actionContext.frontasticContext, getLocale(request), getCurrency(request));
    const accountChangePasswordBody = JSON.parse(request.body);
    account = await accountApi.updatePassword(
      account,
      accountChangePasswordBody.oldPassword,
      accountChangePasswordBody.newPassword
    );
    return {
      statusCode: 200,
      body: JSON.stringify(account),
      sessionData: {
        ...accountApi.getSessionData(),
        account
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};
var requestReset = async (request, actionContext) => {
  try {
    const locale = getLocale(request);
    const accountApi = new AccountApi(actionContext.frontasticContext, locale, getCurrency(request));
    const emailApi = EmailApiFactory.getDefaultApi(actionContext.frontasticContext, locale);
    const accountRequestResetBody = JSON.parse(request.body);
    const passwordResetToken = await accountApi.generatePasswordResetToken(accountRequestResetBody.email);
    emailApi.sendPasswordResetEmail(accountRequestResetBody, passwordResetToken.token);
    return {
      statusCode: 200,
      body: JSON.stringify({}),
      sessionData: {
        ...accountApi.getSessionData(),
        // TODO: should we redirect to logout rather to unset the account?
        account: void 0
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};
var reset = async (request, actionContext) => {
  try {
    const accountResetBody = JSON.parse(request.body);
    const accountApi = new AccountApi(actionContext.frontasticContext, getLocale(request), getCurrency(request));
    const account = await accountApi.resetPassword(accountResetBody.token, accountResetBody.newPassword);
    account.password = accountResetBody.newPassword;
    return await loginAccount(request, actionContext, account);
  } catch (error) {
    return handleError_default(error, request);
  }
};
var update = async (request, actionContext) => {
  try {
    assertIsAuthenticated(request);
    let account = fetchAccountFromSession(request);
    const accountApi = new AccountApi(actionContext.frontasticContext, getLocale(request), getCurrency(request));
    const emailApi = EmailApiFactory.getDefaultApi(actionContext.frontasticContext, getLocale(request));
    account = {
      ...account,
      ...mapRequestToAccount(request)
    };
    account = await accountApi.update(account);
    if (!account.confirmed) {
      emailApi.sendAccountVerificationEmail(account);
    }
    account.confirmationToken = null;
    return {
      statusCode: 200,
      body: JSON.stringify(account),
      sessionData: {
        ...accountApi.getSessionData(),
        account
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};
var addAddress = async (request, actionContext) => {
  try {
    assertIsAuthenticated(request);
    let account = fetchAccountFromSession(request);
    const address = JSON.parse(request.body).address;
    const accountApi = new AccountApi(actionContext.frontasticContext, getLocale(request), getCurrency(request));
    account = await accountApi.addAddress(account, address);
    return {
      statusCode: 200,
      body: JSON.stringify(account),
      sessionData: {
        ...accountApi.getSessionData(),
        account
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};
var addShippingAddress = async (request, actionContext) => {
  try {
    assertIsAuthenticated(request);
    let account = fetchAccountFromSession(request);
    const address = JSON.parse(request.body).address;
    const accountApi = new AccountApi(actionContext.frontasticContext, getLocale(request), getCurrency(request));
    account = await accountApi.addShippingAddress(account, address);
    return {
      statusCode: 200,
      body: JSON.stringify(account),
      sessionData: {
        ...accountApi.getSessionData(),
        account
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};
var addBillingAddress = async (request, actionContext) => {
  try {
    assertIsAuthenticated(request);
    let account = fetchAccountFromSession(request);
    const address = JSON.parse(request.body).address;
    const accountApi = new AccountApi(actionContext.frontasticContext, getLocale(request), getCurrency(request));
    account = await accountApi.addBillingAddress(account, address);
    return {
      statusCode: 200,
      body: JSON.stringify(account),
      sessionData: {
        ...accountApi.getSessionData(),
        account
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};
var updateAddress = async (request, actionContext) => {
  try {
    assertIsAuthenticated(request);
    let account = fetchAccountFromSession(request);
    const address = JSON.parse(request.body);
    const accountApi = new AccountApi(actionContext.frontasticContext, getLocale(request), getCurrency(request));
    account = await accountApi.updateAddress(account, address);
    return {
      statusCode: 200,
      body: JSON.stringify(account),
      sessionData: {
        ...accountApi.getSessionData(),
        account
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};
var removeAddress = async (request, actionContext) => {
  try {
    assertIsAuthenticated(request);
    let account = fetchAccountFromSession(request);
    const address = JSON.parse(request.body);
    const accountApi = new AccountApi(actionContext.frontasticContext, getLocale(request), getCurrency(request));
    account = await accountApi.removeAddress(account, address);
    return {
      statusCode: 200,
      body: JSON.stringify(account),
      sessionData: {
        ...accountApi.getSessionData(),
        account
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};
var setDefaultBillingAddress = async (request, actionContext) => {
  try {
    assertIsAuthenticated(request);
    let account = fetchAccountFromSession(request);
    const address = JSON.parse(request.body);
    const accountApi = new AccountApi(actionContext.frontasticContext, getLocale(request), getCurrency(request));
    account = await accountApi.setDefaultBillingAddress(account, address);
    return {
      statusCode: 200,
      body: JSON.stringify(account),
      sessionData: {
        ...accountApi.getSessionData(),
        account
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};
var setDefaultShippingAddress = async (request, actionContext) => {
  try {
    assertIsAuthenticated(request);
    let account = fetchAccountFromSession(request);
    const address = JSON.parse(request.body);
    const accountApi = new AccountApi(actionContext.frontasticContext, getLocale(request), getCurrency(request));
    account = await accountApi.setDefaultShippingAddress(account, address);
    return {
      statusCode: 200,
      body: JSON.stringify(account),
      sessionData: {
        ...accountApi.getSessionData(),
        account
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};
var deleteAccount = async (request, actionContext) => {
  try {
    assertIsAuthenticated(request);
    let account = fetchAccountFromSession(request);
    const accountDeleteBody = JSON.parse(request.body);
    const accountApi = getAccountApi(request, actionContext);
    account = {
      email: account.email,
      password: accountDeleteBody.password
    };
    account = await accountApi.login(account, void 0);
    await accountApi.delete(account);
    return {
      statusCode: 200,
      body: JSON.stringify(null),
      sessionData: {
        ...request.sessionData,
        account: null
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};

// commerce-commercetools/actionControllers/ProductController.ts
var ProductController_exports = {};
__export(ProductController_exports, {
  getProduct: () => getProduct,
  query: () => query,
  queryCategories: () => queryCategories,
  searchableAttributes: () => searchableAttributes
});

// commerce-commercetools/utils/ProductQueryFactory.ts
var _ProductQueryFactory = class _ProductQueryFactory {
  static queryParamsToFacets(queryParams) {
    const facets = [];
    let key;
    let facetData;
    for ([key, facetData] of Object.entries(queryParams.facets)) {
      if ((facetData == null ? void 0 : facetData.terms) && !Array.isArray(facetData.terms)) {
        facetData.terms = Object.values(facetData.terms);
      }
      switch (true) {
        case (facetData.min !== void 0 && facetData.max !== void 0):
          const min = parseInt(facetData.min);
          const max = parseInt(facetData.max);
          facets.push({
            type: "range" /* RANGE */,
            identifier: key,
            min: isNaN(min) ? 0 : min,
            max: isNaN(max) ? Number.MAX_SAFE_INTEGER : max
          });
          break;
        case facetData.terms !== void 0:
          facets.push({
            type: "term" /* TERM */,
            identifier: key,
            terms: facetData.terms.map((facetValueData) => facetValueData)
          });
          break;
        case facetData.boolean !== void 0:
          facets.push({
            type: "boolean" /* BOOLEAN */,
            identifier: key,
            terms: [facetData.boolean]
          });
          break;
        default:
          break;
      }
    }
    return facets;
  }
  static mergeProductFiltersAndValues(queryParams) {
    var _a4, _b;
    const filtersData = [];
    if (((_a4 = queryParams == null ? void 0 : queryParams.productFilters) == null ? void 0 : _a4.filters) === void 0) {
      return filtersData;
    }
    if (((_b = queryParams == null ? void 0 : queryParams.productFilters) == null ? void 0 : _b.values) === void 0) {
      return queryParams.productFilters.filters;
    }
    queryParams.productFilters.filters.forEach((filter3) => {
      var _a5;
      if (filter3 == null ? void 0 : filter3.field) {
        const filterValues = (
          // TODO: to be adapted when Studio returned multiple values
          [(_a5 = queryParams.productFilters) == null ? void 0 : _a5.values[filter3.field]]
        );
        const filterData = {
          ...filter3,
          values: filterValues
        };
        filtersData.push(filterData);
      }
    });
    return filtersData;
  }
  static configFiltersDataToFilters(configFiltersData) {
    const filters = [];
    configFiltersData.forEach((configFilterData) => {
      var _a4, _b, _c, _d, _e, _f;
      if ((configFilterData == null ? void 0 : configFilterData.field) === "categoryId" || (configFilterData == null ? void 0 : configFilterData.field) === "categoryIds") {
        return;
      }
      switch (configFilterData.type) {
        case "number" /* NUMBER */:
        case "money" /* MONEY */:
          const rangeFilter = {
            identifier: configFilterData == null ? void 0 : configFilterData.field,
            type: "range" /* RANGE */,
            min: +((_b = (_a4 = configFilterData == null ? void 0 : configFilterData.values) == null ? void 0 : _a4[0]) == null ? void 0 : _b.min) || +((_c = configFilterData == null ? void 0 : configFilterData.values) == null ? void 0 : _c[0]) || void 0,
            max: +((_e = (_d = configFilterData == null ? void 0 : configFilterData.values) == null ? void 0 : _d[0]) == null ? void 0 : _e.max) || +((_f = configFilterData == null ? void 0 : configFilterData.values) == null ? void 0 : _f[0]) || void 0
          };
          filters.push(rangeFilter);
          break;
        case "text" /* TEXT */:
          const termFilter = {
            identifier: configFilterData == null ? void 0 : configFilterData.field,
            type: "term" /* TERM */,
            terms: this.getTermsFromConfigFilterData(configFilterData)
          };
          filters.push(termFilter);
          break;
        case "enum" /* ENUM */:
          const enumFilter = {
            identifier: configFilterData == null ? void 0 : configFilterData.field,
            type: "enum" /* ENUM */,
            terms: this.getTermsFromConfigFilterData(configFilterData)
          };
          filters.push(enumFilter);
          break;
        case "boolean" /* BOOLEAN */:
          const booleanFilter = {
            identifier: configFilterData == null ? void 0 : configFilterData.field,
            type: "boolean" /* BOOLEAN */,
            terms: [configFilterData == null ? void 0 : configFilterData.values[0]]
          };
          filters.push(booleanFilter);
          break;
        default:
          break;
      }
    });
    return filters;
  }
  static configFiltersDataToCategoryFilters(configFiltersData) {
    const categoryFilters = [];
    configFiltersData.forEach((configFilterData) => {
      if ((configFilterData == null ? void 0 : configFilterData.field) === "categoryId" || (configFilterData == null ? void 0 : configFilterData.field) === "categoryIds") {
        categoryFilters.push(configFilterData.values);
      }
    });
    return categoryFilters;
  }
  static getTermsFromConfigFilterData(configFilterData) {
    return configFilterData == null ? void 0 : configFilterData.values.map((term) => {
      if (typeof term !== "object") {
        return term;
      }
      const key = Object.keys(term)[0];
      if (term.hasOwnProperty(key)) {
        return term[key];
      }
    });
  }
};
_ProductQueryFactory.queryFromParams = (request, config) => {
  let queryParams;
  const productQuery = {
    categories: [],
    productIds: [],
    skus: []
  };
  if (request == null ? void 0 : request.query) {
    queryParams = request.query;
  }
  if (config == null ? void 0 : config.configuration) {
    for (const [key, value] of Object.entries(config == null ? void 0 : config.configuration)) {
      if (value === void 0 || value === "") {
        continue;
      }
      switch (key) {
        case "categories":
          queryParams["categories"] = value.split(",").map((val) => val.trim());
          break;
        case "productIds":
          queryParams["productIds"] = value.split(",").map((val) => val.trim());
          break;
        case "productSkus":
          queryParams["skus"] = value.split(",").map((val) => val.trim());
          break;
        default:
          queryParams[key] = value;
          break;
      }
    }
  }
  productQuery.query = (queryParams == null ? void 0 : queryParams.query) || void 0;
  if ((queryParams == null ? void 0 : queryParams.categories) && Array.isArray(queryParams == null ? void 0 : queryParams.categories)) {
    queryParams.categories.map((category) => {
      productQuery.categories.push(category.toString());
    });
  }
  if (queryParams == null ? void 0 : queryParams.category) {
    productQuery.categories.push(queryParams.category);
  }
  if ((queryParams == null ? void 0 : queryParams.productIds) && Array.isArray(queryParams == null ? void 0 : queryParams.productIds)) {
    queryParams == null ? void 0 : queryParams.productIds.map((productId) => {
      productQuery.productIds.push(productId.toString());
    });
  }
  if ((queryParams == null ? void 0 : queryParams.skus) && Array.isArray(queryParams == null ? void 0 : queryParams.skus)) {
    queryParams == null ? void 0 : queryParams.skus.map((sku) => {
      productQuery.skus.push(sku.toString());
    });
  }
  const configFiltersData = [];
  configFiltersData.push(..._ProductQueryFactory.mergeProductFiltersAndValues(queryParams));
  const filters = _ProductQueryFactory.configFiltersDataToFilters(configFiltersData);
  if (filters.length > 0) {
    productQuery.filters = filters;
  }
  const categoryFilters = _ProductQueryFactory.configFiltersDataToCategoryFilters(configFiltersData);
  if (categoryFilters.length > 0) {
    productQuery.categories = categoryFilters;
  }
  if (queryParams.facets) {
    productQuery.facets = _ProductQueryFactory.queryParamsToFacets(queryParams);
  }
  if (queryParams.sortAttributes) {
    const sortAttributes = {};
    let sortAttribute;
    for (sortAttribute of Object.values(queryParams.sortAttributes)) {
      const key = Object.keys(sortAttribute)[0];
      sortAttributes[key] = sortAttribute[key] ? sortAttribute[key] : "ascending" /* ASCENDING */;
    }
    productQuery.sortAttributes = sortAttributes;
  }
  productQuery.limit = (queryParams == null ? void 0 : queryParams.limit) || void 0;
  productQuery.cursor = (queryParams == null ? void 0 : queryParams.cursor) || void 0;
  return productQuery;
};
var ProductQueryFactory = _ProductQueryFactory;

// commerce-commercetools/actionControllers/ProductController.ts
function getProductApi(request, actionContext) {
  return new ProductApi(actionContext.frontasticContext, getLocale(request), getCurrency(request), request);
}
var getProduct = async (request, actionContext) => {
  try {
    const productApi = getProductApi(request, actionContext);
    let productQuery = {};
    if ("id" in request.query) {
      productQuery = {
        productIds: [request.query["id"]]
      };
    }
    if ("sku" in request.query) {
      productQuery = {
        skus: [request.query["sku"]]
      };
    }
    const product = await productApi.getProduct(productQuery);
    const response = {
      statusCode: 200,
      body: JSON.stringify(product),
      sessionData: {
        ...productApi.getSessionData()
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var query = async (request, actionContext) => {
  try {
    const productApi = getProductApi(request, actionContext);
    const productQuery = ProductQueryFactory.queryFromParams(request);
    const queryResult = await productApi.query(productQuery);
    const response = {
      statusCode: 200,
      body: JSON.stringify(queryResult),
      sessionData: {
        ...productApi.getSessionData()
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var queryCategories = async (request, actionContext) => {
  var _a4, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  try {
    const productApi = getProductApi(request, actionContext);
    const categoryQuery = {
      limit: (_b = (_a4 = request.query) == null ? void 0 : _a4.limit) != null ? _b : void 0,
      cursor: (_d = (_c = request.query) == null ? void 0 : _c.cursor) != null ? _d : void 0,
      slug: (_f = (_e = request.query) == null ? void 0 : _e.slug) != null ? _f : void 0,
      parentId: (_h = (_g = request.query) == null ? void 0 : _g.parentId) != null ? _h : void 0,
      format: (_j = (_i = request.query) == null ? void 0 : _i.format) != null ? _j : "flat" /* FLAT */
    };
    const queryResult = await productApi.queryCategories(categoryQuery);
    const response = {
      statusCode: 200,
      body: JSON.stringify(queryResult),
      sessionData: {
        ...productApi.getSessionData()
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var searchableAttributes = async (request, actionContext) => {
  try {
    const productApi = getProductApi(request, actionContext);
    const result = await productApi.getSearchableAttributes();
    const response = {
      statusCode: 200,
      body: JSON.stringify(result),
      sessionData: {
        ...productApi.getSessionData()
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};

// commerce-commercetools/actionControllers/CartController.ts
var CartController_exports = {};
__export(CartController_exports, {
  addPaymentByInvoice: () => addPaymentByInvoice,
  addToCart: () => addToCart,
  checkout: () => checkout,
  getAvailableShippingMethods: () => getAvailableShippingMethods,
  getCart: () => getCart,
  getCheckoutSessionToken: () => getCheckoutSessionToken,
  getOrder: () => getOrder,
  getOrders: () => getOrders,
  getShippingMethods: () => getShippingMethods,
  queryOrders: () => queryOrders,
  redeemDiscount: () => redeemDiscount,
  removeDiscount: () => removeDiscount,
  removeLineItem: () => removeLineItem,
  replicateCart: () => replicateCart,
  resetCart: () => resetCart,
  setShippingMethod: () => setShippingMethod,
  updateCart: () => updateCart,
  updateLineItem: () => updateLineItem,
  updatePayment: () => updatePayment
});

// commerce-commercetools/utils/queryParamsToState.ts
var queryParamsToStates = (param, queryParams) => {
  const states = [];
  const requestParamStates = queryParams == null ? void 0 : queryParams[param];
  if (requestParamStates) {
    if (Array.isArray(requestParamStates)) {
      states.push(...requestParamStates);
    } else {
      const params = requestParamStates.split(",");
      if (params.length > 1) {
        states.push(...params);
      } else {
        states.push(requestParamStates);
      }
    }
  }
  return states;
};
var queryParamsToState_default = queryParamsToStates;

// commerce-commercetools/utils/queryParamsToIds.ts
function queryParamsToIds(param, queryParams) {
  const ids = [];
  const requestParamIds = queryParams == null ? void 0 : queryParams[param];
  if (requestParamIds) {
    if (Array.isArray(requestParamIds)) {
      ids.push(...requestParamIds);
    } else {
      const params = requestParamIds.split(",");
      if (params.length > 1) {
        ids.push(...params);
      } else {
        ids.push(requestParamIds);
      }
    }
  }
  return ids;
}
var queryParamsToIds_default = queryParamsToIds;

// commerce-commercetools/utils/fetchAccountFromSession.ts
function fetchAccountFromSession2(request) {
  var _a4;
  if (((_a4 = request.sessionData) == null ? void 0 : _a4.account) !== void 0) {
    return request.sessionData.account;
  }
  return void 0;
}

// commerce-commercetools/errors/CartNotMatchOrderError.ts
var CartNotMatchOrderError = class _CartNotMatchOrderError extends ExtensionError {
  constructor(options) {
    super(options);
    this.errorName = _CartNotMatchOrderError.CART_NOT_MATCH_ORDER_ERROR_NAME;
  }
};

// commerce-commercetools/actionControllers/CartController.ts
function getCartApi2(request, actionContext) {
  return new CartApi(actionContext.frontasticContext, getLocale(request), getCurrency(request), request);
}
function queryParamsToSortAttributes(queryParams) {
  const sortAttributes = {};
  if (queryParams.sortAttributes) {
    let sortAttribute;
    for (sortAttribute of Object.values(queryParams.sortAttributes)) {
      const key = Object.keys(sortAttribute)[0];
      sortAttributes[key] = sortAttribute[key] ? sortAttribute[key] : "ascending" /* ASCENDING */;
    }
  }
  return sortAttributes;
}
async function updateCartFromRequest(cartApi, request) {
  var _a4;
  let cart = await CartFetcher.fetchCart(cartApi, request);
  if ((request == null ? void 0 : request.body) === void 0 || (request == null ? void 0 : request.body) === "") {
    return cart;
  }
  const body = JSON.parse(request.body);
  if (((_a4 = body == null ? void 0 : body.account) == null ? void 0 : _a4.email) !== void 0) {
    cart = await cartApi.setEmail(cart, body.account.email);
  }
  if ((body == null ? void 0 : body.shipping) !== void 0 || (body == null ? void 0 : body.billing) !== void 0) {
    const shippingAddress = (body == null ? void 0 : body.shipping) !== void 0 ? body.shipping : body.billing;
    const billingAddress = (body == null ? void 0 : body.billing) !== void 0 ? body.billing : body.shipping;
    cart = await cartApi.setShippingAddress(cart, shippingAddress);
    cart = await cartApi.setBillingAddress(cart, billingAddress);
  }
  return cart;
}
var getCart = async (request, actionContext) => {
  try {
    const cartApi = getCartApi2(request, actionContext);
    try {
      const cart = await CartFetcher.fetchCartFromSession(cartApi, request);
      return {
        statusCode: 200,
        body: cart ? JSON.stringify(cart) : JSON.stringify({}),
        sessionData: {
          ...cartApi.getSessionData(),
          ...cart ? { cartId: cart.cartId } : {}
        }
      };
    } catch (error) {
      const errorResponse = error;
      return {
        statusCode: 400,
        message: errorResponse.message
      };
    }
  } catch (error) {
    return handleError_default(error, request);
  }
};
var resetCart = async (request, actionContext) => {
  const cartApi = getCartApi2(request, actionContext);
  cartApi.invalidateSessionCheckoutData();
  const response = {
    statusCode: 200,
    body: null,
    sessionData: {
      ...request.sessionData,
      cartId: null
    }
  };
  return response;
};
var addToCart = async (request, actionContext) => {
  var _a4, _b;
  try {
    const cartApi = getCartApi2(request, actionContext);
    const body = JSON.parse(request.body);
    const lineItem = {
      variant: {
        sku: ((_a4 = body.variant) == null ? void 0 : _a4.sku) || void 0,
        price: void 0
      },
      count: +((_b = body.variant) == null ? void 0 : _b.count) || 1
    };
    let cart = await CartFetcher.fetchCart(cartApi, request);
    cart = await cartApi.addToCart(cart, lineItem);
    const cartId = cart.cartId;
    const response = {
      statusCode: 200,
      body: JSON.stringify(cart),
      sessionData: {
        ...cartApi.getSessionData(),
        cartId
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var replicateCart = async (request, actionContext) => {
  var _a4;
  try {
    const cartApi = getCartApi2(request, actionContext);
    const orderId = (_a4 = request.query) == null ? void 0 : _a4["orderId"];
    if (!orderId) {
      throw new ValidationError({ message: `orderId is required` });
    }
    const cart = await cartApi.replicateCart(orderId);
    return {
      statusCode: 200,
      body: JSON.stringify(cart),
      sessionData: {
        ...cartApi.getSessionData(),
        cartId: cart.cartId
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};
var updateLineItem = async (request, actionContext) => {
  var _a4, _b;
  try {
    const cartApi = getCartApi2(request, actionContext);
    const body = JSON.parse(request.body);
    const lineItem = {
      lineItemId: (_a4 = body.lineItem) == null ? void 0 : _a4.id,
      count: +((_b = body.lineItem) == null ? void 0 : _b.count) || 1
    };
    let cart = await CartFetcher.fetchCart(cartApi, request);
    cart = await cartApi.updateLineItem(cart, lineItem);
    const cartId = cart.cartId;
    const response = {
      statusCode: 200,
      body: JSON.stringify(cart),
      sessionData: {
        ...cartApi.getSessionData(),
        cartId
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var removeLineItem = async (request, actionContext) => {
  var _a4;
  try {
    const cartApi = getCartApi2(request, actionContext);
    const body = JSON.parse(request.body);
    const lineItem = {
      lineItemId: (_a4 = body.lineItem) == null ? void 0 : _a4.id
    };
    let cart = await CartFetcher.fetchCart(cartApi, request);
    cart = await cartApi.removeLineItem(cart, lineItem);
    const cartId = cart.cartId;
    const response = {
      statusCode: 200,
      body: JSON.stringify(cart),
      sessionData: {
        ...cartApi.getSessionData(),
        cartId
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var updateCart = async (request, actionContext) => {
  try {
    const cartApi = getCartApi2(request, actionContext);
    const cart = await updateCartFromRequest(cartApi, request);
    const cartId = cart.cartId;
    const response = {
      statusCode: 200,
      body: JSON.stringify(cart),
      sessionData: {
        ...cartApi.getSessionData(),
        cartId
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var checkout = async (request, actionContext) => {
  try {
    const locale = getLocale(request);
    const body = JSON.parse(request.body);
    const cartApi = getCartApi2(request, actionContext);
    const emailApi = EmailApiFactory.getDefaultApi(actionContext.frontasticContext, locale);
    const cart = await updateCartFromRequest(cartApi, request);
    const order = await cartApi.order(cart, body == null ? void 0 : body.purchaseOrderNumber);
    emailApi.sendOrderConfirmationEmail({ ...order, email: order.email || cart.email });
    const cartId = void 0;
    const response = {
      statusCode: 200,
      body: JSON.stringify(order),
      sessionData: {
        ...cartApi.getSessionData(),
        cartId
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var getOrders = async (request, actionContext) => {
  var _a4;
  try {
    const cartApi = getCartApi2(request, actionContext);
    const account = ((_a4 = request.sessionData) == null ? void 0 : _a4.account) !== void 0 ? request.sessionData.account : void 0;
    if (account === void 0) {
      throw new AccountAuthenticationError({ message: "Not logged in." });
    }
    const orders = await cartApi.getOrders(account);
    const response = {
      statusCode: 200,
      body: JSON.stringify(orders),
      sessionData: {
        ...cartApi.getSessionData()
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var getShippingMethods = async (request, actionContext) => {
  try {
    const cartApi = getCartApi2(request, actionContext);
    const onlyMatching = request.query.onlyMatching === "true";
    const shippingMethods = await cartApi.getShippingMethods(onlyMatching);
    const response = {
      statusCode: 200,
      body: JSON.stringify(shippingMethods),
      sessionData: {
        ...cartApi.getSessionData()
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var getAvailableShippingMethods = async (request, actionContext) => {
  try {
    const cartApi = getCartApi2(request, actionContext);
    const cart = await CartFetcher.fetchCart(cartApi, request);
    const availableShippingMethods = await cartApi.getAvailableShippingMethods(cart);
    const response = {
      statusCode: 200,
      body: JSON.stringify(availableShippingMethods),
      sessionData: {
        ...cartApi.getSessionData(),
        cartId: cart.cartId
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var setShippingMethod = async (request, actionContext) => {
  var _a4;
  try {
    const cartApi = getCartApi2(request, actionContext);
    let cart = await CartFetcher.fetchCart(cartApi, request);
    const body = JSON.parse(request.body);
    const shippingMethod = {
      shippingMethodId: (_a4 = body.shippingMethod) == null ? void 0 : _a4.id
    };
    cart = await cartApi.setShippingMethod(cart, shippingMethod);
    const response = {
      statusCode: 200,
      body: JSON.stringify(cart),
      sessionData: {
        ...cartApi.getSessionData(),
        cartId: cart.cartId
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var addPaymentByInvoice = async (request, actionContext) => {
  var _a4, _b, _c, _d;
  try {
    const cartApi = getCartApi2(request, actionContext);
    let cart = await CartFetcher.fetchCart(cartApi, request);
    const body = JSON.parse(request.body);
    const payment = {
      ...body.payment,
      paymentProvider: "frontastic",
      paymentMethod: "invoice",
      paymentStatus: "pending" /* PENDING */
    };
    if (payment.amountPlanned === void 0) {
      payment.amountPlanned = {};
    }
    payment.amountPlanned.centAmount = (_b = (_a4 = payment.amountPlanned.centAmount) != null ? _a4 : cart.sum.centAmount) != null ? _b : void 0;
    payment.amountPlanned.currencyCode = (_d = (_c = payment.amountPlanned.currencyCode) != null ? _c : cart.sum.currencyCode) != null ? _d : void 0;
    cart = await cartApi.addPayment(cart, payment);
    const response = {
      statusCode: 200,
      body: JSON.stringify(cart),
      sessionData: {
        ...cartApi.getSessionData(),
        cartId: cart.cartId
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var updatePayment = async (request, actionContext) => {
  try {
    const cartApi = getCartApi2(request, actionContext);
    const cart = await CartFetcher.fetchCart(cartApi, request);
    const body = JSON.parse(request.body);
    const payment = await cartApi.updatePayment(cart, body.payment);
    const response = {
      statusCode: 200,
      body: JSON.stringify(payment),
      sessionData: {
        ...cartApi.getSessionData(),
        cartId: cart.cartId
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var redeemDiscount = async (request, actionContext) => {
  try {
    const cartApi = getCartApi2(request, actionContext);
    let cart = await CartFetcher.fetchCart(cartApi, request);
    const body = JSON.parse(request.body);
    cart = await cartApi.redeemDiscountCode(cart, body.code);
    return {
      statusCode: 200,
      body: JSON.stringify(cart),
      sessionData: {
        ...cartApi.getSessionData(),
        cartId: cart.cartId
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};
var removeDiscount = async (request, actionContext) => {
  try {
    const cartApi = getCartApi2(request, actionContext);
    let cart = await CartFetcher.fetchCart(cartApi, request);
    const body = JSON.parse(request.body);
    const discount = {
      discountId: body == null ? void 0 : body.discountId
    };
    cart = await cartApi.removeDiscountCode(cart, discount);
    const response = {
      statusCode: 200,
      body: JSON.stringify(cart),
      sessionData: {
        ...cartApi.getSessionData(),
        cartId: cart.cartId
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var queryOrders = async (request, actionContext) => {
  var _a4, _b, _c, _d, _e, _f;
  try {
    const cartApi = getCartApi2(request, actionContext);
    const account = fetchAccountFromSession2(request);
    if (account === void 0) {
      throw new AccountAuthenticationError({ message: "Not logged in." });
    }
    const orderQuery = {
      accountId: account.accountId,
      limit: (_b = (_a4 = request.query) == null ? void 0 : _a4.limit) != null ? _b : void 0,
      cursor: (_d = (_c = request.query) == null ? void 0 : _c.cursor) != null ? _d : void 0,
      orderNumbers: queryParamsToIds_default("orderNumbers", request.query),
      orderIds: queryParamsToIds_default("orderIds", request.query),
      orderState: queryParamsToState_default("orderStates", request.query),
      sortAttributes: queryParamsToSortAttributes(request.query),
      query: (_f = (_e = request.query) == null ? void 0 : _e.query) != null ? _f : void 0
    };
    const queryResult = await cartApi.queryOrders(orderQuery);
    const response = {
      statusCode: 200,
      body: JSON.stringify(queryResult),
      sessionData: {
        ...cartApi.getSessionData()
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var getOrder = async (request, actionContext) => {
  var _a4, _b;
  try {
    const cartApi = getCartApi2(request, actionContext);
    const account = fetchAccountFromSession2(request);
    const orderQuery = {
      accountId: account == null ? void 0 : account.accountId,
      orderIds: [(_a4 = request.query) == null ? void 0 : _a4.orderId],
      limit: 1
    };
    const queryResult = await cartApi.queryOrders(orderQuery);
    const order = queryResult.items[0];
    if (account === void 0) {
      if ((order == null ? void 0 : order.cartId) !== ((_b = request.sessionData) == null ? void 0 : _b.cartId)) {
        throw new CartNotMatchOrderError({ message: "Order does not match the current cart." });
      }
    }
    const response = {
      statusCode: 200,
      body: JSON.stringify(order),
      sessionData: {
        ...cartApi.getSessionData()
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};
var getCheckoutSessionToken = async (request, actionContext) => {
  var _a4;
  try {
    let checkoutSessionToken;
    const cartApi = getCartApi2(request, actionContext);
    const cartId = (_a4 = request.sessionData) == null ? void 0 : _a4.cartId;
    if (cartId !== void 0) {
      checkoutSessionToken = await cartApi.getCheckoutSessionToken(cartId);
    }
    const response = {
      statusCode: 200,
      body: checkoutSessionToken ? JSON.stringify(checkoutSessionToken) : "",
      sessionData: {
        ...cartApi.getSessionData()
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};

// commerce-commercetools/actionControllers/WishlistController.ts
var WishlistController_exports = {};
__export(WishlistController_exports, {
  addToWishlist: () => addToWishlist,
  createWishlist: () => createWishlist,
  deleteWishlist: () => deleteWishlist,
  getWishlist: () => getWishlist,
  removeLineItem: () => removeLineItem2,
  updateLineItemCount: () => updateLineItemCount
});

// commerce-commercetools/mappers/WishlistMapper.ts
var _WishlistMapper = class _WishlistMapper {
};
_WishlistMapper.commercetoolsShoppingListToWishlist = (commercetoolsShoppingList, locale, defaultLocale) => {
  var _a4, _b;
  return {
    wishlistId: commercetoolsShoppingList.id,
    wishlistVersion: commercetoolsShoppingList.version.toString(),
    anonymousId: commercetoolsShoppingList.anonymousId,
    accountId: (_b = (_a4 = commercetoolsShoppingList.customer) == null ? void 0 : _a4.id) != null ? _b : void 0,
    name: LocalizedValue.getLocalizedValue(locale, defaultLocale, commercetoolsShoppingList.name),
    lineItems: (commercetoolsShoppingList.lineItems || []).map(
      (lineItem) => _WishlistMapper.commercetoolsLineItemToLineItem(lineItem, locale, defaultLocale)
    )
  };
};
_WishlistMapper.commercetoolsLineItemToLineItem = (commercetoolsLineItem, locale, defaultLocale) => {
  const lineItem = {
    lineItemId: commercetoolsLineItem.id,
    productId: commercetoolsLineItem.productId,
    name: LocalizedValue.getLocalizedValue(locale, defaultLocale, commercetoolsLineItem.name),
    type: "variant",
    addedAt: new Date(commercetoolsLineItem.addedAt),
    count: commercetoolsLineItem.quantity,
    variant: ProductMapper.commercetoolsProductVariantToVariant(commercetoolsLineItem.variant, locale)
  };
  lineItem._url = ProductRouter.generateUrlFor(lineItem);
  return lineItem;
};
_WishlistMapper.wishlistToCommercetoolsShoppingListDraft = (wishlist, locale) => {
  return {
    anonymousId: wishlist.anonymousId,
    customer: wishlist.accountId === void 0 ? void 0 : { typeId: "customer", id: wishlist.accountId },
    name: { [locale.language]: wishlist.name || "" }
  };
};
var WishlistMapper = _WishlistMapper;

// commerce-commercetools/apis/WishlistApi.ts
var expandVariants = ["lineItems[*].variant"];
var WishlistApi = class extends BaseApi {
  async getById(wishlistId) {
    const locale = await this.getCommercetoolsLocal();
    return await this.requestBuilder().shoppingLists().withId({ ID: wishlistId }).get({
      queryArgs: {
        expand: expandVariants
      }
    }).execute().then((response) => {
      return WishlistMapper.commercetoolsShoppingListToWishlist(response.body, locale, this.defaultLocale);
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async getForAccount(accountId) {
    const locale = await this.getCommercetoolsLocal();
    return await this.requestBuilder().shoppingLists().get({
      queryArgs: {
        where: `customer(id="${accountId}")`,
        expand: expandVariants
      }
    }).execute().then((response) => {
      return response.body.results.map(
        (shoppingList) => WishlistMapper.commercetoolsShoppingListToWishlist(shoppingList, locale, this.defaultLocale)
      );
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async getByIdForAccount(wishlistId, accountId) {
    const locale = await this.getCommercetoolsLocal();
    return await this.requestBuilder().shoppingLists().withId({ ID: wishlistId }).get({
      queryArgs: {
        where: `customer(id="${accountId}")`,
        expand: expandVariants
      }
    }).execute().then((response) => {
      return WishlistMapper.commercetoolsShoppingListToWishlist(response.body, locale, this.defaultLocale);
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async create(wishlist) {
    const locale = await this.getCommercetoolsLocal();
    const body = WishlistMapper.wishlistToCommercetoolsShoppingListDraft(wishlist, locale);
    return await this.requestBuilder().shoppingLists().post({
      body,
      queryArgs: {
        expand: expandVariants
      }
    }).execute().then((response) => {
      return WishlistMapper.commercetoolsShoppingListToWishlist(response.body, locale, this.defaultLocale);
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async addToWishlist(wishlist, request) {
    const locale = await this.getCommercetoolsLocal();
    return await this.requestBuilder().shoppingLists().withId({ ID: wishlist.wishlistId }).post({
      body: {
        version: +wishlist.wishlistVersion,
        actions: [
          {
            action: "addLineItem",
            sku: request.sku,
            quantity: request.count
          }
        ]
      },
      queryArgs: {
        expand: expandVariants
      }
    }).execute().then((response) => {
      return WishlistMapper.commercetoolsShoppingListToWishlist(response.body, locale, this.defaultLocale);
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async removeLineItem(wishlist, lineItemId) {
    const locale = await this.getCommercetoolsLocal();
    return await this.requestBuilder().shoppingLists().withId({ ID: wishlist.wishlistId }).post({
      body: {
        version: +wishlist.wishlistVersion,
        actions: [
          {
            action: "removeLineItem",
            lineItemId
          }
        ]
      },
      queryArgs: {
        expand: expandVariants
      }
    }).execute().then((response) => {
      return WishlistMapper.commercetoolsShoppingListToWishlist(response.body, locale, this.defaultLocale);
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async deleteWishlist(wishlist) {
    await this.requestBuilder().shoppingLists().withId({ ID: wishlist.wishlistId }).delete({
      queryArgs: {
        version: +wishlist.wishlistVersion
      }
    }).execute().catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
  async updateLineItemCount(wishlist, lineItemId, count) {
    const locale = await this.getCommercetoolsLocal();
    return await this.requestBuilder().shoppingLists().withId({ ID: wishlist.wishlistId }).post({
      body: {
        version: +wishlist.wishlistVersion,
        actions: [
          {
            action: "changeLineItemQuantity",
            lineItemId,
            quantity: count
          }
        ]
      },
      queryArgs: {
        expand: expandVariants
      }
    }).execute().then((response) => {
      return WishlistMapper.commercetoolsShoppingListToWishlist(response.body, locale, this.defaultLocale);
    }).catch((error) => {
      throw new ExternalError({ statusCode: error.code, message: error.message, body: error.body });
    });
  }
};

// commerce-commercetools/actionControllers/WishlistController.ts
function getWishlistApi(request, actionContext) {
  return new WishlistApi(actionContext.frontasticContext, getLocale(request), getCurrency(request), request);
}
function fetchAccountFromSession3(request) {
  var _a4;
  return (_a4 = request.sessionData) == null ? void 0 : _a4.account;
}
function fetchAccountFromSessionEnsureLoggedIn(request) {
  const account = fetchAccountFromSession3(request);
  if (!account) {
    throw new AccountAuthenticationError({ message: "Not logged in." });
  }
  return account;
}
async function fetchWishlistFromSession(request, wishlistApi) {
  var _a4, _b;
  if (((_a4 = request.sessionData) == null ? void 0 : _a4.wishlistId) !== void 0) {
    try {
      return await wishlistApi.getById((_b = request.sessionData) == null ? void 0 : _b.wishlistId);
    } catch (error) {
      console.info(`Error fetching the wishlist ${request.sessionData.wishlistId}. ${error}`);
    }
  }
  return void 0;
}
async function fetchWishlist(request, wishlistApi) {
  var _a4, _b;
  if (((_a4 = request.sessionData) == null ? void 0 : _a4.wishlistId) !== void 0) {
    try {
      return await wishlistApi.getById((_b = request.sessionData) == null ? void 0 : _b.wishlistId);
    } catch (error) {
      console.info(`Error fetching the wishlist ${request.sessionData.wishlistId}, creating a new one. ${error}`);
    }
  }
  const account = fetchAccountFromSession3(request);
  if (account) {
    const wishlistId = request.query.id;
    if (wishlistId !== void 0) {
      return await wishlistApi.getByIdForAccount(wishlistId, account.accountId);
    }
    const accountWishlists = await wishlistApi.getForAccount(account.accountId);
    if (accountWishlists.length > 0) {
      return accountWishlists[0];
    }
    return await wishlistApi.create({ accountId: account.accountId, name: "Wishlist" });
  }
  return await wishlistApi.create({ anonymousId: Guid.newGuid(), name: "Wishlist" });
}
var getWishlist = async (request, actionContext) => {
  try {
    const wishlistApi = getWishlistApi(request, actionContext);
    const wishlist = await fetchWishlistFromSession(request, wishlistApi);
    return {
      statusCode: 200,
      body: JSON.stringify(wishlist),
      sessionData: {
        ...wishlistApi.getSessionData()
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};
var createWishlist = async (request, actionContext) => {
  var _a4;
  try {
    const wishlistApi = getWishlistApi(request, actionContext);
    const body = JSON.parse(request.body);
    const account = fetchAccountFromSessionEnsureLoggedIn(request);
    const wishlist = await wishlistApi.create({ accountId: account.accountId, name: (_a4 = body.name) != null ? _a4 : "Wishlist" });
    return {
      statusCode: 200,
      body: JSON.stringify(wishlist),
      sessionData: {
        ...wishlistApi.getSessionData(),
        wishlistId: wishlist.wishlistId
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};
var addToWishlist = async (request, actionContext) => {
  var _a4;
  try {
    const wishlistApi = getWishlistApi(request, actionContext);
    const wishlist = await fetchWishlist(request, wishlistApi);
    const body = JSON.parse(request.body);
    const updatedWishlist = await wishlistApi.addToWishlist(wishlist, {
      sku: ((_a4 = body == null ? void 0 : body.variant) == null ? void 0 : _a4.sku) || void 0,
      count: body.count || 1
    });
    return {
      statusCode: 200,
      body: JSON.stringify(updatedWishlist),
      sessionData: {
        ...wishlistApi.getSessionData(),
        wishlistId: updatedWishlist.wishlistId
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};
var removeLineItem2 = async (request, actionContext) => {
  var _a4, _b;
  try {
    const wishlistApi = getWishlistApi(request, actionContext);
    const wishlist = await fetchWishlist(request, wishlistApi);
    const body = JSON.parse(request.body);
    const updatedWishlist = await wishlistApi.removeLineItem(wishlist, (_b = (_a4 = body.lineItem) == null ? void 0 : _a4.id) != null ? _b : void 0);
    return {
      statusCode: 200,
      body: JSON.stringify(updatedWishlist),
      sessionData: {
        ...wishlistApi.getSessionData(),
        wishlistId: updatedWishlist.wishlistId
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};
var deleteWishlist = async (request, actionContext) => {
  try {
    const wishlistApi = getWishlistApi(request, actionContext);
    const wishlist = await fetchWishlist(request, wishlistApi);
    await wishlistApi.deleteWishlist(wishlist);
    return {
      statusCode: 200,
      body: JSON.stringify(null),
      sessionData: {
        ...wishlistApi.getSessionData(),
        wishlistId: void 0
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};
var updateLineItemCount = async (request, actionContext) => {
  var _a4, _b;
  try {
    const wishlistApi = getWishlistApi(request, actionContext);
    const wishlist = await fetchWishlist(request, wishlistApi);
    const body = JSON.parse(request.body);
    const updatedWishlist = await wishlistApi.updateLineItemCount(
      wishlist,
      (_b = (_a4 = body.lineItem) == null ? void 0 : _a4.id) != null ? _b : void 0,
      body.count || 1
    );
    return {
      statusCode: 200,
      body: JSON.stringify(updatedWishlist),
      sessionData: {
        ...wishlistApi.getSessionData(),
        wishlistId: updatedWishlist.wishlistId
      }
    };
  } catch (error) {
    return handleError_default(error, request);
  }
};

// commerce-commercetools/actionControllers/ProjectController.ts
var ProjectController_exports = {};
__export(ProjectController_exports, {
  getProjectSettings: () => getProjectSettings
});

// commerce-commercetools/apis/ProjectApi.ts
var ProjectApi = class extends BaseApi {
  async getProjectSettings() {
    return await this.getProject().then((response) => {
      const projectSettings = {
        name: response.name,
        countries: response.countries,
        currencies: response.currencies,
        languages: response.languages,
        projectKey: response.key
      };
      return projectSettings;
    });
  }
};

// commerce-commercetools/actionControllers/ProjectController.ts
function getProjectApi(request, actionContext) {
  return new ProjectApi(actionContext.frontasticContext, getLocale(request), getCurrency(request), request);
}
var getProjectSettings = async (request, actionContext) => {
  try {
    const projectApi = getProjectApi(request, actionContext);
    const project = await projectApi.getProjectSettings();
    const response = {
      statusCode: 200,
      body: JSON.stringify(project),
      sessionData: {
        ...projectApi.getSessionData()
      }
    };
    return response;
  } catch (error) {
    return handleError_default(error, request);
  }
};

// commerce-commercetools/utils/routers/SearchRouter.ts
var SearchRouter = class {
  static identifyFrom(request) {
    var _a4;
    const urlMatches = (_a4 = getPath(request)) == null ? void 0 : _a4.match(/^\/search/);
    if (urlMatches) {
      return true;
    }
    return false;
  }
};
SearchRouter.loadFor = async (request, commercetoolsFrontendContext) => {
  var _a4;
  const productApi = new ProductApi(commercetoolsFrontendContext, getLocale(request), getCurrency(request), request);
  const urlMatches = (_a4 = getPath(request)) == null ? void 0 : _a4.match(/\/search/);
  if (urlMatches) {
    const productQuery = ProductQueryFactory.queryFromParams({
      ...request,
      query: { ...request.query, query: request.query.query || request.query.q }
    });
    return productApi.query(productQuery);
  }
  return null;
};

// commerce-commercetools/utils/routers/CategoryRouter.ts
var CategoryRouter = class {
  static identifyFrom(request) {
    var _a4;
    if ((_a4 = getPath(request)) == null ? void 0 : _a4.match(/[^/]+(?=\/$|$)/)) {
      return true;
    }
    return false;
  }
};
CategoryRouter.loadFor = async (request, commercetoolsFrontendContext) => {
  var _a4;
  const productApi = new ProductApi(commercetoolsFrontendContext, getLocale(request), getCurrency(request), request);
  const urlMatches = (_a4 = getPath(request)) == null ? void 0 : _a4.match(/[^/]+(?=\/$|$)/);
  if (urlMatches) {
    const categoryQuery = {
      slug: urlMatches[0]
    };
    const categoryQueryResult = await productApi.queryCategories(categoryQuery);
    if (categoryQueryResult.items.length == 0) {
      return null;
    }
    request.query.categories = [categoryQueryResult.items[0].categoryId];
    const productQuery = ProductQueryFactory.queryFromParams({
      ...request
    });
    return await productApi.query(productQuery);
  }
  return null;
};

// commerce-commercetools/index.ts
var getPreviewPayload = (queryResult) => {
  return queryResult.items.map((product) => {
    var _a4;
    return {
      title: product.name,
      image: (_a4 = product == null ? void 0 : product.variants[0]) == null ? void 0 : _a4.images[0]
    };
  });
};
var commerce_commercetools_default = {
  "dynamic-page-handler": async (request, context) => {
    var _a4;
    try {
      const staticPageMatch = (_a4 = getPath(request)) == null ? void 0 : _a4.match(
        /^\/(cart|checkout|wishlist|account|login|register|reset-password|thank-you)$/
      );
      if (staticPageMatch) {
        return {
          dynamicPageType: `frontastic${staticPageMatch[0]}`,
          dataSourcePayload: {},
          pageMatchingPayload: {}
        };
      }
      if (ProductRouter.identifyFrom(request)) {
        return ProductRouter.loadFor(request, context.frontasticContext).then((product) => {
          if (product) {
            return {
              dynamicPageType: "frontastic/product-detail-page",
              dataSourcePayload: {
                product
              },
              pageMatchingPayload: {
                product
              }
            };
          }
          return null;
        });
      }
      if (SearchRouter.identifyFrom(request)) {
        return SearchRouter.loadFor(request, context.frontasticContext).then((result) => {
          if (result) {
            return {
              dynamicPageType: "frontastic/search",
              dataSourcePayload: result,
              pageMatchingPayload: result
            };
          }
          return null;
        });
      }
      if (CategoryRouter.identifyFrom(request)) {
        return CategoryRouter.loadFor(request, context.frontasticContext).then((result) => {
          if (result) {
            return {
              dynamicPageType: "frontastic/category",
              dataSourcePayload: result,
              pageMatchingPayload: result
            };
          }
          return null;
        });
      }
      return null;
    } catch (error) {
      if (context.frontasticContext.environment !== "production") {
        return {
          dynamicPageType: "frontastic/error",
          dataSourcePayload: handleError_default(error, request)
        };
      }
      return null;
    }
  },
  "data-sources": {
    "frontastic/product-list": async (config, context) => {
      try {
        const productApi = new ProductApi(
          context.frontasticContext,
          getLocale(context.request),
          getCurrency(context.request),
          context.request
        );
        const productQuery = ProductQueryFactory.queryFromParams(context == null ? void 0 : context.request, config);
        const queryResult = await productApi.query(productQuery);
        return !context.isPreview ? { dataSourcePayload: queryResult } : {
          dataSourcePayload: queryResult,
          previewPayload: getPreviewPayload(queryResult)
        };
      } catch (error) {
        return {
          dataSourcePayload: handleError_default(error, context.request)
        };
      }
    },
    "frontastic/similar-products": async (config, context) => {
      var _a4, _b, _c, _d, _e;
      if (!context.hasOwnProperty("request")) {
        throw new ValidationError({
          message: `Request is not defined in context ${context}`
        });
      }
      try {
        const productApi = new ProductApi(
          context.frontasticContext,
          getLocale(context.request),
          getCurrency(context.request),
          context.request
        );
        const productQuery = ProductQueryFactory.queryFromParams(context.request, config);
        const query2 = {
          ...productQuery,
          categories: [
            (_e = (_d = (_c = (_b = (_a4 = context.pageFolder.dataSourceConfigurations.find(
              (stream) => stream.streamId === "__master"
            )) == null ? void 0 : _a4.preloadedValue) == null ? void 0 : _b.product) == null ? void 0 : _c.categories) == null ? void 0 : _d[0]) == null ? void 0 : _e.categoryId
          ]
        };
        const queryResult = await productApi.query(query2);
        return !context.isPreview ? { dataSourcePayload: queryResult } : {
          dataSourcePayload: queryResult,
          previewPayload: getPreviewPayload(queryResult)
        };
      } catch (error) {
        return {
          dataSourcePayload: handleError_default(error, context.request)
        };
      }
    },
    "frontastic/product": async (config, context) => {
      var _a4;
      try {
        const productApi = new ProductApi(
          context.frontasticContext,
          getLocale(context.request),
          getCurrency(context.request),
          context.request
        );
        const productQuery = ProductQueryFactory.queryFromParams(context == null ? void 0 : context.request, config);
        const queryResult = await productApi.getProduct(productQuery);
        const payLoadResult = { dataSourcePayload: { product: queryResult } };
        return !context.isPreview ? payLoadResult : {
          payLoadResult,
          previewPayload: [
            {
              title: queryResult.name,
              image: (_a4 = queryResult == null ? void 0 : queryResult.variants[0]) == null ? void 0 : _a4.images[0]
            }
          ]
        };
      } catch (error) {
        return {
          dataSourcePayload: handleError_default(error, context.request)
        };
      }
    },
    "frontastic/other-products": async (config, context) => {
      if (!context.hasOwnProperty("request")) {
        throw new ValidationError({
          message: `Request is not defined in context ${context}`
        });
      }
      try {
        const productApi = new ProductApi(
          context.frontasticContext,
          getLocale(context.request),
          getCurrency(context.request),
          context.request
        );
        const productQuery = ProductQueryFactory.queryFromParams(context.request, config);
        const shuffleArray = (array) => {
          for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const temp = array[i];
            array[i] = array[j];
            array[j] = temp;
          }
          return array;
        };
        const queryResult = await productApi.query(productQuery);
        return {
          dataSourcePayload: {
            ...queryResult,
            items: shuffleArray(queryResult.items)
          }
        };
      } catch (error) {
        return {
          dataSourcePayload: handleError_default(error, context.request)
        };
      }
    },
    "frontastic/empty": async (config, context) => {
      return !context.isPreview ? { dataSourcePayload: {} } : {
        dataSourcePayload: {},
        previewPayload: []
      };
    }
  },
  actions: {
    account: AccountController_exports,
    cart: CartController_exports,
    product: ProductController_exports,
    wishlist: WishlistController_exports,
    project: ProjectController_exports
  }
};

// content-contentful/apis/ContentApi.ts
var import_contentful2 = __toESM(require_contentful());

// content-contentful/mappers/ContentfulMapper.ts
var import_contentful = __toESM(require_contentful());
var ContentfulMapper = class {
  static contentfulEntryToContent(contentfulEntry, contentfulContentType) {
    const attributes = this.contentfulFieldsToAttributes(contentfulEntry.fields, contentfulContentType);
    return {
      contentId: contentfulEntry.sys.id,
      contentTypeId: contentfulEntry.sys.contentType.sys.id,
      name: attributes.hasOwnProperty(contentfulContentType.displayField) && typeof attributes[contentfulContentType.displayField].content === "string" ? attributes[contentfulContentType.displayField].content : void 0,
      attributes
    };
  }
  static contentfulFieldsToAttributes(fields, contentfulContentType) {
    var _a4;
    const attributes = {};
    for (const [key, value] of Object.entries(fields)) {
      attributes[key] = {
        attributeId: key,
        content: typeof value === "string" || typeof value === "number" ? value.toString() : this.contentfulCompoundAttributeToAttributeContent(value),
        type: (_a4 = contentfulContentType.fields.find((field) => {
          return field.id === key;
        })) == null ? void 0 : _a4.type
      };
    }
    return attributes;
  }
  static contentfulCompoundAttributeToAttributeContent(value) {
    var _a4;
    if (((_a4 = value.sys) == null ? void 0 : _a4.type) === "Asset") {
      return this.contentfulAsseToAsset(value);
    }
    if (value.data && value.content && value.nodeType == "document") {
      return this.contentfulRichTextContentListToContentList(value.content);
    }
    const content = {};
    for (const [key, data] of Object.entries(value)) {
      content[key] = data;
    }
    return content;
  }
  static contentfulRichTextContentListToContentList(richTextContentList) {
    return richTextContentList.map((richTextContent) => {
      return richTextContent;
    });
  }
  static contentfulAsseToAsset(contentfulAsset) {
    return {
      url: contentfulAsset.fields.file.url,
      title: contentfulAsset.fields.title,
      description: contentfulAsset.fields.description
    };
  }
};

// content-contentful/utils/Context.ts
var projectConfigurationOverrides4 = {};
var isDevEnv4 = (context) => {
  return context.environment === "development" || context.environment === "dev";
};
var getFromProjectConfig4 = (key, context) => {
  if (isDevEnv4(context) && projectConfigurationOverrides4[key]) {
    return projectConfigurationOverrides4[key];
  }
  return context.projectConfiguration[key];
};

// content-contentful/apis/ContentApi.ts
var ContentApi = class {
  constructor(frontasticContext, locale) {
    var _a4, _b, _c, _d;
    let space = getFromProjectConfig4("EXTENSION_CONTENTFUL_SPACE_ID", frontasticContext);
    if (!space) {
      space = (_b = (_a4 = frontasticContext.project.configuration) == null ? void 0 : _a4.contentful) == null ? void 0 : _b.space;
    }
    let accessToken = getFromProjectConfig4("EXTENSION_CONTENTFUL_ACCESS_TOKEN", frontasticContext);
    if (!accessToken) {
      accessToken = (_d = (_c = frontasticContext.project.configuration) == null ? void 0 : _c.contentful) == null ? void 0 : _d.accessToken;
    }
    this.client = (0, import_contentful2.createClient)({
      space,
      accessToken
    });
    this.locale = this.formatLocale(locale !== null ? locale : frontasticContext.project.defaultLocale);
  }
  formatLocale(locale) {
    return locale.replace("_", "-");
  }
  async getContent(id) {
    const contentfulEntry = await this.client.getEntry(id, { locale: this.locale });
    const contentfulContentType = await this.client.getContentType(contentfulEntry.sys.contentType.sys.id);
    return ContentfulMapper.contentfulEntryToContent(contentfulEntry, contentfulContentType);
  }
};

// content-contentful/actionControllers/ContentController.ts
var ContentController_exports = {};
__export(ContentController_exports, {
  getContent: () => getContent
});

// content-contentful/utils/Request.ts
var getLocale2 = (request) => {
  var _a4;
  const locale = (_a4 = getHeader2(request, ["commercetools-frontend-locale" /* commercetoolsFrontendLocale */, "frontastic-locale" /* frontasticLocale */])) != null ? _a4 : request.query.locale;
  if (locale !== void 0) {
    return locale;
  }
  throw new ValidationError({ message: `Locale is missing from request ${request}` });
};
var getHeader2 = (request, headers) => {
  for (const header of headers) {
    const foundHeader = request.headers[header.toLowerCase()];
    if (foundHeader !== void 0) {
      if (Array.isArray(foundHeader)) {
        return foundHeader[0];
      }
      return foundHeader;
    }
  }
  return null;
};

// content-contentful/actionControllers/ContentController.ts
var getContent = async (request, actionContext) => {
  const contentApi = new ContentApi(actionContext.frontasticContext, getLocale2(request));
  const data = await contentApi.getContent(request.query.id);
  const response = {
    statusCode: 200,
    body: JSON.stringify(data),
    sessionData: request.sessionData
  };
  return response;
};

// content-contentful/index.ts
var content_contentful_default = {
  "data-sources": {
    "frontastic/content": async (config, context) => {
      const contentApi = new ContentApi(context.frontasticContext, getLocale2(context.request));
      return await contentApi.getContent(config.configuration.contentId).then((contentResult) => {
        return !context.isPreview ? { dataSourcePayload: contentResult } : {
          dataSourcePayload: contentResult,
          previewPayload: [
            {
              title: contentResult.name
            }
          ]
        };
      });
    }
  },
  actions: {
    content: ContentController_exports
  }
};

// content-dynamicyield/apis/DynamicYieldApi.ts
init_lib();

// content-dynamicyield/apis/BaseApi.ts
var BaseApi2 = class {
  constructor(frontasticContext, userId, sessionId) {
    this.userId = userId;
    this.sessionId = sessionId;
    this.dyClient = this.createDyClient(frontasticContext);
  }
  getSessionId() {
    return this.sessionId;
  }
  getUserId() {
    return this.userId;
  }
  getDyClient() {
    return this.dyClient;
  }
  createDyClient(frontasticContext) {
    var _a4, _b, _c, _d;
    let apikey = getFromProjectConfig("EXTENSION_DYNAMICYIELD_API_KEY", frontasticContext);
    if (!apikey) {
      apikey = (_b = (_a4 = frontasticContext.project.configuration) == null ? void 0 : _a4.dynamicyield) == null ? void 0 : _b.apiKey;
    }
    let host = getFromProjectConfig("EXTENSION_DYNAMICYIELD_HOST", frontasticContext);
    if (!host) {
      host = (_d = (_c = frontasticContext.project.configuration) == null ? void 0 : _c.dynamicyield) == null ? void 0 : _d.host;
    }
    const dyClient = {
      apiKey: apikey,
      url: `${host}/v2/serve/user/choose`
    };
    return dyClient;
  }
};

// content-dynamicyield/mappers/DynamicYieldMapper.ts
var DynamicYieldMapper = class {
  static mapToVariants(slotItem, price) {
    var _a4, _b;
    const variants = [];
    const variant = {
      sku: slotItem == null ? void 0 : slotItem.sku,
      price,
      groupId: (_a4 = slotItem == null ? void 0 : slotItem.productData) == null ? void 0 : _a4.group_id,
      images: [(_b = slotItem == null ? void 0 : slotItem.productData) == null ? void 0 : _b.image_url]
    };
    variants.push(variant);
    return variants;
  }
  static mapToCategories(slotItem) {
    var _a4;
    const categories = [];
    const categoriesText = (_a4 = slotItem == null ? void 0 : slotItem.productData) == null ? void 0 : _a4.categories;
    categoriesText.forEach((categoryName) => {
      const category = {
        name: categoryName
      };
      categories.push(category);
    });
    return categories;
  }
  static mapChooseResponseToProducts(result) {
    var _a4, _b, _c;
    const products = [];
    const resultJson = JSON.parse(result);
    const variation = (_a4 = resultJson == null ? void 0 : resultJson.choices[0]) == null ? void 0 : _a4.variations[0];
    const slots = (_c = (_b = variation == null ? void 0 : variation.payload) == null ? void 0 : _b.data) == null ? void 0 : _c.slots;
    slots.forEach((slotItem) => {
      var _a5, _b2, _c2, _d;
      const price = {
        fractionDigits: 2,
        centAmount: (_a5 = slotItem == null ? void 0 : slotItem.productData) == null ? void 0 : _a5.price
      };
      const variants = this.mapToVariants(slotItem, price);
      const categories = this.mapToCategories(slotItem);
      const product = {
        name: (_b2 = slotItem == null ? void 0 : slotItem.productData) == null ? void 0 : _b2.name,
        description: (_c2 = slotItem == null ? void 0 : slotItem.productData) == null ? void 0 : _c2.description,
        _url: (_d = slotItem == null ? void 0 : slotItem.productData) == null ? void 0 : _d.url,
        categories,
        variants
      };
      products.push(product);
    });
    return products;
  }
};

// content-dynamicyield/utils/Errors.ts
var ExtensionError2 = class extends Error {
  constructor({ message, errors }) {
    var _a4;
    super(message || ((_a4 = errors == null ? void 0 : errors[0]) == null ? void 0 : _a4.message));
    this.errors = errors || [{ message }];
  }
};
var ValidationError2 = class extends ExtensionError2 {
  constructor(options) {
    super(options);
    this.code = "validation_error";
  }
};
var ExternalError2 = class extends ExtensionError2 {
  constructor(options) {
    super(options);
    this.status = options.status;
    this.body = options.body;
    this.code = "external_error";
  }
};

// content-dynamicyield/apis/DynamicYieldApi.ts
var DynamicYieldApi = class extends BaseApi2 {
  async choose(dyContext, selectors = []) {
    const userId = this.getUserId();
    const sessionId = this.getSessionId();
    const body = {
      selector: {
        names: selectors
      },
      user: {
        id: userId
      },
      session: {
        custom: sessionId
      },
      context: dyContext
    };
    const headers = {
      "dy-api-key": this.getDyClient().apiKey,
      "Content-Type": "application/json"
    };
    const resultBody = await lib_default(this.getDyClient().url, {
      method: "post",
      body: JSON.stringify(body),
      headers
    }).then((response) => response.json()).catch((error) => {
      throw new ExternalError2({ status: error.code, message: error.message, body: error.body });
    });
    const stringifyResultBody = JSON.stringify(resultBody);
    const items = DynamicYieldMapper.mapChooseResponseToProducts(stringifyResultBody);
    return items;
  }
};

// content-dynamicyield/utils/Request.ts
var getPath2 = (request) => {
  var _a4;
  return (_a4 = getHeader3(request, ["frontastic-path" /* frontasticPath */, "commercetools-frontend-path" /* commercetoolsFrontendPath */])) != null ? _a4 : request.query.path;
};
var getContext = (request, pageContextType) => {
  const referrer = getHeader3(request, ["referrer"]);
  const userAgent = getHeader3(request, ["userAgent"]);
  const ip = request == null ? void 0 : request.clientIp;
  const hostname = request == null ? void 0 : request.hostname;
  const path = getPath2(request);
  const query2 = request == null ? void 0 : request.query;
  const data = [];
  const dyContext = {
    page: {
      location: `https://${hostname}${path}`,
      referrer: referrer || "",
      type: pageContextType,
      data
    },
    device: {
      userAgent: userAgent || "",
      ip
    },
    pageAttributes: query2
  };
  return dyContext;
};
var getHeader3 = (request, headers) => {
  for (const header of headers) {
    const foundHeader = request.headers[header.toLowerCase()];
    if (foundHeader !== void 0) {
      if (Array.isArray(foundHeader)) {
        return foundHeader[0];
      }
      return foundHeader;
    }
  }
  return null;
};

// content-dynamicyield/index.ts
var content_dynamicyield_default = {
  "data-sources": {
    "dynamicyield/product-recommendations-campaign": async (config, context) => {
      var _a4, _b, _c, _d, _e, _f, _g, _h;
      if (!context.hasOwnProperty("request")) {
        throw new ValidationError2({
          message: `Request is not defined in context ${context}`
        });
      }
      const userId = (_b = (_a4 = context.request) == null ? void 0 : _a4.query) == null ? void 0 : _b.dyId;
      const sessionId = (_d = (_c = context.request) == null ? void 0 : _c.query) == null ? void 0 : _d.dySessionId;
      if (!userId) {
        throw new ValidationError2({
          message: `dyId user ID is not defined in request query ${JSON.stringify((_e = context.request) == null ? void 0 : _e.query)}`
        });
      }
      if (!sessionId) {
        throw new ValidationError2({
          message: `dySessionId is not defined in request query ${JSON.stringify((_f = context.request) == null ? void 0 : _f.query)}`
        });
      }
      const dyApi = new DynamicYieldApi(context.frontasticContext, userId, sessionId);
      const pageContextType = (_g = config == null ? void 0 : config.configuration) == null ? void 0 : _g.pageContextType;
      if (!pageContextType) {
        throw new ValidationError2({
          message: `Page context type is not defined in configuration ${config}`
        });
      }
      const dyContext = getContext(context.request, pageContextType);
      const campaignSelectorName = (_h = config == null ? void 0 : config.configuration) == null ? void 0 : _h.campaignSelectorName;
      if (!campaignSelectorName) {
        throw new ValidationError2({
          message: `Dynamicyield campaign selector name is not defined in configuration ${config}`
        });
      }
      const selector = [campaignSelectorName];
      const items = await dyApi.choose(dyContext, selector);
      return {
        dataSourcePayload: { items }
      };
    }
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/config/index.js
function isContentClientConfigV1(config) {
  return config.account !== void 0;
}
function isContentClientConfigV2(config) {
  return config.hubName !== void 0;
}
function isContentClientConfigV2Fresh(config) {
  return isContentClientConfigV2(config) && config.apiKey !== void 0;
}

// node_modules/dc-delivery-sdk-js/build/module/lib/utils/Url.js
function encodeQueryString(queryParameters) {
  const components = [];
  for (const keyValuePair of queryParameters) {
    const key = keyValuePair[0];
    const value = keyValuePair[1];
    components.push(`${key}=${encodeURIComponent(value)}`);
  }
  return components.join("&");
}

// node_modules/dc-delivery-sdk-js/build/module/lib/rendering/model/RenderedContentItem.js
var RenderedContentItem = class {
};

// node_modules/dc-delivery-sdk-js/build/module/lib/content/model/Edition.js
var Edition = class {
  /**
   * Creates a new Edition instance.
   * @param data JSON representation of the Edition model
   */
  constructor(data) {
    if (data) {
      Object.assign(this, data);
    }
  }
  /**
   * Date when the edition should begin
   */
  getStartDate() {
    return new Date(this.start);
  }
  /**
   * Date when the edition should end
   */
  getEndDate() {
    return new Date(this.end);
  }
  /**
   * Export to JSON
   */
  toJSON() {
    return {
      id: this.id,
      start: this.start,
      end: this.end
    };
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/content/model/ContentLifecycle.js
var ContentLifecycle = class {
  /**
   * Creates a new ContentLifecycle instance.
   * @param data JSON representation of the ContentLifecycle model
   */
  constructor(data) {
    if (data) {
      Object.assign(this, data);
    }
  }
  /**
   * Returns a boolean to indicate if the content should no longer be displayed by your application.
   * @param currentTime Optional date to override the current time.
   */
  isExpired(currentTime) {
    currentTime = currentTime || /* @__PURE__ */ new Date();
    return this.expiryTime !== void 0 && new Date(this.expiryTime).getTime() < currentTime.getTime();
  }
  /**
   * Export to JSON
   */
  toJSON() {
    return {
      expiryTime: this.expiryTime
    };
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/rendering/coordinators/RenderContentItem.js
var RenderContentItem = class {
  constructor(config, contentClient) {
    this.config = config;
    this.contentClient = contentClient;
  }
  renderContentItem(contentItemId, templateName, customParameters) {
    const queryParameters = this.getQueryParams(templateName, customParameters);
    const queryString = encodeQueryString(queryParameters);
    const path = `/v1/content/${encodeURIComponent(this.config.account)}/content-item/${encodeURIComponent(contentItemId)}`;
    return this.contentClient.get(`${path}?${queryString}`).then((response) => {
      return this.parseResponse(response);
    });
  }
  getQueryParams(templateName, customParameters) {
    const queryParameters = [["template", templateName]];
    if (customParameters) {
      for (const key of Object.keys(customParameters)) {
        const value = customParameters[key];
        queryParameters.push([`crparam.${key}`, value]);
      }
    }
    if (this.config.locale) {
      queryParameters.push(["locale", this.config.locale]);
    }
    return queryParameters;
  }
  parseResponse(response) {
    const headers = response.headers;
    const result = new RenderedContentItem();
    result.body = response.data;
    if (headers) {
      const editionId = headers["X-Amp-Edition-ID"];
      const editionStart = headers["X-Amp-Edition-Start-Time"];
      const editionEnd = headers["X-Amp-Edition-End-Time"];
      const lifecycleExpiryTime = headers["X-Amp-Lifecycle-Expiry-Time"];
      if (editionId) {
        result.edition = new Edition({
          id: editionId,
          start: editionStart,
          end: editionEnd
        });
      }
      if (lifecycleExpiryTime) {
        result.lifecycle = new ContentLifecycle({
          expiryTime: lifecycleExpiryTime
        });
      }
    }
    return result;
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/content/model/HttpError.js
function dataToMessage(data) {
  if (typeof data === "string") {
    return data;
  } else if (data.error && data.error.message) {
    return data.error.message;
  } else {
    return JSON.stringify(data);
  }
}
var HttpError2 = class extends Error {
  constructor(status, data, message) {
    super(message || dataToMessage(data));
    this.status = status;
    this.data = data;
    this.name = "HTTP_ERROR";
    Object.setPrototypeOf(this, new.target.prototype);
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/content/coordinators/FilterByImpl.js
var FilterByImpl = class {
  constructor(config, contentClient) {
    this.config = config;
    this.contentClient = contentClient;
  }
  async fetch(requestConfig) {
    var _a4, _b;
    try {
      if (!((_a4 = requestConfig.parameters) == null ? void 0 : _a4.locale) && ((_b = this.config) == null ? void 0 : _b.locale)) {
        requestConfig.parameters = Object.assign({}, {
          ...requestConfig.parameters || {},
          locale: this.config.locale
        });
      }
      const { data } = await this.contentClient.post("content/filter", requestConfig);
      if (data.page.nextCursor) {
        const request = Object.assign({}, {
          ...requestConfig,
          page: {
            ...requestConfig.page || {},
            cursor: data.page.nextCursor
          }
        });
        data.page.next = () => this.fetch(request);
      }
      return data;
    } catch (err) {
      if (err.response) {
        throw new HttpError2(err.response.status, err.response.data);
      }
      throw err;
    }
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/content/coordinators/FilterBy.js
var FilterBy = class _FilterBy {
  constructor(config, contentClient) {
    this.config = config;
    this.contentClient = contentClient;
    this.requestConfig = {
      filterBy: []
    };
    this.filterByService = new FilterByImpl(this.config, this.contentClient);
  }
  /**
   *  This function will help construct requests for filtering Content Items or Slots
   *
   * @param path - json path to the property you wish to filter by e.g `/_meta/schema`
   * @param value - value you want to return matches for
   *
   * @returns `FilterBy<Body>`
   */
  filterBy(path, value) {
    this.requestConfig.filterBy.push({
      path,
      value
    });
    return this;
  }
  /**
   *
   *  equivalent to:
   *
   * ```ts
   *  client.filterBy('/_meta/schema', contentTypeUri)
   * ```
   *
   * @param contentTypeUri - Content Type Uri you want to filter
   *
   * @returns `FilterBy<Body>`
   */
  filterByContentType(value) {
    return this.filterBy(_FilterBy.SCHEMA_PATH, value);
  }
  /**
   * Fetch content by parent id
   *
   * equivalent to:
   *
   * ```ts
   *  client.filterBy('/_meta/hierarchy/parentId', id)
   * ```
   *
   * @param id - ID of a Hierarchy Content Item
   *
   * @returns `FilterBy<Body>`
   */
  filterByParentId(value) {
    return this.filterBy(_FilterBy.PARENT_PATH, value);
  }
  /**
   * Set sortable key based on schema [`trait:sortable`](https://amplience.com/docs/development/contentdelivery/filterandsort.html#sorttrait)
   *
   *
   * @param key - key you wish to sort by
   * @param order - order enum ASC, DESC
   *
   * @returns `FilterBy<Body>`
   */
  sortBy(key, order) {
    this.requestConfig.sortBy = {
      key,
      order
    };
    return this;
  }
  page(size, cursor) {
    if (!this.requestConfig.page) {
      this.requestConfig.page = {};
    }
    if (arguments.length === 1 && typeof size === "string") {
      this.requestConfig.page.cursor = size;
      return this;
    }
    if (typeof size === "number") {
      this.requestConfig.page.size = size;
    }
    if (cursor) {
      this.requestConfig.page.cursor = cursor;
    }
    return this;
  }
  /**
   *
   * @param parameters - api options for response format
   *
   * @returns `FilterBy<Body>`
   */
  async request(parameters) {
    if (parameters) {
      this.requestConfig.parameters = parameters;
    }
    return this.filterByService.fetch(this.requestConfig);
  }
};
FilterBy.SCHEMA_PATH = "/_meta/schema";
FilterBy.PARENT_PATH = "/_meta/hierarchy/parentId";

// node_modules/dc-delivery-sdk-js/build/module/lib/utils/JsonWalker.js
function walkAndReplace(value, options, pointer = []) {
  if (options.beforeWalk) {
    value = options.beforeWalk(value, pointer);
  }
  if (Array.isArray(value)) {
    const newValue = [];
    for (let i = 0; i < value.length; i++) {
      let entryValue = value[i];
      entryValue = walkAndReplace(entryValue, options, pointer.concat(`${i}`));
      newValue.push(entryValue);
    }
    value = newValue;
  } else if (typeof value === "object" && value !== null) {
    const newValue = {};
    const keys = Object.keys(value);
    for (const entryKey of keys) {
      let entryValue = value[entryKey];
      entryValue = walkAndReplace(entryValue, options, pointer.concat(entryKey));
      newValue[entryKey] = entryValue;
    }
    value = newValue;
  }
  if (options.afterWalk) {
    value = options.afterWalk(value, pointer);
  }
  return value;
}

// node_modules/dc-delivery-sdk-js/build/module/lib/content/model/ContentItem.js
var ContentItem = class {
  /**
   * Returns a plain JSON version of the content body, removing helper properties and functions.
   * This should be used if your application needs to serialize the content body, e.g. in an API response.
   */
  toJSON() {
    return JSON.parse(JSON.stringify(this.body));
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/content/model/ContentNotFoundError.js
var ContentNotFoundError = class extends Error {
  constructor(contentItem) {
    super(`Content item "${contentItem}" was not found`);
    this.contentItem = contentItem;
    this.name = "CONTENT_NOT_FOUND";
    Object.setPrototypeOf(this, new.target.prototype);
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/content/coordinators/GetContentItemV1Impl.js
var LD_ID = "@id";
var LD_TYPE = "@type";
var LD_GRAPH = "@graph";
var GetContentItemV1Impl = class {
  constructor(config, contentClient, mapper) {
    this.config = config;
    this.contentClient = contentClient;
    this.mapper = mapper;
  }
  /**
   * @deprecated use getContentItemById
   */
  getContentItem(id) {
    return this.getContentItemById(id);
  }
  async getContentItemById(id) {
    const url = this.getUrl({
      "sys.iri": `http://content.cms.amplience.com/${id}`
    });
    try {
      const response = await this.contentClient.get(url);
      const contentItems = this.processResponse(response.data);
      if (contentItems.length === 0) {
        throw new ContentNotFoundError(id);
      }
      const item = contentItems.find((x) => x._meta.deliveryId === id);
      if (!item) {
        throw new ContentNotFoundError(id);
      }
      return this.hydrateContentItem(item);
    } catch (err) {
      if (err.response) {
        throw new HttpError2(err.response.status, err.response.data);
      }
      throw err;
    }
  }
  getUrl(query2) {
    const args = [
      ["query", JSON.stringify(query2)],
      ["fullBodyObject", "true"],
      ["scope", "tree"],
      ["store", this.config.account]
    ];
    if (this.config.locale) {
      args.push(["locale", this.config.locale]);
    }
    const queryString = encodeQueryString(args);
    return `/cms/content/query?${queryString}`;
  }
  /**
   * Convert plain content JSON into ContentItem instamce
   * @param content
   */
  hydrateContentItem(content) {
    const contentItem = new ContentItem();
    contentItem.body = this.mapper.toMappedContent(content);
    return contentItem;
  }
  /**
   * Pre-processes the response to create a single content item object
   * with all linked content items inlined.
   * @param data Response from content query API
   */
  processResponse(data) {
    if (!data.result || !data[LD_GRAPH] || !Array.isArray(data.result)) {
      return [];
    } else {
      const graph = data[LD_GRAPH];
      const graphChildrenById = {};
      graph.forEach((child) => graphChildrenById[child[LD_ID]] = child);
      return data.result.map((result) => {
        result = graphChildrenById[result[LD_ID]];
        result = walkAndReplace(result, {
          beforeWalk: (node) => {
            if (typeof node === "object" && node !== null) {
              if (node[LD_ID]) {
                node = graphChildrenById[node[LD_ID]];
              }
            }
            return node;
          }
        });
        result = walkAndReplace(result, {
          beforeWalk: (node) => {
            node = this.upgradeLegacyContent(node);
            node = this.injectMetaData(node);
            node = this.removeJsonLD(node);
            return node;
          }
        });
        return result;
      });
    }
  }
  /**
   * Content produced by older versions do not include _meta.schema.
   * This function inserts those values to normalize the output
   */
  upgradeLegacyContent(node) {
    if (!node) {
      return node;
    }
    const type = node[LD_TYPE];
    const id = node[LD_ID];
    const isImage = id && id.indexOf("http://image.cms.amplience.com/") === 0;
    const isVideo = id && id.indexOf("http://video.cms.amplience.com/") === 0;
    if (type || isImage || isVideo) {
      if (!node._meta) {
        node._meta = {};
      }
      if (type) {
        if (!node._meta.schema) {
          node._meta.schema = type;
        }
        if (!node._meta.name && node._title) {
          node._meta.name = node._title;
        }
      } else if (isImage) {
        node._meta.schema = "http://bigcontent.io/cms/schema/v1/core#/definitions/image-link";
      } else if (isVideo) {
        node._meta.schema = "http://bigcontent.io/cms/schema/v1/core#/definitions/video-link";
      }
    }
    return node;
  }
  /**
   * Injects additional meta data which is lost by removing
   * the JSON-LD properties
   */
  injectMetaData(node) {
    if (node) {
      const id = node[LD_ID];
      if (id) {
        if (id.indexOf("http://content.cms.amplience.com/") === 0) {
          node._meta = node._meta || {};
          node._meta.deliveryId = id.slice(33);
        } else if (id.indexOf("http://image.cms.amplience.com/") === 0 || id.indexOf("http://video.cms.amplience.com/") === 0) {
          node.id = id.slice(31);
        }
      }
    }
    return node;
  }
  /**
   * JSON-LD keywords are just for delivery payload
   */
  removeJsonLD(node) {
    if (node) {
      delete node[LD_TYPE];
      delete node[LD_ID];
    }
    return node;
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/content/model/FragmentMeta.js
var FragmentMeta = class {
  /**
   * Creates a new FragmentMeta instance.
   * @param data JSON representation of the FragmentMeta model
   */
  constructor(data) {
    if (data) {
      Object.assign(this, data);
    }
  }
  /**
   * Export to JSON
   */
  toJSON() {
    return {
      schema: this.schema
    };
  }
  /**
   * @hidden
   * Returns true if the provided node contains meta data to self-describe the JSON schema it was created against.
   * @param node JSON node to test
   */
  static isFragment(node) {
    return node != null && node._meta != null && node._meta.schema != null;
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/content/model/ContentMeta.js
var ContentReferenceMeta = class extends FragmentMeta {
  constructor(data) {
    super(data);
  }
};
var ContentMeta = class extends FragmentMeta {
  /**
   * Creates a new ContentMeta instance.
   * @param data JSON representation of the ContentMeta model
   */
  constructor(data) {
    super(data);
    if (data) {
      if (data.edition) {
        this.edition = new Edition(data.edition);
      }
      if (data.lifecycle) {
        this.lifecycle = new ContentLifecycle(data.lifecycle);
      }
    }
  }
  /**
   * Export to JSON
   */
  toJSON() {
    const result = super.toJSON();
    if (this.deliveryId) {
      result.deliveryId = this.deliveryId;
    }
    if (this.deliveryKey) {
      result.deliveryKey = this.deliveryKey;
    }
    if (this.name) {
      result.name = this.name;
    }
    if (this.edition) {
      result.edition = this.edition.toJSON();
    }
    if (this.lifecycle) {
      result.lifecycle = this.lifecycle.toJSON();
    }
    if (this.hierarchy) {
      result.hierarchy = this.hierarchy;
    }
    return result;
  }
  /**
   * @hidden
   * Returns true if the provided node is a content item meta data object
   * @param node JSON node to test
   */
  static isContentMeta(node) {
    return node != null && node.schema != null && (node.name != null || node.deliveryId != null);
  }
  /**
   * @hidden
   * Returns true if the provided node is a content body object
   * @param node JSON node to test
   */
  static isContentBody(node) {
    return node != null && this.isContentMeta(node._meta);
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/media/Media.js
var Media = class {
  constructor(data, config) {
    this.config = config;
    Object.assign(this, data);
  }
  /**
   * Returns the hostname that should be used to load this media resource.
   * The hostname will use the staging and media host overrides if specified
   * otherwise it will use the defaultHost provided by the delivery API.
   * @param secure
   */
  getHost(secure) {
    if (this.config.stagingEnvironment) {
      return this.config.stagingEnvironment;
    }
    if (secure) {
      return this.config.secureMediaHost || this.defaultHost;
    } else {
      return this.config.mediaHost || this.config.secureMediaHost || this.defaultHost;
    }
  }
  /**
   * Export media object to JSON
   */
  toJSON() {
    return {
      defaultHost: this.defaultHost,
      endpoint: this.endpoint,
      name: this.name,
      id: this.id
    };
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/media/MediaMeta.js
var MediaMeta = class extends FragmentMeta {
  constructor(data) {
    super(data);
  }
};
var ImageMeta = class extends MediaMeta {
  constructor(data) {
    super(data);
  }
};
var VideoMeta = class extends MediaMeta {
  constructor(data) {
    super(data);
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/media/ImageUrlBuilder.js
var ImageUrlBuilder = class {
  constructor(media) {
    this.media = media;
    this._protocol = "https";
    this._query = [];
  }
  /**
   * Protocol configures what protocol style to use when building the image URL.
   *
   * ```{{protocol}}[:]//images.site.com/i/account/image```
   * @param value URL protocol, valid values are: http, https and // for protocol relative URLs
   */
  protocol(value) {
    this._protocol = value;
    return this;
  }
  /**
   * Host configures the hostname to use when building the image URL.
   * By default, the SDK will use the most appropriate hostname based on
   * the SDK configuration.
   *
   * ```https://{{host}}/i/account/image```
   * @param value Hostname to use instead of the default value.
   */
  host(value) {
    this._host = value;
    return this;
  }
  /**
   * Format converts the image to the file format specified.
   * The format will be appended to the URL as a file extension.
   *
   * ```https://images.site.com/i/account/image.webp```
   * @param value  Images format to use when encoding the output.
   */
  format(value) {
    this._format = value;
    return this;
  }
  /**
   * SEO filename allows a custom filename to be used to improve SEO.
   *
   * ```https://images.site.com/i/account/image/{{seoFileName}}```
   * @param value
   */
  seoFileName(value) {
    this._seoFileName = value;
    return this;
  }
  /**
   * Template applies a transformation template to the image, which will
   * apply all of the transformation parameters contained in the template to the image.
   *
   * ```https://images.site.com/i/account/image?${{name}}$```
   * @param name The name of the transformation template previously configured in the Amplience back-office.
   */
  template(name) {
    this._query.push(`$${encodeURIComponent(name)}$`);
    return this;
  }
  /**
   * Parameter appends the specified parameter to the query string. This can be used to
   * pass variables into templates.
   *
   * ```https://images.site.com/i/account/image?{{name}}={{value}}```
   * @param name
   * @param value
   */
  parameter(name, value) {
    this._query.push(`${encodeURIComponent(name)}=${encodeURIComponent(value)}`);
    return this;
  }
  /**
   * Quality sets the compression level for the image output
   *
   * ```https://images.site.com/i/account/image?qlt={{value}}```
   * @param value The quality percentage (0-100)
   */
  quality(value) {
    this._query.push(`qlt=${value}`);
    return this;
  }
  /**
   * Sharpen applies an unsharp mask to the image to refine edges or make an image look more crisp.
   *
   * ```https://images.site.com/i/account/image?unsharp={{radius}},{{sigma}},{{amount}},{{threshold}}```
   *
   * @param radius The radius of the Gaussian, in pixels, not counting the center pixel.
   * @param sigma The standard deviation of the Gaussian, in pixels.
   * @param amount The percentage of the difference between the original and the blur image that is added back into the original.
   * @param threshold The threshold, as a fraction of MaxRGB, needed to apply the difference amount.
   */
  sharpen(radius = 0, sigma = 1, amount = 1, threshold = 0.05) {
    this._query.push(`unsharp=${radius},${sigma},${amount},${threshold}`);
    return this;
  }
  /**
   * Width resizes an image to the pixel size provided. If you only provide one axis,
   * the other will be calculated to maintain aspect ratio. Use the scale mode parameter
   * to apply different resize effects like stretch or crop.
   *
   * ```https://images.site.com/i/account/image?w={{value}}```
   * @param value The new width in pixels.
   */
  width(value) {
    this._query.push(`w=${value}`);
    return this;
  }
  /**
   * Height resizes an image to the pixel size provided. If you only provide one axis,
   * the other will be calculated to maintain aspect ratio. Use the scale mode parameter
   * to apply different resize effects like stretch or crop.
   *
   * ```https://images.site.com/i/account/image?h={{value}}```
   * @param value The new height in pixels.
   */
  height(value) {
    this._query.push(`h=${value}`);
    return this;
  }
  /**
   * Returns the fully constructed URL for this image with any transformations.
   */
  build() {
    const isSecure = this._protocol === "//" || this._protocol === "https";
    const isVideo = this.media._meta && this.media._meta.schema === "http://bigcontent.io/cms/schema/v1/core#/definitions/video-link";
    let url = this._protocol === "//" ? "//" : `${this._protocol}://`;
    const host = this._host ? this._host : this.media.getHost(isSecure);
    url += host;
    url += `/${isVideo ? "v" : "i"}/`;
    url += encodeURIComponent(this.media.endpoint);
    url += "/";
    url += encodeURIComponent(this.media.name);
    if (this._seoFileName) {
      url += "/";
      url += encodeURIComponent(this._seoFileName);
    }
    if (this._format) {
      url += `.${this._format}`;
    }
    if (this._query.length > 0) {
      url += "?";
      url += this._query.join("&");
    }
    return url;
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/media/Image.js
var Image = class extends Media {
  /**
   * Creates a new Image instance.
   * @param data JSON data from delivery API
   * @param config Client configuration
   */
  constructor(data, config) {
    super(data, config);
    if (data && data._meta) {
      this._meta = new ImageMeta(data._meta);
    }
  }
  /**
   * Returns a builder which can be used to construct a URL to this image resource.
   * You can apply transformations such as resize and image format using the returned builder.
   *
   * ```typescript
   * image.thumbnail().width(500).build();
   * ```
   */
  url() {
    return new ImageUrlBuilder(this);
  }
  /**
   * Export Image to JSON
   */
  toJSON() {
    const result = super.toJSON();
    if (this._meta) {
      result._meta = this._meta.toJSON();
    }
    return result;
  }
  /**
   * @hidden
   * Returns true if the provided fragment is an image
   * @param fragment
   */
  static isImage(fragment) {
    return FragmentMeta.isFragment(fragment) && fragment._meta.schema === "http://bigcontent.io/cms/schema/v1/core#/definitions/image-link";
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/media/Video.js
var Video = class extends Media {
  /**
   * Creates a new Video instance.
   * @param data JSON data from delivery API
   */
  constructor(data, config) {
    super(data, config);
    if (data && data._meta) {
      this._meta = new VideoMeta(data._meta);
    }
  }
  /**
   * Returns a builder which can be used to construct a video thumbnail URL.
   * You can apply transformations such as resize and image format using the returned builder.
   *
   * ```typescript
   * video.thumbnail().width(500).build();
   * ```
   */
  thumbnail() {
    return new ImageUrlBuilder(this);
  }
  /**
   * Export Video to JSON
   */
  toJSON() {
    const result = super.toJSON();
    if (this._meta) {
      result._meta = this._meta.toJSON();
    }
    return result;
  }
  /**
   * @hidden
   * Returns true if the provided fragment is a video
   * @param fragment
   */
  static isVideo(fragment) {
    return FragmentMeta.isFragment(fragment) && fragment._meta.schema === "http://bigcontent.io/cms/schema/v1/core#/definitions/video-link";
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/content/model/ContentReference.js
var ContentReference = class {
  constructor(data) {
    Object.assign(this, data);
    if (data && data._meta) {
      this._meta = new ContentReferenceMeta(data._meta);
    }
    if (data && data.contentType) {
      this.contentType = data.contentType;
    }
  }
  /**
   * Export ContentReference to JSON
   */
  toJSON() {
    const { id } = this;
    const result = {
      id
    };
    if (this._meta) {
      result._meta = this._meta.toJSON();
    }
    if (this.contentType) {
      result.contentType = this.contentType;
    }
    return result;
  }
  /**
   * @hidden
   * Returns true if the provided fragment is an content reference
   * @param fragment
   */
  static isContentReference(fragment) {
    return FragmentMeta.isFragment(fragment) && fragment._meta.schema === "http://bigcontent.io/cms/schema/v1/core#/definitions/content-reference";
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/content/mapper/ContentMapper.js
var ContentMapper = class {
  constructor(config) {
    this.config = config;
    this.mappers = [];
    this.registerBuiltInMappers();
  }
  /**
   * Registers a custom model / fn to hydrate a specific schema
   * @param schema JSON schema ID or Regex that matches against the JSON schema ID
   * @param fn Model Class or Function that can convert the schema
   */
  addSchema(schema, fn) {
    if (typeof schema === "string") {
      this.addCustomMapper((fragment) => {
        if (fragment._meta.schema === schema) {
          return fn(fragment);
        }
      });
    } else {
      this.addCustomMapper((fragment) => {
        if (schema.test(fragment._meta.schema)) {
          return fn(fragment);
        }
      });
    }
  }
  /**
   * Registers a custom function to hydrate content fragments
   * @param fn Mapper function
   */
  addCustomMapper(fn) {
    this.mappers.push(fn);
  }
  /**
   * Converts the provided content into hydrated model classes
   * @param content Content to convert
   */
  toMappedContent(content) {
    return walkAndReplace(content, {
      afterWalk: (node) => {
        if (FragmentMeta.isFragment(node)) {
          return this.mapFragment(node);
        }
        return node;
      }
    });
  }
  /**
   * Converts a single fragment using the registered mappers
   * @param fragment Fragment to convert
   */
  mapFragment(fragment) {
    for (const mapper of this.mappers) {
      const result = mapper(fragment);
      if (result) {
        return result;
      }
    }
    return fragment;
  }
  /**
   * Registers built in mappers
   */
  registerBuiltInMappers() {
    this.addCustomMapper(this.convertContentReference.bind(this));
    this.addCustomMapper(this.convertContentMeta.bind(this));
    this.addCustomMapper(this.convertImage.bind(this));
    this.addCustomMapper(this.convertVideo.bind(this));
  }
  /**
   * Converts _meta inside Content Items into a ContentMeta instance
   * @param fragment
   */
  convertContentMeta(fragment) {
    if (ContentMeta.isContentBody(fragment)) {
      return {
        ...fragment,
        _meta: new ContentMeta(fragment._meta)
      };
    }
  }
  /**
   * Converts content-link into an Content reference class instance
   * @param fragment
   */
  convertContentReference(fragment) {
    if (ContentReference.isContentReference(fragment)) {
      const result = new ContentReference(fragment);
      return result;
    }
  }
  /**
   * Converts image-link into an Image class instance
   * @param fragment
   */
  convertImage(fragment) {
    if (Image.isImage(fragment)) {
      const result = new Image(fragment, this.config);
      return result;
    }
  }
  /**
   * Converts image-link into an Image class instance
   * @param fragment
   */
  convertVideo(fragment) {
    if (Video.isVideo(fragment)) {
      const result = new Video(fragment, this.config);
      return result;
    }
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/content/coordinators/GetContentItemV2Impl.js
var GetContentItemV2Impl = class {
  constructor(config, contentClient, mapper) {
    this.config = config;
    this.contentClient = contentClient;
    this.mapper = mapper;
  }
  getContentItemByKey(key) {
    return this.getContentItem("key", key);
  }
  async getContentItemById(id) {
    return this.getContentItem("id", id);
  }
  async getContentItem(requestType, value) {
    const args = [
      ["depth", "all"],
      ["format", "inlined"]
    ];
    if (this.config.locale) {
      args.push(["locale", this.config.locale]);
    }
    const url = `content/${requestType}/${value}?${encodeQueryString(args)}`;
    let response;
    try {
      response = await this.contentClient.get(url);
    } catch (err) {
      if (err.response) {
        if (err.response.status === 404) {
          throw new ContentNotFoundError(value);
        } else {
          throw new HttpError2(err.response.status, err.response.data);
        }
      }
      throw err;
    }
    const contentItem = new ContentItem();
    contentItem.body = this.mapper.toMappedContent(response.data.content);
    return contentItem;
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/content/coordinators/GetContentItemsV2Impl.js
function mapToRequests(property, values) {
  if (!Array.isArray(values)) {
    throw new TypeError("Expecting an array");
  }
  return values.map((value) => ({ [property]: String(value) }));
}
var GetContentItemsV2Impl = class {
  constructor(config, contentClient) {
    this.config = config;
    this.contentClient = contentClient;
  }
  async getContentItemsByKey(keys) {
    return this.getContentItems(mapToRequests("key", keys));
  }
  async getContentItemsById(ids) {
    return this.getContentItems(mapToRequests("id", ids));
  }
  async getContentItems(requests, parameters) {
    return this.fetchContentItems({
      parameters,
      requests
    });
  }
  async fetchContentItems({ requests, parameters }) {
    const defaultParameters = {
      depth: "all",
      format: "inlined"
    };
    if (this.config.locale) {
      defaultParameters.locale = this.config.locale;
    }
    const mergedParameters = {
      ...defaultParameters,
      ...parameters || {}
    };
    try {
      const { data } = await this.contentClient.post("content/fetch", {
        parameters: mergedParameters,
        requests
      });
      return data;
    } catch (err) {
      if (err.response) {
        throw new HttpError2(err.response.status, err.response.data);
      }
      throw err;
    }
  }
};

// node_modules/axios-retry/lib/esm/index.js
var import_is_retry_allowed = __toESM(require_is_retry_allowed(), 1);
function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve2(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve2, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty4(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var namespace = "axios-retry";
function isNetworkError(error) {
  return !error.response && Boolean(error.code) && // Prevents retrying cancelled requests
  error.code !== "ECONNABORTED" && // Prevents retrying timed out requests
  (0, import_is_retry_allowed.default)(error);
}
var SAFE_HTTP_METHODS = ["get", "head", "options"];
var IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(["put", "delete"]);
function isRetryableError(error) {
  return error.code !== "ECONNABORTED" && (!error.response || error.response.status >= 500 && error.response.status <= 599);
}
function isSafeRequestError(error) {
  if (!error.config) {
    return false;
  }
  return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;
}
function isIdempotentRequestError(error) {
  if (!error.config) {
    return false;
  }
  return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;
}
function isNetworkOrIdempotentRequestError(error) {
  return isNetworkError(error) || isIdempotentRequestError(error);
}
function noDelay() {
  return 0;
}
function exponentialDelay() {
  var retryNumber = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  var delay3 = Math.pow(2, retryNumber) * 100;
  var randomSum = delay3 * 0.2 * Math.random();
  return delay3 + randomSum;
}
function getCurrentState(config) {
  var currentState = config[namespace] || {};
  currentState.retryCount = currentState.retryCount || 0;
  config[namespace] = currentState;
  return currentState;
}
function getRequestOptions(config, defaultOptions) {
  return _objectSpread(_objectSpread({}, defaultOptions), config[namespace]);
}
function fixConfig(axios2, config) {
  if (axios2.defaults.agent === config.agent) {
    delete config.agent;
  }
  if (axios2.defaults.httpAgent === config.httpAgent) {
    delete config.httpAgent;
  }
  if (axios2.defaults.httpsAgent === config.httpsAgent) {
    delete config.httpsAgent;
  }
}
function shouldRetry(_x, _x2, _x3, _x4) {
  return _shouldRetry.apply(this, arguments);
}
function _shouldRetry() {
  _shouldRetry = _asyncToGenerator(function* (retries, retryCondition, currentState, error) {
    var shouldRetryOrPromise = currentState.retryCount < retries && retryCondition(error);
    if (typeof shouldRetryOrPromise === "object") {
      try {
        var shouldRetryPromiseResult = yield shouldRetryOrPromise;
        return shouldRetryPromiseResult !== false;
      } catch (_err) {
        return false;
      }
    }
    return shouldRetryOrPromise;
  });
  return _shouldRetry.apply(this, arguments);
}
function axiosRetry(axios2, defaultOptions) {
  axios2.interceptors.request.use((config) => {
    var currentState = getCurrentState(config);
    currentState.lastRequestTime = Date.now();
    return config;
  });
  axios2.interceptors.response.use(null, /* @__PURE__ */ function() {
    var _ref = _asyncToGenerator(function* (error) {
      var {
        config
      } = error;
      if (!config) {
        return Promise.reject(error);
      }
      var {
        retries = 3,
        retryCondition = isNetworkOrIdempotentRequestError,
        retryDelay = noDelay,
        shouldResetTimeout = false,
        onRetry = () => {
        }
      } = getRequestOptions(config, defaultOptions);
      var currentState = getCurrentState(config);
      if (yield shouldRetry(retries, retryCondition, currentState, error)) {
        currentState.retryCount += 1;
        var delay3 = retryDelay(currentState.retryCount, error);
        fixConfig(axios2, config);
        if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {
          var lastRequestDuration = Date.now() - currentState.lastRequestTime;
          var timeout = config.timeout - lastRequestDuration - delay3;
          if (timeout <= 0) {
            return Promise.reject(error);
          }
          config.timeout = timeout;
        }
        config.transformRequest = [(data) => data];
        onRetry(currentState.retryCount, error, config);
        return new Promise((resolve2) => setTimeout(() => resolve2(axios2(config)), delay3));
      }
      return Promise.reject(error);
    });
    return function(_x5) {
      return _ref.apply(this, arguments);
    };
  }());
}
axiosRetry.isNetworkError = isNetworkError;
axiosRetry.isSafeRequestError = isSafeRequestError;
axiosRetry.isIdempotentRequestError = isIdempotentRequestError;
axiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;
axiosRetry.exponentialDelay = exponentialDelay;
axiosRetry.isRetryableError = isRetryableError;

// node_modules/dc-delivery-sdk-js/build/module/lib/client/createBaseContentClient.js
var import_axios = __toESM(require_axios6());
function createBaseContentClient(config, defaultHost) {
  const client = import_axios.default.create({
    adapter: config.adaptor,
    timeout: config.timeout || 0
  });
  if (config.stagingEnvironment) {
    client.defaults.baseURL = `https://${config.stagingEnvironment}`;
  } else {
    client.defaults.baseURL = config.baseUrl || defaultHost;
  }
  return client;
}

// node_modules/dc-delivery-sdk-js/build/module/lib/client/createContentClientV2Fresh.js
var isThrottled = (error) => {
  var _a4;
  return ((_a4 = error == null ? void 0 : error.response) == null ? void 0 : _a4.status) === 429;
};
var DEFAULT_RETRY_CONFIG = {
  retries: 3,
  retryDelay: axiosRetry.exponentialDelay,
  retryCondition: isThrottled
};
function getRetryConfig(retryConfig) {
  var _a4, _b, _c;
  return {
    retries: (_a4 = retryConfig == null ? void 0 : retryConfig.retries) != null ? _a4 : DEFAULT_RETRY_CONFIG.retries,
    retryDelay: (_b = retryConfig == null ? void 0 : retryConfig.retryDelay) != null ? _b : DEFAULT_RETRY_CONFIG.retryDelay,
    retryCondition: (_c = retryConfig == null ? void 0 : retryConfig.retryCondition) != null ? _c : DEFAULT_RETRY_CONFIG.retryCondition
  };
}
function createContentClientV2Fresh(config, defaultHost) {
  const client = createBaseContentClient(config, defaultHost);
  client.defaults.headers.common["X-API-Key"] = config.apiKey;
  axiosRetry(client, getRetryConfig(config.retryConfig));
  return client;
}

// node_modules/dc-delivery-sdk-js/build/module/lib/client/createContentClient.js
function createContentClient(config) {
  if (isContentClientConfigV2Fresh(config)) {
    return createContentClientV2Fresh(config, `https://${config.hubName}.fresh.content.amplience.net`);
  }
  if (isContentClientConfigV2(config)) {
    return createBaseContentClient(config, `https://${config.hubName}.cdn.content.amplience.net`);
  }
  return createBaseContentClient(config, "https://cdn.c1.amplience.net");
}

// node_modules/dc-delivery-sdk-js/build/module/lib/content/model/NotSupportedError.js
var NotSupportedError = class extends Error {
  constructor(property, method) {
    super(`Not supported. You need to define "${property}" configuration property to use ${method}()`);
    this.property = property;
    this.method = method;
    this.name = "NOT_SUPPORTED";
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
var NotSupportedV1Error = class extends NotSupportedError {
  constructor(method) {
    super("account", method);
    this.method = method;
    this.name = "NOT_SUPPORTED_V1";
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
var NotSupportedV2Error = class extends NotSupportedError {
  constructor(method) {
    super("hubName", method);
    this.method = method;
    this.name = "NOT_SUPPORTED_V2";
    Object.setPrototypeOf(this, new.target.prototype);
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/ContentClient.js
var ContentClient = class {
  /**
   * Creates a Delivery API Client instance. You must provide a configuration object with the required details for the particular service you wish to fetch content from.
   * @param config Client configuration options
   */
  constructor(config) {
    this.config = config;
    if (!config) {
      throw new TypeError('Parameter "config" is required');
    }
    if (!config.account && !config.hubName) {
      throw new TypeError('Parameter "config" must contain a valid "account" name or "hubName" property');
    }
    if (config.stagingEnvironment && config.stagingEnvironment.indexOf("://") !== -1) {
      throw new TypeError('Parameter "stagingEnvironment" should be a hostname not a URL');
    }
    this.contentMapper = this.createContentMapper(config);
    this.contentClient = createContentClient(config);
  }
  /**
   * @deprecated use getContentItemById
   */
  getContentItem(contentItemId) {
    return this.getContentItemById(contentItemId);
  }
  /**
   * This function will load a Content Item or Slot by id and return a Promise of the result.
   * If the content is not found the promise will reject with an error.
   * If the content is found the promise will resolve with a parsed version of the content with all dependencies.
   *
   * The content body will match the format defined by your content type, however keep in mind that if you have evolved your content type some published content may still be in the older format.
   *
   * Some pre-processing is applied to the content body to make it easier to work with:
   *
   * * Linked content items are joined together into the root content item to create a single JSON document.
   * * Media references (images and videos) are replaced with wrapper objects [[Image]] and [[Video]] which provide helper functions.
   * * Content created using V1 of the CMS will be upgraded to the V2 format.
   *
   * You can convert the content back to plain JSON by calling the toJSON() function on the returned ContentItem.
   * @typeparam T The type of content returned. This is optional and by default the content returned is assumed to be any.
   * @param id Unique id of the Content Item or Slot to load
   */
  getContentItemById(id) {
    if (isContentClientConfigV2(this.config)) {
      return new GetContentItemV2Impl(this.config, this.contentClient, this.contentMapper).getContentItemById(id);
    }
    return new GetContentItemV1Impl(this.config, this.contentClient, this.contentMapper).getContentItemById(id);
  }
  /**
   * This function will load a Content Item or Slot by key and return a Promise of the result.
   * If the content is not found the promise will reject with an error.
   * If the content is found the promise will resolve with a parsed version of the content with all dependencies.
   *
   * A delivery key can be a simple string or a path such as "home-page/feature-banner". This makes it simpler to write your integration code and allows users more control over where items of content are delivered. You can add a delivery key to a slot in the Dynamic Content app or to a content item or slot using the Dynamic Content Management API.
   * Note that a delivery key may not start or end with "/" and must be between 1 and 150 characters. Delivery keys can contain the following alphanumeric characters: a to z, A to Z and 0 to 9. You can also include "-" and "_" and "/" as long as it is not included at the start or end of the key.
   *
   * The content body will match the format defined by your content type.
   *
   * Some pre-processing is applied to the content body to make it easier to work with:
   *
   * * Linked content items are joined together into the root content item to create a single JSON document.
   * * Media references (images and videos) are replaced with wrapper objects [[Image]] and [[Video]] which provide helper functions.
   * * Content created using V1 of the CMS will be upgraded to the V2 format.
   *
   * You can convert the content back to plain JSON by calling the toJSON() function on the returned ContentItem.
   * @typeparam T The type of content returned. This is optional and by default the content returned is assumed to be any.
   * @param id Unique id of the Content Item or Slot to load
   */
  getContentItemByKey(key) {
    if (!isContentClientConfigV2(this.config)) {
      throw new NotSupportedV2Error("getContentItemByKey");
    }
    return new GetContentItemV2Impl(this.config, this.contentClient, this.contentMapper).getContentItemByKey(key);
  }
  /**
   * This function will help construct requests for filtering Content Items or Slots
   *
   * @param filterBy - API options for `/content/filter` endpoint [docs](https://amplience.com/docs/development/contentdelivery/filterandsort.html)
   * @returns
   */
  filterContentItems(filterBy) {
    if (!isContentClientConfigV2(this.config)) {
      throw new NotSupportedV2Error("filterContentItems");
    }
    return new FilterByImpl(this.config, this.contentClient).fetch(filterBy);
  }
  /**
   *  This function will help construct requests for filtering Content Items or Slots
   *
   * @param path - json path to property you wish to filter by e.g `/_meta/schema`
   * @param value - value you want to return matches for
   *
   * @returns `FilterBy<Body>`
   */
  filterBy(path, value) {
    if (!isContentClientConfigV2(this.config)) {
      throw new NotSupportedV2Error("filterBy");
    }
    return new FilterBy(this.config, this.contentClient).filterBy(path, value);
  }
  /**
   *
   *  This function will help construct requests for filtering Content Items or Slots
   *
   *  equivalent to:
   *
   * ```ts
   *  client.filterBy('/_meta/schema', contentTypeUri)
   * ```
   *
   * @param contentTypeUri - Content Type Uri you want to filter
   *
   * @returns `FilterBy<Body>`
   */
  filterByContentType(contentTypeUri) {
    if (!isContentClientConfigV2(this.config)) {
      throw new NotSupportedV2Error("filterByContentType");
    }
    return new FilterBy(this.config, this.contentClient).filterByContentType(contentTypeUri);
  }
  /**
   *  This function will help construct requests for filtering Content Items or Slots
   *
   * equivalent to:
   *
   * ```ts
   *  client.filterBy('/_meta/hierarchy/parentId', id)
   * ```
   *
   * @param id - ID of a Hierarchy Content Item
   *
   * @returns `FilterBy<Body>`
   */
  filterByParentId(id) {
    if (!isContentClientConfigV2(this.config)) {
      throw new NotSupportedV2Error("filterByParentId");
    }
    return new FilterBy(this.config, this.contentClient).filterByParentId(id);
  }
  /**
   * This function will help construct requests for fetching multiple Content Items or Slots by delivery ID
   * and is equivalent to:
   *
   * ```ts
   *  client.fetchContentItems({
   *    parameters: {
   *      depth: 'all',
   *      format: 'inlined'
   *    },
   *    requests: [
   *      { id: '6cd4de36-591b-4ca2-874b-1dec7b681d7e' },
   *      { id: 'c6d9e038-591b-4ca2-874b-da354f5d6e61' },
   *    ],
   *  });
   * ```
   *
   * @param keys An array of Delivery keys of the content you wish to fetch
   * @typeparam Body The type of content returned. This is optional and by default the content returned is assumed to be any.
   * @returns `Promise<FetchResponse<Body>>`
   */
  getContentItemsById(ids) {
    if (!isContentClientConfigV2(this.config)) {
      throw new NotSupportedV2Error("getContentItemsById");
    }
    return new GetContentItemsV2Impl(this.config, this.contentClient).getContentItemsById(ids);
  }
  /**
   * This function will help construct requests for fetching multiple Content Items or Slots by delivery key
   * and is equivalent to:
   *
   * ```ts
   *  client.fetchContentItems({
   *    parameters: {
   *      depth: 'all',
   *      format: 'inlined'
   *    },
   *    requests: [
   *      { key: 'blog/article-1' },
   *      { key: 'blog/article-2' },
   *    ],
   *  });
   * ```
   *
   * @param keys An array of delivery IDs of the content you wish to fetch
   * @typeparam Body The type of content returned. This is optional and by default the content returned is assumed to be any.
   * @returns `Promise<FetchResponse<Body>>`
   */
  getContentItemsByKey(keys) {
    if (!isContentClientConfigV2(this.config)) {
      throw new NotSupportedV2Error("getContentItemsByKey");
    }
    return new GetContentItemsV2Impl(this.config, this.contentClient).getContentItemsByKey(keys);
  }
  /**
   * This function will help construct requests for fetching multiple Content Items or Slots by delivery key and/or id
   * and is equivalent to:
   *
   * ```ts
   *  client.fetchContentItems({
   *    parameters: {
   *      depth: 'all',
   *      format: 'inlined'
   *    },
   *    requests: [
   *      { id: '6cd4de36-591b-4ca2-874b-1dec7b681d7e' },
   *      { key: 'blog/article-1' },
   *    ],
   *  });
   * ```
   *
   * @param requests An array of delivery IDs of the content you wish to fetch
   * @param parameters Optional override of default parameters
   * @typeparam Body The type of content returned. This is optional and by default the content returned is assumed to be any.
   * @returns `Promise<FetchResponse<Body>>`
   */
  getContentItems(requests, parameters) {
    if (!isContentClientConfigV2(this.config)) {
      throw new NotSupportedV2Error("getContentItems");
    }
    return new GetContentItemsV2Impl(this.config, this.contentClient).getContentItems(requests, parameters);
  }
  /**
   * This function will help construct requests for fetching multiple Content Items or Slots by delivery key or ID. Wraps [`/content/fetch`](https://amplience.com/docs/api/dynamic-content/delivery/content-delivery-2/index.html#operation/multiGetContent) endpoint.
   * [Additional documentation](https://amplience.com/docs/development/contentdelivery/readme.html#multipleitems)
   *
   * @param body The request body. Can include per item parameters as well as global parameters
   * @typeparam Body The type of content returned. This is optional and by default the content returned is assumed to be any.
   * @returns `Promise<FetchResponse<Body>>`
   */
  fetchContentItems(body) {
    if (!isContentClientConfigV2(this.config)) {
      throw new NotSupportedV2Error("fetchContentItems");
    }
    return new GetContentItemsV2Impl(this.config, this.contentClient).fetchContentItems(body);
  }
  /**
   * Converts a Content Item or Slot into a custom format (e.g. HTML / XML) by applying a template server side.
   * @param contentItemId Unique id of the Content Item or Slot to convert using the rendering service
   * @param templateName Name of the template to render the content item or slot with. The template must be setup in your account
   * @param customParameters Custom parameters which will be sent to the rendering API and made avaliable to your template
   */
  renderContentItem(contentItemId, templateName, customParameters) {
    if (!isContentClientConfigV1(this.config)) {
      throw new NotSupportedV1Error("renderContentItem");
    }
    return new RenderContentItem(this.config, this.contentClient).renderContentItem(contentItemId, templateName, customParameters);
  }
  /**
   * Creates a parser which converts content JSON into classes and objects used by the SDK
   * @param config
   * @hidden
   */
  createContentMapper(config) {
    return new ContentMapper(config);
  }
};

// node_modules/dc-delivery-sdk-js/build/module/lib/staging-environment/StagingEnvironmentFactory.js
var import_axios2 = __toESM(require_axios6());

// node_modules/dc-delivery-sdk-js/build/module/lib/media/model/ImageFormat.js
var ImageFormat;
(function(ImageFormat2) {
  ImageFormat2["JPEG"] = "jpg";
  ImageFormat2["PNG"] = "png";
  ImageFormat2["GIF"] = "gif";
  ImageFormat2["WEBP"] = "webp";
  ImageFormat2["BITMAP"] = "bmp";
})(ImageFormat || (ImageFormat = {}));

// content-amplience/mappers/ContentMapper.ts
var ContentMapper2 = class {
  static buildUrl(mediaObj, suffix) {
    var _a4;
    return `https://${(_a4 = mediaObj.host) != null ? _a4 : mediaObj.defaultHost}/${suffix}/${mediaObj.endpoint}/${mediaObj.name}`;
  }
  static amplienceContentToContent({ _meta, ...attrs }) {
    const content = { _meta };
    for (const attr in attrs) {
      if (!attrs[attr]._meta) {
        content[attr] = attrs[attr];
        continue;
      }
      switch (attrs[attr]._meta.schema) {
        case "http://bigcontent.io/cms/schema/v1/core#/definitions/image-link":
          content[attr] = this.buildUrl(attrs[attr], "i");
          break;
        case "http://bigcontent.io/cms/schema/v1/core#/definitions/video-link":
          content[attr] = this.buildUrl(attrs[attr], "v");
          break;
        default:
          content[attr] = attrs[attr];
      }
    }
    return content;
  }
};

// content-amplience/utils/Context.ts
var projectConfigurationOverrides5 = {};
var isDevEnv5 = (context) => {
  return context.environment === "development" || context.environment === "dev";
};
var getFromProjectConfig5 = (key, context) => {
  if (isDevEnv5(context) && projectConfigurationOverrides5[key]) {
    return projectConfigurationOverrides5[key];
  }
  return context.projectConfiguration[key];
};

// content-amplience/apis/ContentApi.ts
var ContentApi2 = class {
  constructor(commercetoolsFrontendContext, locale) {
    var _a4, _b;
    this.locale = (locale != null ? locale : commercetoolsFrontendContext.project.defaultLocale).replace("_", "-");
    let hubName = getFromProjectConfig5("EXTENSION_AMPLIENCE_HUB_NAME", commercetoolsFrontendContext);
    if (!hubName) {
      hubName = (_b = (_a4 = commercetoolsFrontendContext.project.configuration) == null ? void 0 : _a4.amplience) == null ? void 0 : _b.hubName;
    }
    this.client = new ContentClient({
      hubName,
      locale: this.locale
    });
  }
  async getContentById(contentId) {
    const response = await this.client.getContentItemById(contentId);
    return ContentMapper2.amplienceContentToContent(response.body);
  }
  async getContentList({
    contentType,
    filters,
    sorting,
    limit = 12,
    resolveHierarchyTree = false
  }) {
    let query2 = this.client.filterByContentType(contentType);
    if (filters)
      filters.forEach(([key, val]) => query2 = query2.filterBy(`/${key}`, val));
    if (sorting)
      sorting.forEach(([key, val]) => query2 = query2.filterBy(key, val.toUpperCase()));
    query2 = query2.page(limit);
    const response = await query2.request({
      depth: resolveHierarchyTree ? "all" : "root",
      format: "inlined",
      locale: this.locale
    });
    return response.responses.map(({ content }) => ContentMapper2.amplienceContentToContent(content));
  }
};

// content-amplience/utils/Request.ts
var getLocale3 = (request) => {
  var _a4;
  const locale = (_a4 = getHeader4(request, ["commercetools-frontend-locale" /* commercetoolsFrontendLocale */, "frontastic-locale" /* frontasticLocale */])) != null ? _a4 : request.query.locale;
  if (locale !== void 0) {
    return locale;
  }
  throw new ValidationError({ message: `Locale is missing from request ${request}` });
};
var getHeader4 = (request, headers) => {
  for (const header of headers) {
    const foundHeader = request.headers[header.toLowerCase()];
    if (foundHeader !== void 0) {
      if (Array.isArray(foundHeader)) {
        return foundHeader[0];
      }
      return foundHeader;
    }
  }
  return null;
};

// content-amplience/index.ts
var content_amplience_default = {
  "data-sources": {
    "amplience/content": async (config, context) => {
      const contentApi = new ContentApi2(context.frontasticContext, getLocale3(context.request));
      const { contentId } = config.configuration;
      const payload = await contentApi.getContentById(contentId);
      return {
        dataSourcePayload: payload
      };
    },
    "amplience/content-list": async (config, context) => {
      const contentApi = new ContentApi2(context.frontasticContext, getLocale3(context.request));
      const { contentType, filters, sorting, limit, resolveHierarchyTree } = config.configuration;
      const payload = await contentApi.getContentList({
        contentType,
        filters: filters ? filters.split(" ").map((token) => token.split("=")) : null,
        sorting: sorting ? sorting.split(" ").map((token) => token.split("=")) : null,
        limit,
        resolveHierarchyTree
      });
      return {
        dataSourcePayload: payload
      };
    }
  }
};

// content-contentstack/apis/ContentApi.ts
var Contentstack = __toESM(require_contentstack());

// content-contentstack/mappers/ContentMapper.ts
var ContentMapper3 = class {
  static contentstackEntryToContent(response) {
    var _a4;
    response = JSON.parse(JSON.stringify(response));
    delete response._version;
    delete response.created_at;
    delete response.created_by;
    delete response.updated_at;
    delete response.updated_by;
    delete response.publish_details;
    return {
      title: response.title,
      contentId: response.uid,
      contentTypeId: response.contentTypeUid,
      banner: (_a4 = response.featured_image) == null ? void 0 : _a4.url,
      summary: response.multi_line
    };
  }
};

// content-contentstack/apis/ContentApi.ts
var ContentApi3 = class {
  constructor(frontasticContext, locale) {
    var _a4, _b, _c, _d, _e, _f, _g, _h;
    this.locale = (locale != null ? locale : frontasticContext.project.defaultLocale).replace("_", "-");
    let apiKey = getFromProjectConfig4("EXTENSION_CONTENTSTACK_API_KEY", frontasticContext);
    let deliveryToken = getFromProjectConfig4("EXTENSION_CONTENTSTACK_DELIVERY_TOKEN", frontasticContext);
    let environment = getFromProjectConfig4("EXTENSION_CONTENTSTACK_ENVIRONMENT", frontasticContext);
    let region = getFromProjectConfig4("EXTENSION_CONTENTSTACK_REGION", frontasticContext);
    if (!apiKey) {
      apiKey = (_b = (_a4 = frontasticContext.project.configuration) == null ? void 0 : _a4.contentstack) == null ? void 0 : _b.apiKey;
    }
    if (!deliveryToken) {
      deliveryToken = (_d = (_c = frontasticContext.project.configuration) == null ? void 0 : _c.contentstack) == null ? void 0 : _d.deliveryToken;
    }
    if (!environment) {
      environment = (_f = (_e = frontasticContext.project.configuration) == null ? void 0 : _e.contentstack) == null ? void 0 : _f.environment;
    }
    if (!region) {
      region = (_h = (_g = frontasticContext.project.configuration) == null ? void 0 : _g.contentstack) == null ? void 0 : _h.region;
    }
    this.stack = Contentstack.Stack(apiKey, deliveryToken, environment, region);
  }
  async getContent({ contentTypeUid, entryUid }) {
    const Query = this.stack.ContentType(contentTypeUid).Entry(entryUid);
    return await Query.fetch().then(
      function success(entry) {
        return ContentMapper3.contentstackEntryToContent(entry);
      },
      function error(err) {
        console.log("Failed to fetch ContentStack entry, Error log: " + err);
        return { err };
      }
    );
  }
  async getContentList({ contentTypeUid, limit }) {
    const dataQuery = this.stack.ContentType(contentTypeUid).Query();
    const Query = dataQuery.limit(parseInt(limit)).find();
    return await Query.then(
      function success(entries) {
        return entries[0].map((entry) => ContentMapper3.contentstackEntryToContent(entry));
      },
      function error(err) {
        console.log("Failed to fetch ContentStack entries, Error log: " + err);
        return { err };
      }
    );
  }
};

// content-contentstack/utils/Request.ts
var getLocale4 = (request) => {
  var _a4;
  const locale = (_a4 = getHeader5(request, ["commercetools-frontend-locale" /* commercetoolsFrontendLocale */, "frontastic-locale" /* frontasticLocale */])) != null ? _a4 : request.query.locale;
  if (locale !== void 0) {
    return locale;
  }
  throw new ValidationError({ message: `Locale is missing from request ${request}` });
};
var getHeader5 = (request, headers) => {
  for (const header of headers) {
    const foundHeader = request.headers[header.toLowerCase()];
    if (foundHeader !== void 0) {
      if (Array.isArray(foundHeader)) {
        return foundHeader[0];
      }
      return foundHeader;
    }
  }
  return null;
};

// content-contentstack/actionControllers/ContentstackController.ts
var ContentstackController_exports = {};
__export(ContentstackController_exports, {
  getContent: () => getContent2,
  getContentList: () => getContentList
});
var getContent2 = async (request, actionContext) => {
  const { entryUid, contentTypeUid } = request.query;
  if (!contentTypeUid) {
    return {
      body: "Missing contentTypeUid",
      statusCode: 400
    };
  }
  if (!entryUid) {
    return {
      body: "Missing entryUid",
      statusCode: 400
    };
  }
  const contentApi = new ContentApi3(actionContext.frontasticContext, getLocale4(request));
  const data = await contentApi.getContent({ contentTypeUid, entryUid });
  const response = {
    statusCode: 200,
    body: JSON.stringify(data),
    sessionData: request.sessionData
  };
  return response;
};
var getContentList = async (request, actionContext) => {
  const { limit, contentTypeUid } = request.query;
  if (!contentTypeUid) {
    return {
      body: "Missing contentTypeUid",
      statusCode: 400
    };
  }
  const contentApi = new ContentApi3(actionContext.frontasticContext, getLocale4(request));
  const data = await contentApi.getContentList({ contentTypeUid, limit });
  const response = {
    statusCode: 200,
    body: JSON.stringify(data),
    sessionData: request.sessionData
  };
  return response;
};

// content-contentstack/index.ts
var content_contentstack_default = {
  "data-sources": {
    "contentstack/content": async (config, context) => {
      const contentApi = new ContentApi3(context.frontasticContext, getLocale4(context.request));
      const { contentTypeUid, entryUid } = config.configuration;
      return {
        dataSourcePayload: await contentApi.getContent({ contentTypeUid, entryUid })
      };
    },
    "contentstack/content-list": async (config, context) => {
      const contentApi = new ContentApi3(context.frontasticContext, getLocale4(context.request));
      const { contentTypeUid, limit } = config.configuration;
      const payload = await contentApi.getContentList({
        contentTypeUid,
        limit
      });
      return {
        dataSourcePayload: payload
      };
    }
  },
  actions: {
    contentstack: ContentstackController_exports
  }
};

// content-bloomreach/apis/ContentApi.ts
var import_axios3 = __toESM(require_axios2());

// node_modules/@bloomreach/spa-sdk/dist/index.js
var import_inversify = __toESM(require_inversify());

// node_modules/reflect-metadata/Reflect.js
var Reflect2;
(function(Reflect3) {
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
    var exporter = makeExporter(Reflect3);
    if (typeof root.Reflect === "undefined") {
      root.Reflect = Reflect3;
    } else {
      exporter = makeExporter(root.Reflect, exporter);
    }
    factory(exporter);
    function makeExporter(target, previous) {
      return function(key, value) {
        if (typeof target[key] !== "function") {
          Object.defineProperty(target, key, { configurable: true, writable: true, value });
        }
        if (previous)
          previous(key, value);
      };
    }
  })(function(exporter) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var supportsCreate = typeof Object.create === "function";
    var supportsProto = { __proto__: [] } instanceof Array;
    var downLevel = !supportsCreate && !supportsProto;
    var HashMap = {
      // create an object in dictionary mode (a.k.a. "slow" mode in v8)
      create: supportsCreate ? function() {
        return MakeDictionary(/* @__PURE__ */ Object.create(null));
      } : supportsProto ? function() {
        return MakeDictionary({ __proto__: null });
      } : function() {
        return MakeDictionary({});
      },
      has: downLevel ? function(map, key) {
        return hasOwn.call(map, key);
      } : function(map, key) {
        return key in map;
      },
      get: downLevel ? function(map, key) {
        return hasOwn.call(map, key) ? map[key] : void 0;
      } : function(map, key) {
        return map[key];
      }
    };
    var functionPrototype = Object.getPrototypeOf(Function);
    var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
    var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    var Metadata = new _WeakMap();
    function decorate(decorators, target, propertyKey, attributes) {
      if (!IsUndefined(propertyKey)) {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsObject(target))
          throw new TypeError();
        if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
          throw new TypeError();
        if (IsNull(attributes))
          attributes = void 0;
        propertyKey = ToPropertyKey(propertyKey);
        return DecorateProperty(decorators, target, propertyKey, attributes);
      } else {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsConstructor(target))
          throw new TypeError();
        return DecorateConstructor(decorators, target);
      }
    }
    exporter("decorate", decorate);
    function metadata(metadataKey, metadataValue) {
      function decorator(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
          throw new TypeError();
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      return decorator;
    }
    exporter("metadata", metadata);
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    exporter("defineMetadata", defineMetadata);
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasMetadata", hasMetadata);
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasOwnMetadata", hasOwnMetadata);
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    exporter("getMetadata", getMetadata);
    function getOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("getOwnMetadata", getOwnMetadata);
    function getMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryMetadataKeys(target, propertyKey);
    }
    exporter("getMetadataKeys", getMetadataKeys);
    function getOwnMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    exporter("getOwnMetadataKeys", getOwnMetadataKeys);
    function deleteMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      var metadataMap = GetOrCreateMetadataMap(
        target,
        propertyKey,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return false;
      if (!metadataMap.delete(metadataKey))
        return false;
      if (metadataMap.size > 0)
        return true;
      var targetMetadata = Metadata.get(target);
      targetMetadata.delete(propertyKey);
      if (targetMetadata.size > 0)
        return true;
      Metadata.delete(target);
      return true;
    }
    exporter("deleteMetadata", deleteMetadata);
    function DecorateConstructor(decorators, target) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsConstructor(decorated))
            throw new TypeError();
          target = decorated;
        }
      }
      return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsObject(decorated))
            throw new TypeError();
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    function GetOrCreateMetadataMap(O, P, Create) {
      var targetMetadata = Metadata.get(O);
      if (IsUndefined(targetMetadata)) {
        if (!Create)
          return void 0;
        targetMetadata = new _Map();
        Metadata.set(O, targetMetadata);
      }
      var metadataMap = targetMetadata.get(P);
      if (IsUndefined(metadataMap)) {
        if (!Create)
          return void 0;
        metadataMap = new _Map();
        targetMetadata.set(P, metadataMap);
      }
      return metadataMap;
    }
    function OrdinaryHasMetadata(MetadataKey, O, P) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn2)
        return true;
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryHasMetadata(MetadataKey, parent, P);
      return false;
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return false;
      return ToBoolean(metadataMap.has(MetadataKey));
    }
    function OrdinaryGetMetadata(MetadataKey, O, P) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn2)
        return OrdinaryGetOwnMetadata(MetadataKey, O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryGetMetadata(MetadataKey, parent, P);
      return void 0;
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return void 0;
      return metadataMap.get(MetadataKey);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P,
        /*Create*/
        true
      );
      metadataMap.set(MetadataKey, MetadataValue);
    }
    function OrdinaryMetadataKeys(O, P) {
      var ownKeys3 = OrdinaryOwnMetadataKeys(O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (parent === null)
        return ownKeys3;
      var parentKeys = OrdinaryMetadataKeys(parent, P);
      if (parentKeys.length <= 0)
        return ownKeys3;
      if (ownKeys3.length <= 0)
        return parentKeys;
      var set = new _Set();
      var keys = [];
      for (var _i = 0, ownKeys_1 = ownKeys3; _i < ownKeys_1.length; _i++) {
        var key = ownKeys_1[_i];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      for (var _a4 = 0, parentKeys_1 = parentKeys; _a4 < parentKeys_1.length; _a4++) {
        var key = parentKeys_1[_a4];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      return keys;
    }
    function OrdinaryOwnMetadataKeys(O, P) {
      var keys = [];
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return keys;
      var keysObj = metadataMap.keys();
      var iterator = GetIterator(keysObj);
      var k = 0;
      while (true) {
        var next = IteratorStep(iterator);
        if (!next) {
          keys.length = k;
          return keys;
        }
        var nextValue = IteratorValue(next);
        try {
          keys[k] = nextValue;
        } catch (e) {
          try {
            IteratorClose(iterator);
          } finally {
            throw e;
          }
        }
        k++;
      }
    }
    function Type(x) {
      if (x === null)
        return 1;
      switch (typeof x) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return x === null ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x) {
      return x === void 0;
    }
    function IsNull(x) {
      return x === null;
    }
    function IsSymbol(x) {
      return typeof x === "symbol";
    }
    function IsObject(x) {
      return typeof x === "object" ? x !== null : typeof x === "function";
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
          return input;
        case 1:
          return input;
        case 2:
          return input;
        case 3:
          return input;
        case 4:
          return input;
        case 5:
          return input;
      }
      var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
      var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (exoticToPrim !== void 0) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result))
          throw new TypeError();
        return result;
      }
      return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    function OrdinaryToPrimitive(O, hint) {
      if (hint === "string") {
        var toString_1 = O.toString;
        if (IsCallable(toString_1)) {
          var result = toString_1.call(O);
          if (!IsObject(result))
            return result;
        }
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
      } else {
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
        var toString_2 = O.toString;
        if (IsCallable(toString_2)) {
          var result = toString_2.call(O);
          if (!IsObject(result))
            return result;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      var key = ToPrimitive(
        argument,
        3
        /* String */
      );
      if (IsSymbol(key))
        return key;
      return ToString(key);
    }
    function IsArray(argument) {
      return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
    }
    function IsCallable(argument) {
      return typeof argument === "function";
    }
    function IsConstructor(argument) {
      return typeof argument === "function";
    }
    function IsPropertyKey(argument) {
      switch (Type(argument)) {
        case 3:
          return true;
        case 4:
          return true;
        default:
          return false;
      }
    }
    function GetMethod(V, P) {
      var func = V[P];
      if (func === void 0 || func === null)
        return void 0;
      if (!IsCallable(func))
        throw new TypeError();
      return func;
    }
    function GetIterator(obj) {
      var method = GetMethod(obj, iteratorSymbol);
      if (!IsCallable(method))
        throw new TypeError();
      var iterator = method.call(obj);
      if (!IsObject(iterator))
        throw new TypeError();
      return iterator;
    }
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    function IteratorStep(iterator) {
      var result = iterator.next();
      return result.done ? false : result;
    }
    function IteratorClose(iterator) {
      var f = iterator["return"];
      if (f)
        f.call(iterator);
    }
    function OrdinaryGetPrototypeOf(O) {
      var proto = Object.getPrototypeOf(O);
      if (typeof O !== "function" || O === functionPrototype)
        return proto;
      if (proto !== functionPrototype)
        return proto;
      var prototype = O.prototype;
      var prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (prototypeProto == null || prototypeProto === Object.prototype)
        return proto;
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function")
        return proto;
      if (constructor === O)
        return proto;
      return constructor;
    }
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      var arraySentinel = [];
      var MapIterator = (
        /** @class */
        function() {
          function MapIterator2(keys, values, selector) {
            this._index = 0;
            this._keys = keys;
            this._values = values;
            this._selector = selector;
          }
          MapIterator2.prototype["@@iterator"] = function() {
            return this;
          };
          MapIterator2.prototype[iteratorSymbol] = function() {
            return this;
          };
          MapIterator2.prototype.next = function() {
            var index2 = this._index;
            if (index2 >= 0 && index2 < this._keys.length) {
              var result = this._selector(this._keys[index2], this._values[index2]);
              if (index2 + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return { value: result, done: false };
            }
            return { value: void 0, done: true };
          };
          MapIterator2.prototype.throw = function(error) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error;
          };
          MapIterator2.prototype.return = function(value) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return { value, done: true };
          };
          return MapIterator2;
        }()
      );
      return (
        /** @class */
        function() {
          function Map2() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }
          Object.defineProperty(Map2.prototype, "size", {
            get: function() {
              return this._keys.length;
            },
            enumerable: true,
            configurable: true
          });
          Map2.prototype.has = function(key) {
            return this._find(
              key,
              /*insert*/
              false
            ) >= 0;
          };
          Map2.prototype.get = function(key) {
            var index2 = this._find(
              key,
              /*insert*/
              false
            );
            return index2 >= 0 ? this._values[index2] : void 0;
          };
          Map2.prototype.set = function(key, value) {
            var index2 = this._find(
              key,
              /*insert*/
              true
            );
            this._values[index2] = value;
            return this;
          };
          Map2.prototype.delete = function(key) {
            var index2 = this._find(
              key,
              /*insert*/
              false
            );
            if (index2 >= 0) {
              var size = this._keys.length;
              for (var i = index2 + 1; i < size; i++) {
                this._keys[i - 1] = this._keys[i];
                this._values[i - 1] = this._values[i];
              }
              this._keys.length--;
              this._values.length--;
              if (key === this._cacheKey) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              return true;
            }
            return false;
          };
          Map2.prototype.clear = function() {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };
          Map2.prototype.keys = function() {
            return new MapIterator(this._keys, this._values, getKey);
          };
          Map2.prototype.values = function() {
            return new MapIterator(this._keys, this._values, getValue);
          };
          Map2.prototype.entries = function() {
            return new MapIterator(this._keys, this._values, getEntry);
          };
          Map2.prototype["@@iterator"] = function() {
            return this.entries();
          };
          Map2.prototype[iteratorSymbol] = function() {
            return this.entries();
          };
          Map2.prototype._find = function(key, insert) {
            if (this._cacheKey !== key) {
              this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
            }
            if (this._cacheIndex < 0 && insert) {
              this._cacheIndex = this._keys.length;
              this._keys.push(key);
              this._values.push(void 0);
            }
            return this._cacheIndex;
          };
          return Map2;
        }()
      );
      function getKey(key, _) {
        return key;
      }
      function getValue(_, value) {
        return value;
      }
      function getEntry(key, value) {
        return [key, value];
      }
    }
    function CreateSetPolyfill() {
      return (
        /** @class */
        function() {
          function Set2() {
            this._map = new _Map();
          }
          Object.defineProperty(Set2.prototype, "size", {
            get: function() {
              return this._map.size;
            },
            enumerable: true,
            configurable: true
          });
          Set2.prototype.has = function(value) {
            return this._map.has(value);
          };
          Set2.prototype.add = function(value) {
            return this._map.set(value, value), this;
          };
          Set2.prototype.delete = function(value) {
            return this._map.delete(value);
          };
          Set2.prototype.clear = function() {
            this._map.clear();
          };
          Set2.prototype.keys = function() {
            return this._map.keys();
          };
          Set2.prototype.values = function() {
            return this._map.values();
          };
          Set2.prototype.entries = function() {
            return this._map.entries();
          };
          Set2.prototype["@@iterator"] = function() {
            return this.keys();
          };
          Set2.prototype[iteratorSymbol] = function() {
            return this.keys();
          };
          return Set2;
        }()
      );
    }
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var keys = HashMap.create();
      var rootKey = CreateUniqueKey();
      return (
        /** @class */
        function() {
          function WeakMap2() {
            this._key = CreateUniqueKey();
          }
          WeakMap2.prototype.has = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.has(table, this._key) : false;
          };
          WeakMap2.prototype.get = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.get(table, this._key) : void 0;
          };
          WeakMap2.prototype.set = function(target, value) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              true
            );
            table[this._key] = value;
            return this;
          };
          WeakMap2.prototype.delete = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? delete table[this._key] : false;
          };
          WeakMap2.prototype.clear = function() {
            this._key = CreateUniqueKey();
          };
          return WeakMap2;
        }()
      );
      function CreateUniqueKey() {
        var key;
        do
          key = "@@WeakMap@@" + CreateUUID();
        while (HashMap.has(keys, key));
        keys[key] = true;
        return key;
      }
      function GetOrCreateWeakMapTable(target, create3) {
        if (!hasOwn.call(target, rootKey)) {
          if (!create3)
            return void 0;
          Object.defineProperty(target, rootKey, { value: HashMap.create() });
        }
        return target[rootKey];
      }
      function FillRandomBytes(buffer, size) {
        for (var i = 0; i < size; ++i)
          buffer[i] = Math.random() * 255 | 0;
        return buffer;
      }
      function GenRandomBytes(size) {
        if (typeof Uint8Array === "function") {
          if (typeof crypto !== "undefined")
            return crypto.getRandomValues(new Uint8Array(size));
          if (typeof msCrypto !== "undefined")
            return msCrypto.getRandomValues(new Uint8Array(size));
          return FillRandomBytes(new Uint8Array(size), size);
        }
        return FillRandomBytes(new Array(size), size);
      }
      function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        data[6] = data[6] & 79 | 64;
        data[8] = data[8] & 191 | 128;
        var result = "";
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data[offset];
          if (offset === 4 || offset === 6 || offset === 8)
            result += "-";
          if (byte < 16)
            result += "0";
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
    }
    function MakeDictionary(obj) {
      obj.__ = void 0;
      delete obj.__;
      return obj;
    }
  });
})(Reflect2 || (Reflect2 = {}));

// node_modules/@bloomreach/spa-sdk/dist/index.js
var import_emittery = __toESM(require_emittery());

// node_modules/domelementtype/lib/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  CDATA: () => CDATA,
  Comment: () => Comment,
  Directive: () => Directive,
  Doctype: () => Doctype,
  ElementType: () => ElementType,
  Root: () => Root,
  Script: () => Script,
  Style: () => Style,
  Tag: () => Tag,
  Text: () => Text,
  isTag: () => isTag
});
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
var Root = ElementType.Root;
var Text = ElementType.Text;
var Directive = ElementType.Directive;
var Comment = ElementType.Comment;
var Script = ElementType.Script;
var Style = ElementType.Style;
var Tag = ElementType.Tag;
var CDATA = ElementType.CDATA;
var Doctype = ElementType.Doctype;

// node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
  // prettier-ignore
  '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
  // prettier-ignore
  "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/decode_codepoint.js
var _a3;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a3 = String.fromCodePoint) !== null && _a3 !== void 0 ? _a3 : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a4;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a4 = decodeMap.get(codePoint)) !== null && _a4 !== void 0 ? _a4 : codePoint;
}

// node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes3) {
  CharCodes3[CharCodes3["NUM"] = 35] = "NUM";
  CharCodes3[CharCodes3["SEMI"] = 59] = "SEMI";
  CharCodes3[CharCodes3["EQUALS"] = 61] = "EQUALS";
  CharCodes3[CharCodes3["ZERO"] = 48] = "ZERO";
  CharCodes3[CharCodes3["NINE"] = 57] = "NINE";
  CharCodes3[CharCodes3["LOWER_A"] = 97] = "LOWER_A";
  CharCodes3[CharCodes3["LOWER_F"] = 102] = "LOWER_F";
  CharCodes3[CharCodes3["LOWER_X"] = 120] = "LOWER_X";
  CharCodes3[CharCodes3["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes3[CharCodes3["UPPER_A"] = 65] = "UPPER_A";
  CharCodes3[CharCodes3["UPPER_F"] = 70] = "UPPER_F";
  CharCodes3[CharCodes3["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a4;
    if (this.consumed <= expectedLength) {
      (_a4 = this.errors) === null || _a4 === void 0 ? void 0 : _a4.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a4;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a4 = this.errors) === null || _a4 === void 0 ? void 0 : _a4.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a4;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a4 = this.errors) === null || _a4 === void 0 ? void 0 : _a4.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);

// node_modules/entities/lib/esm/generated/encode-html.js
function restoreDiff(arr) {
  for (let i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
var encode_html_default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

// node_modules/entities/lib/esm/escape.js
var xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index2) => str.codePointAt(index2) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c, index2) => (c.charCodeAt(index2) & 64512) === 55296 ? (c.charCodeAt(index2) - 55296) * 1024 + c.charCodeAt(index2 + 1) - 56320 + 65536 : c.charCodeAt(index2)
  )
);
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i = match.index;
    const char = str.charCodeAt(i);
    const next = xmlCodeMap.get(char);
    if (next !== void 0) {
      ret += str.substring(lastIdx, i) + next;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex, map) {
  return function escape3(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      result += map.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// node_modules/dom-serializer/lib/esm/foreignNames.js
var elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val) => [val.toLowerCase(), val]));
var attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val) => [val.toLowerCase(), val]));

// node_modules/dom-serializer/lib/esm/index.js
var unencodedElements = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes, opts) {
  var _a4;
  if (!attributes)
    return;
  const encode = ((_a4 = opts.encodeEntities) !== null && _a4 !== void 0 ? _a4 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes).map((key) => {
    var _a5, _b;
    const value = (_a5 = attributes[key]) !== null && _a5 !== void 0 ? _a5 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return `${key}="${encode(value)}"`;
  }).join(" ");
}
var singleTag = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node, options = {}) {
  const nodes = "length" in node ? node : [node];
  let output = "";
  for (let i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
var esm_default2 = render;
function renderNode(node, options) {
  switch (node.type) {
    case Root:
      return render(node.children, options);
    case Doctype:
    case Directive:
      return renderDirective(node);
    case Comment:
      return renderComment(node);
    case CDATA:
      return renderCdata(node);
    case Script:
    case Style:
    case Tag:
      return renderTag(node, options);
    case Text:
      return renderText(node, options);
  }
}
var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a4;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a4 = elementNames.get(elem.name)) !== null && _a4 !== void 0 ? _a4 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a4;
  let data = elem.data || "";
  if (((_a4 = opts.encodeEntities) !== null && _a4 !== void 0 ? _a4 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data) : escapeText(data);
  }
  return data;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}

// node_modules/domhandler/lib/esm/node.js
var Node = class {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent) {
    this.parent = parent;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev) {
    this.prev = prev;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next) {
    this.next = next;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
};
var DataNode = class extends Node {
  /**
   * @param data The content of the data node
   */
  constructor(data) {
    super();
    this.data = data;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data) {
    this.data = data;
  }
};
var Text2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
};
var Comment2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
};
var ProcessingInstruction = class extends DataNode {
  constructor(name, data) {
    super(data);
    this.name = name;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
};
var NodeWithChildren = class extends Node {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(children) {
    super();
    this.children = children;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var _a4;
    return (_a4 = this.children[0]) !== null && _a4 !== void 0 ? _a4 : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(children) {
    this.children = children;
  }
};
var CDATA2 = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
};
var Document = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
};
var Element = class extends NodeWithChildren {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(name, attribs, children = [], type = name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag) {
    super(children);
    this.name = name;
    this.attribs = attribs;
    this.type = type;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(name) {
    this.name = name;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name) => {
      var _a4, _b;
      return {
        name,
        value: this.attribs[name],
        namespace: (_a4 = this["x-attribsNamespace"]) === null || _a4 === void 0 ? void 0 : _a4[name],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
      };
    });
  }
};
function isTag2(node) {
  return isTag(node);
}
function isCDATA(node) {
  return node.type === ElementType.CDATA;
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}
function isDirective(node) {
  return node.type === ElementType.Directive;
}
function isDocument(node) {
  return node.type === ElementType.Root;
}
function hasChildren(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}
function cloneNode(node, recursive = false) {
  let result;
  if (isText(node)) {
    result = new Text2(node.data);
  } else if (isComment(node)) {
    result = new Comment2(node.data);
  } else if (isTag2(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone2 = new Element(node.name, { ...node.attribs }, children);
    children.forEach((child) => child.parent = clone2);
    if (node.namespace != null) {
      clone2.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone2["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
    }
    if (node["x-attribsPrefix"]) {
      clone2["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
    }
    result = clone2;
  } else if (isCDATA(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone2 = new CDATA2(children);
    children.forEach((child) => child.parent = clone2);
    result = clone2;
  } else if (isDocument(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone2 = new Document(children);
    children.forEach((child) => child.parent = clone2);
    if (node["x-mode"]) {
      clone2["x-mode"] = node["x-mode"];
    }
    result = clone2;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children = childs.map((child) => cloneNode(child, true));
  for (let i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}

// node_modules/domhandler/lib/esm/index.js
var defaultOpts = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
var DomHandler = class {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(callback2, options, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    if (typeof callback2 === "object") {
      options = callback2;
      callback2 = void 0;
    }
    this.callback = callback2 !== null && callback2 !== void 0 ? callback2 : null;
    this.options = options !== null && options !== void 0 ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error) {
    this.handleCallback(error);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name, attribs) {
    const type = this.options.xmlMode ? ElementType.Tag : void 0;
    const element = new Element(name, attribs, void 0, type);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node = new Text2(data);
      this.addNode(node);
      this.lastNode = node;
    }
  }
  oncomment(data) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }
    const node = new Comment2(data);
    this.addNode(node);
    this.lastNode = node;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text = new Text2("");
    const node = new CDATA2([text]);
    this.addNode(node);
    text.parent = node;
    this.lastNode = text;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name, data) {
    const node = new ProcessingInstruction(name, data);
    this.addNode(node);
  }
  handleCallback(error) {
    if (typeof this.callback === "function") {
      this.callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  }
  addNode(node) {
    const parent = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node.endIndex = this.parser.endIndex;
    }
    parent.children.push(node);
    if (previousSibling) {
      node.prev = previousSibling;
      previousSibling.next = node;
    }
    node.parent = parent;
    this.lastNode = null;
  }
};

// node_modules/domutils/lib/esm/traversal.js
function getAttributeValue(elem, name) {
  var _a4;
  return (_a4 = elem.attribs) === null || _a4 === void 0 ? void 0 : _a4[name];
}
function hasAttrib(elem, name) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
}

// node_modules/domutils/lib/esm/querying.js
function filter(test, node, recurse = true, limit = Infinity) {
  if (!Array.isArray(node))
    node = [node];
  return find2(test, node, recurse, limit);
}
function find2(test, nodes, recurse, limit) {
  const result = [];
  for (const elem of nodes) {
    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0)
        break;
    }
    if (recurse && hasChildren(elem) && elem.children.length > 0) {
      const children = find2(test, elem.children, recurse, limit);
      result.push(...children);
      limit -= children.length;
      if (limit <= 0)
        break;
    }
  }
  return result;
}

// node_modules/domutils/lib/esm/legacy.js
var Checks = {
  tag_name(name) {
    if (typeof name === "function") {
      return (elem) => isTag2(elem) && name(elem.name);
    } else if (name === "*") {
      return isTag2;
    }
    return (elem) => isTag2(elem) && elem.name === name;
  },
  tag_type(type) {
    if (typeof type === "function") {
      return (elem) => type(elem.type);
    }
    return (elem) => elem.type === type;
  },
  tag_contains(data) {
    if (typeof data === "function") {
      return (elem) => isText(elem) && data(elem.data);
    }
    return (elem) => isText(elem) && elem.data === data;
  }
};
function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_name"](tagName), nodes, recurse, limit);
}

// node_modules/domutils/lib/esm/helpers.js
var DocumentPosition;
(function(DocumentPosition3) {
  DocumentPosition3[DocumentPosition3["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition3[DocumentPosition3["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition3[DocumentPosition3["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition3[DocumentPosition3["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition3[DocumentPosition3["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));

// node_modules/htmlparser2/lib/esm/Tokenizer.js
var CharCodes2;
(function(CharCodes3) {
  CharCodes3[CharCodes3["Tab"] = 9] = "Tab";
  CharCodes3[CharCodes3["NewLine"] = 10] = "NewLine";
  CharCodes3[CharCodes3["FormFeed"] = 12] = "FormFeed";
  CharCodes3[CharCodes3["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes3[CharCodes3["Space"] = 32] = "Space";
  CharCodes3[CharCodes3["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes3[CharCodes3["Number"] = 35] = "Number";
  CharCodes3[CharCodes3["Amp"] = 38] = "Amp";
  CharCodes3[CharCodes3["SingleQuote"] = 39] = "SingleQuote";
  CharCodes3[CharCodes3["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes3[CharCodes3["Dash"] = 45] = "Dash";
  CharCodes3[CharCodes3["Slash"] = 47] = "Slash";
  CharCodes3[CharCodes3["Zero"] = 48] = "Zero";
  CharCodes3[CharCodes3["Nine"] = 57] = "Nine";
  CharCodes3[CharCodes3["Semi"] = 59] = "Semi";
  CharCodes3[CharCodes3["Lt"] = 60] = "Lt";
  CharCodes3[CharCodes3["Eq"] = 61] = "Eq";
  CharCodes3[CharCodes3["Gt"] = 62] = "Gt";
  CharCodes3[CharCodes3["Questionmark"] = 63] = "Questionmark";
  CharCodes3[CharCodes3["UpperA"] = 65] = "UpperA";
  CharCodes3[CharCodes3["LowerA"] = 97] = "LowerA";
  CharCodes3[CharCodes3["UpperF"] = 70] = "UpperF";
  CharCodes3[CharCodes3["LowerF"] = 102] = "LowerF";
  CharCodes3[CharCodes3["UpperZ"] = 90] = "UpperZ";
  CharCodes3[CharCodes3["LowerZ"] = 122] = "LowerZ";
  CharCodes3[CharCodes3["LowerX"] = 120] = "LowerX";
  CharCodes3[CharCodes3["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes2 || (CharCodes2 = {}));
var State;
(function(State2) {
  State2[State2["Text"] = 1] = "Text";
  State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
  State2[State2["InTagName"] = 3] = "InTagName";
  State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
  State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State2[State2["InAttributeName"] = 9] = "InAttributeName";
  State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
  State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State2[State2["InDeclaration"] = 16] = "InDeclaration";
  State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State2[State2["BeforeComment"] = 18] = "BeforeComment";
  State2[State2["CDATASequence"] = 19] = "CDATASequence";
  State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
  State2[State2["InCommentLike"] = 21] = "InCommentLike";
  State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
  State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
  State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
  State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
  State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
  State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
  State2[State2["InHexEntity"] = 29] = "InHexEntity";
})(State || (State = {}));
function isWhitespace(c) {
  return c === CharCodes2.Space || c === CharCodes2.NewLine || c === CharCodes2.Tab || c === CharCodes2.FormFeed || c === CharCodes2.CarriageReturn;
}
function isEndOfTagSection(c) {
  return c === CharCodes2.Slash || c === CharCodes2.Gt || isWhitespace(c);
}
function isNumber2(c) {
  return c >= CharCodes2.Zero && c <= CharCodes2.Nine;
}
function isASCIIAlpha(c) {
  return c >= CharCodes2.LowerA && c <= CharCodes2.LowerZ || c >= CharCodes2.UpperA && c <= CharCodes2.UpperZ;
}
function isHexDigit(c) {
  return c >= CharCodes2.UpperA && c <= CharCodes2.UpperF || c >= CharCodes2.LowerA && c <= CharCodes2.LowerF;
}
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
var Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  // `</title`
};
var Tokenizer = class {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
    this.trieIndex = 0;
    this.trieCurrent = 0;
    this.entityResult = 0;
    this.entityExcess = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityTrie = xmlMode ? decode_data_xml_default : decode_data_html_default;
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = void 0;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  /**
   * The current index within all of the written data.
   */
  getIndex() {
    return this.index;
  }
  /**
   * The start of the current section.
   */
  getSectionStart() {
    return this.sectionStart;
  }
  stateText(c) {
    if (c === CharCodes2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes2.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.state = State.BeforeEntity;
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === CharCodes2.Gt || isWhitespace(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c === CharCodes2.Amp) {
          this.state = State.BeforeEntity;
        }
      } else if (this.fastForwardTo(CharCodes2.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c === CharCodes2.Lt);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(c) {
    return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c) {
    if (c === CharCodes2.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c)) {
      const lower = c | 32;
      this.sectionStart = this.index;
      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
        this.startSpecial(Sequences.TitleEnd, 3);
      } else {
        this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
      }
    } else if (c === CharCodes2.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace(c)) {
    } else if (c === CharCodes2.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === CharCodes2.Gt || isWhitespace(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c) {
    if (c === CharCodes2.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.baseState = this.state;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace(c)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === CharCodes2.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace(c)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateInAttributeName(c) {
    if (c === CharCodes2.Eq || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c);
    }
  }
  stateAfterAttributeName(c) {
    if (c === CharCodes2.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c === CharCodes2.Slash || c === CharCodes2.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (!isWhitespace(c)) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c) {
    if (c === CharCodes2.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c);
    }
  }
  handleInAttributeValue(c, quote) {
    if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateInAttributeValueDoubleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes2.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes2.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c) {
    if (isWhitespace(c) || c === CharCodes2.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateBeforeDeclaration(c) {
    if (c === CharCodes2.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c === CharCodes2.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === CharCodes2.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    const lower = c | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c);
    }
  }
  stateBeforeEntity(c) {
    this.entityExcess = 1;
    this.entityResult = 0;
    if (c === CharCodes2.Number) {
      this.state = State.BeforeNumericEntity;
    } else if (c === CharCodes2.Amp) {
    } else {
      this.trieIndex = 0;
      this.trieCurrent = this.entityTrie[0];
      this.state = State.InNamedEntity;
      this.stateInNamedEntity(c);
    }
  }
  stateInNamedEntity(c) {
    this.entityExcess += 1;
    this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
    if (this.trieIndex < 0) {
      this.emitNamedEntity();
      this.index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
    if (masked) {
      const valueLength = (masked >> 14) - 1;
      if (!this.allowLegacyEntity() && c !== CharCodes2.Semi) {
        this.trieIndex += valueLength;
      } else {
        const entityStart = this.index - this.entityExcess + 1;
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.entityResult = this.trieIndex;
        this.trieIndex += valueLength;
        this.entityExcess = 0;
        this.sectionStart = this.index + 1;
        if (valueLength === 0) {
          this.emitNamedEntity();
        }
      }
    }
  }
  emitNamedEntity() {
    this.state = this.baseState;
    if (this.entityResult === 0) {
      return;
    }
    const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
    switch (valueLength) {
      case 1: {
        this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);
        break;
      }
      case 2: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        break;
      }
      case 3: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
      }
    }
  }
  stateBeforeNumericEntity(c) {
    if ((c | 32) === CharCodes2.LowerX) {
      this.entityExcess++;
      this.state = State.InHexEntity;
    } else {
      this.state = State.InNumericEntity;
      this.stateInNumericEntity(c);
    }
  }
  emitNumericEntity(strict) {
    const entityStart = this.index - this.entityExcess - 1;
    const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
    if (numberStart !== this.index) {
      if (entityStart > this.sectionStart) {
        this.emitPartial(this.sectionStart, entityStart);
      }
      this.sectionStart = this.index + Number(strict);
      this.emitCodePoint(replaceCodePoint(this.entityResult));
    }
    this.state = this.baseState;
  }
  stateInNumericEntity(c) {
    if (c === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c)) {
      this.entityResult = this.entityResult * 10 + (c - CharCodes2.Zero);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  stateInHexEntity(c) {
    if (c === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c)) {
      this.entityResult = this.entityResult * 16 + (c - CharCodes2.Zero);
      this.entityExcess++;
    } else if (isHexDigit(c)) {
      this.entityResult = this.entityResult * 16 + ((c | 32) - CharCodes2.LowerA + 10);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  allowLegacyEntity() {
    return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    while (this.shouldContinue()) {
      const c = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c);
          break;
        }
        case State.InNamedEntity: {
          this.stateInNamedEntity(c);
          break;
        }
        case State.BeforeEntity: {
          this.stateBeforeEntity(c);
          break;
        }
        case State.InHexEntity: {
          this.stateInHexEntity(c);
          break;
        }
        case State.InNumericEntity: {
          this.stateInNumericEntity(c);
          break;
        }
        default: {
          this.stateBeforeNumericEntity(c);
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InNamedEntity) {
      this.emitNamedEntity();
    }
    if (this.sectionStart < this.index) {
      this.handleTrailingData();
    }
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
    } else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitPartial(start, endIndex) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribdata(start, endIndex);
    } else {
      this.cbs.ontext(start, endIndex);
    }
  }
  emitCodePoint(cp) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribentity(cp);
    } else {
      this.cbs.ontextentity(cp);
    }
  }
};

// node_modules/htmlparser2/lib/esm/Parser.js
var formTags = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = /* @__PURE__ */ new Set(["p"]);
var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
var openImpliesClose = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
var htmlIntegrationElements = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;
var Parser = class {
  constructor(cbs, options = {}) {
    var _a4, _b, _c, _d, _e;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.lowerCaseTagNames = (_a4 = options.lowerCaseTags) !== null && _a4 !== void 0 ? _a4 : !options.xmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer)(this.options, this);
    (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(start, endIndex) {
    var _a4, _b;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a4 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a4, data);
    this.startIndex = endIndex;
  }
  /** @internal */
  ontextentity(cp) {
    var _a4, _b;
    const index2 = this.tokenizer.getSectionStart();
    this.endIndex = index2 - 1;
    (_b = (_a4 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a4, fromCodePoint(cp));
    this.startIndex = index2;
  }
  isVoidElement(name) {
    return !this.options.xmlMode && voidElements.has(name);
  }
  /** @internal */
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    this.emitOpenTag(name);
  }
  emitOpenTag(name) {
    var _a4, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name;
    const impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
        const element = this.stack.pop();
        (_b = (_a4 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a4, element, true);
      }
    }
    if (!this.isVoidElement(name)) {
      this.stack.push(name);
      if (foreignContextElements.has(name)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements.has(name)) {
        this.foreignContext.push(false);
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a4, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a4 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a4, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  /** @internal */
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onclosetag(start, endIndex) {
    var _a4, _b, _c, _d, _e, _f;
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
      this.foreignContext.pop();
    }
    if (!this.isVoidElement(name)) {
      const pos = this.stack.lastIndexOf(name);
      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          let count = this.stack.length - pos;
          while (count--) {
            this.cbs.onclosetag(this.stack.pop(), count !== 0);
          }
        } else
          this.stack.length = pos;
      } else if (!this.options.xmlMode && name === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (!this.options.xmlMode && name === "br") {
      (_b = (_a4 = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a4, "br");
      (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
      (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a4, _b;
    const name = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[this.stack.length - 1] === name) {
      (_b = (_a4 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a4, name, !isOpenImplied);
      this.stack.pop();
    }
  }
  /** @internal */
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
  }
  /** @internal */
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  /** @internal */
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  /** @internal */
  onattribend(quote, endIndex) {
    var _a4, _b;
    this.endIndex = endIndex;
    (_b = (_a4 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a4, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? void 0 : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index2 = value.search(reNameEnd);
    let name = index2 < 0 ? value : value.substr(0, index2);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    return name;
  }
  /** @internal */
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncomment(start, endIndex, offset) {
    var _a4, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a4 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a4, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncdata(start, endIndex, offset) {
    var _a4, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b = (_a4 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a4);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
      (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onend() {
    var _a4, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index2 = this.stack.length; index2 > 0; this.cbs.onclosetag(this.stack[--index2], true))
        ;
    }
    (_b = (_a4 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a4);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var _a4, _b, _c, _d;
    (_b = (_a4 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a4);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
    this.buffers.length = 0;
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(chunk) {
    var _a4, _b;
    if (this.ended) {
      (_b = (_a4 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a4, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(chunk) {
    var _a4, _b;
    if (this.ended) {
      (_b = (_a4 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a4, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(chunk) {
    this.write(chunk);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(chunk) {
    this.end(chunk);
  }
};

// node_modules/htmlparser2/node_modules/domutils/lib/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  DocumentPosition: () => DocumentPosition2,
  append: () => append,
  appendChild: () => appendChild,
  compareDocumentPosition: () => compareDocumentPosition,
  existsOne: () => existsOne,
  filter: () => filter2,
  find: () => find3,
  findAll: () => findAll,
  findOne: () => findOne2,
  findOneChild: () => findOneChild,
  getAttributeValue: () => getAttributeValue2,
  getChildren: () => getChildren,
  getElementById: () => getElementById,
  getElements: () => getElements,
  getElementsByTagName: () => getElementsByTagName2,
  getElementsByTagType: () => getElementsByTagType,
  getFeed: () => getFeed,
  getInnerHTML: () => getInnerHTML,
  getName: () => getName,
  getOuterHTML: () => getOuterHTML,
  getParent: () => getParent,
  getSiblings: () => getSiblings,
  getText: () => getText,
  hasAttrib: () => hasAttrib2,
  hasChildren: () => hasChildren,
  innerText: () => innerText,
  isCDATA: () => isCDATA,
  isComment: () => isComment,
  isDocument: () => isDocument,
  isTag: () => isTag2,
  isText: () => isText,
  nextElementSibling: () => nextElementSibling,
  prepend: () => prepend,
  prependChild: () => prependChild,
  prevElementSibling: () => prevElementSibling,
  removeElement: () => removeElement,
  removeSubsets: () => removeSubsets,
  replaceElement: () => replaceElement,
  testElement: () => testElement,
  textContent: () => textContent2,
  uniqueSort: () => uniqueSort
});

// node_modules/htmlparser2/node_modules/domutils/lib/esm/stringify.js
function getOuterHTML(node, options) {
  return esm_default2(node, options);
}
function getInnerHTML(node, options) {
  return hasChildren(node) ? node.children.map((node2) => getOuterHTML(node2, options)).join("") : "";
}
function getText(node) {
  if (Array.isArray(node))
    return node.map(getText).join("");
  if (isTag2(node))
    return node.name === "br" ? "\n" : getText(node.children);
  if (isCDATA(node))
    return getText(node.children);
  if (isText(node))
    return node.data;
  return "";
}
function textContent2(node) {
  if (Array.isArray(node))
    return node.map(textContent2).join("");
  if (hasChildren(node) && !isComment(node)) {
    return textContent2(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}
function innerText(node) {
  if (Array.isArray(node))
    return node.map(innerText).join("");
  if (hasChildren(node) && (node.type === ElementType.Tag || isCDATA(node))) {
    return innerText(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}

// node_modules/htmlparser2/node_modules/domutils/lib/esm/traversal.js
function getChildren(elem) {
  return hasChildren(elem) ? elem.children : [];
}
function getParent(elem) {
  return elem.parent || null;
}
function getSiblings(elem) {
  const parent = getParent(elem);
  if (parent != null)
    return getChildren(parent);
  const siblings = [elem];
  let { prev, next } = elem;
  while (prev != null) {
    siblings.unshift(prev);
    ({ prev } = prev);
  }
  while (next != null) {
    siblings.push(next);
    ({ next } = next);
  }
  return siblings;
}
function getAttributeValue2(elem, name) {
  var _a4;
  return (_a4 = elem.attribs) === null || _a4 === void 0 ? void 0 : _a4[name];
}
function hasAttrib2(elem, name) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
}
function getName(elem) {
  return elem.name;
}
function nextElementSibling(elem) {
  let { next } = elem;
  while (next !== null && !isTag2(next))
    ({ next } = next);
  return next;
}
function prevElementSibling(elem) {
  let { prev } = elem;
  while (prev !== null && !isTag2(prev))
    ({ prev } = prev);
  return prev;
}

// node_modules/htmlparser2/node_modules/domutils/lib/esm/manipulation.js
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    const childs = elem.parent.children;
    const childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
function replaceElement(elem, replacement) {
  const prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  const next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  const parent = replacement.parent = elem.parent;
  if (parent) {
    const childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
function appendChild(parent, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    const sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
function append(elem, next) {
  removeElement(next);
  const { parent } = elem;
  const currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      const childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
function prependChild(parent, child) {
  removeElement(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    const sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
function prepend(elem, prev) {
  removeElement(prev);
  const { parent } = elem;
  if (parent) {
    const childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}

// node_modules/htmlparser2/node_modules/domutils/lib/esm/querying.js
function filter2(test, node, recurse = true, limit = Infinity) {
  return find3(test, Array.isArray(node) ? node : [node], recurse, limit);
}
function find3(test, nodes, recurse, limit) {
  const result = [];
  const nodeStack = [nodes];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
function findOneChild(test, nodes) {
  return nodes.find(test);
}
function findOne2(test, nodes, recurse = true) {
  let elem = null;
  for (let i = 0; i < nodes.length && !elem; i++) {
    const node = nodes[i];
    if (!isTag2(node)) {
      continue;
    } else if (test(node)) {
      elem = node;
    } else if (recurse && node.children.length > 0) {
      elem = findOne2(test, node.children, true);
    }
  }
  return elem;
}
function existsOne(test, nodes) {
  return nodes.some((checked) => isTag2(checked) && (test(checked) || existsOne(test, checked.children)));
}
function findAll(test, nodes) {
  const result = [];
  const nodeStack = [nodes];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (!isTag2(elem))
      continue;
    if (test(elem))
      result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}

// node_modules/htmlparser2/node_modules/domutils/lib/esm/legacy.js
var Checks2 = {
  tag_name(name) {
    if (typeof name === "function") {
      return (elem) => isTag2(elem) && name(elem.name);
    } else if (name === "*") {
      return isTag2;
    }
    return (elem) => isTag2(elem) && elem.name === name;
  },
  tag_type(type) {
    if (typeof type === "function") {
      return (elem) => type(elem.type);
    }
    return (elem) => elem.type === type;
  },
  tag_contains(data) {
    if (typeof data === "function") {
      return (elem) => isText(elem) && data(elem.data);
    }
    return (elem) => isText(elem) && elem.data === data;
  }
};
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return (elem) => isTag2(elem) && value(elem.attribs[attrib]);
  }
  return (elem) => isTag2(elem) && elem.attribs[attrib] === value;
}
function combineFuncs(a, b) {
  return (elem) => a(elem) || b(elem);
}
function compileTest(options) {
  const funcs = Object.keys(options).map((key) => {
    const value = options[key];
    return Object.prototype.hasOwnProperty.call(Checks2, key) ? Checks2[key](value) : getAttribCheck(key, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
function testElement(options, node) {
  const test = compileTest(options);
  return test ? test(node) : true;
}
function getElements(options, nodes, recurse, limit = Infinity) {
  const test = compileTest(options);
  return test ? filter2(test, nodes, recurse, limit) : [];
}
function getElementById(id, nodes, recurse = true) {
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return findOne2(getAttribCheck("id", id), nodes, recurse);
}
function getElementsByTagName2(tagName, nodes, recurse = true, limit = Infinity) {
  return filter2(Checks2["tag_name"](tagName), nodes, recurse, limit);
}
function getElementsByTagType(type, nodes, recurse = true, limit = Infinity) {
  return filter2(Checks2["tag_type"](type), nodes, recurse, limit);
}

// node_modules/htmlparser2/node_modules/domutils/lib/esm/helpers.js
function removeSubsets(nodes) {
  let idx = nodes.length;
  while (--idx >= 0) {
    const node = nodes[idx];
    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }
    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }
  return nodes;
}
var DocumentPosition2;
(function(DocumentPosition3) {
  DocumentPosition3[DocumentPosition3["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition3[DocumentPosition3["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition3[DocumentPosition3["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition3[DocumentPosition3["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition3[DocumentPosition3["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition2 || (DocumentPosition2 = {}));
function compareDocumentPosition(nodeA, nodeB) {
  const aParents = [];
  const bParents = [];
  if (nodeA === nodeB) {
    return 0;
  }
  let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = hasChildren(nodeB) ? nodeB : nodeB.parent;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  const maxIdx = Math.min(aParents.length, bParents.length);
  let idx = 0;
  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return DocumentPosition2.DISCONNECTED;
  }
  const sharedParent = aParents[idx - 1];
  const siblings = sharedParent.children;
  const aSibling = aParents[idx];
  const bSibling = bParents[idx];
  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return DocumentPosition2.FOLLOWING | DocumentPosition2.CONTAINED_BY;
    }
    return DocumentPosition2.FOLLOWING;
  }
  if (sharedParent === nodeA) {
    return DocumentPosition2.PRECEDING | DocumentPosition2.CONTAINS;
  }
  return DocumentPosition2.PRECEDING;
}
function uniqueSort(nodes) {
  nodes = nodes.filter((node, i, arr) => !arr.includes(node, i + 1));
  nodes.sort((a, b) => {
    const relative = compareDocumentPosition(a, b);
    if (relative & DocumentPosition2.PRECEDING) {
      return -1;
    } else if (relative & DocumentPosition2.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
}

// node_modules/htmlparser2/node_modules/domutils/lib/esm/feeds.js
function getFeed(doc) {
  const feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
function getAtomFeed(feedRoot) {
  var _a4;
  const childs = feedRoot.children;
  const feed = {
    type: "atom",
    items: getElementsByTagName2("entry", childs).map((item) => {
      var _a5;
      const { children } = item;
      const entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "id", children);
      addConditionally(entry, "title", "title", children);
      const href2 = (_a5 = getOneElement("link", children)) === null || _a5 === void 0 ? void 0 : _a5.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      const description = fetch3("summary", children) || fetch3("content", children);
      if (description) {
        entry.description = description;
      }
      const pubDate = fetch3("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  const href = (_a4 = getOneElement("link", childs)) === null || _a4 === void 0 ? void 0 : _a4.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  const updated = fetch3("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed(feedRoot) {
  var _a4, _b;
  const childs = (_b = (_a4 = getOneElement("channel", feedRoot.children)) === null || _a4 === void 0 ? void 0 : _a4.children) !== null && _b !== void 0 ? _b : [];
  const feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: getElementsByTagName2("item", feedRoot.children).map((item) => {
      const { children } = item;
      const entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "guid", children);
      addConditionally(entry, "title", "title", children);
      addConditionally(entry, "link", "link", children);
      addConditionally(entry, "description", "description", children);
      const pubDate = fetch3("pubDate", children) || fetch3("dc:date", children);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  const updated = fetch3("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements(where) {
  return getElementsByTagName2("media:content", where).map((elem) => {
    const { attribs } = elem;
    const media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (const attrib of MEDIA_KEYS_STRING) {
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (const attrib of MEDIA_KEYS_INT) {
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement(tagName, node) {
  return getElementsByTagName2(tagName, node, true, 1)[0];
}
function fetch3(tagName, where, recurse = false) {
  return textContent2(getElementsByTagName2(tagName, where, recurse, 1)).trim();
}
function addConditionally(obj, prop, tagName, where, recurse = false) {
  const val = fetch3(tagName, where, recurse);
  if (val)
    obj[prop] = val;
}
function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}

// node_modules/htmlparser2/lib/esm/index.js
function parseDocument(data, options) {
  const handler = new DomHandler(void 0, options);
  new Parser(handler, options).end(data);
  return handler.root;
}

// node_modules/@bloomreach/spa-sdk/dist/index.js
var import_cookie = __toESM(require_cookie());
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var Level;
(function(Level2) {
  Level2["Debug"] = "debug";
  Level2["Info"] = "info";
  Level2["Warn"] = "warn";
  Level2["Error"] = "error";
})(Level || (Level = {}));
var Logger = class Logger2 {
  constructor() {
    this.level = Level.Error;
    this.debug = this.log.bind(this, Level.Debug);
    this.info = this.log.bind(this, Level.Info);
    this.warn = this.log.bind(this, Level.Warn);
    this.error = this.log.bind(this, Level.Error);
  }
  log(level, ...message) {
    const levels = Object.values(Level);
    if (!levels.includes(level) || levels.indexOf(level) < levels.indexOf(this.level)) {
      return;
    }
    this.write(level, "[SPA]", `[${level.toUpperCase()}]`, ...message);
  }
};
Logger = __decorate([(0, import_inversify.injectable)(), __metadata("design:paramtypes", [])], Logger);
var ConsoleToken = Symbol.for("ConsoleToken");
var ConsoleLogger = class ConsoleLogger2 extends Logger {
  constructor(console2) {
    super();
    this.console = console2;
  }
  write(level, ...message) {
    this.console[level](...message);
  }
};
ConsoleLogger = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(ConsoleToken)), __metadata("design:paramtypes", [Object])], ConsoleLogger);
function LoggerModule() {
  return new import_inversify.ContainerModule((bind) => {
    bind(ConsoleToken).toConstantValue(console);
    bind(ConsoleLogger).toSelf().inSingletonScope();
    bind(Logger).toService(ConsoleLogger);
  });
}
var CmsEventBusService = Symbol("CmsEventBusService");
function EmitterMixin(Super) {
  return class EmitterMixin extends Super {
    constructor() {
      super(...arguments);
      this.emitter = new import_emittery.Typed();
      this.on = this.emitter.on.bind(this.emitter);
      this.off = this.emitter.off.bind(this.emitter);
      this.emit = this.emitter.emit.bind(this.emitter);
    }
  };
}
var RpcClientService = Symbol.for("RpcClientService");
var RpcServerService = Symbol.for("RpcServerService");
var TYPE_EVENT = "brxm:event";
var TYPE_RESPONSE = "brxm:response";
var TYPE_REQUEST = "brxm:request";
var STATE_FULFILLED = "fulfilled";
var STATE_REJECTED = "rejected";
var Dummy = class {
};
var Rpc = class extends EmitterMixin(Dummy) {
  constructor() {
    super(...arguments);
    this.calls = /* @__PURE__ */ new Map();
    this.callbacks = /* @__PURE__ */ new Map();
  }
  generateId() {
    let id;
    do {
      id = `${Math.random()}`.slice(2);
    } while (this.calls.has(id));
    return id;
  }
  call(command, ...payload) {
    return new Promise((resolve2, reject) => {
      const id = this.generateId();
      this.calls.set(id, [resolve2, reject]);
      this.send({
        id,
        command,
        payload,
        type: TYPE_REQUEST
      });
    });
  }
  register(command, callback2) {
    this.callbacks.set(command, callback2);
  }
  trigger(event, payload) {
    this.send({
      event,
      payload,
      type: TYPE_EVENT
    });
  }
  process(message) {
    switch (message === null || message === void 0 ? void 0 : message.type) {
      case TYPE_EVENT:
        this.processEvent(message);
        break;
      case TYPE_RESPONSE:
        this.processResponse(message);
        break;
      case TYPE_REQUEST:
        this.processRequest(message);
        break;
    }
  }
  processEvent(event) {
    this.emit(event.event, event.payload);
  }
  processResponse(response) {
    if (!this.calls.has(response.id)) {
      return;
    }
    const [resolve2, reject] = this.calls.get(response.id);
    this.calls.delete(response.id);
    if (response.state === STATE_REJECTED) {
      reject(response.result);
    }
    resolve2(response.result);
  }
  processRequest(request) {
    return __awaiter(this, void 0, void 0, function* () {
      const callback2 = this.callbacks.get(request.command);
      if (!callback2) {
        return;
      }
      try {
        this.send({
          type: TYPE_RESPONSE,
          id: request.id,
          state: STATE_FULFILLED,
          result: yield callback2(...request.payload)
        });
      } catch (result) {
        this.send({
          result,
          type: TYPE_RESPONSE,
          id: request.id,
          state: STATE_REJECTED
        });
      }
    });
  }
};
var CmsService = Symbol.for("CmsService");
var GLOBAL_WINDOW$2 = typeof window === "undefined" ? void 0 : window;
var CmsImpl = class CmsImpl2 {
  constructor(rpcClient, rpcServer, cmsEventBus, logger) {
    var _a4;
    this.rpcClient = rpcClient;
    this.rpcServer = rpcServer;
    this.cmsEventBus = cmsEventBus;
    this.logger = logger;
    this.onStateChange = this.onStateChange.bind(this);
    (_a4 = this.cmsEventBus) === null || _a4 === void 0 ? void 0 : _a4.on("page.ready", this.onPageReady.bind(this));
    this.rpcClient.on("update", this.onUpdate.bind(this));
    this.rpcServer.register("inject", this.inject.bind(this));
  }
  initialize({ window: window2 = GLOBAL_WINDOW$2 }) {
    var _a4, _b, _c, _d;
    if (this.window === window2) {
      return;
    }
    this.window = window2;
    if (((_b = (_a4 = this.window) === null || _a4 === void 0 ? void 0 : _a4.document) === null || _b === void 0 ? void 0 : _b.readyState) !== "loading") {
      this.onInitialize();
      return;
    }
    (_d = (_c = this.window) === null || _c === void 0 ? void 0 : _c.document) === null || _d === void 0 ? void 0 : _d.addEventListener("readystatechange", this.onStateChange);
  }
  onInitialize() {
    var _a4;
    (_a4 = this.logger) === null || _a4 === void 0 ? void 0 : _a4.debug("The page is ready to accept incoming messages.");
    this.rpcServer.trigger("ready", void 0);
  }
  onStateChange() {
    if (this.window.document.readyState === "loading") {
      return;
    }
    this.onInitialize();
    this.window.document.removeEventListener("readystatechange", this.onStateChange);
  }
  onPageReady() {
    var _a4;
    (_a4 = this.logger) === null || _a4 === void 0 ? void 0 : _a4.debug("Synchronizing the page.");
    this.rpcClient.call("sync");
  }
  onUpdate(event) {
    var _a4, _b, _c;
    (_a4 = this.logger) === null || _a4 === void 0 ? void 0 : _a4.debug("Received update event.");
    (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug("Event:", event);
    (_c = this.cmsEventBus) === null || _c === void 0 ? void 0 : _c.emit("cms.update", event);
  }
  inject(resource) {
    var _a4, _b, _c;
    if (!((_a4 = this.window) === null || _a4 === void 0 ? void 0 : _a4.document)) {
      return Promise.reject(new Error("SPA document is not ready."));
    }
    (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug("Received request to inject a resource.");
    (_c = this.logger) === null || _c === void 0 ? void 0 : _c.debug("Resource:", resource);
    return new Promise((resolve2, reject) => {
      const script = this.window.document.createElement("script");
      script.type = "text/javascript";
      script.src = resource;
      script.addEventListener("load", () => resolve2());
      script.addEventListener("error", () => reject(new Error(`Failed to load resource '${resource}'.`)));
      this.window.document.body.appendChild(script);
    });
  }
};
CmsImpl = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(RpcClientService)), __param(1, (0, import_inversify.inject)(RpcServerService)), __param(2, (0, import_inversify.inject)(CmsEventBusService)), __param(2, (0, import_inversify.optional)()), __param(3, (0, import_inversify.inject)(Logger)), __param(3, (0, import_inversify.optional)()), __metadata("design:paramtypes", [Object, Object, Object, Logger])], CmsImpl);
var GLOBAL_WINDOW$1 = typeof window === "undefined" ? void 0 : window;
var Cms14Impl = class Cms14Impl2 {
  constructor(eventBus, logger) {
    this.eventBus = eventBus;
    this.logger = logger;
    this.postponed = [];
  }
  flush() {
    return __awaiter(this, void 0, void 0, function* () {
      this.postponed.splice(0).forEach((task) => task());
    });
  }
  postpone(task) {
    return (...args) => {
      if (this.api) {
        return task.apply(this, args);
      }
      this.postponed.push(task.bind(this, ...args));
      return void 0;
    };
  }
  initialize({ window: window2 = GLOBAL_WINDOW$1 }) {
    var _a4, _b;
    if (this.api || !window2 || window2.SPA) {
      return;
    }
    (_a4 = this.logger) === null || _a4 === void 0 ? void 0 : _a4.debug("Initiating a handshake with the Experience Manager.");
    (_b = this.eventBus) === null || _b === void 0 ? void 0 : _b.on("page.ready", this.postpone(this.sync));
    window2.SPA = {
      init: this.onInit.bind(this),
      renderComponent: this.onRenderComponent.bind(this)
    };
  }
  onInit(api) {
    var _a4;
    (_a4 = this.logger) === null || _a4 === void 0 ? void 0 : _a4.debug("Completed the handshake with the Experience Manager.");
    this.api = api;
    this.flush();
  }
  onRenderComponent(id, properties) {
    var _a4, _b, _c, _d;
    (_a4 = this.logger) === null || _a4 === void 0 ? void 0 : _a4.debug("Received component rendering request.");
    (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug("Component:", id);
    (_c = this.logger) === null || _c === void 0 ? void 0 : _c.debug("Properties", properties);
    (_d = this.eventBus) === null || _d === void 0 ? void 0 : _d.emit("cms.update", {
      id,
      properties
    });
  }
  sync() {
    var _a4;
    (_a4 = this.logger) === null || _a4 === void 0 ? void 0 : _a4.debug("Synchronizing the page.");
    this.api.sync();
  }
};
Cms14Impl = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(CmsEventBusService)), __param(0, (0, import_inversify.optional)()), __param(1, (0, import_inversify.inject)(Logger)), __param(1, (0, import_inversify.optional)()), __metadata("design:paramtypes", [Object, Logger])], Cms14Impl);
function parseUrl(url) {
  const DUMMY_BASE_URL = "http://example.com";
  const parsedUrl = new URL(url, DUMMY_BASE_URL);
  const { hash, search, searchParams } = parsedUrl;
  let { origin, pathname } = parsedUrl;
  origin = origin !== DUMMY_BASE_URL ? origin : "";
  if (url.startsWith("//")) {
    origin = origin.replace(parsedUrl.protocol, "");
  }
  if (url.startsWith(origin) && !url.replace(origin, "").startsWith("/") && pathname.startsWith("/")) {
    pathname = pathname.substring(1);
  }
  return {
    hash,
    origin,
    pathname,
    search,
    searchParams,
    path: `${pathname}${search}${hash}`
  };
}
function buildUrl(url) {
  var _a4, _b, _c, _d, _e, _f, _g;
  const searchParams = (_b = (_a4 = url.searchParams) === null || _a4 === void 0 ? void 0 : _a4.toString()) !== null && _b !== void 0 ? _b : "";
  const search = (_c = url.search) !== null && _c !== void 0 ? _c : `${searchParams && `?${searchParams}`}`;
  const path = (_d = url.path) !== null && _d !== void 0 ? _d : `${(_e = url.pathname) !== null && _e !== void 0 ? _e : ""}${search}${(_f = url.hash) !== null && _f !== void 0 ? _f : ""}`;
  return `${(_g = url.origin) !== null && _g !== void 0 ? _g : ""}${path}`;
}
function mergeSearchParams(params, ...rest) {
  const result = new URLSearchParams(params);
  rest.forEach((restParams) => restParams.forEach((value, key) => result.set(key, value)));
  return result;
}
function appendSearchParams(url, params) {
  const { hash, origin, pathname, searchParams } = parseUrl(url);
  return buildUrl({
    hash,
    origin,
    pathname,
    searchParams: mergeSearchParams(searchParams, params)
  });
}
function extractSearchParams(url, params) {
  const { hash, origin, pathname, searchParams } = parseUrl(url);
  const extracted = new URLSearchParams();
  params.forEach((param) => {
    if (searchParams.has(param)) {
      extracted.set(param, searchParams.get(param));
      searchParams.delete(param);
    }
  });
  return {
    searchParams: extracted,
    url: buildUrl({
      hash,
      origin,
      pathname,
      searchParams
    })
  };
}
function isAbsoluteUrl(url) {
  const { origin, pathname } = parseUrl(url);
  return !!origin || pathname.startsWith("/");
}
function isMatchedOrigin(origin, baseOrigin) {
  const [schema, host = ""] = origin.split("//", 2);
  const [baseSchema, baseHost = ""] = baseOrigin.split("//", 2);
  return !baseOrigin || !origin || (!schema || !baseSchema || schema === baseSchema) && baseHost === host;
}
function isMatchedPathname(pathname, basePathname) {
  return !basePathname || pathname.startsWith(basePathname);
}
function isMatchedQuery(search, baseSearch) {
  let match = true;
  baseSearch.forEach((value, key) => {
    match = match && (!value && search.has(key) || search.getAll(key).includes(value));
  });
  return match;
}
function isMatched(link, base = "") {
  const linkUrl = parseUrl(link);
  const baseUrl = parseUrl(base);
  return isMatchedOrigin(linkUrl.origin, baseUrl.origin) && isMatchedPathname(linkUrl.pathname, baseUrl.pathname) && isMatchedQuery(linkUrl.searchParams, baseUrl.searchParams);
}
function resolveUrl(url, base) {
  const baseUrl = parseUrl(base);
  const sourceUrl = parseUrl(url);
  const pathname = sourceUrl.pathname.startsWith("/") ? sourceUrl.pathname : `${baseUrl.pathname}${baseUrl.pathname.endsWith("/") || !sourceUrl.pathname ? "" : "/"}${sourceUrl.pathname}`;
  return buildUrl({
    pathname,
    hash: sourceUrl.hash || baseUrl.hash,
    origin: sourceUrl.origin || baseUrl.origin,
    searchParams: mergeSearchParams(baseUrl.searchParams, sourceUrl.searchParams)
  });
}
var UrlBuilderOptionsToken = Symbol.for("UrlBuilderOptionsToken");
var UrlBuilderService = Symbol.for("UrlBuilderService");
var UrlBuilderImpl$1 = class UrlBuilderImpl {
  constructor(options) {
    var _a4, _b;
    this.endpoint = parseUrl((_a4 = options.endpoint) !== null && _a4 !== void 0 ? _a4 : "");
    this.baseUrl = parseUrl((_b = options.baseUrl) !== null && _b !== void 0 ? _b : "");
  }
  getApiUrl(link) {
    const { pathname, searchParams } = parseUrl(link);
    if (this.baseUrl.pathname && !pathname.startsWith(this.baseUrl.pathname)) {
      throw new Error(`The path "${pathname}" does not start with the base path "${this.baseUrl.pathname}".`);
    }
    const route = pathname.substring(this.baseUrl.pathname.length);
    return buildUrl({
      origin: this.endpoint.origin,
      pathname: `${this.endpoint.pathname}${route}`,
      searchParams: mergeSearchParams(searchParams, this.endpoint.searchParams)
    });
  }
  getSpaUrl(link) {
    const { hash, pathname, searchParams } = parseUrl(link);
    const route = !pathname.startsWith("/") && !this.baseUrl.pathname ? `/${pathname}` : pathname;
    return buildUrl({
      origin: this.baseUrl.origin,
      pathname: `${this.baseUrl.pathname}${route}`,
      searchParams: mergeSearchParams(searchParams, this.baseUrl.searchParams),
      hash: hash || this.baseUrl.hash
    });
  }
};
UrlBuilderImpl$1 = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(UrlBuilderOptionsToken)), __metadata("design:paramtypes", [Object])], UrlBuilderImpl$1);
function UrlModule$1() {
  return new import_inversify.ContainerModule((bind) => {
    bind(UrlBuilderService).to(UrlBuilderImpl$1).inSingletonScope();
  });
}
var DEFAULT_API_BASE_URL = "/resourceapi";
var DEFAULT_SPA_BASE_URL = "";
var UrlBuilderImpl2 = class UrlBuilderImpl3 {
  constructor(options) {
    var _a4, _b, _c, _d;
    this.apiBaseUrl = parseUrl((_a4 = options.apiBaseUrl) !== null && _a4 !== void 0 ? _a4 : `${(_b = options.cmsBaseUrl) !== null && _b !== void 0 ? _b : ""}${DEFAULT_API_BASE_URL}`);
    this.cmsBaseUrl = parseUrl((_c = options.cmsBaseUrl) !== null && _c !== void 0 ? _c : "");
    this.spaBaseUrl = parseUrl((_d = options.spaBaseUrl) !== null && _d !== void 0 ? _d : DEFAULT_SPA_BASE_URL);
  }
  getApiUrl(link) {
    const { pathname, searchParams } = parseUrl(link);
    if (this.apiBaseUrl.pathname && pathname.startsWith(this.apiBaseUrl.pathname)) {
      return buildUrl({
        pathname,
        origin: this.apiBaseUrl.origin,
        searchParams: mergeSearchParams(this.apiBaseUrl.searchParams, searchParams)
      });
    }
    if (this.spaBaseUrl.pathname && !pathname.startsWith(this.spaBaseUrl.pathname)) {
      throw new Error(`The path "${pathname}" does not start with the base path "${this.spaBaseUrl.pathname}".`);
    }
    const route = pathname.substring(this.spaBaseUrl.pathname.length);
    return buildUrl({
      origin: this.apiBaseUrl.origin,
      pathname: `${this.apiBaseUrl.pathname}${route}`,
      searchParams: mergeSearchParams(searchParams, this.apiBaseUrl.searchParams)
    });
  }
  getSpaUrl(link) {
    const { hash, pathname, searchParams } = parseUrl(link);
    let route = pathname.startsWith(this.cmsBaseUrl.pathname) ? pathname.substring(this.cmsBaseUrl.pathname.length) : pathname;
    if (!route.startsWith("/") && !this.spaBaseUrl.pathname) {
      route = `/${route}`;
    }
    return buildUrl({
      origin: this.spaBaseUrl.origin,
      pathname: `${this.spaBaseUrl.pathname}${route}`,
      searchParams: mergeSearchParams(searchParams, this.spaBaseUrl.searchParams),
      hash: hash || this.spaBaseUrl.hash
    });
  }
};
UrlBuilderImpl2 = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(UrlBuilderOptionsToken)), __metadata("design:paramtypes", [Object])], UrlBuilderImpl2);
function UrlModule() {
  return new import_inversify.ContainerModule((bind) => {
    bind(UrlBuilderService).to(UrlBuilderImpl2).inSingletonScope();
  });
}
var PostMessageService = Symbol.for("PostMessageService");
var GLOBAL_WINDOW = typeof window === "undefined" ? void 0 : window;
var PostMessage = class PostMessage2 extends Rpc {
  constructor(logger) {
    super();
    this.logger = logger;
    this.onMessage = this.onMessage.bind(this);
  }
  initialize({ origin, window: window2 = GLOBAL_WINDOW }) {
    var _a4, _b;
    (_a4 = this.window) === null || _a4 === void 0 ? void 0 : _a4.removeEventListener("message", this.onMessage, false);
    this.origin = origin;
    this.window = window2;
    (_b = this.window) === null || _b === void 0 ? void 0 : _b.addEventListener("message", this.onMessage, false);
  }
  send(message) {
    var _a4, _b, _c;
    if (!this.origin) {
      return;
    }
    (_a4 = this.logger) === null || _a4 === void 0 ? void 0 : _a4.debug("[OUTGOING]", `[${this.origin}]`, message);
    (_c = (_b = this.window) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.postMessage(message, this.origin);
  }
  onMessage(event) {
    var _a4, _b;
    if (!event.data || !isMatched(event.origin, this.origin === "*" ? "" : this.origin)) {
      return;
    }
    if ((_a4 = event.data) === null || _a4 === void 0 ? void 0 : _a4.type) {
      (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug("[INCOMING]", `[${event.origin}]`, event.data);
    }
    this.process(event.data);
  }
};
PostMessage = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(Logger)), __param(0, (0, import_inversify.optional)()), __metadata("design:paramtypes", [Logger])], PostMessage);
function CmsModule() {
  return new import_inversify.ContainerModule((bind) => {
    bind(CmsEventBusService).toDynamicValue(() => new import_emittery.Typed()).inSingletonScope().when(() => typeof window !== "undefined");
    bind(PostMessageService).to(PostMessage).inSingletonScope();
    bind(RpcClientService).toService(PostMessageService);
    bind(RpcServerService).toService(PostMessageService);
    bind(CmsService).to(CmsImpl).inSingletonScope().whenTargetIsDefault();
    bind(CmsService).to(Cms14Impl).inSingletonScope().whenTargetNamed("cms14");
  });
}
function isConfigurationWithProxy(value) {
  var _a4, _b;
  return !!(((_a4 = value === null || value === void 0 ? void 0 : value.options) === null || _a4 === void 0 ? void 0 : _a4.live) && ((_b = value === null || value === void 0 ? void 0 : value.options) === null || _b === void 0 ? void 0 : _b.preview));
}
function isConfigurationWithJwt09(value) {
  return !!(value === null || value === void 0 ? void 0 : value.cmsBaseUrl);
}
var TYPE_LINK_EXTERNAL = "external";
var TYPE_LINK_INTERNAL = "internal";
var TYPE_LINK_RESOURCE = "resource";
var TYPE_LINK_UNKNOWN = "unknown";
function isLink3(value) {
  return !!value && (Object.prototype.hasOwnProperty.call(value, "href") || Object.prototype.hasOwnProperty.call(value, "type") && [TYPE_LINK_EXTERNAL, TYPE_LINK_INTERNAL, TYPE_LINK_RESOURCE, TYPE_LINK_UNKNOWN].includes(value.type));
}
var SimpleFactory = class {
  constructor() {
    this.mapping = /* @__PURE__ */ new Map();
  }
  /**
   * Registers a builder for the specified type.
   * @param type The entity type.
   * @param builder The entity builder.
   */
  register(type, builder) {
    this.mapping.set(type, builder);
    return this;
  }
};
var LinkFactory = class LinkFactory2 extends SimpleFactory {
  create(link) {
    if (isLink3(link)) {
      return this.createLink(link);
    }
    return this.createPath(link);
  }
  createLink(link) {
    if (!link.type || typeof link.href === "undefined" || !this.mapping.has(link.type)) {
      return link.href;
    }
    const builder = this.mapping.get(link.type);
    return builder(link.href);
  }
  createPath(path) {
    return this.createLink({
      href: path,
      type: TYPE_LINK_INTERNAL
    });
  }
};
LinkFactory = __decorate([(0, import_inversify.injectable)()], LinkFactory);
var MetaCollectionFactory = Symbol.for("MetaCollectionFactory");
var ComponentChildrenToken = Symbol.for("ComponentChildrenToken");
var ComponentModelToken = Symbol.for("ComponentModelToken");
var TYPE_COMPONENT$1 = "component";
var TYPE_COMPONENT_CONTAINER$1 = "container";
var TYPE_COMPONENT_CONTAINER_ITEM$1 = "container-item";
var TYPE_COMPONENT_CONTAINER_ITEM_CONTENT = "componentcontent";
var ComponentImpl$1 = class ComponentImpl {
  constructor(model, children, linkFactory, metaFactory) {
    this.model = model;
    this.children = children;
    this.linkFactory = linkFactory;
    this.meta = metaFactory(this.model.meta);
  }
  getId() {
    return this.model.id;
  }
  getMeta() {
    return this.meta;
  }
  getModels() {
    return this.model.models || {};
  }
  getUrl() {
    return this.linkFactory.create(this.model.links.self);
  }
  getName() {
    return this.model.name || "";
  }
  getParameters() {
    var _a4;
    return (_a4 = this.model.meta.params) !== null && _a4 !== void 0 ? _a4 : {};
  }
  getProperties() {
    return this.getParameters();
  }
  getChildren() {
    return this.children;
  }
  getComponent(...componentNames) {
    let component = this;
    while (componentNames.length && component) {
      const name = componentNames.shift();
      component = component.getChildren().find((childComponent) => childComponent.getName() === name);
    }
    return component;
  }
  getComponentById(id) {
    const queue = [this];
    while (queue.length) {
      const component = queue.shift();
      if (component.getId() === id) {
        return component;
      }
      queue.push(...component.getChildren());
    }
    return void 0;
  }
};
ComponentImpl$1 = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(ComponentModelToken)), __param(1, (0, import_inversify.inject)(ComponentChildrenToken)), __param(2, (0, import_inversify.inject)(LinkFactory)), __param(3, (0, import_inversify.inject)(MetaCollectionFactory)), __metadata("design:paramtypes", [Object, Array, LinkFactory, Function])], ComponentImpl$1);
var TYPE_COMPONENT = "COMPONENT";
var TYPE_COMPONENT_CONTAINER_ITEM = "CONTAINER_ITEM_COMPONENT";
var TYPE_COMPONENT_CONTAINER = "CONTAINER_COMPONENT";
var ComponentImpl2 = class ComponentImpl3 {
  constructor(model, children, metaFactory, urlBuilder) {
    this.model = model;
    this.children = children;
    this.urlBuilder = urlBuilder;
    this.meta = metaFactory(this.model._meta);
  }
  getId() {
    return this.model.id;
  }
  getMeta() {
    return this.meta;
  }
  getModels() {
    return this.model.models || {};
  }
  getUrl() {
    return this.urlBuilder.getApiUrl(this.model._links.componentRendering.href);
  }
  getName() {
    return this.model.name || "";
  }
  getParameters() {
    var _a4;
    return (_a4 = this.model._meta.params) !== null && _a4 !== void 0 ? _a4 : {};
  }
  getProperties() {
    return this.getParameters();
  }
  getChildren() {
    return this.children;
  }
  getComponent(...componentNames) {
    let component = this;
    while (componentNames.length && component) {
      const name = componentNames.shift();
      component = component.getChildren().find((childComponent) => childComponent.getName() === name);
    }
    return component;
  }
  getComponentById(id) {
    const queue = [this];
    while (queue.length) {
      const component = queue.shift();
      if (component.getId() === id) {
        return component;
      }
      queue.push(...component.getChildren());
    }
    return void 0;
  }
};
ComponentImpl2 = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(ComponentModelToken)), __param(1, (0, import_inversify.inject)(ComponentChildrenToken)), __param(2, (0, import_inversify.inject)(MetaCollectionFactory)), __param(3, (0, import_inversify.inject)(UrlBuilderService)), __metadata("design:paramtypes", [Object, Array, Function, Object])], ComponentImpl2);
var ContainerImpl$1 = class ContainerImpl extends ComponentImpl$1 {
  getChildren() {
    return this.children;
  }
  getType() {
    var _a4;
    return (_a4 = this.model.xtype) === null || _a4 === void 0 ? void 0 : _a4.toLowerCase();
  }
};
ContainerImpl$1 = __decorate([(0, import_inversify.injectable)()], ContainerImpl$1);
var ContainerImpl2 = class ContainerImpl3 extends ComponentImpl2 {
  getChildren() {
    return this.children;
  }
  getType() {
    var _a4;
    return (_a4 = this.model.xtype) === null || _a4 === void 0 ? void 0 : _a4.toLowerCase();
  }
};
ContainerImpl2 = __decorate([(0, import_inversify.injectable)()], ContainerImpl2);
var PageEventBusService = Symbol("PageEventBusService");
function isReference(value) {
  return !!(value === null || value === void 0 ? void 0 : value.$ref);
}
function resolve(object, reference) {
  return reference.$ref.split("/").reduce((value, key) => key ? value === null || value === void 0 ? void 0 : value[key] : object, object);
}
var TYPE_CONTAINER_ITEM_UNDEFINED = Symbol.for("ContainerItemUndefined");
function getContainerItemContent(component, page) {
  const contentRef = component.getContentReference();
  if (!contentRef) {
    return null;
  }
  const componentContent = page.getContent(contentRef);
  if (!componentContent) {
    return null;
  }
  if ((componentContent === null || componentContent === void 0 ? void 0 : componentContent.type) !== TYPE_COMPONENT_CONTAINER_ITEM_CONTENT) {
    return null;
  }
  return componentContent.data;
}
var ContainerItemImpl$1 = class ContainerItemImpl extends EmitterMixin(ComponentImpl$1) {
  constructor(model, linkFactory, metaFactory, eventBus, logger) {
    super(model, [], linkFactory, metaFactory);
    this.model = model;
    this.metaFactory = metaFactory;
    this.logger = logger;
    eventBus === null || eventBus === void 0 ? void 0 : eventBus.on("page.update", this.onPageUpdate.bind(this));
  }
  onPageUpdate(event) {
    var _a4, _b;
    const page = event.page;
    const model = resolve(page, page.root);
    if ((model === null || model === void 0 ? void 0 : model.id) !== this.getId()) {
      return;
    }
    (_a4 = this.logger) === null || _a4 === void 0 ? void 0 : _a4.debug("Received container item update event.");
    (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug("Event:", event);
    this.model = model;
    this.meta = this.metaFactory(model.meta);
    this.emit("update", {});
  }
  getLabel() {
    return this.model.label;
  }
  getType() {
    var _a4;
    return (_a4 = this.model.ctype) !== null && _a4 !== void 0 ? _a4 : this.model.label;
  }
  isHidden() {
    return !!this.model.meta.hidden;
  }
  getParameters() {
    var _a4;
    return (_a4 = this.model.meta.paramsInfo) !== null && _a4 !== void 0 ? _a4 : {};
  }
  getContent(page) {
    return getContainerItemContent(this, page);
  }
  getContentReference() {
    return this.model.content;
  }
};
ContainerItemImpl$1 = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(ComponentModelToken)), __param(1, (0, import_inversify.inject)(LinkFactory)), __param(2, (0, import_inversify.inject)(MetaCollectionFactory)), __param(3, (0, import_inversify.inject)(PageEventBusService)), __param(3, (0, import_inversify.optional)()), __param(4, (0, import_inversify.inject)(Logger)), __param(4, (0, import_inversify.optional)()), __metadata("design:paramtypes", [Object, LinkFactory, Function, Object, Logger])], ContainerItemImpl$1);
var ContainerItemImpl2 = class ContainerItemImpl3 extends EmitterMixin(ComponentImpl2) {
  constructor(model, metaFactory, urlBuilder, eventBus, logger) {
    super(model, [], metaFactory, urlBuilder);
    this.model = model;
    this.metaFactory = metaFactory;
    this.logger = logger;
    eventBus === null || eventBus === void 0 ? void 0 : eventBus.on("page.update", this.onPageUpdate.bind(this));
  }
  onPageUpdate(event) {
    var _a4, _b;
    const { page: model } = event.page;
    if (model.id !== this.getId()) {
      return;
    }
    (_a4 = this.logger) === null || _a4 === void 0 ? void 0 : _a4.debug("Received container item update event.");
    (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug("Event:", event);
    this.model = model;
    this.meta = this.metaFactory(model._meta);
    this.emit("update", {});
  }
  getLabel() {
    return this.model.label;
  }
  getType() {
    var _a4;
    return (_a4 = this.model.ctype) !== null && _a4 !== void 0 ? _a4 : this.model.label;
  }
  isHidden() {
    return !!this.model._meta.hidden;
  }
  getParameters() {
    var _a4;
    return (_a4 = this.model._meta.paramsInfo) !== null && _a4 !== void 0 ? _a4 : {};
  }
  getContent() {
    var _a4;
    (_a4 = this.logger) === null || _a4 === void 0 ? void 0 : _a4.warn('The method "getContent" is not supported in PMA 0.9 and always returns "null".');
    return null;
  }
  getContentReference() {
    var _a4;
    (_a4 = this.logger) === null || _a4 === void 0 ? void 0 : _a4.warn('The method "getContentReference" is not supported in PMA 0.9 and always returns "undefined".');
    return void 0;
  }
};
ContainerItemImpl2 = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(ComponentModelToken)), __param(1, (0, import_inversify.inject)(MetaCollectionFactory)), __param(2, (0, import_inversify.inject)(UrlBuilderService)), __param(3, (0, import_inversify.inject)(PageEventBusService)), __param(3, (0, import_inversify.optional)()), __param(4, (0, import_inversify.inject)(Logger)), __param(4, (0, import_inversify.optional)()), __metadata("design:paramtypes", [Object, Function, Object, Object, Logger])], ContainerItemImpl2);
var TYPE_META_COMMENT = "comment";
var META_POSITION_BEGIN = "begin";
var META_POSITION_END = "end";
var MetaImpl = class {
  constructor(model, position) {
    this.model = model;
    this.position = position;
  }
  getData() {
    return this.model.data;
  }
  getPosition() {
    return this.position;
  }
};
var HTML_COMMENT = /^<!--(.*)-->$/;
var MetaCommentImpl = class extends MetaImpl {
  getData() {
    const data = super.getData();
    const [, payload = data] = data.match(HTML_COMMENT) || [];
    return payload;
  }
};
function isMetaComment(value) {
  return value instanceof MetaCommentImpl;
}
var MetaFactory = class MetaFactory2 extends SimpleFactory {
  create(meta, position) {
    const builder = this.mapping.get(meta.type);
    if (!builder) {
      throw new Error(`Unsupported meta type: '${meta.type}'.`);
    }
    return builder(meta, position);
  }
};
MetaFactory = __decorate([(0, import_inversify.injectable)()], MetaFactory);
var MetaCollectionImpl_1;
var MetaCollectionModelToken = Symbol.for("MetaCollectionModelToken");
var MetaCollectionImpl = MetaCollectionImpl_1 = class MetaCollectionImpl2 extends Array {
  constructor(model, metaFactory) {
    super(...(model.beginNodeSpan || []).map((beginModel) => metaFactory.create(beginModel, META_POSITION_BEGIN)), ...(model.endNodeSpan || []).map((endModel) => metaFactory.create(endModel, META_POSITION_END)));
    this.comments = [];
    const prototype = Object.create(MetaCollectionImpl_1.prototype);
    prototype.constructor = Array.prototype.constructor;
    Object.setPrototypeOf(this, prototype);
    Object.freeze(this);
  }
  clear(comments = [...this.comments]) {
    comments.forEach((comment) => {
      comment.remove();
      const index2 = this.comments.indexOf(comment);
      if (index2 > -1) {
        this.comments.splice(index2, 1);
      }
    });
  }
  render(head, tail) {
    var _a4;
    const document2 = (_a4 = head.ownerDocument) !== null && _a4 !== void 0 ? _a4 : tail.ownerDocument;
    const comments = document2 ? [...this.filter(isMetaComment).filter((meta) => meta.getPosition() === META_POSITION_BEGIN).map((meta) => document2.createComment(meta.getData())).map((comment) => {
      var _a5;
      (_a5 = head.parentNode) === null || _a5 === void 0 ? void 0 : _a5.insertBefore(comment, head);
      return comment;
    }), ...this.filter(isMetaComment).filter((meta) => meta.getPosition() === META_POSITION_END).reverse().map((meta) => document2.createComment(meta.getData())).map((comment) => {
      var _a5, _b;
      if (tail.nextSibling) {
        (_a5 = tail.parentNode) === null || _a5 === void 0 ? void 0 : _a5.insertBefore(comment, tail.nextSibling);
      } else {
        (_b = tail.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(comment);
      }
      return comment;
    })] : [];
    this.comments.push(...comments);
    return this.clear.bind(this, comments);
  }
};
MetaCollectionImpl = MetaCollectionImpl_1 = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(MetaCollectionModelToken)), __param(1, (0, import_inversify.inject)(MetaFactory)), __metadata("design:paramtypes", [Object, MetaFactory])], MetaCollectionImpl);
function isMetaCollection(value) {
  return value instanceof MetaCollectionImpl;
}
var ButtonFactory = class ButtonFactory2 extends SimpleFactory {
  constructor(metaCollectionFactory) {
    super();
    this.metaCollectionFactory = metaCollectionFactory;
  }
  create(type, ...params) {
    if (!this.mapping.has(type)) {
      throw new Error(`Unsupported button type: '${type}'.`);
    }
    const meta = this.mapping.get(type)(...params);
    return isMetaCollection(meta) ? meta : this.metaCollectionFactory(meta);
  }
};
ButtonFactory = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(MetaCollectionFactory)), __metadata("design:paramtypes", [Function])], ButtonFactory);
var ComponentFactory$1 = class ComponentFactory extends SimpleFactory {
  /**
   * Produces a component based on the page model.
   * @param page The page model.
   */
  create(page) {
    var _a4, _b;
    const heap = [page.root];
    const pool = /* @__PURE__ */ new Map();
    for (let i = 0; i < heap.length; i++) {
      heap.push(...(_b = (_a4 = resolve(page, heap[i])) === null || _a4 === void 0 ? void 0 : _a4.children) !== null && _b !== void 0 ? _b : []);
    }
    return heap.reverse().reduce((previous, reference) => {
      var _a5, _b2;
      const model = resolve(page, reference);
      const children = (_b2 = (_a5 = model === null || model === void 0 ? void 0 : model.children) === null || _a5 === void 0 ? void 0 : _a5.map((child) => pool.get(resolve(page, child)))) !== null && _b2 !== void 0 ? _b2 : [];
      const component = this.buildComponent(model, children);
      pool.set(model, component);
      return component;
    }, void 0);
  }
  buildComponent(model, children) {
    const builder = this.mapping.get(model.type);
    if (!builder) {
      throw new Error(`Unsupported component type: '${model.type}'.`);
    }
    return builder(model, children);
  }
};
ComponentFactory$1 = __decorate([(0, import_inversify.injectable)()], ComponentFactory$1);
var ContentFactory$1 = class ContentFactory extends SimpleFactory {
  create(model) {
    if (!this.mapping.has(model.type)) {
      return model;
    }
    return this.mapping.get(model.type)(model);
  }
};
ContentFactory$1 = __decorate([(0, import_inversify.injectable)()], ContentFactory$1);
var LinkRewriterService = Symbol.for("LinkRewriterService");
var LinkRewriterImpl = class LinkRewriterImpl2 {
  constructor(linkFactory) {
    this.linkFactory = linkFactory;
  }
  rewrite(content, type = "text/html") {
    const document2 = parseDocument(content, {
      xmlMode: type !== "text/html"
    });
    this.rewriteAnchors(document2);
    this.rewriteImages(document2);
    return esm_default2(document2, {
      selfClosingTags: true
    });
  }
  rewriteAnchors(document2) {
    Array.from(getElementsByTagName("a", document2)).filter((element) => hasAttrib(element, "href") && hasAttrib(element, "data-type")).forEach((element) => {
      const url = this.linkFactory.create({
        href: getAttributeValue(element, "href"),
        type: getAttributeValue(element, "data-type")
      });
      if (url) {
        element.attribs.href = url;
      }
      return element;
    });
  }
  rewriteImages(document2) {
    Array.from(getElementsByTagName("img", document2)).filter((element) => hasAttrib(element, "src")).forEach((element) => {
      const url = this.linkFactory.create({
        href: getAttributeValue(element, "src"),
        type: TYPE_LINK_RESOURCE
      });
      if (url) {
        element.attribs.src = url;
      }
    });
  }
};
LinkRewriterImpl = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(LinkFactory)), __metadata("design:paramtypes", [LinkFactory])], LinkRewriterImpl);
var PageModelToken = Symbol.for("PageModelToken");
var PageImpl$1 = class PageImpl {
  constructor(model, buttonFactory, componentFactory, contentFactory, linkFactory, linkRewriter, metaFactory, cmsEventBus, pageEventBus, logger) {
    this.model = model;
    this.buttonFactory = buttonFactory;
    this.contentFactory = contentFactory;
    this.linkFactory = linkFactory;
    this.linkRewriter = linkRewriter;
    this.metaFactory = metaFactory;
    this.cmsEventBus = cmsEventBus;
    this.logger = logger;
    this.content = /* @__PURE__ */ new WeakMap();
    pageEventBus === null || pageEventBus === void 0 ? void 0 : pageEventBus.on("page.update", this.onPageUpdate.bind(this));
    this.root = componentFactory.create(model);
  }
  onPageUpdate(event) {
    Object.assign(this.model.page, event.page.page);
  }
  getButton(type, ...params) {
    return this.buttonFactory.create(type, ...params);
  }
  getChannelParameters() {
    return this.model.channel.info.props;
  }
  getComponent(...componentNames) {
    var _a4;
    return (_a4 = this.root) === null || _a4 === void 0 ? void 0 : _a4.getComponent(...componentNames);
  }
  getContent(reference) {
    const model = resolve(this.model, isReference(reference) ? reference : {
      $ref: `/page/${reference}`
    });
    if (!model) {
      return void 0;
    }
    if (!this.content.has(model)) {
      this.content.set(model, this.contentFactory.create(model));
    }
    return this.content.get(model);
  }
  getDocument() {
    return this.model.document && this.getContent(this.model.document);
  }
  getLocale() {
    return this.model.meta.locale || "en_US";
  }
  getMeta(meta) {
    return this.metaFactory(meta);
  }
  getTitle() {
    var _a4, _b;
    return (_b = (_a4 = resolve(this.model, this.model.root)) === null || _a4 === void 0 ? void 0 : _a4.meta) === null || _b === void 0 ? void 0 : _b.pageTitle;
  }
  getUrl(link) {
    var _a4, _b, _c;
    if (typeof link === "undefined" || isLink3(link) || isAbsoluteUrl(link)) {
      return this.linkFactory.create((_b = (_a4 = link) !== null && _a4 !== void 0 ? _a4 : this.model.links.site) !== null && _b !== void 0 ? _b : "");
    }
    return resolveUrl(link, (_c = this.linkFactory.create(this.model.links.site)) !== null && _c !== void 0 ? _c : "");
  }
  getVersion() {
    return this.model.meta.version;
  }
  getVisitor() {
    return this.model.meta.visitor;
  }
  getVisit() {
    return this.model.meta.visit;
  }
  isPreview() {
    return !!this.model.meta.preview;
  }
  rewriteLinks(content, type = "text/html") {
    return this.linkRewriter.rewrite(content, type);
  }
  sync() {
    var _a4;
    (_a4 = this.cmsEventBus) === null || _a4 === void 0 ? void 0 : _a4.emit("page.ready", {});
  }
  toJSON() {
    return this.model;
  }
};
PageImpl$1 = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(PageModelToken)), __param(1, (0, import_inversify.inject)(ButtonFactory)), __param(2, (0, import_inversify.inject)(ComponentFactory$1)), __param(3, (0, import_inversify.inject)(ContentFactory$1)), __param(4, (0, import_inversify.inject)(LinkFactory)), __param(5, (0, import_inversify.inject)(LinkRewriterService)), __param(6, (0, import_inversify.inject)(MetaCollectionFactory)), __param(7, (0, import_inversify.inject)(CmsEventBusService)), __param(7, (0, import_inversify.optional)()), __param(8, (0, import_inversify.inject)(PageEventBusService)), __param(8, (0, import_inversify.optional)()), __param(9, (0, import_inversify.inject)(Logger)), __param(9, (0, import_inversify.optional)()), __metadata("design:paramtypes", [Object, ButtonFactory, ComponentFactory$1, ContentFactory$1, LinkFactory, Object, Function, Object, Object, Logger])], PageImpl$1);
function isPage$2(value) {
  return value instanceof PageImpl$1;
}
var ComponentFactory2 = class ComponentFactory3 extends SimpleFactory {
  /**
   * Produces a component based on the model.
   * @param model The component model.
   */
  create(model) {
    var _a4, _b;
    let component;
    const queue = [{
      model
    }];
    while (queue.length) {
      const head = queue.shift();
      if (!head.children && ((_a4 = head.model.components) === null || _a4 === void 0 ? void 0 : _a4.length)) {
        head.children = [];
        queue.unshift(...head.model.components.map((componentModel) => ({
          model: componentModel,
          siblings: head.children
        })), head);
        continue;
      }
      component = this.buildComponent(head.model, (_b = head.children) !== null && _b !== void 0 ? _b : []);
      if (head.siblings) {
        head.siblings.push(component);
      }
    }
    return component;
  }
  buildComponent(model, children) {
    const builder = this.mapping.get(model.type);
    if (!builder) {
      throw new Error(`Unsupported component type: '${model.type}'.`);
    }
    return builder(model, children);
  }
};
ComponentFactory2 = __decorate([(0, import_inversify.injectable)()], ComponentFactory2);
var ContentFactory2 = Symbol.for("ContentFactory");
var PageImpl_1;
var PageImpl2 = PageImpl_1 = class PageImpl3 {
  constructor(model, buttonFactory, componentFactory, contentFactory, linkFactory, linkRewriter, metaFactory, cmsEventBus, eventBus, logger) {
    this.model = model;
    this.buttonFactory = buttonFactory;
    this.contentFactory = contentFactory;
    this.linkFactory = linkFactory;
    this.linkRewriter = linkRewriter;
    this.metaFactory = metaFactory;
    this.cmsEventBus = cmsEventBus;
    this.logger = logger;
    eventBus === null || eventBus === void 0 ? void 0 : eventBus.on("page.update", this.onPageUpdate.bind(this));
    this.root = componentFactory.create(model.page);
    this.content = new Map(Object.entries(model.content || {}).map(([alias, m]) => [alias, this.contentFactory(m)]));
  }
  onPageUpdate(event) {
    Object.entries(event.page.content || {}).forEach(([alias, model]) => this.content.set(alias, this.contentFactory(model)));
  }
  static getContentReference(reference) {
    return reference.$ref.split("/", 3)[2] || "";
  }
  getButton(type, ...params) {
    return this.buttonFactory.create(type, ...params);
  }
  getChannelParameters() {
    var _a4, _b;
    return (_b = (_a4 = this.model.channel) === null || _a4 === void 0 ? void 0 : _a4.info.props) !== null && _b !== void 0 ? _b : {};
  }
  getComponent(...componentNames) {
    return this.root.getComponent(...componentNames);
  }
  getContent(reference) {
    const contentReference = isReference(reference) ? PageImpl_1.getContentReference(reference) : reference;
    return this.content.get(contentReference);
  }
  getDocument() {
    throw new Error("The page document is not supported by this version of the Page Model API.");
  }
  getLocale() {
    throw new Error("The locale is not supported by this version of the Page Model API.");
  }
  getMeta(meta) {
    return this.metaFactory(meta);
  }
  getTitle() {
    return this.model.page._meta.pageTitle;
  }
  getUrl(link) {
    var _a4;
    return this.linkFactory.create((_a4 = link) !== null && _a4 !== void 0 ? _a4 : Object.assign(Object.assign({}, this.model._links.site), {
      type: TYPE_LINK_INTERNAL
    }));
  }
  getVersion() {
    return this.model._meta.version;
  }
  getVisitor() {
    return this.model._meta.visitor;
  }
  getVisit() {
    return this.model._meta.visit;
  }
  isPreview() {
    return !!this.model._meta.preview;
  }
  rewriteLinks(content, type = "text/html") {
    return this.linkRewriter.rewrite(content, type);
  }
  sync() {
    var _a4;
    (_a4 = this.cmsEventBus) === null || _a4 === void 0 ? void 0 : _a4.emit("page.ready", {});
  }
  toJSON() {
    return this.model;
  }
};
PageImpl2 = PageImpl_1 = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(PageModelToken)), __param(1, (0, import_inversify.inject)(ButtonFactory)), __param(2, (0, import_inversify.inject)(ComponentFactory2)), __param(3, (0, import_inversify.inject)(ContentFactory2)), __param(4, (0, import_inversify.inject)(LinkFactory)), __param(5, (0, import_inversify.inject)(LinkRewriterService)), __param(6, (0, import_inversify.inject)(MetaCollectionFactory)), __param(7, (0, import_inversify.inject)(CmsEventBusService)), __param(8, (0, import_inversify.inject)(PageEventBusService)), __param(8, (0, import_inversify.optional)()), __param(9, (0, import_inversify.inject)(Logger)), __param(9, (0, import_inversify.optional)()), __metadata("design:paramtypes", [Object, ButtonFactory, ComponentFactory2, Function, LinkFactory, Object, Function, Object, Object, Logger])], PageImpl2);
function isPage$1(value) {
  return value instanceof PageImpl2;
}
var ContentModelToken = Symbol.for("ContentModelToken");
var ContentImpl = class ContentImpl2 {
  constructor(model, linkFactory, metaFactory) {
    var _a4;
    this.model = model;
    this.linkFactory = linkFactory;
    this.meta = metaFactory((_a4 = this.model._meta) !== null && _a4 !== void 0 ? _a4 : {});
  }
  getId() {
    return this.model.id;
  }
  getLocale() {
    return this.model.localeString;
  }
  getMeta() {
    return this.meta;
  }
  getName() {
    return this.model.name;
  }
  getData() {
    return this.model;
  }
  getUrl() {
    return this.linkFactory.create(this.model._links.site);
  }
};
ContentImpl = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(ContentModelToken)), __param(1, (0, import_inversify.inject)(LinkFactory)), __param(2, (0, import_inversify.inject)(MetaCollectionFactory)), __metadata("design:paramtypes", [Object, LinkFactory, Function])], ContentImpl);
var DocumentModelToken = Symbol.for("DocumentModelToken");
var TYPE_DOCUMENT = "document";
var DocumentImpl = class DocumentImpl2 {
  constructor(model, linkFactory, metaFactory) {
    var _a4;
    this.model = model;
    this.linkFactory = linkFactory;
    this.meta = metaFactory((_a4 = this.model.meta) !== null && _a4 !== void 0 ? _a4 : {});
  }
  getId() {
    return this.model.data.id;
  }
  getLocale() {
    return this.model.data.localeString;
  }
  getMeta() {
    return this.meta;
  }
  getName() {
    return this.model.data.name;
  }
  getData() {
    return this.model.data;
  }
  getUrl() {
    return this.linkFactory.create(this.model.links.site);
  }
};
DocumentImpl = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(DocumentModelToken)), __param(1, (0, import_inversify.inject)(LinkFactory)), __param(2, (0, import_inversify.inject)(MetaCollectionFactory)), __metadata("design:paramtypes", [Object, LinkFactory, Function])], DocumentImpl);
var ImageFactory = Symbol.for("ImageFactory");
var ImageModelToken = Symbol.for("ImageModelToken");
var ImageImpl = class ImageImpl2 {
  constructor(model, linkFactory) {
    this.model = model;
    this.linkFactory = linkFactory;
  }
  getDisplayName() {
    return this.model.displayName;
  }
  getFileName() {
    var _a4;
    return (_a4 = this.model.fileName) !== null && _a4 !== void 0 ? _a4 : void 0;
  }
  getHeight() {
    return this.model.height;
  }
  getMimeType() {
    return this.model.mimeType;
  }
  getName() {
    return this.model.name;
  }
  getSize() {
    return this.model.size;
  }
  getUrl() {
    return this.model.links.site && this.linkFactory.create(this.model.links.site);
  }
  getWidth() {
    return this.model.width;
  }
};
ImageImpl = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(ImageModelToken)), __param(1, (0, import_inversify.inject)(LinkFactory)), __metadata("design:paramtypes", [Object, LinkFactory])], ImageImpl);
var ImageSetModelToken = Symbol.for("ImageSetModelToken");
var TYPE_IMAGE_SET = "imageset";
var ImageSetImpl = class ImageSetImpl2 {
  constructor(model, imageFactory) {
    this.model = model;
    this.original = model.data.original ? imageFactory(model.data.original) : void 0;
    this.thumbnail = model.data.thumbnail ? imageFactory(model.data.thumbnail) : void 0;
  }
  getDescription() {
    var _a4;
    return (_a4 = this.model.data.description) !== null && _a4 !== void 0 ? _a4 : void 0;
  }
  getDisplayName() {
    return this.model.data.displayName;
  }
  getFileName() {
    var _a4;
    return (_a4 = this.model.data.fileName) !== null && _a4 !== void 0 ? _a4 : void 0;
  }
  getId() {
    return this.model.data.id;
  }
  getLocale() {
    var _a4;
    return (_a4 = this.model.data.localeString) !== null && _a4 !== void 0 ? _a4 : void 0;
  }
  getName() {
    return this.model.data.name;
  }
  getOriginal() {
    return this.original;
  }
  getThumbnail() {
    return this.thumbnail;
  }
};
ImageSetImpl = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(ImageSetModelToken)), __param(1, (0, import_inversify.inject)(ImageFactory)), __metadata("design:paramtypes", [Object, Function])], ImageSetImpl);
var TYPE_MANAGE_CONTENT_BUTTON = "MANAGE_CONTENT_LINK";
function createManageContentButton(params) {
  var _a4;
  const meta = (_a4 = params.content) === null || _a4 === void 0 ? void 0 : _a4.getMeta();
  const entries = [["defaultPath", params.path], ["documentTemplateQuery", params.documentTemplateQuery], ["folderTemplateQuery", params.folderTemplateQuery], ["rootPath", params.root], ["parameterName", params.parameter], ["parameterValueIsRelativePath", params.relative ? "true" : void 0], ["pickerEnableUpload", params.pickerEnableUpload], ["pickerConfiguration", params.pickerConfiguration], ["pickerInitialPath", params.pickerInitialPath], ["pickerRemembersLastVisited", params.pickerRemembersLastVisited ? "true" : void 0], ["pickerRootPath", params.pickerRootPath], ["pickerSelectableNodeTypes", params.pickerSelectableNodeTypes]].filter(([, value]) => !!value);
  if (!entries.length) {
    return meta !== null && meta !== void 0 ? meta : {};
  }
  const model = Object.fromEntries(entries);
  if (!meta) {
    return {
      beginNodeSpan: [{
        type: TYPE_META_COMMENT,
        data: JSON.stringify(Object.assign({
          "HST-Type": TYPE_MANAGE_CONTENT_BUTTON
        }, model))
      }]
    };
  }
  const merge = (item) => ({
    type: TYPE_META_COMMENT,
    data: JSON.stringify(Object.assign(JSON.parse(item.getData()), model))
  });
  return {
    beginNodeSpan: meta.filter((item) => item.getPosition() === META_POSITION_BEGIN).map(merge),
    endNodeSpan: meta.filter((item) => item.getPosition() === META_POSITION_END).map(merge)
  };
}
var MenuItemFactory = Symbol.for("MenuItemFactory");
var MenuItemModelToken = Symbol.for("MenuItemModelToken");
var MenuItemImpl = class MenuItemImpl2 {
  constructor(model, linkFactory, menuItemFactory) {
    this.model = model;
    this.linkFactory = linkFactory;
    this.children = model.childMenuItems.map(menuItemFactory);
  }
  getChildren() {
    return this.children;
  }
  getDepth() {
    return this.model.depth;
  }
  getLink() {
    return this.model.links.site;
  }
  getName() {
    return this.model.name;
  }
  getParameters() {
    return this.model.parameters;
  }
  getUrl() {
    return this.model.links.site && this.linkFactory.create(this.model.links.site);
  }
  isExpanded() {
    return this.model.expanded;
  }
  isRepositoryBased() {
    return this.model.repositoryBased;
  }
  isSelected() {
    return this.model.selected;
  }
};
MenuItemImpl = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(MenuItemModelToken)), __param(1, (0, import_inversify.inject)(LinkFactory)), __param(2, (0, import_inversify.inject)(MenuItemFactory)), __metadata("design:paramtypes", [Object, LinkFactory, Function])], MenuItemImpl);
var MenuModelToken = Symbol.for("MenuModelToken");
var TYPE_MANAGE_MENU_BUTTON = "EDIT_MENU_LINK";
var TYPE_MENU = "menu";
var MenuImpl = class MenuImpl2 {
  constructor(model, metaFactory, menuItemFactory) {
    this.model = model;
    this.items = model.data.siteMenuItems.map(menuItemFactory);
    this.meta = metaFactory(model.meta);
    this.selected = model.data.selectSiteMenuItem ? menuItemFactory(model.data.selectSiteMenuItem) : void 0;
  }
  getItems() {
    return this.items;
  }
  getMeta() {
    return this.meta;
  }
  getName() {
    return this.model.data.name;
  }
  getSelected() {
    return this.selected;
  }
};
MenuImpl = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(MenuModelToken)), __param(1, (0, import_inversify.inject)(MetaCollectionFactory)), __param(2, (0, import_inversify.inject)(MenuItemFactory)), __metadata("design:paramtypes", [Object, Function, Function])], MenuImpl);
var PageFactory = Symbol.for("PageFactory");
var PaginationItemFactory = Symbol.for("PaginationItemFactory");
var PaginationItemModelToken = Symbol.for("PaginationItemModelToken");
var PaginationItemImpl = class PaginationItemImpl2 {
  constructor(model, linkFactory) {
    this.model = model;
    this.linkFactory = linkFactory;
  }
  getNumber() {
    return this.model.number;
  }
  getUrl() {
    return this.linkFactory.create(this.model.links.site);
  }
};
PaginationItemImpl = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(PaginationItemModelToken)), __param(1, (0, import_inversify.inject)(LinkFactory)), __metadata("design:paramtypes", [Object, LinkFactory])], PaginationItemImpl);
var PaginationModelToken = Symbol.for("PaginationModelToken");
var TYPE_PAGINATION = "pagination";
var PaginationImpl = class PaginationImpl2 {
  constructor(model, paginationItemFactory) {
    this.model = model;
    this.current = paginationItemFactory(model.current);
    this.first = paginationItemFactory(model.first);
    this.last = paginationItemFactory(model.last);
    this.next = model.next ? paginationItemFactory(model.next) : void 0;
    this.previous = model.previous ? paginationItemFactory(model.previous) : void 0;
    this.pages = model.pages.map(paginationItemFactory);
  }
  getCurrent() {
    return this.current;
  }
  getFirst() {
    return this.first;
  }
  getItems() {
    return this.model.items;
  }
  getLast() {
    return this.last;
  }
  getNext() {
    return this.next;
  }
  getOffset() {
    return this.model.offset;
  }
  getPages() {
    return this.pages;
  }
  getPrevious() {
    return this.previous;
  }
  getSize() {
    return this.model.size;
  }
  getTotal() {
    return this.model.total;
  }
  isEnabled() {
    return this.model.enabled;
  }
};
PaginationImpl = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(PaginationModelToken)), __param(1, (0, import_inversify.inject)(PaginationItemFactory)), __metadata("design:paramtypes", [Object, Function])], PaginationImpl);
function PageModule$1() {
  return new import_inversify.ContainerModule((bind) => {
    bind(PageEventBusService).toDynamicValue(() => new import_emittery.Typed()).inSingletonScope().when(() => typeof window !== "undefined");
    bind(LinkRewriterService).to(LinkRewriterImpl).inSingletonScope();
    bind(ButtonFactory).toSelf().inSingletonScope().onActivation((context, factory) => factory.register(TYPE_MANAGE_CONTENT_BUTTON, createManageContentButton).register(TYPE_MANAGE_MENU_BUTTON, (menu) => menu.getMeta()));
    bind(LinkFactory).toSelf().inSingletonScope().onActivation(({ container: container2 }, factory) => {
      const url = container2.get(UrlBuilderService);
      return factory.register(TYPE_LINK_INTERNAL, url.getSpaUrl.bind(url));
    });
    bind(MetaCollectionFactory).toFactory(({ container: container2 }) => (model) => {
      const scope = container2.createChild();
      scope.bind(MetaCollectionImpl).toSelf();
      scope.bind(MetaCollectionModelToken).toConstantValue(model);
      return scope.get(MetaCollectionImpl);
    });
    bind(MetaFactory).toSelf().inSingletonScope().onActivation((context, factory) => factory.register(TYPE_META_COMMENT, (model, position) => new MetaCommentImpl(model, position)));
    bind(MenuItemFactory).toFactory(({ container: container2 }) => (model) => {
      const scope = container2.createChild();
      scope.bind(MenuItemImpl).toSelf();
      scope.bind(MenuItemModelToken).toConstantValue(model);
      return scope.get(MenuItemImpl);
    });
    bind(ImageFactory).toFactory(({ container: container2 }) => (model) => {
      const scope = container2.createChild();
      scope.bind(ImageImpl).toSelf();
      scope.bind(ImageModelToken).toConstantValue(model);
      return scope.get(ImageImpl);
    });
    bind(PaginationItemFactory).toFactory(({ container: container2 }) => (model) => {
      const scope = container2.createChild();
      scope.bind(PaginationItemImpl).toSelf();
      scope.bind(PaginationItemModelToken).toConstantValue(model);
      return scope.get(PaginationItemImpl);
    });
    bind(ContentFactory$1).toSelf().inSingletonScope().onActivation(({ container: container2 }, factory) => factory.register(TYPE_DOCUMENT, (model) => {
      const scope = container2.createChild();
      scope.bind(DocumentImpl).toSelf();
      scope.bind(DocumentModelToken).toConstantValue(model);
      return scope.get(DocumentImpl);
    }).register(TYPE_IMAGE_SET, (model) => {
      const scope = container2.createChild();
      scope.bind(ImageSetImpl).toSelf();
      scope.bind(ImageSetModelToken).toConstantValue(model);
      return scope.get(ImageSetImpl);
    }).register(TYPE_MENU, (model) => {
      const scope = container2.createChild();
      scope.bind(MenuImpl).toSelf();
      scope.bind(MenuModelToken).toConstantValue(model);
      return scope.get(MenuImpl);
    }).register(TYPE_PAGINATION, (model) => {
      const scope = container2.createChild();
      scope.bind(PaginationImpl).toSelf();
      scope.bind(PaginationModelToken).toConstantValue(model);
      return scope.get(PaginationImpl);
    }));
    bind(ComponentFactory$1).toSelf().inSingletonScope().onActivation(({ container: container2 }, factory) => factory.register(TYPE_COMPONENT$1, (model, children) => {
      const scope = container2.createChild();
      scope.bind(ComponentImpl$1).toSelf();
      scope.bind(ComponentModelToken).toConstantValue(model);
      scope.bind(ComponentChildrenToken).toConstantValue(children);
      return scope.get(ComponentImpl$1);
    }).register(TYPE_COMPONENT_CONTAINER$1, (model, children) => {
      const scope = container2.createChild();
      scope.bind(ContainerImpl$1).toSelf();
      scope.bind(ComponentModelToken).toConstantValue(model);
      scope.bind(ComponentChildrenToken).toConstantValue(children);
      return scope.get(ContainerImpl$1);
    }).register(TYPE_COMPONENT_CONTAINER_ITEM$1, (model) => {
      const scope = container2.createChild();
      scope.bind(ContainerItemImpl$1).toSelf();
      scope.bind(ComponentModelToken).toConstantValue(model);
      return scope.get(ContainerItemImpl$1);
    }));
    bind(PageFactory).toFactory(({ container: container2 }) => (model) => {
      const scope = container2.createChild();
      scope.bind(PageImpl$1).toSelf();
      scope.bind(PageModelToken).toConstantValue(model);
      return scope.get(PageImpl$1);
    });
  });
}
function PageModule() {
  return new import_inversify.ContainerModule((bind) => {
    bind(PageEventBusService).toDynamicValue(() => new import_emittery.Typed()).inSingletonScope().when(() => typeof window !== "undefined");
    bind(LinkRewriterService).to(LinkRewriterImpl).inSingletonScope();
    bind(ButtonFactory).toSelf().inSingletonScope().onActivation((context, factory) => factory.register(TYPE_MANAGE_CONTENT_BUTTON, createManageContentButton).register(TYPE_MANAGE_MENU_BUTTON, ({ _meta }) => _meta !== null && _meta !== void 0 ? _meta : {}));
    bind(LinkFactory).toSelf().inSingletonScope().onActivation(({ container: container2 }, factory) => {
      const url = container2.get(UrlBuilderService);
      return factory.register(TYPE_LINK_INTERNAL, url.getSpaUrl.bind(url));
    });
    bind(MetaCollectionFactory).toFactory(({ container: container2 }) => (model) => {
      const scope = container2.createChild();
      scope.bind(MetaCollectionImpl).toSelf();
      scope.bind(MetaCollectionModelToken).toConstantValue(model);
      return scope.get(MetaCollectionImpl);
    });
    bind(MetaFactory).toSelf().inSingletonScope().onActivation((context, factory) => factory.register(TYPE_META_COMMENT, (model, position) => new MetaCommentImpl(model, position)));
    bind(ContentFactory2).toFactory(({ container: container2 }) => (model) => {
      const scope = container2.createChild();
      scope.bind(ContentImpl).toSelf();
      scope.bind(ContentModelToken).toConstantValue(model);
      return scope.get(ContentImpl);
    });
    bind(ComponentFactory2).toSelf().inSingletonScope().onActivation(({ container: container2 }, factory) => factory.register(TYPE_COMPONENT, (model, children) => {
      const scope = container2.createChild();
      scope.bind(ComponentImpl2).toSelf();
      scope.bind(ComponentModelToken).toConstantValue(model);
      scope.bind(ComponentChildrenToken).toConstantValue(children);
      return scope.get(ComponentImpl2);
    }).register(TYPE_COMPONENT_CONTAINER, (model, children) => {
      const scope = container2.createChild();
      scope.bind(ContainerImpl2).toSelf();
      scope.bind(ComponentModelToken).toConstantValue(model);
      scope.bind(ComponentChildrenToken).toConstantValue(children);
      return scope.get(ContainerImpl2);
    }).register(TYPE_COMPONENT_CONTAINER_ITEM, (model) => {
      const scope = container2.createChild();
      scope.bind(ContainerItemImpl2).toSelf();
      scope.bind(ComponentModelToken).toConstantValue(model);
      return scope.get(ContainerItemImpl2);
    }));
    bind(PageFactory).toFactory(({ container: container2 }) => (model) => {
      const scope = container2.createChild();
      scope.bind(PageImpl2).toSelf();
      scope.bind(PageModelToken).toConstantValue(model);
      return scope.get(PageImpl2);
    });
  });
}
function isPage(value) {
  return isPage$2(value) || isPage$1(value);
}
var Cookie = class {
  /**
   * Set cookie in the document
   * @param name Cookie name
   * @param value Cookie value
   * @param ttl  Sets the cookie max-age in days
   */
  static SET_COOKIE(name, value, ttl) {
    if (this.isWindowAvailable() && name && value) {
      const maxAge = ttl > this.MAX_TTL_DAYS ? this.getSeconds(this.MAX_TTL_DAYS) : this.getSeconds(ttl);
      document.cookie = import_cookie.default.serialize(name, value, {
        maxAge
      });
    }
  }
  /**
   * Retrieve data from cookies
   * @return Cookie object.
   */
  static GET_COOKIE() {
    var _a4;
    return this.isWindowAvailable() ? import_cookie.default.parse((_a4 = document.cookie) !== null && _a4 !== void 0 ? _a4 : "") : {};
  }
  /**
   * Retrieve data from request cookies
   * @param request Current user's request.
   * @return Cookie object.
   */
  static GET_COOKIE_FROM_REQUEST(request) {
    var _a4, _b;
    return import_cookie.default.parse((_b = (_a4 = request.headers) === null || _a4 === void 0 ? void 0 : _a4.cookie) !== null && _b !== void 0 ? _b : "");
  }
  /**
   * Erase cookie in the document
   * @param name Cookie name
   */
  static ERASE_COOKIE(name) {
    if (this.isWindowAvailable()) {
      document.cookie = import_cookie.default.serialize(name, "", {
        maxAge: 0
      });
    }
  }
  /**
   * Check if Window is available
   */
  static isWindowAvailable() {
    return typeof window !== "undefined";
  }
  /**
   * Convert days to seconds
   * @param days Time in days
   * @return number
   */
  static getSeconds(days) {
    return days * 24 * 60 * 60;
  }
};
Cookie.MAX_TTL_DAYS = 28;
var Campaign = class {
  /**
   * Get the campaign variant from URL or cookie
   * @param campaignId Campaign id from URL
   * @param segmentId Segment id from URL
   * @param ttl TTL param in days from URL
   * @param request Current user's request
   * @return string
   */
  static GET_VARIANT_ID(campaignId, segmentId, ttl, request) {
    const TTL = this.getCookieTTL(ttl);
    if (TTL === 0) {
      return "";
    }
    if (campaignId && segmentId) {
      return `${campaignId}:${segmentId}`;
    }
    const { [this.CAMPAIGN_PARAMETER]: _campaignId, [this.SEGMENT_PARAMETER]: _segmentId } = (request === null || request === void 0 ? void 0 : request.headers) ? Cookie.GET_COOKIE_FROM_REQUEST(request) : Cookie.GET_COOKIE();
    if (_campaignId && _segmentId) {
      return `${_campaignId}:${_segmentId}`;
    }
    return "";
  }
  /**
   * Get cookie TTL value
   * @param ttl TTL param in days
   * @return number
   */
  static getCookieTTL(ttl) {
    const TTL = Number(ttl);
    return Number.isNaN(TTL) ? this.DEFAULT_TTL_DAYS : TTL;
  }
};
Campaign.CAMPAIGN_PARAMETER = "__br__campaign_id";
Campaign.SEGMENT_PARAMETER = "__br__segment";
Campaign.TTL_PARAMETER = "__br__ttl";
Campaign.DEFAULT_TTL_DAYS = 7;
var Segmentation = class {
  /**
   * Get the segmentIds from cookie
   * @return string
   */
  static GET_SEGMENT_IDS(request) {
    var _a4;
    const cookie2 = (request === null || request === void 0 ? void 0 : request.headers) ? Cookie.GET_COOKIE_FROM_REQUEST(request) : Cookie.GET_COOKIE();
    return (_a4 = cookie2[this.SEGMENT_IDS_PARAMETER]) !== null && _a4 !== void 0 ? _a4 : "";
  }
};
Segmentation.SEGMENT_IDS_PARAMETER = "__br__segment_ids";
var ApiImpl_1;
var DEFAULT_API_VERSION_HEADER = "Accept-Version";
var DEFAULT_AUTHORIZATION_HEADER = "Authorization";
var DEFAULT_SERVER_ID_HEADER = "Server-Id";
var ApiOptionsToken = Symbol.for("ApiOptionsToken");
var ApiService = Symbol.for("ApiService");
var ApiImpl = ApiImpl_1 = class ApiImpl2 {
  constructor(urlBuilder, options, logger) {
    this.urlBuilder = urlBuilder;
    this.logger = logger;
    this.headers = ApiImpl_1.getHeaders(options);
    this.httpClient = options.httpClient;
  }
  static getHeaders(options) {
    var _a4, _b, _c, _d;
    const { cookie: cookie2, referer, "x-forwarded-for": ip = (_b = (_a4 = options.request) === null || _a4 === void 0 ? void 0 : _a4.connection) === null || _b === void 0 ? void 0 : _b.remoteAddress, "user-agent": userAgent } = ((_c = options.request) === null || _c === void 0 ? void 0 : _c.headers) || {};
    const { apiVersionHeader = DEFAULT_API_VERSION_HEADER, apiVersion, authorizationHeader = DEFAULT_AUTHORIZATION_HEADER, authorizationToken, serverIdHeader = DEFAULT_SERVER_ID_HEADER, serverId, visitor = (_d = options.request) === null || _d === void 0 ? void 0 : _d.visitor } = options;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, ip && {
      "X-Forwarded-For": ip
    }), apiVersion && {
      [apiVersionHeader]: apiVersion
    }), authorizationToken && {
      [authorizationHeader]: `Bearer ${authorizationToken}`
    }), isConfigurationWithProxy(options) && cookie2 && {
      Cookie: cookie2
    }), referer && {
      Referer: referer
    }), serverId && {
      [serverIdHeader]: serverId
    }), userAgent && {
      "User-Agent": userAgent
    }), visitor && {
      [visitor.header]: visitor.id
    });
  }
  getPage(path) {
    const url = this.urlBuilder.getApiUrl(path);
    return this.send({
      url,
      method: "GET"
    });
  }
  getComponent(url, payload) {
    const data = new URLSearchParams(payload);
    return this.send({
      url,
      data: data.toString(),
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      method: Object.keys(payload || {}).length ? "POST" : "GET"
    });
  }
  send(config) {
    var _a4, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
      (_a4 = this.logger) === null || _a4 === void 0 ? void 0 : _a4.debug("Request:", config.method, config.url);
      (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug("Headers:", Object.assign(Object.assign({}, this.headers), config.headers));
      if (config.data) {
        (_c = this.logger) === null || _c === void 0 ? void 0 : _c.debug("Body:", config.data);
      }
      const response = yield this.httpClient(Object.assign(Object.assign({}, config), {
        headers: Object.assign(Object.assign({}, this.headers), config.headers)
      }));
      return response.data;
    });
  }
};
ApiImpl = ApiImpl_1 = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(UrlBuilderService)), __param(1, (0, import_inversify.inject)(ApiOptionsToken)), __param(2, (0, import_inversify.inject)(Logger)), __param(2, (0, import_inversify.optional)()), __metadata("design:paramtypes", [Object, Object, Logger])], ApiImpl);
var SpaService = Symbol.for("SpaService");
var Spa = class Spa2 {
  /**
   * @param pageEventBus Event bus to exchange data between submodules.
   * @param api Api client.
   * @param pageFactory Factory to produce page instances.
   */
  constructor(api, pageFactory, cmsEventBus, pageEventBus, logger) {
    this.api = api;
    this.pageFactory = pageFactory;
    this.cmsEventBus = cmsEventBus;
    this.pageEventBus = pageEventBus;
    this.logger = logger;
    this.onCmsUpdate = this.onCmsUpdate.bind(this);
  }
  onCmsUpdate(event) {
    var _a4, _b, _c, _d, _e, _f;
    return __awaiter(this, void 0, void 0, function* () {
      (_a4 = this.logger) === null || _a4 === void 0 ? void 0 : _a4.debug("Received CMS update event.");
      (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug("Event:", event);
      const root = this.page.getComponent();
      const component = root.getComponentById(event.id);
      const url = component === null || component === void 0 ? void 0 : component.getUrl();
      if (!url) {
        (_c = this.logger) === null || _c === void 0 ? void 0 : _c.debug("Skipping the update event.");
        return;
      }
      (_d = this.logger) === null || _d === void 0 ? void 0 : _d.debug("Trying to request the component model.");
      const model = yield this.api.getComponent(url, event.properties);
      (_e = this.logger) === null || _e === void 0 ? void 0 : _e.debug("Model:", model);
      (_f = this.pageEventBus) === null || _f === void 0 ? void 0 : _f.emit("page.update", {
        page: model
      });
    });
  }
  /**
   * Initializes the SPA.
   * @param modelOrPath A preloaded page model or URL to a page model.
   */
  initialize(modelOrPath) {
    var _a4, _b;
    if (typeof modelOrPath === "string") {
      (_a4 = this.logger) === null || _a4 === void 0 ? void 0 : _a4.debug("Trying to request the page model.");
      return this.api.getPage(modelOrPath).then(this.hydrate.bind(this));
    }
    (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug("Received dehydrated model.");
    return this.hydrate(modelOrPath);
  }
  hydrate(model) {
    var _a4, _b, _c;
    (_a4 = this.logger) === null || _a4 === void 0 ? void 0 : _a4.debug("Model:", model);
    (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug("Hydrating.");
    this.page = this.pageFactory(model);
    if (this.page.isPreview()) {
      (_c = this.cmsEventBus) === null || _c === void 0 ? void 0 : _c.on("cms.update", this.onCmsUpdate);
    }
    return this.page;
  }
  /**
   * Destroys the integration with the SPA page.
   */
  destroy() {
    var _a4, _b, _c;
    (_a4 = this.cmsEventBus) === null || _a4 === void 0 ? void 0 : _a4.off("cms.update", this.onCmsUpdate);
    (_b = this.pageEventBus) === null || _b === void 0 ? void 0 : _b.clearListeners();
    delete this.page;
    (_c = this.logger) === null || _c === void 0 ? void 0 : _c.debug("Destroyed page.");
  }
};
Spa = __decorate([(0, import_inversify.injectable)(), __param(0, (0, import_inversify.inject)(ApiService)), __param(1, (0, import_inversify.inject)(PageFactory)), __param(2, (0, import_inversify.inject)(CmsEventBusService)), __param(2, (0, import_inversify.optional)()), __param(3, (0, import_inversify.inject)(PageEventBusService)), __param(3, (0, import_inversify.optional)()), __param(4, (0, import_inversify.inject)(Logger)), __param(4, (0, import_inversify.optional)()), __metadata("design:paramtypes", [Object, Function, Object, Object, Logger])], Spa);
function SpaModule() {
  return new import_inversify.ContainerModule((bind) => {
    bind(ApiService).to(ApiImpl).inSingletonScope();
    bind(SpaService).to(Spa).inSingletonScope();
  });
}
var DEFAULT_AUTHORIZATION_PARAMETER = "token";
var DEFAULT_SERVER_ID_PARAMETER = "server-id";
var BTM_PREFIX = "btm_";
var DEFAULT_CAMPAIGN_VARIANT_PARAMETER_URL = `${BTM_PREFIX}campaign_id`;
var DEFAULT_SEGMENT_PARAMETER_URL = `${BTM_PREFIX}segment`;
var DEFAULT_TTL_PARAMETER_URL = `${BTM_PREFIX}ttl`;
var BR_PREFIX = "__br__";
var DEFAULT_CAMPAIGN_VARIANT_PARAMETER_API = `${BR_PREFIX}campaignVariant`;
var DEFAULT_SEGMENT_IDS_PARAMETER_API = `${BR_PREFIX}segmentIds`;
var container = new import_inversify.Container({
  skipBaseClassChecks: true
});
var pages = /* @__PURE__ */ new WeakMap();
container.load(CmsModule(), LoggerModule(), UrlModule$1());
function onReady(value, callback2) {
  const wrapper = (result) => (callback2(result), result);
  return value instanceof Promise ? value.then(wrapper) : wrapper(value);
}
function initializeWithProxy(scope, configuration, model) {
  var _a4, _b, _c, _d, _e, _f, _g, _h, _j;
  const logger = scope.get(Logger);
  logger.info("Enabled reverse-proxy based setup.");
  logger.warn("This setup is deprecated and will not work in the next major release.");
  logger.debug("Path:", (_c = (_a4 = configuration.path) !== null && _a4 !== void 0 ? _a4 : (_b = configuration.request) === null || _b === void 0 ? void 0 : _b.path) !== null && _c !== void 0 ? _c : "/");
  logger.debug("Base URL:", configuration.options.preview.spaBaseUrl);
  const options = isMatched((_f = (_d = configuration.path) !== null && _d !== void 0 ? _d : (_e = configuration.request) === null || _e === void 0 ? void 0 : _e.path) !== null && _f !== void 0 ? _f : "/", configuration.options.preview.spaBaseUrl) ? configuration.options.preview : configuration.options.live;
  logger.info(`Using ${options === configuration.options.preview ? "preview" : "live"} configuration.`);
  const config = Object.assign(Object.assign({}, configuration), {
    NBRMode: configuration.NBRMode || false
  });
  scope.load(PageModule(), SpaModule(), UrlModule());
  scope.bind(ApiOptionsToken).toConstantValue(config);
  scope.bind(UrlBuilderOptionsToken).toConstantValue(options);
  scope.getNamed(CmsService, "cms14").initialize(configuration);
  return onReady(scope.get(SpaService).initialize((_j = (_g = model !== null && model !== void 0 ? model : configuration.path) !== null && _g !== void 0 ? _g : (_h = configuration.request) === null || _h === void 0 ? void 0 : _h.path) !== null && _j !== void 0 ? _j : "/"), () => {
    scope.unbind(ApiOptionsToken);
    scope.unbind(UrlBuilderOptionsToken);
  });
}
function initializeWithJwt09(scope, configuration, model) {
  var _a4, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
  const logger = scope.get(Logger);
  logger.info("Enabled token-based setup.");
  logger.info("Using Page Model API 0.9.");
  logger.warn("This version of the Page Model API is deprecated and will be removed in the next major release.");
  const authorizationParameter = (_a4 = configuration.authorizationQueryParameter) !== null && _a4 !== void 0 ? _a4 : DEFAULT_AUTHORIZATION_PARAMETER;
  const serverIdParameter = (_b = configuration.serverIdQueryParameter) !== null && _b !== void 0 ? _b : DEFAULT_SERVER_ID_PARAMETER;
  const { url: path, searchParams } = extractSearchParams((_e = (_c = configuration.path) !== null && _c !== void 0 ? _c : (_d = configuration.request) === null || _d === void 0 ? void 0 : _d.path) !== null && _e !== void 0 ? _e : "/", [authorizationParameter, serverIdParameter].filter(Boolean));
  const authorizationToken = (_f = searchParams.get(authorizationParameter)) !== null && _f !== void 0 ? _f : void 0;
  const serverId = (_g = searchParams.get(serverIdParameter)) !== null && _g !== void 0 ? _g : void 0;
  const config = Object.assign(Object.assign({}, configuration), {
    origin: (_h = configuration.origin) !== null && _h !== void 0 ? _h : parseUrl((_k = (_j = configuration.apiBaseUrl) !== null && _j !== void 0 ? _j : configuration.cmsBaseUrl) !== null && _k !== void 0 ? _k : "").origin,
    spaBaseUrl: appendSearchParams((_l = configuration.spaBaseUrl) !== null && _l !== void 0 ? _l : "", searchParams),
    NBRMode: configuration.NBRMode || false
  });
  if (authorizationToken) {
    logger.debug("Token:", authorizationToken);
  }
  if (serverId) {
    logger.debug("Server Id:", serverId);
  }
  logger.debug("Origin:", config.origin);
  logger.debug("Path:", path);
  logger.debug("Base URL:", config.spaBaseUrl);
  scope.load(PageModule(), SpaModule(), UrlModule());
  scope.bind(ApiOptionsToken).toConstantValue(Object.assign({
    authorizationToken,
    serverId
  }, config));
  scope.bind(UrlBuilderOptionsToken).toConstantValue(config);
  return onReady(scope.get(SpaService).initialize(model !== null && model !== void 0 ? model : path), (page) => {
    if (page.isPreview() && config.cmsBaseUrl) {
      logger.info("Running in preview mode.");
      scope.get(PostMessageService).initialize(config);
      scope.get(CmsService).initialize(config);
    } else {
      logger.info("Running in live mode.");
    }
    scope.unbind(ApiOptionsToken);
    scope.unbind(UrlBuilderOptionsToken);
  });
}
function initializeWithJwt10(scope, configuration, model) {
  var _a4, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
  const logger = scope.get(Logger);
  logger.info("Enabled token-based setup.");
  logger.info("Using Page Model API 1.0.");
  const authorizationParameter = (_a4 = configuration.authorizationQueryParameter) !== null && _a4 !== void 0 ? _a4 : DEFAULT_AUTHORIZATION_PARAMETER;
  const serverIdParameter = (_b = configuration.serverIdQueryParameter) !== null && _b !== void 0 ? _b : DEFAULT_SERVER_ID_PARAMETER;
  const campaignParameter = DEFAULT_CAMPAIGN_VARIANT_PARAMETER_URL;
  const segmentParameter = DEFAULT_SEGMENT_PARAMETER_URL;
  const ttlParameter = DEFAULT_TTL_PARAMETER_URL;
  const { url: path, searchParams } = extractSearchParams((_e = (_c = configuration.path) !== null && _c !== void 0 ? _c : (_d = configuration.request) === null || _d === void 0 ? void 0 : _d.path) !== null && _e !== void 0 ? _e : "/", [authorizationParameter, serverIdParameter, campaignParameter, segmentParameter, ttlParameter].filter(Boolean));
  const authorizationToken = (_f = searchParams.get(authorizationParameter)) !== null && _f !== void 0 ? _f : void 0;
  const serverId = (_g = searchParams.get(serverIdParameter)) !== null && _g !== void 0 ? _g : void 0;
  const campaignId = (_h = searchParams.get(campaignParameter)) !== null && _h !== void 0 ? _h : void 0;
  const segmentId = (_j = searchParams.get(segmentParameter)) !== null && _j !== void 0 ? _j : void 0;
  const ttl = (_k = searchParams.get(ttlParameter)) !== null && _k !== void 0 ? _k : void 0;
  let endpointUrl = configuration.endpoint;
  const campaignVariantId = Campaign.GET_VARIANT_ID(campaignId, segmentId, ttl, configuration.request);
  const segmentIds = Segmentation.GET_SEGMENT_IDS(configuration.request);
  const params = new URLSearchParams();
  if (campaignVariantId) {
    params.append(DEFAULT_CAMPAIGN_VARIANT_PARAMETER_API, campaignVariantId);
  }
  if (segmentIds) {
    params.append(DEFAULT_SEGMENT_IDS_PARAMETER_API, segmentIds);
  }
  endpointUrl = appendSearchParams(endpointUrl !== null && endpointUrl !== void 0 ? endpointUrl : "", params);
  const config = Object.assign(Object.assign({}, configuration), {
    endpoint: endpointUrl,
    baseUrl: appendSearchParams((_l = configuration.baseUrl) !== null && _l !== void 0 ? _l : "", searchParams),
    origin: (_m = configuration.origin) !== null && _m !== void 0 ? _m : parseUrl((_o = configuration.endpoint) !== null && _o !== void 0 ? _o : "").origin,
    NBRMode: configuration.NBRMode || false
  });
  if (authorizationToken) {
    logger.debug("Token:", authorizationToken);
  }
  if (serverId) {
    logger.debug("Server Id:", serverId);
  }
  if (campaignId) {
    logger.debug("Campaign Id:", campaignId);
  }
  if (segmentId) {
    logger.debug("Segment Id:", segmentId);
  }
  if (ttl) {
    logger.debug("TTL:", ttl);
  }
  if (campaignVariantId) {
    logger.debug("Campaign variant Id:", campaignVariantId);
  }
  logger.debug("Endpoint:", config.endpoint);
  logger.debug("Origin:", config.origin);
  logger.debug("Path:", path);
  logger.debug("Base URL:", config.baseUrl);
  scope.load(PageModule$1(), SpaModule(), UrlModule$1());
  scope.bind(ApiOptionsToken).toConstantValue(Object.assign({
    authorizationToken,
    serverId
  }, config));
  scope.bind(UrlBuilderOptionsToken).toConstantValue(config);
  return onReady(scope.get(SpaService).initialize(model !== null && model !== void 0 ? model : path), (page) => {
    if (page.isPreview() && config.endpoint) {
      logger.info("Running in preview mode.");
      scope.get(PostMessageService).initialize(config);
      scope.get(CmsService).initialize(config);
    } else {
      logger.info("Running in live mode.");
    }
    scope.unbind(ApiOptionsToken);
    scope.unbind(UrlBuilderOptionsToken);
  });
}
function initialize(configuration, model) {
  if (isPage(model)) {
    return model;
  }
  const scope = container.createChild();
  const logger = scope.get(Logger);
  logger.level = configuration.debug ? Level.Debug : Level.Error;
  logger.debug("Configuration:", configuration);
  return onReady(isConfigurationWithProxy(configuration) ? initializeWithProxy(scope, configuration, model) : isConfigurationWithJwt09(configuration) ? initializeWithJwt09(scope, configuration, model) : initializeWithJwt10(scope, configuration, model), (page) => {
    var _a4, _b;
    pages.set(page, scope);
    (_b = (_a4 = configuration.request) === null || _a4 === void 0 ? void 0 : _a4.emit) === null || _b === void 0 ? void 0 : _b.call(_a4, "br:spa:initialized", page);
  });
}

// content-bloomreach/mappers/ContentMapper.ts
var ContentMapper4 = class {
  static bloomreachDocumentToContent(response) {
    var _a4, _b, _c;
    response = JSON.parse(JSON.stringify(response));
    const pageRef = response.root.$ref.split("/").pop();
    const pageData = response.page[pageRef];
    const documentRef = (_a4 = response.document) == null ? void 0 : _a4.$ref.split("/").pop();
    const documentData = response.page[documentRef];
    const { id, title, introduction, image } = documentData.data;
    const imageRef = image.$ref.split("/").pop();
    const imageLinks = (_b = response.page[imageRef].data.original) == null ? void 0 : _b.links;
    return {
      contentId: pageData.id,
      contentTypeId: id,
      title,
      banner: (_c = imageLinks == null ? void 0 : imageLinks.site) == null ? void 0 : _c.href,
      summary: introduction
    };
  }
};

// content-bloomreach/utils/Context.ts
var projectConfigurationOverrides6 = {};
var isDevEnv6 = (context) => {
  return context.environment === "development" || context.environment === "dev";
};
var getFromProjectConfig6 = (key, context) => {
  if (isDevEnv6(context) && projectConfigurationOverrides6[key]) {
    return projectConfigurationOverrides6[key];
  }
  return context.projectConfiguration[key];
};

// content-bloomreach/apis/ContentApi.ts
var ContentApi4 = class {
  constructor(frontasticContext, locale) {
    var _a4, _b;
    this.locale = (locale != null ? locale : frontasticContext.project.defaultLocale).replace("_", "-");
    this.deliveryApiUrl = getFromProjectConfig6("EXTENSION_BLOOMREACH_DELIVERY_API_URL", frontasticContext);
    if (!this.deliveryApiUrl) {
      this.deliveryApiUrl = (_b = (_a4 = frontasticContext.project.configuration) == null ? void 0 : _a4.bloomreach) == null ? void 0 : _b.deliveryApiUrl;
    }
  }
  async getContent(channel, page) {
    const path = "";
    const pageData = await initialize({
      // The path to request from the Page Model API, should include query
      // parameters if those are present in the url
      path,
      // The location of the Page Model API of the brX channel
      endpoint: `${this.deliveryApiUrl}channels/${channel}/pages/${page}`,
      // The httpClient used to make requests
      httpClient: import_axios3.default
    });
    return ContentMapper4.bloomreachDocumentToContent(pageData);
  }
  async getContentList(channel, pages2) {
    const path = "";
    const pageResults = [];
    await Promise.all(
      pages2.map(async (page) => {
        const pageData = await initialize({
          path,
          endpoint: `${this.deliveryApiUrl}channels/${channel}/pages/${page}`,
          httpClient: import_axios3.default
        });
        await pageResults.push(ContentMapper4.bloomreachDocumentToContent(pageData));
      })
    );
    return pageResults;
  }
};

// content-bloomreach/utils/Request.ts
var getLocale5 = (request) => {
  var _a4;
  const locale = (_a4 = getHeader6(request, ["commercetools-frontend-locale" /* commercetoolsFrontendLocale */, "frontastic-locale" /* frontasticLocale */])) != null ? _a4 : request.query.locale;
  if (locale !== void 0) {
    return locale;
  }
  throw new ValidationError({ message: `Locale is missing from request ${request}` });
};
var getHeader6 = (request, headers) => {
  for (const header of headers) {
    const foundHeader = request.headers[header.toLowerCase()];
    if (foundHeader !== void 0) {
      if (Array.isArray(foundHeader)) {
        return foundHeader[0];
      }
      return foundHeader;
    }
  }
  return null;
};

// content-bloomreach/actionControllers/BloomreachController.ts
var BloomreachController_exports = {};
__export(BloomreachController_exports, {
  getContent: () => getContent3,
  getContentList: () => getContentList2
});
var getContent3 = async (request, actionContext) => {
  const { channel, page } = request.query;
  if (!channel) {
    return {
      body: "Missing channel info",
      statusCode: 400
    };
  }
  if (!page) {
    return {
      body: "Missing page name/path info",
      statusCode: 400
    };
  }
  const contentApi = new ContentApi4(actionContext.frontasticContext, getLocale5(request));
  const data = await contentApi.getContent(channel, page);
  const response = {
    statusCode: 200,
    body: JSON.stringify(data),
    sessionData: request.sessionData
  };
  return response;
};
var getContentList2 = async (request, actionContext) => {
  const { channel, pages: pages2 } = request.query;
  let pageList;
  if (!channel) {
    return {
      body: "Missing channel info",
      statusCode: 400
    };
  }
  if (!pages2) {
    return {
      body: "Missing page name/path List",
      statusCode: 400
    };
  } else {
    pageList = pages2.split(",");
  }
  const contentApi = new ContentApi4(actionContext.frontasticContext, getLocale5(request));
  const data = await contentApi.getContentList(channel, pageList);
  const response = {
    statusCode: 200,
    body: JSON.stringify(data),
    sessionData: request.sessionData
  };
  return response;
};

// content-bloomreach/index.ts
var content_bloomreach_default = {
  "data-sources": {
    "bloomreach/content": async (config, context) => {
      const contentApi = new ContentApi4(context.frontasticContext, getLocale5(context.request));
      const { channel, page } = config.configuration;
      return {
        dataSourcePayload: await contentApi.getContent(channel, page)
      };
    },
    "bloomreach/content-list": async (config, context) => {
      const contentApi = new ContentApi4(context.frontasticContext, getLocale5(context.request));
      const { channel, pages: pages2 } = config.configuration;
      const payload = await contentApi.getContentList(channel, pages2);
      return {
        dataSourcePayload: payload
      };
    }
  },
  actions: {
    bloomreach: BloomreachController_exports
  }
};

// content-nosto/utils/Errors.ts
var ExtensionError3 = class extends Error {
  constructor({ message, errors }) {
    var _a4;
    super(message || ((_a4 = errors == null ? void 0 : errors[0]) == null ? void 0 : _a4.message));
    this.errors = errors || [{ message }];
  }
};
var ValidationError3 = class extends ExtensionError3 {
  constructor(options) {
    super(options);
    this.code = "validation_error";
  }
};

// content-nosto/mappers/NostoMapper.ts
var NostoMapper = class {
  static mapToVariant(recommendedProduct, price) {
    const variant = {
      sku: recommendedProduct == null ? void 0 : recommendedProduct.productId,
      price,
      images: [recommendedProduct == null ? void 0 : recommendedProduct.imageUrl]
    };
    return variant;
  }
  static mapToCategories(recommendedProduct) {
    return recommendedProduct == null ? void 0 : recommendedProduct.categories.map((categoryName) => {
      return {
        name: categoryName
      };
    });
  }
  static mapNostoResponseToProducts(recommendedProducts) {
    const products = [];
    recommendedProducts.forEach((recommendedProduct) => {
      const price = {
        fractionDigits: 0,
        centAmount: recommendedProduct == null ? void 0 : recommendedProduct.listPrice
      };
      const variant = this.mapToVariant(recommendedProduct, price);
      const categories = this.mapToCategories(recommendedProduct);
      const product = {
        name: recommendedProduct == null ? void 0 : recommendedProduct.name,
        categories,
        variants: [variant],
        _url: recommendedProduct.url
      };
      products.push(product);
    });
    return products;
  }
};

// content-nosto/apis/BaseApi.ts
init_lib();

// content-nosto/utils/Context.ts
var projectConfigurationOverrides7 = {};
var isDevEnv7 = (context) => {
  return context.environment === "development" || context.environment === "dev";
};
var getFromProjectConfig7 = (key, context) => {
  if (isDevEnv7(context) && projectConfigurationOverrides7[key]) {
    return projectConfigurationOverrides7[key];
  }
  return context.projectConfiguration[key];
};

// content-nosto/apis/BaseApi.ts
var BaseApi3 = class {
  constructor(frontasticContext, nostoSessionId) {
    this.graphqlQueryFields = `{
    divId
    resultId
    primary {
      productId
      name
      listPrice
      imageUrl
      categories
      url
    }
  }`;
    this.graphqlQueryImageVersion = `VERSION_8_400_400`;
    var _a4, _b, _c, _d;
    this.apiToken = getFromProjectConfig7("EXTENSION_NOSTO_API_TOKEN", frontasticContext);
    if (!this.apiToken) {
      this.apiToken = (_b = (_a4 = frontasticContext.project.configuration) == null ? void 0 : _a4.nosto) == null ? void 0 : _b.apiToken;
    }
    this.apiUrl = getFromProjectConfig7("EXTENSION_NOSTO_API_URL", frontasticContext);
    if (!this.apiUrl) {
      this.apiUrl = (_d = (_c = frontasticContext.project.configuration) == null ? void 0 : _c.nosto) == null ? void 0 : _d.apiUrl;
    }
    this.sessionId = nostoSessionId;
  }
  getSessionId() {
    return this.sessionId;
  }
  getQueryFields() {
    return this.graphqlQueryFields;
  }
  getQueryImageVersion() {
    return this.graphqlQueryImageVersion;
  }
  fetch(body) {
    const headers = {
      "Content-Type": "application/graphql",
      Authorization: "Basic " + Buffer.from(`:${this.apiToken}`).toString("base64")
    };
    try {
      const responseJson = lib_default(this.apiUrl, {
        method: "POST",
        body,
        headers
      }).then((response) => {
        return response.json();
      });
      return responseJson;
    } catch (error) {
      throw error;
    }
  }
};

// content-nosto/apis/ProductPageRecommendationApi.ts
var ProductPageRecommendationApi = class extends BaseApi3 {
  async fetchRecommendation(target, placementId) {
    var _a4, _b, _c;
    const sessionId = this.getSessionId();
    const body = `mutation {
      updateSession(by: BY_CID, id: "${sessionId}",
        params: {
          event: {
            type: VIEWED_PRODUCT
            target: "${target}"
            ref: "front-page-slot-1"
          }
        }
      ) {
        pages {
          forProductPage(params: {
            isPreview: false, imageVersion:   ${this.getQueryImageVersion()}
          }, product: "${target}") ${this.getQueryFields()}
        }
      }
    }`;
    const recommendationResult = await this.fetch(body);
    const placementList = (_c = (_b = (_a4 = recommendationResult == null ? void 0 : recommendationResult.data) == null ? void 0 : _a4.updateSession) == null ? void 0 : _b.pages) == null ? void 0 : _c.forProductPage;
    const recommendations = placementList.filter((obj) => (obj == null ? void 0 : obj.resultId) == placementId)[0];
    const recommendedProducts = recommendations == null ? void 0 : recommendations.primary;
    const mappedProducts = NostoMapper.mapNostoResponseToProducts(recommendedProducts);
    return mappedProducts;
  }
};

// content-nosto/apis/CategoryPageRecommendationApi.ts
var CategoryPageRecommendationApi = class extends BaseApi3 {
  async fetchRecommendation(target, placementId) {
    var _a4, _b, _c;
    const sessionId = this.getSessionId();
    const body = `mutation {
      updateSession(by: BY_CID, id: "${sessionId}",
        params: {
          event: {
            type: VIEWED_CATEGORY
            target: "/${target}"
          }
        }
      ) {
        pages {
          forCategoryPage(params: {
            isPreview: false, imageVersion:   ${this.getQueryImageVersion()}
          }, category: "${target}") ${this.getQueryFields()}
        }
      }
    }`;
    const recommendationResult = await this.fetch(body);
    const placementList = (_c = (_b = (_a4 = recommendationResult == null ? void 0 : recommendationResult.data) == null ? void 0 : _a4.updateSession) == null ? void 0 : _b.pages) == null ? void 0 : _c.forCategoryPage;
    const recommendations = placementList.filter((obj) => (obj == null ? void 0 : obj.resultId) == placementId)[0];
    const recommendedProducts = recommendations == null ? void 0 : recommendations.primary;
    const mappedProducts = NostoMapper.mapNostoResponseToProducts(recommendedProducts);
    return mappedProducts;
  }
};

// content-nosto/apis/SearchPageRecommendationApi.ts
var SearchPageRecommendationApi = class extends BaseApi3 {
  async fetchRecommendation(target, placementId) {
    var _a4, _b, _c;
    const sessionId = this.getSessionId();
    const body = `mutation {
      updateSession(by: BY_CID, id: "${sessionId}",
        params: {
          event: {
            type: SEARCHED_FOR
            target: "${target}"
          }
        }
      ) {
        pages {
          forSearchPage(params: {
            isPreview: false, imageVersion:   ${this.getQueryImageVersion()}
          }, term: "${target}") ${this.getQueryFields()}
        }
      }
    }`;
    const recommendationResult = await this.fetch(body);
    const placementList = (_c = (_b = (_a4 = recommendationResult == null ? void 0 : recommendationResult.data) == null ? void 0 : _a4.updateSession) == null ? void 0 : _b.pages) == null ? void 0 : _c.forSearchPage;
    const recommendations = placementList.filter((obj) => (obj == null ? void 0 : obj.resultId) == placementId)[0];
    const recommendedProducts = recommendations == null ? void 0 : recommendations.primary;
    const mappedProducts = NostoMapper.mapNostoResponseToProducts(recommendedProducts);
    return mappedProducts;
  }
};

// content-nosto/apis/CartPageRecommendationApi.ts
var CartPageRecommendationApi = class extends BaseApi3 {
  async fetchRecommendation(target, placementId) {
    var _a4, _b, _c;
    const sessionId = this.getSessionId();
    const body = `mutation {
      updateSession(by: BY_CID, id: "${sessionId}",
        params: {
          event: {
            type: VIEWED_PAGE
            target: "${target}"
          }
        }
      ) {
        pages {
          forCartPage(params: {
            isPreview: false, imageVersion:  ${this.getQueryImageVersion()}
          }, value: 100) ${this.getQueryFields()}
        }
      }
    }`;
    const recommendationResult = await this.fetch(body);
    const placementList = (_c = (_b = (_a4 = recommendationResult == null ? void 0 : recommendationResult.data) == null ? void 0 : _a4.updateSession) == null ? void 0 : _b.pages) == null ? void 0 : _c.forCartPage;
    const recommendations = placementList.filter((obj) => (obj == null ? void 0 : obj.resultId) == placementId)[0];
    const recommendedProducts = recommendations == null ? void 0 : recommendations.primary;
    const mappedProducts = NostoMapper.mapNostoResponseToProducts(recommendedProducts);
    return mappedProducts;
  }
};

// content-nosto/apis/FrontPageRecommendationApi.ts
var FrontPageRecommendationApi = class extends BaseApi3 {
  async fetchRecommendation(target, placementId) {
    var _a4, _b, _c;
    const sessionId = this.getSessionId();
    const body = `mutation {
      updateSession(by: BY_CID, id: "${sessionId}",
        params: {
          event: {
            type: VIEWED_PAGE
            target: "${target}"
          }
        }
      ) {
        pages {
          forFrontPage(params: {
            isPreview: false, imageVersion:  ${this.getQueryImageVersion()}
          }) ${this.getQueryFields()}
        }
      }
    }`;
    const recommendationResult = await this.fetch(body);
    const placementList = (_c = (_b = (_a4 = recommendationResult == null ? void 0 : recommendationResult.data) == null ? void 0 : _a4.updateSession) == null ? void 0 : _b.pages) == null ? void 0 : _c.forFrontPage;
    const recommendations = placementList.filter((obj) => (obj == null ? void 0 : obj.resultId) == placementId)[0];
    const recommendedProducts = recommendations == null ? void 0 : recommendations.primary;
    return NostoMapper.mapNostoResponseToProducts(recommendedProducts);
  }
};

// content-nosto/apis/RecommendationApiFactory.ts
var RecommendationApiFactory = class {
  static getInstance(frontasticContext, nostoSessionId, pageType) {
    switch (pageType) {
      case "PRODUCT":
        return new ProductPageRecommendationApi(frontasticContext, nostoSessionId);
      case "CATEGORY":
        return new CategoryPageRecommendationApi(frontasticContext, nostoSessionId);
      case "SEARCH":
        return new SearchPageRecommendationApi(frontasticContext, nostoSessionId);
      case "CART":
        return new CartPageRecommendationApi(frontasticContext, nostoSessionId);
      case "FRONT":
        return new FrontPageRecommendationApi(frontasticContext, nostoSessionId);
      default:
        throw new ValidationError3({
          message: `pageType is not valid. ${pageType} is not included within [PRODUCT, CATEGORY, SEARCH, CART, FRONT]`
        });
    }
  }
};

// content-nosto/index.ts
var content_nosto_default = {
  "data-sources": {
    "nosto/product-recommendations": async (config, context) => {
      validate2(config, context);
      const { target, nostoSessionId } = context.request.query;
      const { pageType, placementId } = config.configuration;
      const recommendApi = RecommendationApiFactory.getInstance(
        context.frontasticContext,
        nostoSessionId,
        pageType
      );
      const recommendedProducts = await recommendApi.fetchRecommendation(target, placementId);
      return {
        dataSourcePayload: { recommendedProducts }
      };
    }
  }
};
function validate2(config, context) {
  var _a4, _b, _c;
  if (!context.hasOwnProperty("request")) {
    throw new ValidationError3({
      message: `Request is not defined in context ${context}`
    });
  }
  if (!config.hasOwnProperty("configuration")) {
    throw new ValidationError3({
      message: `Configuration is not defined in data source configuration ${config}`
    });
  }
  const target = (_b = (_a4 = context.request) == null ? void 0 : _a4.query) == null ? void 0 : _b.target;
  const pageType = (_c = config.configuration) == null ? void 0 : _c.pageType;
  const nostoSessionId = context.request.query.nostoSessionId;
  if (!target) {
    throw new ValidationError3({
      message: `target is not defined in context request ${context.request}`
    });
  }
  if (!pageType) {
    throw new ValidationError3({
      message: `pageType is not defined in data source configuration ${config.configuration}`
    });
  }
  if (!nostoSessionId) {
    throw new ValidationError3({
      message: `nostoSessionId is not defined in context request ${context.request}`
    });
  }
}

// promotion-talon-one/index.ts
var promotion_talon_one_default = {
  "data-sources": {},
  actions: {}
};

// index.ts
var extensionsToMerge = [
  commerce_commercetools_default,
  content_contentful_default,
  content_dynamicyield_default,
  content_amplience_default,
  content_contentstack_default,
  content_bloomreach_default,
  promotion_talon_one_default,
  content_nosto_default
];
var mergeActions = (extensions) => {
  const actionNamespaces = {};
  for (const extension of extensions) {
    for (const actionNamespace in extension["actions"] || {}) {
      if (!actionNamespaces[actionNamespace]) {
        actionNamespaces[actionNamespace] = {};
      }
      actionNamespaces[actionNamespace] = Object.assign(
        {},
        actionNamespaces[actionNamespace],
        extension["actions"][actionNamespace]
      );
    }
  }
  return actionNamespaces;
};
var mergeDynamicPageHandlers = (extensions) => {
  return async (request, dynamicPageContext) => {
    for (const extension of extensions) {
      if (extension["dynamic-page-handler"]) {
        const result = await extension["dynamic-page-handler"](request, dynamicPageContext);
        if (result !== null) {
          return result;
        }
      }
    }
    return null;
  };
};
var backend_default = {
  "dynamic-page-handler": mergeDynamicPageHandlers(extensionsToMerge),
  "data-sources": extensionsToMerge.map((extension) => {
    return extension["data-sources"] || {};
  }).reduce(Object.assign, {}),
  actions: mergeActions(extensionsToMerge)
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

@contentstack/utils/dist/index.es.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

es6-promise/dist/es6-promise.js:
  (*!
   * @overview es6-promise - a tiny implementation of Promises/A+.
   * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
   * @license   Licensed under MIT license
   *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
   * @version   v4.2.8+1e68dce6
   *)

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
*/
//# sourceMappingURL=bundle.min.js.map